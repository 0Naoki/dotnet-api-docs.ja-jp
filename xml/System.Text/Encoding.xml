<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="610471fbf0d011485114fda063427ce017aac1e7" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51931421" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>文字エンコーディングを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 エンコーディングは、Unicode 文字のセットをバイト シーケンスに変換するプロセスです。 これに対し、デコードは、Unicode 文字のセットにエンコードされたバイトのシーケンスを変換するプロセスです。 Unicode 変換形式 (UTFs) とでサポートされているその他のエンコーディングについて<xref:System.Text.Encoding>を参照してください[.NET における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)します。  
  
 なお<xref:System.Text.Encoding>バイト配列などの任意のバイナリ データではなく Unicode 文字を操作するためのものです。 テキストには、任意のバイナリ データをエンコードする必要がある場合、は、uuencode などの方法で実装されているなどのプロトコルを使用する必要があります<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>します。  
  
 .NET の次の実装を提供する、<xref:System.Text.Encoding>を現在の Unicode エンコーディングやその他のエンコーディングをサポートするクラス。  
  
-   <xref:System.Text.ASCIIEncoding> 1 つの 7 ビット ASCII 文字と Unicode 文字をエンコードします。 このエンコード U + 間の文字値のみをサポートしている 0000 と U + 007F します。 コード ページ 20127 です。 でも、<xref:System.Text.Encoding.ASCII%2A>プロパティ。  
  
-   <xref:System.Text.UTF7Encoding> utf-7 エンコードを使用して Unicode 文字をエンコードします。 このエンコーディングと Unicode 文字の値をすべてサポートしています。 コード ページ 65000 です。 でも、<xref:System.Text.Encoding.UTF7%2A>プロパティ。  
  
-   <xref:System.Text.UTF8Encoding> utf-8 エンコーディングを使用して Unicode 文字をエンコードします。 このエンコーディングと Unicode 文字の値をすべてサポートしています。 コード ページ 65001 です。 でも、<xref:System.Text.Encoding.UTF8%2A>プロパティ。  
  
-   <xref:System.Text.UnicodeEncoding> Unicode 文字の utf-16 エンコーディングを使用してエンコードします。 リトル エンディアンとビッグ エンディアン バイト順順の両方がサポートされています。 でも、<xref:System.Text.Encoding.Unicode%2A>プロパティおよび<xref:System.Text.Encoding.BigEndianUnicode%2A>プロパティ。  
  
-   <xref:System.Text.UTF32Encoding> Unicode 文字の utf-32 エンコーディングを使用してエンコードします。 両方リトル エンディアン (コード ページ 12000) とビッグ エンディアン (コード ページ 12001) バイト注文がサポートされています。 でも、<xref:System.Text.Encoding.UTF32%2A>プロパティ。  
  
 <xref:System.Text.Encoding>クラスは主に、さまざまなエンコーディングと Unicode の間で変換します。 多くの場合、Unicode の派生クラスの 1 つは、アプリに対して適切な選択です。  
  
 使用して、<xref:System.Text.Encoding.GetEncoding%2A>その他のエンコーディングを取得するメソッドを呼び出すと、<xref:System.Text.Encoding.GetEncodings%2A>すべてのエンコーディングの一覧を取得するメソッド。  
  
 次の表には、.NET Framework と .NET Core でサポートされているエンコーディングが一覧表示します。 各エンコーディングのコード ページ番号とエンコーディングの値を一覧表示<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>と<xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType>プロパティ。 あるチェック マーク、 **.NET Framework サポート**と **.NET Core のサポート**列は、コード ページは、基になるプラットフォームに関係なく、その .NET 実装によってネイティブでサポートすることを示します。 .NET Framework での表に示すその他のエンコーディングの可用性は、オペレーティング システムによって異なります。 .NET core では、別のエンコーディングが使用可能なを使用して、<xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType>クラスまたはからの派生によって、<xref:System.Text.EncodingProvider?displayProperty=nameWithType>クラス。  

> [!NOTE]
> コード ページの持つ<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>プロパティは、国際標準に対応必ずしもその標準に完全に準拠していません。 

|コード ページ|name|表示名|.NET framework のサポート| .NET Core サポート | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (米国およびカナダ)|||  
|437|IBM437|OEM United States|||  
|500|IBM500|IBM EBCDIC (インターナショナル)|||  
|708|ASMO-708|アラビア語 (ASMO 708)|||  
|720|DOS-720|アラビア語 (DOS)|||  
|737|ibm737|Řečtina (DOS)|||  
|775|ibm775|バルト言語 (DOS)|||  
|850|ibm850|西ヨーロッパ言語 (DOS)|||  
|852|ibm852|中央ヨーロッパ言語 (DOS)|||  
|855|IBM855|OEM キリル語|||  
|857|ibm857|トルコ語 (DOS)|||  
|858|IBM00858|OEM 多言語ラテン I|||  
|860|IBM860|ポルトガル語 (DOS)|||  
|861|ibm861|アイスランド語 (DOS)|||  
|862|DOS-862|ヘブライ語 (DOS)|||  
|863|IBM863|カナダ系フランス語 (DOS)|||  
|864|IBM864|アラビア語 (864)|||  
|865|IBM865|北欧 (DOS)|||  
|866|cp866|キリル語 (DOS)|||  
|869|ibm869|ギリシャ語, Modern (DOS)|||  
|870|IBM870|IBM EBCDIC (多言語ラテン 2)|||  
|874|windows-874|タイ語 (Windows)|||  
|875|cp875|IBM EBCDIC (ギリシャ語 Modern)|||  
|932|shift_jis|日本語 (SHIFT-JIS)|||  
|936|gb2312|簡体字中国語 (GB2312)|✓||  
|949|ks_c_5601-1987|韓国語|||  
|950|big5|繁体字中国語 (Big5)|||  
|1026|IBM1026|IBM EBCDIC (トルコ語ラテン-5)|||  
|1047|IBM01047|IBM Latin 1|||  
|1140|IBM01140|IBM EBCDIC (米国-カナダ-ヨーロッパ)|||  
|1141|IBM01141|IBM EBCDIC (ドイツ-ヨーロッパ)|||  
|1142|IBM01142|IBM EBCDIC (デンマーク-ノルウェー-ヨーロッパ)|||  
|1143|IBM01143|IBM EBCDIC (フィンランド-スウェーデン-ヨーロッパ)|||  
|1144|IBM01144|IBM EBCDIC (イタリア-ヨーロッパ)|||  
|1145|IBM01145|IBM EBCDIC (Španělsko-Euro)|||  
|1146|IBM01146|IBM EBCDIC (UK-ヨーロッパ)|||  
|1147|IBM01147|IBM EBCDIC (フランス-ヨーロッパ)|||  
|1148|IBM01148|IBM EBCDIC (インターナショナル-ヨーロッパ)|||  
|1149|IBM01149|IBM EBCDIC (アイスランド語-ヨーロッパ)|||  
|1200|utf-16|Unicode|✓|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|✓|  
|1250|windows-1250|中央ヨーロッパ言語 (Windows)|||  
|1251|windows-1251|キリル語 (Windows)|||  
|1252|utf-8|西ヨーロッパ言語 (Windows)|✓||  
|1253|windows-1253|ギリシャ語 (Windows)|||  
|1254|windows-1254|トルコ語 (Windows)|||  
|1255|windows-1255|ヘブライ語 (Windows)|||  
|1256|windows-1256|アラビア語 (Windows)|||  
|1257|windows-1257|バルト語 (Windows)|||  
|1258|windows-1258|ベトナム語 (Windows)|||  
|1361|Johab|韓国語 (Johab)|||  
|10000|macintosh|西ヨーロッパ言語 (Mac)|||  
|10001|x-mac-日本語|日本語 (Mac)|||  
|10002|x-mac-chinesetrad|繁体字中国語 (Mac)|||  
|10003|x-mac-korean|韓国語 (Mac)|✓||  
|10004|x-mac-arabic|アラビア語 (Mac)|||  
|10005|x-mac-hebrew|ヘブライ語 (Mac)|||  
|10006|x-mac-greek|Řečtina (Mac)|||  
|10007|x-mac-キリル語|キリル語 (Mac)|||  
|10008|x-mac-chinesesimp|簡体字中国語 (Mac)|✓||  
|10010|x-mac-ルーマニア語|ルーマニア語 (Mac)|||  
|10017|x-mac-ukrainian|ウクライナ語 (Mac)|||  
|10021|x-mac-thai|タイ語 (Mac)|||  
|10029|x-mac-ce|中央ヨーロッパ言語 (Mac)|||  
|10079|x-mac-アイスランド語|アイスランド語 (Mac)|||  
|10081|x-mac-turkish|トルコ語 (Mac)|||  
|10082|クロアチア語 mac x|クロアチア語 (Mac)|||  
|12000|utf-32|Unicode (utf-32)|✓|✓|  
|12001|utf-32be|Unicode (utf-32 ビッグ エンディアン)|✓|✓|  
|20000|x-中国語-CN|繁体字中国語 (CN)|||  
|20001|x-cp20001|Tca|||  
|20002|x-中国語-Eten|繁体字中国語 (Eten)|||  
|20003|x-cp20003|Ibm5550|||  
|20004|x-cp20004|文字放送 (台湾)|||  
|20005|x-cp20005|Wang 台湾|||  
|20105|x-IA5|西ヨーロッパ言語 (IA5)|||  
|20106|x-IA5-ドイツ語|ドイツ語 (IA5)|||  
|20107|x-IA5-スウェーデン語|スウェーデン語 (IA5)|||  
|20108|ノルウェー語 IA5 x|ノルウェー語 (IA5)|||  
|20127|us-ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (ドイツ)|||  
|20277|IBM277|IBM EBCDIC (デンマーク-ノルウェー)|||  
|20278|IBM278|IBM EBCDIC (フィンランド-スウェーデン語)|||  
|20280|IBM280|IBM EBCDIC (イタリア)|||  
|20284|IBM284|IBM EBCDIC (Španělsko)|||  
|20285|IBM285|IBM EBCDIC (UK)|||  
|20290|IBM290|IBM EBCDIC (日本語のカタカナ)|||  
|20297|IBM297|IBM EBCDIC (フランス)|||  
|20420|IBM420|IBM EBCDIC (アラビア語)|||  
|20423|IBM423|IBM EBCDIC (ギリシャ語)|||  
|20424|IBM424|IBM EBCDIC (ヘブライ語)|||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (韓国語拡張)|||  
|20838|IBM タイ語|IBM EBCDIC (タイ語)|||  
|20866|koi8-r|キリル語 (KOI8 R)|||  
|20871|IBM871|IBM EBCDIC (アイスランド語)|||  
|20880|IBM880|IBM EBCDIC (キリル文字のロシア語)|||  
|20905|IBM905|IBM EBCDIC (トルコ語)|||  
|20924|IBM00924|IBM Latin 1|||  
|20932|EUC-JP|日本語 (JIS 0208 1990 と 0212 1990)|||  
|20936|x-cp20936|簡体字中国語 (GB2312 80)|✓||  
|20949|x-cp20949|韓国語 Wansung|✓||  
|21025|cp1025|IBM EBCDIC (キリル言語セルビア-ブルガリア)|||  
|21866|koi8-u|キリル語 (KOI8 U)|||  
|28591|iso 8859-1|西ヨーロッパ言語 (ISO)|✓|✓|  
|28592|iso 8859-2|中央ヨーロッパ言語 (ISO)|||  
|28593|iso 8859-3|ラテン 3 (ISO)|||  
|28594|iso 8859-4|バルト語 (ISO)|||  
|28595|iso 8859-5|キリル語 (ISO)|||  
|28596|iso 8859-6|アラビア語 (ISO)|||  
|28597|iso 8859-7|ギリシャ語 (ISO)|||  
|28598|iso 8859-8|ヘブライ語 (Iso-visual)|✓||  
|28599|iso-8859-9|トルコ語 (ISO)|||  
|28603|iso 8859-13|エストニア語 (ISO)|||  
|28605|iso-8859-15|ラテン 9 (ISO)|||  
|29001|x Europa|Europa|||  
|38598|iso 8859-8 i|ヘブライ語 (Iso-logical)|✓||  
|50220|iso-2022-jp|日本語 (JIS)|✓||  
|50221|csISO2022JP|日本語 (Jis 1 バイト カタカナ)|✓||  
|50222|iso-2022-jp|日本語 (Jis 1 バイト カタカナ -、/SI)|✓||  
|50225|iso-2022-韓国|韓国語 (ISO)|✓||  
|50227|x-cp50227|簡体字中国語 (iso-2022)|✓||  
|51932|-euc-jp|日本語 (EUC)|✓||  
|51936|EUC CN|簡体字中国語 (EUC)|✓||  
|51949|-euc-kr|韓国語 (EUC)|✓||  
|52936|hz-gb-2312|簡体字中国語 (HZ)|✓||  
|54936|GB18030|簡体字中国語 (GB18030)|✓||  
|57002|x-iscii-de|ISCII デバナガリ文字|✓||  
|57003|iscii する x|ISCII ベンガル語|✓||  
|57004|x-iscii-ta|ISCII タミール語|✓||  
|57005|x-iscii-te|ISCII テルグ語|✓||  
|57006|x-iscii-として|ISCII アッサム語|✓||  
|57007|x iscii または|ISCII オリヤー語|✓||  
|57008|x-iscii-ka|ISCII カンナダ語|✓||  
|57009|x-iscii-ma|ISCII マラヤーラム語|✓||  
|57010|x-iscii-gu|ISCII グジャラート語|✓||  
|57011|x-iscii-pa|ISCII パンジャーブ語|✓||  
|65000|utf-7|Unicode (utf-7)|✓|✓|  
|65001|utf-8|Unicode (UTF-8)|✓|✓|  
  
 次の例では、<xref:System.Text.Encoding.GetEncoding%28System.Int32%29>と<xref:System.Text.Encoding.GetEncoding%28System.String%29>ギリシャ語 (Windows) を取得するメソッドのコード ページ エンコーディングします。 比較、<xref:System.Text.Encoding>それらが等しいか、およびマップが、Unicode コード ポイントと各文字に対応するコード ページ値をギリシャ語のアルファベットで表示し、メソッド呼び出しによって返されるオブジェクト。  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A>メソッドまたは<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 Utf-16、utf-32 エンコーダーは、ビッグ エンディアン バイト順を使用できます (最上位バイト最初) またはリトル エンディアン バイト順 (最下位バイト最初)。 たとえば、としてシリアル化されます (u+0041) Latin Capital Letter は (16 進数) で次に示します。  
  
-   Utf-16 ビッグ エンディアン バイト順: 00 41  
  
-   Utf-16 リトル エンディアン バイト順: 41 00  
  
-   Utf-32 ビッグ エンディアン バイト順: 00 00 00 41  
  
-   Utf-32 リトル エンディアン バイト順: 41 00 00 00  
  
 ネイティブのバイト順を使用して Unicode 文字を格納する方が効率的になります。 たとえば、intel ベースのコンピューターなど、リトル エンディアンのプラットフォームでリトル エンディアン バイト順を使用することをお勧めします。  
  
 <xref:System.Text.Encoding.GetPreamble%2A>メソッドはバイト オーダー マーク (BOM) を含むバイト配列を取得します。 このバイト配列は、エンコードされたストリームをプレフィックスとして、デコーダーが使用されるエンコード形式を識別するのに役立ちます。  
  
 バイト オーダーとバイト順マークの詳細については、Unicode 標準を参照してください、 [Unicode ホーム ページ](https://go.microsoft.com/fwlink/?LinkId=37123)します。  
  
 エンコーディング クラスは、エラーを許可することに注意してください。  
  
-   なしに変更を"?"文字。  
  
-   "Best fit"の文字を使用します。  
  
-   使用して、アプリケーション固有の動作を変更、<xref:System.Text.EncoderFallback>と<xref:System.Text.DecoderFallback>Unicode U + FFFD 置換文字を持つクラス。  
  
 データ ストリームのエラー発生時、例外をスローする必要があります。 アプリが該当する場合は、"throwonerror"フラグを使用またはを使用して、<xref:System.Text.EncoderExceptionFallback>と<xref:System.Text.DecoderExceptionFallback>クラス。 データの損失や混乱を引き起こす可能性が単純な文字の置き換えよりも低いために、最適フォールバックはあまりお勧めします。 ANSI エンコーディングでは、既定値は、最適動作します。  
  
   
  
## Examples  
 次の例では、別のエンコーディングから文字列に変換します。  
  
> [!NOTE]
>  Byte[] 配列は、エンコードされたデータを格納するこの例では、唯一の種類です。 .NET の文字と文字列型をそれ自体は Unicode、ため、<xref:System.Text.Encoding.GetChars%2A>呼び出しが Unicode にデータをデコードします。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生クラスでは、このコンス トラクターをオーバーライドします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">使用するエンコーディングのコード ページ ID。  
  
- または - 
既定のエンコーディングを使用する場合は 0。</param>
        <summary>指定したコード ページに対応する <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生クラスでは、このコンス トラクターをオーバーライドします。  
  
 派生クラスからこのコンス トラクターへの呼び出しを作成、<xref:System.Text.Encoding>エンコードとデコード操作の両方の最適フォールバックを使用するオブジェクト。 両方の<xref:System.Text.Encoding.DecoderFallback%2A>と<xref:System.Text.Encoding.EncoderFallback%2A>プロパティは読み取り専用と変更できません。 派生したクラスのフォールバック ストラテジを制御する<xref:System.Text.Encoding>を呼び出し、<xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>コンス トラクター。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> が 0 未満です。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">エンコーディングのコード ページ ID。</param>
        <param name="encoderFallback">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <param name="decoderFallback">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <summary>指定したコード ページに対応する <see cref="T:System.Text.Encoding" /> クラスの新しいインスタンスを、指定したエンコーダーとデコーダーのフォールバック方法を使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは`protected`; 派生クラスでオーバーライドします。  
  
 フォールバックのエンコードおよびデコードの方法を制御する派生クラスには、このコンス トラクターを呼び出します。 <xref:System.Text.Encoding>クラスのコンス トラクターは、オブジェクトが作成された後に設定するには、エンコーダーまたはデコーダーのフォールバックを許可しない読み取り専用のエンコーディング オブジェクトを作成します。  
  
 いずれか`encoderFallback`または`decoderFallback`が null の場合最適フォールバックは、対応するフォールバックとして使用されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASCII (7 ビット) 文字セットのエンコーディングを取得します。</summary>
        <value>ASCII (7 ビット) 文字セットのエンコーディング。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASCII 文字は、u+0000 U + 007F ~ から下位 128 Unicode 文字に制限されます。  
  
 アプリの ASCII エンコードを選択する場合は、次を考慮してください。  
  
-   ASCII エンコーディングは、ASCII が必要なプロトコルには、通常に適しています。  
  
-   ASCII よりも、utf-8 エンコードが推奨するには、8 ビットのエンコーディング (はされることがあると呼ばれるしない"ASCII") が必要とする場合のエンコードします。 文字 0 ~ 7 f、結果は同じですが utf-8 の使用が表現可能なすべての Unicode 文字の表現を許可することでデータの損失を回避できます。 ASCII エンコーディングは、8 ビットのあいまいさが悪意のある使用を許可することができますが、utf-8 エンコード 8 番目のビットに関するあいまいさを削除します。  
  
-   .NET Framework version 2.0 では、前に、.NET Framework では、なりすましが行われる 8 番目のビットを無視することによって許可されています。 デコード中に、.NET Framework 2.0 以降では、ASCII 以外のコード ポイントを戻る分類されます。  
  
 <xref:System.Text.ASCIIEncoding>このプロパティによって返されるオブジェクトは、アプリの適切な動作がありません。 置換フォールバックを使用して、各エンコードできない文字列とデコードできないバイトがごとに疑問符 () を置き換えます ("?") 文字。 代わりに、呼び出すことができます、<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>をインスタンス化するメソッド、<xref:System.Text.ASCIIEncoding>がフォールバックであるか、オブジェクト、<xref:System.Text.EncoderFallbackException>または<xref:System.Text.DecoderFallbackException>次の例に示すように、します。  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 次の例では、ASCII 文字が ASCII の範囲外にいるエンコーディングの効果を示します。  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ビッグ エンディアンのバイト順を使用する UTF-16 形式のエンコーディングを取得します。</summary>
        <value>ビッグ エンディアンのバイト順を使用する UTF-16 形式のエンコーディング オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UnicodeEncoding>このプロパティによって返されるオブジェクトで、アプリの適切な動作がない可能性があります。 置換フォールバックを使用して、各エンコードできない文字列とデコードできないバイトがごとに疑問符 () を置き換えます ("?") 文字。 代わりに、呼び出すことができます、<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>ビッグ エンディアンのインスタンスを作成するコンス トラクター<xref:System.Text.UnicodeEncoding>のフォールバックは、いずれかのオブジェクト、<xref:System.Text.EncoderFallbackException>または<xref:System.Text.DecoderFallbackException>、次の例に示すようにします。  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 返された<xref:System.Text.UnicodeEncoding>オブジェクトが<xref:System.Text.Encoding.BodyName%2A>、<xref:System.Text.Encoding.HeaderName%2A>と<xref:System.Text.Encoding.WebName%2A>プロパティで、"unicodeFFFE"という名前を生成します。 Utf-16 ビッグ エンディアン バイト順マークが 16 進数の FEFF が、名前"unicodeFFFE"リトル エンディアン Windows コンピューターで 16 進数の FFFE としてバイト オーダー マークが表示されるために選択されました。  
  
   
  
## Examples  
 次の例では、utf-16 エンコーディングをビッグ エンディアン バイト順を使用してテキスト ファイルを読み取ります。  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 次の例は、文字配列をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール エージェントの Body タグと共に使用できる現在のエンコーディングの名前を取得します。</summary>
        <value>メール エージェントの Body タグと共に使用できる、現在の <see cref="T:System.Text.Encoding" /> の名前。  
  
- または - 
現在の <see cref="T:System.Text.Encoding" /> が使用できない場合は、空の文字列 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本文の名前のエンコーディングが必要な場合を呼び出す必要があります<xref:System.Text.Encoding.GetEncoding%2A>で、<xref:System.Text.Encoding.BodyName%2A>プロパティ。 多くの場合、メソッドの呼び出しで提供されるテストのエンコーディングから別のエンコーディングを取得します。 一般にのみ電子メール アプリケーションは、このようなエンコーディングを取得する必要があります。エンコーディングを記述する必要があるその他のほとんどのアプリケーションを使用する必要があります、<xref:System.Text.Encoding.WebName%2A>します。  
  
 場合によっては、値で、<xref:System.Text.Encoding.BodyName%2A>プロパティは、そのエンコーディングを定義する国際標準に対応します。 これは、実装は、その標準に完全に準拠しているという意味しません。  
  
   
  
## Examples  
 次の例は、エンコーディングごとに異なる名前を取得し、エンコーディングとは異なる 1 つまたは複数の名前を表示します。<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>します。 表示されます<xref:System.Text.Encoding.EncodingName%2A>が、それに対しては比較されません。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在の <see cref="T:System.Text.Encoding" /> オブジェクトの簡易コピーを作成します。</summary>
        <returns>現在の <see cref="T:System.Text.Encoding" /> オブジェクトのコピー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クローンが書き込み可能な場合でも、元の<xref:System.Text.Encoding>オブジェクトは読み取り専用です。 そのため、複製のプロパティを変更できます。  
  
 オブジェクトのシャロー コピーは、のみ、オブジェクトのコピーです。 オブジェクトに他のオブジェクトへの参照が含まれている場合、シャロー コピーは、参照されるオブジェクトのコピーを作成できません。 元のオブジェクトを代わりに参照します。 これに対し、オブジェクトのディープ コピーでは、オブジェクトのコピーと、直接または間接的には、そのオブジェクトが参照するすべてのコピーを作成します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在の <see cref="T:System.Text.Encoding" /> のコード ページ ID を取得します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> のコード ページ ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、エンコーディングごとに異なる名前を取得し、エンコーディングとは異なる 1 つまたは複数の名前を表示します。<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>します。 表示されます<xref:System.Text.Encoding.EncodingName%2A>が、それに対しては比較されません。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バイト配列を、あるエンコーディングから別のエンコーディングに変換します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">
          <c>bytes</c> のエンコーディング形式。</param>
        <param name="dstEncoding">変換後のエンコーディング形式。</param>
        <param name="bytes">変換対象のバイト。</param>
        <summary>バイト配列全体を、あるエンコーディングから別のエンコーディングに変換します。</summary>
        <returns>
          <see cref="T:System.Byte" /> を <paramref name="bytes" /> から <paramref name="srcEncoding" /> へ変換した結果を格納する <paramref name="dstEncoding" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、ASCII でエンコードされた文字列に Unicode でエンコードされた文字列に変換します。 ASCII エンコード オブジェクトがによって返されるため、<xref:System.Text.Encoding.ASCII%2A>プロパティが置換フォールバックを使用して、Pi 文字、ASCII 文字セットの一部でないと、例の出力として、Pi の文字が疑問符 (?) に置き換えられます。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="dstEncoding" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="bytes" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 **srcEncoding です。** <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 **dstEncoding です。** <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">変換前の配列 <c>bytes</c> のエンコーディング。</param>
        <param name="dstEncoding">変換後の配列のエンコーディング。</param>
        <param name="bytes">変換対象のバイト配列。</param>
        <param name="index">変換対象の <c>bytes</c> の最初の要素を示すインデックス。</param>
        <param name="count">変換するバイト数。</param>
        <summary>バイト配列内のバイトの範囲を、あるエンコーディングから別のエンコーディングに変換します。</summary>
        <returns>
          <see cref="T:System.Byte" /> に含まれる特定の範囲のバイトを <paramref name="bytes" /> から <paramref name="srcEncoding" /> へ変換した結果が格納されている <paramref name="dstEncoding" /> 型の配列。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="dstEncoding" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="bytes" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> および <paramref name="count" /> がバイト配列内の有効範囲を指定していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 **srcEncoding です。** <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 **dstEncoding です。** <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.DecoderFallback" /> オブジェクトの <see cref="T:System.Text.Encoding" /> オブジェクトを取得または設定します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> オブジェクトのデコーダー フォールバック オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback>オブジェクトは、エンコード済みバイト シーケンスを文字にデコードできないときに呼び出されるエラー ハンドラーを表します。 次のハンドラーの種類のいずれかがサポートされています。  
  
-   デコードできないバイトをいくつかの適切な置換文字に置き換え、最適フォールバックのハンドラー。  
  
-   置換フォールバック ハンドラー、いくつかの任意の置換文字をデコードできないバイトに取って代わります。 .NET には、1 つの置換フォールバック ハンドラーが含まれています。 <xref:System.Text.DecoderFallback>、疑問符でデコードできないバイトを置き換える既定で ("?") 文字。  
  
-   例外フォールバック ハンドラーのバイトをデコードできないときに例外をスローします。 .NET には、1 つの例外フォールバック ハンドラーが含まれています。 <xref:System.Text.DecoderExceptionFallback>、どのがスローされます、<xref:System.Text.DecoderFallbackException>バイトをデコードできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">設定操作の値が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Text.Encoding" /> オブジェクトが読み取り専用であるため、値を設定操作に割り当てることができません。</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この .NET 実装の既定のエンコードを取得します。</summary>
        <value>既定のこの実装は .NET のエンコーディングします。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  別のコンピューターは、さまざまなエンコーディングを使用して、既定値として、1 台のコンピューターで、既定のエンコーディングを変更できます。 使用する場合、<xref:System.Text.Encoding.Default%2A>エンコードおよびストリーミングのコンピューター間または同じコンピューター上のさまざまなタイミングで取得データをデコードするエンコード、その可能性がありますいないデータを正しく変換します。 さらに、によって返される、エンコード、<xref:System.Text.Encoding.Default%2A>プロパティでは、最適フォールバックを使用して、サポートされていない文字をコード ページでサポートされている文字にマップします。 これらの理由から、既定のエンコード方法は推奨されません。 エンコードされたバイトを正しくデコードは、Unicode のエンコードなどを使用する必要があります、<xref:System.Text.UTF8Encoding>または<xref:System.Text.UnicodeEncoding>します。 同じ形式をエンコードおよびデコードに使用されるようにするのに上位レベルのプロトコルを使用することも可能性があります。  

### <a name="the-default-property-in-the-net-framework"></a>.NET Framework の既定のプロパティ

Windows デスクトップで、.NET Framework で、<xref:System.Text.Encoding.Default%2A>プロパティは常に、システムのアクティブなコード ページを取得し、作成、<xref:System.Text.Encoding>それに対応するオブジェクト。 現在のコード ページには、ANSI コード ページ、コード ページによって異なる追加の文字と設定の ASCII 文字が含まれている可能性があります。 すべて<xref:System.Text.Encoding.Default%2A>ANSI コード ページに基づいてエンコード データが失われる、使用を検討して、<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>代わりにエンコードします。 Utf-8 では、U + 7 f の範囲と同じ U + 00 がよくありますが、失うことがなく ASCII 範囲外の文字をエンコードすることができます。

## <a name="the-default-property-on-net-core"></a>.NET Core での既定のプロパティ

.NET Core で、<xref:System.Text.Encoding.Default%2A>プロパティは常に返します、<xref:System.Text.UTF8Encoding>します。 Utf-8 は、実行する .NET Core アプリケーションのすべてのオペレーティング システム (Windows、Linux、および Max OS X) でサポートされます。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.EncoderFallback" /> オブジェクトの <see cref="T:System.Text.Encoding" /> オブジェクトを取得または設定します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> オブジェクトのエンコーダー フォールバック オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.EncoderFallback>オブジェクトは、文字、エンコード済みバイト シーケンスに変換できないときに呼び出されるエラー ハンドラーを表します。 次のハンドラーの種類のいずれかがサポートされています。  
  
-   いくつかの適切な代替文字をエンコードできない文字に置き換えます、最適フォールバックのハンドラー。  
  
-   置換フォールバック ハンドラーをいくつか任意の置換文字をエンコードできない文字に置き換えます。 .NET には、1 つの置換フォールバック ハンドラーが含まれています。 <xref:System.Text.EncoderFallback>、エンコードできない文字を疑問符 () で置き換えます既定で ("?") 文字。  
  
-   例外フォールバック ハンドラーの文字をエンコードできないときに例外をスローします。 .NET には、1 つの例外フォールバック ハンドラーが含まれています。 <xref:System.Text.EncoderExceptionFallback>、どのがスローされます、<xref:System.Text.EncoderFallbackException>文字をデコードできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">設定操作の値が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">現在の <see cref="T:System.Text.Encoding" /> オブジェクトが読み取り専用であるため、値を設定操作に割り当てることができません。</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングについての記述を、ユーザーが判読できる形式で取得します。</summary>
        <value>ユーザーが判読できる形式の、現在の <see cref="T:System.Text.Encoding" /> の記述。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.EncodingName%2A>プロパティが表示を目的とします。 渡すことができる名前を検索する、<xref:System.Text.Encoding.GetEncoding%2A>メソッドを使用して、<xref:System.Text.Encoding.WebName%2A>プロパティ。  
  
   
  
## Examples  
 次の例は、エンコーディングごとに異なる名前を取得し、エンコーディングとは異なる 1 つまたは複数の名前を表示します。<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>します。 表示されます<xref:System.Text.Encoding.EncodingName%2A>が、それに対しては比較されません。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">現在のインスタンスと比較する <see cref="T:System.Object" />。</param>
        <summary>指定した <see cref="T:System.Object" /> が、現在のインスタンスと等しいかどうかを判断します。</summary>
        <returns>
          <paramref name="value" /> が <see cref="T:System.Text.Encoding" /> のインスタンスで、現在のインスタンスと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 2 つのインスタンス<xref:System.Text.Encoding>が等しい場合は、同じコード ページに対応して、その`EncoderFallback`と`DecoderFallback`オブジェクトが等しい。 具体的には、派生コード ページは、すべてが 0 のコード ページがあるし、通常は、フォールバック`null`(`Nothing` Visual Basic .NET で)。 したがって、すべて等しいと見なされます互いにします。 1 つの結果は場合<xref:System.Text.Encoding.Equals%2A>ハッシュ テーブルを設定するために使用、すべての派生と同じエンコーディングの比較、およびハッシュ テーブルの同じスロットに分類されます。  
  
   
  
## Examples  
 次の例では、(コード ページによって 1 つ)、もう一方は名前をエンコードするには、同じ 2 つのインスタンスを取得し、等しいかどうかを確認します。  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字を格納している文字配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されているすべての文字をエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字配列に格納されているすべての文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要な正確な配列のサイズを計算する<xref:System.Text.Encoding.GetBytes%2A>結果のバイトを格納するには、呼び出す、<xref:System.Text.Encoding.GetByteCount%2A>メソッド。 配列の最大サイズを計算するには、呼び出し、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッド。 <xref:System.Text.Encoding.GetByteCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>メソッドでは、バイト数が、Unicode 文字のセットがエンコードされるかを判断します。 および<xref:System.Text.Encoding.GetBytes%2A>メソッドは、実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数の変換を処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetByteCount%2A>と<xref:System.Text.Encoding.GetBytes%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードし、複数の呼び出しを使用して文字を処理する必要があります。 この場合、おそらく必要がありますを永続化状態を考慮して、呼び出し間で状態を維持するために、<xref:System.Text.Encoder>使用されているオブジェクトします。  
  
-   アプリでは、文字列入力を処理する場合は、文字列バージョンを使用する必要があります、<xref:System.Text.Encoding.GetBytes%2A>メソッド。  
  
-   Unicode 文字バッファー バージョン<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>により、特に、複数の呼び出しを使用して、いくつかの高速テクニック、<xref:System.Text.Encoder>オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   場合は、アプリは、大量のデータを変換する必要があります、出力バッファーを再利用する必要があります。 ここで、<xref:System.Text.Encoding.GetBytes%2A>バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、可能であれば、できるだけ多くのデータを変換しは出力バッファーが小さすぎる場合は例外をスローします。 継続的なストリームのエンコーディングでは、このメソッドと、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例は、文字配列をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">エンコード対象の文字のセットを格納している文字列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列に含まれる文字をエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要な正確な配列のサイズを計算する<xref:System.Text.Encoding.GetBytes%2A>結果のバイトを格納するには、呼び出す、<xref:System.Text.Encoding.GetByteCount%2A>メソッド。 配列の最大サイズを計算するには、呼び出し、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッド。 <xref:System.Text.Encoding.GetByteCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>メソッドでは、バイト数が、Unicode 文字のセットがエンコードされるかを判断します。 および<xref:System.Text.Encoding.GetBytes%2A>メソッドは、実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数の変換を処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetByteCount%2A>と<xref:System.Text.Encoding.GetBytes%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードし、複数の呼び出しを使用して文字を処理する必要があります。 この場合、おそらく必要がありますを永続化状態を考慮して、呼び出し間で状態を維持するために、<xref:System.Text.Encoder>使用されているオブジェクトします。  
  
-   アプリが入力文字列の文字列形式を処理する場合<xref:System.Text.Encoding.GetBytes%2A>をお勧めします。  
  
-   Unicode 文字バッファー バージョン<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>により、特に、複数の呼び出しを使用して、いくつかの高速テクニック、<xref:System.Text.Encoder>オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、<xref:System.Text.Encoding.GetBytes%2A>バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、可能であれば、できるだけ多くのデータを変換しは出力バッファーが小さすぎる場合は例外をスローします。 継続的なストリームのエンコーディングでは、このメソッドと、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例は、文字列または文字列の範囲をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字ポインターから始まる文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 計算する正確な配列のサイズを<xref:System.Text.Encoding.GetBytes%2A>必要呼び出す必要があります、結果のバイトを格納する、<xref:System.Text.Encoding.GetByteCount%2A>メソッド。 配列の最大サイズを計算するには、呼び出し、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッド。 <xref:System.Text.Encoding.GetByteCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29>メソッドでは、バイト数が、Unicode 文字のセットがエンコードされるかを判断します。 および<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>メソッドは、実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数の変換を処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetByteCount%2A>と<xref:System.Text.Encoding.GetBytes%2A>はサポートされています。 次に、これらのメソッドの使用に関するいくつかの考慮事項を示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードし、複数の呼び出しを使用して文字を処理する必要があります。 この場合、おそらく必要がありますを永続化状態を考慮して、呼び出し間で状態を維持するために、<xref:System.Text.Encoder>使用されているオブジェクトします。  
  
-   アプリでは、文字列入力を処理する場合の文字列バージョンを使用する必要があります、<xref:System.Text.Encoding.GetBytes%2A>メソッド。  
  
-   Unicode 文字バッファー バージョン<xref:System.Text.Encoding.GetBytes%2A>により、特に、複数の呼び出しを使用して、いくつかの高速テクニック、<xref:System.Text.Encoder>オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、<xref:System.Text.Encoding.GetBytes%2A>バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、可能であれば、できるだけ多くのデータを変換しは出力バッファーが小さすぎる場合は例外をスローします。 継続的なストリームのエンコーディングでは、このメソッドと、最適な選択肢では多くの場合です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットをエンコードすることによって生成されるバイト数を計算します。</summary>
        <returns>指定した文字をエンコードすることによって生成されるバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要な正確な配列のサイズを計算する<xref:System.Text.Encoding.GetBytes%2A>結果のバイトを格納するには、呼び出す、<xref:System.Text.Encoding.GetByteCount%2A>メソッド。 配列の最大サイズを計算するには、呼び出し、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッド。 <xref:System.Text.Encoding.GetByteCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>メソッドでは、バイト数が、Unicode 文字のセットがエンコードされるかを判断します。 および<xref:System.Text.Encoding.GetBytes%2A>メソッドは、実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数の変換を処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetByteCount%2A>と<xref:System.Text.Encoding.GetBytes%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードし、複数の呼び出しを使用して文字を処理する必要があります。 この場合、おそらく必要がありますを永続化状態を考慮して、呼び出し間で状態を維持するために、<xref:System.Text.Encoder>使用されているオブジェクトします。  
  
-   アプリが入力文字列の文字列形式を処理する場合<xref:System.Text.Encoding.GetBytes%2A>をお勧めします。  
  
-   Unicode 文字バッファー バージョン<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>により、特に、複数の呼び出しを使用して、いくつかの高速テクニック、<xref:System.Text.Encoder>オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、<xref:System.Text.Encoding.GetBytes%2A>バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、可能であれば、できるだけ多くのデータを変換しは出力バッファーが小さすぎる場合は例外をスローします。 継続的なストリームのエンコーディングでは、このメソッドと、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例は、文字配列から次の 3 つの文字をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
- または - 
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、文字のセットをバイト シーケンスにエンコードします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字を格納している文字配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されているすべての文字をバイト シーケンスにエンコードします。</summary>
        <returns>指定した文字のセットをエンコードした結果を格納しているバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A>メソッドまたは<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>メソッドでは、バイト数が、Unicode 文字のセットがエンコードされるかを判断します。 および<xref:System.Text.Encoding.GetBytes%2A>メソッドは、実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数の変換を処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetByteCount%2A>と<xref:System.Text.Encoding.GetBytes%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードし、複数の呼び出しを使用して文字を処理する必要があります。 この場合、おそらく必要がありますを永続化状態を考慮して、呼び出し間で状態を維持するために、<xref:System.Text.Encoder>使用されているオブジェクトします。 (たとえば、サロゲート ペアを含む文字シーケンスから上位サロゲートで終わる可能性があります。 <xref:System.Text.Encoder>できるので、次の呼び出しの先頭に下位サロゲートで組み合わせることができますが、その上位サロゲートが記憶されます。 <xref:System.Text.Encoding> 文字が送信されるため、状態を維持することはできません、 <xref:System.Text.EncoderFallback>)。  
  
-   アプリでは、文字列入力を処理する場合の文字列バージョンを呼び出す必要があります、<xref:System.Text.Encoding.GetBytes%2A>メソッド。  
  
-   Unicode 文字バッファー バージョン<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>により、特に、複数の呼び出しを使用して、いくつかの高速テクニック、<xref:System.Text.Encoder>オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、<xref:System.Text.Encoding.GetBytes%2A>バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、可能であれば、できるだけ多くのデータを変換しは出力バッファーが小さすぎる場合は例外をスローします。 継続的なストリームのエンコーディングでは、このメソッドと、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例は、文字配列をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">エンコードする文字を含む文字列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列に含まれるすべての文字をバイト シーケンスにエンコードします。</summary>
        <returns>指定した文字のセットをエンコードした結果を格納しているバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A>メソッドまたは<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>メソッドでは、バイト数が、Unicode 文字のセットがエンコードされるかを判断します。 および<xref:System.Text.Encoding.GetBytes%2A>メソッドは、実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数の変換を処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetByteCount%2A>と<xref:System.Text.Encoding.GetBytes%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードし、複数の呼び出しを使用して文字を処理する必要があります。 この場合、おそらく必要がありますを永続化状態を考慮して、呼び出し間で状態を維持するために、<xref:System.Text.Encoder>使用されているオブジェクトします。 (たとえば、サロゲート ペアを含む文字シーケンスから上位サロゲートで終わる可能性があります。 <xref:System.Text.Encoder>できるので、次の呼び出しの先頭に下位サロゲートで組み合わせることができますが、その上位サロゲートが記憶されます。 <xref:System.Text.Encoding> 文字が送信されるため、状態を維持することはできません、 <xref:System.Text.EncoderFallback>)。  
  
-   アプリでは、文字列入力を処理する場合の文字列バージョンを使用する必要があります<xref:System.Text.Encoding.GetBytes%2A>します。  
  
-   Unicode 文字バッファー バージョン<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>により、特に、複数の呼び出しを使用して、いくつかの高速テクニック、<xref:System.Text.Encoder>オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、<xref:System.Text.Encoding.GetBytes%2A>バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、可能であれば、できるだけ多くのデータを変換しは出力バッファーが小さすぎる場合は例外をスローします。 継続的なストリームのエンコーディングでは、このメソッドと、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例は、文字列または文字列の範囲をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="index">エンコードする最初の文字のインデックス。</param>
        <param name="count">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットをバイト シーケンスにエンコードします。</summary>
        <returns>指定した文字のセットをエンコードした結果を格納しているバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A>メソッドまたは<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>メソッドでは、バイト数が、Unicode 文字のセットがエンコードされるかを判断します。 および<xref:System.Text.Encoding.GetBytes%2A>メソッドは、実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数の変換を処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetByteCount%2A>と<xref:System.Text.Encoding.GetBytes%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードし、複数の呼び出しを使用して文字を処理する必要があります。 この場合、おそらく必要がありますを永続化状態を考慮して、呼び出し間で状態を維持するために、<xref:System.Text.Encoder>使用されているオブジェクトします。 (たとえば、サロゲート ペアを含む文字シーケンスから上位サロゲートで終わる可能性があります。 <xref:System.Text.Encoder>できるので、次の呼び出しの先頭に下位サロゲートで組み合わせることができますが、その上位サロゲートが記憶されます。 <xref:System.Text.Encoding> 文字が送信されるため、状態を維持することはできません、 <xref:System.Text.EncoderFallback>)。  
  
-   アプリでは、文字列入力を処理する場合の文字列バージョンを使用する必要があります<xref:System.Text.Encoding.GetBytes%2A>します。  
  
-   Unicode 文字バッファー バージョン<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>により、特に、複数の呼び出しを使用して、いくつかの高速テクニック、<xref:System.Text.Encoder>オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、<xref:System.Text.Encoding.GetBytes%2A>バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、可能であれば、できるだけ多くのデータを変換しは出力バッファーが小さすぎる場合は例外をスローします。 継続的なストリームのエンコーディングでは、このメソッドと、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例は、文字配列から次の 3 つの文字をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
- または - 
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="chars" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコードする最初の文字へのポインター。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスの書き込みを開始する位置へのポインター。</param>
        <param name="byteCount">書き込む最大バイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字ポインターで始まる文字のセットを、指定したバイト ポインターを開始位置として格納されるバイト シーケンスにエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> パラメーターによって示される位置に書き込む実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 計算する正確な配列のサイズを<xref:System.Text.Encoding.GetBytes%2A>が必要です、結果のバイトを格納するには、呼び出す、<xref:System.Text.Encoding.GetByteCount%2A>メソッド。 配列の最大サイズを計算するには、呼び出し、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッド。 <xref:System.Text.Encoding.GetByteCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッドは通常、高速に実行されます。  
  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>オブジェクト、によって提供される<xref:System.Text.Encoding.GetDecoder%2A>または<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>メソッドでは、バイト数が、Unicode 文字のセットがエンコードされるかを判断します。 および<xref:System.Text.Encoding.GetBytes%2A>メソッドは、実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数の変換を処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetByteCount%2A>と<xref:System.Text.Encoding.GetBytes%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードし、複数の呼び出しを使用して文字を処理する必要があります。 この場合、おそらく必要がありますを永続化状態を考慮して、呼び出し間で状態を維持するために、<xref:System.Text.Encoder>使用されているオブジェクトします。 (たとえば、サロゲート ペアを含む文字シーケンスから上位サロゲートで終わる可能性があります。 <xref:System.Text.Encoder>できるので、次の呼び出しの先頭に下位サロゲートで組み合わせることができますが、その上位サロゲートが記憶されます。 <xref:System.Text.Encoding> 文字が送信されるため、状態を維持することはできません、 <xref:System.Text.EncoderFallback>)。  
  
-   アプリでは、文字列入力を処理する場合の文字列バージョンを使用する必要があります<xref:System.Text.Encoding.GetBytes%2A>します。  
  
-   Unicode 文字バッファー バージョン<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>により、特に、複数の呼び出しを使用して、いくつかの高速テクニック、<xref:System.Text.Encoder>オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、<xref:System.Text.Encoding.GetBytes%2A>バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、可能であれば、できるだけ多くのデータを変換しは出力バッファーが小さすぎる場合は例外をスローします。 継続的なストリームのエンコーディングでは、このメソッドと、最適な選択肢では多くの場合です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="bytes" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> が結果のバイト数より少なくなっています。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">エンコード対象の文字のセットを格納している文字配列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字配列に格納されている文字のセットを、指定したバイト配列にエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要な正確な配列のサイズを計算する<xref:System.Text.Encoding.GetBytes%2A>呼び出す必要があります、結果のバイトを格納する、<xref:System.Text.Encoding.GetByteCount%2A>メソッド。 配列の最大サイズを計算するには、呼び出し、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッド。 <xref:System.Text.Encoding.GetByteCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッドは通常、高速に実行されます。  
  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A>メソッドまたは<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>メソッドでは、バイト数が、Unicode 文字のセットがエンコードされるかを判断します。 および<xref:System.Text.Encoding.GetBytes%2A>メソッドは、実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数の変換を処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetByteCount%2A>と<xref:System.Text.Encoding.GetBytes%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードし、複数の呼び出しを使用して文字を処理する必要があります。 この場合、おそらく必要がありますを永続化状態を考慮して、呼び出し間で状態を維持するために、<xref:System.Text.Encoder>使用されているオブジェクトします。 (たとえば、サロゲート ペアを含む文字シーケンスから上位サロゲートで終わる可能性があります。 <xref:System.Text.Encoder>できるので、次の呼び出しの先頭に下位サロゲートで組み合わせることができますが、その上位サロゲートが記憶されます。 <xref:System.Text.Encoding> 文字が送信されるため、状態を維持することはできません、 <xref:System.Text.EncoderFallback>)。  
  
-   アプリでは、文字列入力を処理する場合の文字列バージョンを使用する必要があります<xref:System.Text.Encoding.GetBytes%2A>します。  
  
-   Unicode 文字バッファー バージョン<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>により、特に、複数の呼び出しを使用して、いくつかの高速テクニック、<xref:System.Text.Encoder>オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、<xref:System.Text.Encoding.GetBytes%2A>バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、可能であれば、できるだけ多くのデータを変換しは出力バッファーが小さすぎる場合は例外をスローします。 継続的なストリームのエンコーディングでは、このメソッドと、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例は、文字配列から次の 3 つの文字をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="bytes" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />、<paramref name="charCount" />、または <paramref name="byteIndex" /> が 0 未満です。  
  
- または - 
 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
- または - 
 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> には、<paramref name="byteIndex" /> から配列の末尾までに十分なサイズがなく、結果のバイトを格納できません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">エンコード対象の文字のセットを格納している文字列。</param>
        <param name="charIndex">エンコードする最初の文字のインデックス。</param>
        <param name="charCount">エンコードする文字数。</param>
        <param name="bytes">結果のバイト シーケンスを格納するバイト配列。</param>
        <param name="byteIndex">結果のバイト シーケンスを書き込む開始位置のインデックス。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字列に含まれる文字のセットを、指定したバイト配列にエンコードします。</summary>
        <returns>
          <paramref name="bytes" /> に書き込まれた実際のバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要な正確な配列のサイズを計算する<xref:System.Text.Encoding.GetBytes%2A>呼び出す必要があります、結果のバイトを格納する、<xref:System.Text.Encoding.GetByteCount%2A>メソッド。 配列の最大サイズを計算するには、呼び出し、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッド。 <xref:System.Text.Encoding.GetByteCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッドは通常、高速に実行されます。  
  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A>メソッドまたは<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 <xref:System.Text.Encoding.GetByteCount%2A>メソッドでは、バイト数が、Unicode 文字のセットがエンコードされるかを判断します。 および<xref:System.Text.Encoding.GetBytes%2A>メソッドは、実際のエンコードを実行します。 <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数の変換を処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetByteCount%2A>と<xref:System.Text.Encoding.GetBytes%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページに多くの入力文字をエンコードし、複数の呼び出しを使用して文字を処理する必要があります。 この場合、おそらく必要がありますを永続化状態を考慮して、呼び出し間で状態を維持するために、<xref:System.Text.Encoder>使用されているオブジェクトします。 (たとえば、サロゲート ペアを含む文字シーケンスから上位サロゲートで終わる可能性があります。 <xref:System.Text.Encoder>できるので、次の呼び出しの先頭に下位サロゲートで組み合わせることができますが、その上位サロゲートが記憶されます。 <xref:System.Text.Encoding> 文字が送信されるため、状態を維持することはできません、 <xref:System.Text.EncoderFallback>)。  
  
-   アプリでは、文字列入力を処理する場合の文字列バージョンを使用する必要があります<xref:System.Text.Encoding.GetBytes%2A>します。  
  
-   Unicode 文字バッファー バージョン<xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29>により、特に、複数の呼び出しを使用して、いくつかの高速テクニック、<xref:System.Text.Encoder>オブジェクトまたは既存のバッファーに挿入します。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、<xref:System.Text.Encoding.GetBytes%2A>バイト配列をサポートするバージョンをお勧めします。  
  
-   使用を検討して、<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetByteCount%2A>します。 変換メソッドは、可能であれば、できるだけ多くのデータを変換しは出力バッファーが小さすぎる場合は例外をスローします。 継続的なストリームのエンコーディングでは、このメソッドと、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例は、文字列または文字列の範囲をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="bytes" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />、<paramref name="charCount" />、または <paramref name="byteIndex" /> が 0 未満です。  
  
- または - 
 <paramref name="charIndex" /> および <paramref name="charCount" /> は <paramref name="chars" /> において有効な範囲を表していません。  
  
- または - 
 <paramref name="byteIndex" /> が <paramref name="bytes" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> には、<paramref name="byteIndex" /> から配列の末尾までに十分なサイズがなく、結果のバイトを格納できません。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要な正確な配列のサイズを計算する<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29>、結果の文字を保存するには、使用する必要があります、<xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>メソッド。 配列の最大サイズを計算する必要がありますを使用する、<xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29>メソッド。 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29>メソッドでは、文字数が発生するシーケンス (バイト単位) をデコードするかを判断します。 および<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29>メソッドは、実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数のパスを処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetCharCount%2A>と<xref:System.Text.Encoding.GetChars%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 この場合、おそらく、呼び出しの間で状態を維持する必要があります。  
  
-   使用する必要があります、アプリは、文字列出力を処理する場合、<xref:System.Text.Encoding.GetString%2A>メソッド。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、結果しますが、<xref:System.String>型は、お勧めします。  
  
-   バイト バージョン<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、[\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > バージョンの出力の文字をサポートしていますバッファーは、最適な選択肢です。  
  
-   使用を検討して、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドは、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例では、(バイト単位) の配列に文字列をエンコードし、文字の配列にバイトをデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト ポインターから始まるバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 計算する正確な配列のサイズを<xref:System.Text.Encoding.GetChars%2A>が必要です、結果の文字を保存するには、使用する必要があります、<xref:System.Text.Encoding.GetCharCount%2A>メソッド。 配列の最大サイズを計算するには、使用、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッド。 <xref:System.Text.Encoding.GetCharCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>メソッドでは、文字数が発生するシーケンス (バイト単位) をデコードするかを判断します。 および<xref:System.Text.Encoding.GetChars%2A>メソッドは、実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数のパスを処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetCharCount%2A>と<xref:System.Text.Encoding.GetChars%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 この場合、おそらく、呼び出しの間で状態を維持する必要があります。  
  
-   使用する場合は、アプリは、文字列出力を処理するをお勧め、<xref:System.Text.Encoding.GetString%2A>メソッド。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、結果しますが、<xref:System.String>型は、お勧めします。  
  
-   バイト バージョン<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、[\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > バージョンの出力の文字をサポートしていますバッファーは、最適な選択肢です。  
  
-   使用を検討して、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドは、最適な選択肢では多くの場合です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要な正確な配列のサイズを計算する<xref:System.Text.Encoding.GetChars%2A>、結果の文字を保存するには、使用する必要があります、<xref:System.Text.Encoding.GetCharCount%2A>メソッド。 配列の最大サイズを計算するには、使用、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッド。 <xref:System.Text.Encoding.GetCharCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>メソッドでは、文字数が発生するシーケンス (バイト単位) をデコードするかを判断します。 および<xref:System.Text.Encoding.GetChars%2A>メソッドは、実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数のパスを処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetCharCount%2A>と<xref:System.Text.Encoding.GetChars%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 この場合、おそらく、呼び出しの間で状態を維持する必要があります。  
  
-   使用する場合は、アプリは、文字列出力を処理するをお勧め、<xref:System.Text.Encoding.GetString%2A>メソッド。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、結果しますが、<xref:System.String>型は、お勧めします。  
  
-   バイト バージョン<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、[\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > バージョンの出力の文字をサポートしていますバッファーは、最適な選択肢です。  
  
-   使用を検討して、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドは、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例では、別のエンコーディングから文字列に変換します。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 次の例では、(バイト単位) の配列に文字列をエンコードし、その文字の配列にバイトの範囲をデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
- または - 
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスを文字のセットにデコードします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトを文字のセットにデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納された文字配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイト シーケンスから文字を取得します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 異なります<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>ため<xref:System.Text.Encoding>不連続の変換が必要ですが中に<xref:System.Text.Decoder>は 1 つの入力ストリームで複数のパスに設計されています。  
  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A>メソッドまたは<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 **注**このメソッドはバイト配列などの任意のバイナリ データではなく、Unicode 文字を操作するためのものです。 テキストに任意のバイナリ データをエンコードする必要がある場合は、uuencode などの方法で実装されているなどのプロトコルを使用する必要があります<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>します。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>メソッドでは、文字数が発生するシーケンス (バイト単位) をデコードするかを判断します。 および<xref:System.Text.Encoding.GetChars%2A>メソッドは、実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数のパスを処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetCharCount%2A>と<xref:System.Text.Encoding.GetChars%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 ここでは、おそらく必要があります、呼び出し間で状態を維持するためにバッチ処理では、バイト シーケンスを中断することがあるため。 (たとえば、iso-2022 のシフト シーケンスの一部がなる可能性がありますいずれかの<xref:System.Text.Encoding.GetChars%2A>を呼び出すし、次の先頭から継続<xref:System.Text.Encoding.GetChars%2A>を呼び出します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不完全なシーケンスの場合、フォールバックを呼び出しますが、<xref:System.Text.Decoder>は、次の呼び出しのシーケンスに注意してください)。  
  
-   使用する場合は、アプリは、文字列出力を処理するをお勧め、<xref:System.Text.Encoding.GetString%2A>メソッド。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、結果しますが、<xref:System.String>型は、お勧めします。  
  
-   バイト バージョン<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、[\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > バージョンの出力の文字をサポートしていますバッファーは、最適な選択肢です。  
  
-   使用を検討して、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドは、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例では、(バイト単位) の配列に文字列をエンコードし、文字の配列にバイトをデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを文字のセットにデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納された文字配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイト シーケンスから文字を取得します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 異なります<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>ため<xref:System.Text.Encoding>不連続の変換が必要ですが中に<xref:System.Text.Decoder>は 1 つの入力ストリームで複数のパスに設計されています。  
  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A>メソッドまたは<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 **注**このメソッドはバイト配列などの任意のバイナリ データではなく、Unicode 文字を操作するためのものです。 テキストに任意のバイナリ データをエンコードする必要がある場合は、uuencode などの方法で実装されているなどのプロトコルを使用する必要があります<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>します。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>メソッドでは、文字数が発生するシーケンス (バイト単位) をデコードするかを判断します。 および<xref:System.Text.Encoding.GetChars%2A>メソッドは、実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数のパスを処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetCharCount%2A>と<xref:System.Text.Encoding.GetChars%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 ここでは、おそらく必要があります、呼び出し間で状態を維持するためにバッチ処理では、バイト シーケンスを中断することがあるため。 (たとえば、iso-2022 のシフト シーケンスの一部がなる可能性がありますいずれかの<xref:System.Text.Encoding.GetChars%2A>を呼び出すし、次の先頭から継続<xref:System.Text.Encoding.GetChars%2A>を呼び出します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不完全なシーケンスの場合、フォールバックを呼び出しますが、<xref:System.Text.Decoder>は、次の呼び出しのシーケンスに注意してください)。  
  
-   使用する場合は、アプリは、文字列出力を処理するをお勧め、<xref:System.Text.Encoding.GetString%2A>メソッド。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、結果しますが、<xref:System.String>型は、お勧めします。  
  
-   バイト バージョン<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、[\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > バージョンの出力の文字をサポートしていますバッファーは、最適な選択肢です。  
  
-   使用を検討して、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドは、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例では、(バイト単位) の配列に文字列をエンコードし、その文字の配列にバイトの範囲をデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
- または - 
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字セットの書き込みを開始する位置へのポインター。</param>
        <param name="charCount">書き込む文字の最大数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト ポインターで始まるバイト シーケンスを、指定した文字ポインターを開始位置として格納される文字のセットにデコードします。</summary>
        <returns>
          <paramref name="chars" /> パラメーターによって示される位置に書き込む実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 計算する正確な配列のサイズを<xref:System.Text.Encoding.GetChars%2A>が必要です、結果の文字を保存するには、使用する必要があります、<xref:System.Text.Encoding.GetCharCount%2A>メソッド。 配列の最大サイズを計算するには、使用、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッド。 <xref:System.Text.Encoding.GetCharCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 入力バイト シーケンスから文字を取得します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 異なります<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>ため<xref:System.Text.Encoding>不連続の変換が必要ですが中に<xref:System.Text.Decoder>は 1 つの入力ストリームで複数のパスに設計されています。  
  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>オブジェクト、によって提供される<xref:System.Text.Encoding.GetDecoder%2A>または<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 **注**このメソッドはバイト配列などの任意のバイナリ データではなく、Unicode 文字を操作するためのものです。 テキストに任意のバイナリ データをエンコードする必要がある場合は、uuencode などの方法で実装されているなどのプロトコルを使用する必要があります<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>します。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>メソッドでは、文字数が発生するシーケンス (バイト単位) をデコードするかを判断します。 および<xref:System.Text.Encoding.GetChars%2A>メソッドは、実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数のパスを処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetCharCount%2A>と<xref:System.Text.Encoding.GetChars%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 ここでは、おそらく必要があります、呼び出し間で状態を維持するためにバッチ処理では、バイト シーケンスを中断することがあるため。 (たとえば、iso-2022 のシフト シーケンスの一部がなる可能性がありますいずれかの<xref:System.Text.Encoding.GetChars%2A>を呼び出すし、次の先頭から継続<xref:System.Text.Encoding.GetChars%2A>を呼び出します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> 不完全なシーケンスの場合、フォールバックを呼び出しますが、<xref:System.Text.Decoder>は、次の呼び出しのシーケンスに注意してください)。  
  
-   アプリが、文字列出力を処理する場合、<xref:System.Text.Encoding.GetString%2A>方法はお勧めします。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、結果しますが、<xref:System.String>型は、お勧めします。  
  
-   バイト バージョン<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、[\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > バージョンの出力の文字をサポートしていますバッファーは、最適な選択肢です。  
  
-   使用を検討して、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドは、最適な選択肢では多くの場合です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="chars" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> または <paramref name="charCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" /> が結果の文字数より少なくなっています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="byteIndex">デコードする最初のバイトのインデックス。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字のセットを格納する文字配列。</param>
        <param name="charIndex">結果の文字のセットを書き込む開始位置のインデックス。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを、指定した文字配列にデコードします。</summary>
        <returns>
          <paramref name="chars" /> に書き込まれた実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要な正確な配列のサイズを計算する<xref:System.Text.Encoding.GetChars%2A>、結果の文字を保存するには、使用する必要があります、<xref:System.Text.Encoding.GetCharCount%2A>メソッド。 配列の最大サイズを計算するには、使用、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッド。 <xref:System.Text.Encoding.GetCharCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッドは通常、高速に実行されます。  
  
 [\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType >、入力バイト シーケンスから文字を取得します。 [\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > とは異なります<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>ため<xref:System.Text.Encoding>不連続の変換が必要ですが中に<xref:System.Text.Decoder>は用に設計されています1 つの入力ストリームで複数のパス。  
  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A>メソッドまたは<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 **注**このメソッドはバイト配列などの任意のバイナリ データではなく、Unicode 文字を操作するためのものです。 テキストに任意のバイナリ データをエンコードする必要がある場合は、uuencode などの方法で実装されているなどのプロトコルを使用する必要があります<xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>します。  
  
 <xref:System.Text.Encoding.GetCharCount%2A>メソッドでは、文字数が発生するシーケンス (バイト単位) をデコードするかを判断します。 および<xref:System.Text.Encoding.GetChars%2A>メソッドは、実際のデコードを実行します。 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>メソッドには、不連続の変換とは異なりが必要ですが、<xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>メソッドで、1 つの入力ストリームで複数のパスを処理します。  
  
 複数のバージョンの<xref:System.Text.Encoding.GetCharCount%2A>と<xref:System.Text.Encoding.GetChars%2A>はサポートされています。 次に、これらのメソッドの使用のプログラミング注意事項を示します。  
  
-   アプリは、コード ページから複数の入力バイトをデコードし、複数の呼び出しを使用してバイトを処理する必要があります。 ここでは、おそらく必要があります、呼び出し間で状態を維持するためにバッチ処理では、バイト シーケンスを中断することがあるため。 (たとえば、iso-2022 のシフト シーケンスの一部がなる可能性がありますいずれかの [\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > を呼び出すし、次の先頭に引き続き [\]、Int32, Int32, Char\<xref: System.Text.Encoding.GetChars%2A > を呼び出します。 [\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > は、不完全なシーケンスの場合、フォールバックを呼び出しますが、<xref:System.Text.Decoder>は、次の呼び出しのシーケンスに注意してください)。  
  
-   アプリが、文字列出力を処理する場合、<xref:System.Text.Encoding.GetString%2A>方法はお勧めします。 わずかに遅くなりますが、このメソッドは、文字列の長さを確認し、バッファーを割り当てる必要があります、ため、結果しますが、<xref:System.String>型は、お勧めします。  
  
-   バイト バージョン<xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29>により、特に大きなバッファーを複数回呼び出すと、いくつかの高速なテクニックです。 ただし、このメソッド バージョンがないことも、安全なポインターが必要なので注意してください。  
  
-   アプリでは、大量のデータを変換する必要がある場合、は、出力バッファーを再利用する必要があります。 ここで、[\]、Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > バージョンの出力の文字をサポートしていますバッファーは、最適な選択肢です。  
  
-   使用を検討して、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>メソッドの代わりに<xref:System.Text.Encoding.GetCharCount%2A>します。 変換メソッドは、可能なデータを変換し、出力バッファーが小さすぎる場合に例外をスローします。 継続的なストリームのデコード、このメソッドは、最適な選択肢では多くの場合です。  
  
   
  
## Examples  
 次の例では、別のエンコーディングから文字列に変換します。  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 次の例では、(バイト単位) の配列に文字列をエンコードし、その文字の配列にバイトの範囲をデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" /> です。  
  
- または - 
 <paramref name="chars" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />、<paramref name="byteCount" />、または <paramref name="charIndex" /> が 0 未満です。  
  
- または - 
 <paramref name="byteindex" /> および <paramref name="byteCount" /> は <paramref name="bytes" /> において有効な範囲を表していません。  
  
- または - 
 <paramref name="charIndex" /> が <paramref name="chars" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> には、<paramref name="charIndex" /> から配列の末尾までに十分なサイズがなく、結果の文字を格納できません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、エンコード済みバイト シーケンスを文字シーケンスに変換するデコーダーを取得します。</summary>
        <returns>エンコード済みバイト シーケンスを文字シーケンスに変換する <see cref="T:System.Text.Decoder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType>メソッドと同様の方法で、文字のシーケンシャル ブロックにバイトのシーケンシャル ブロックを変換する、<xref:System.Text.Encoding.GetChars%2A>このクラスのメソッド。 ただし、<xref:System.Text.Decoder>のブロックをまたぐバイト シーケンスを正しくデコードするための呼び出しの間の状態情報を保持します。 <xref:System.Text.Decoder>もデータ ブロックの末尾にある後続バイトが保持され、[次へ] のデコード操作で末尾のバイトを使用します。 そのため、<xref:System.Text.Encoding.GetDecoder%2A>と<xref:System.Text.Encoding.GetEncoder%2A>は完全なデータ ストリームではなくデータのブロックを頻繁にこれらの操作を処理するためにネットワーク転送と、ファイル操作に便利です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>既定の実装を返します、<see cref="T:System.Text.Decoder" />を呼び出す、<see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />と<see cref="M:System.Text.Encoding.GetChars(System.Byte[])" />メソッドは、現在の<see cref="T:System.Text.Encoding" />します。 返すには、このメソッドをオーバーライドする必要があります、<see cref="T:System.Text.Decoder" />呼び出しの間の状態を保持します。</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、Unicode 文字のシーケンスをエンコード済みバイト シーケンスに変換するエンコーダーを取得します。</summary>
        <returns>Unicode 文字のシーケンスをエンコード済みバイト シーケンスに変換する <see cref="T:System.Text.Encoder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType>メソッドと同様の方法で、バイトのブロックをシーケンシャルに文字のシーケンシャル ブロックを変換する、<xref:System.Text.Encoding.GetBytes%2A>このクラスのメソッド。 ただし、<xref:System.Text.Encoder>のブロックをまたぐ文字シーケンスが正しくエンコードするための呼び出しの間の状態情報を保持します。 <xref:System.Text.Encoder>も末尾の保持のデータ ブロックの末尾に文字し、末尾の文字を次のエンコードの操作に使用されます。 たとえば、データ ブロック上位サロゲートで終了し、[次へ] のデータ ブロックに一致する下位サロゲートがあります。 そのため、<xref:System.Text.Encoding.GetDecoder%2A>と<xref:System.Text.Encoding.GetEncoder%2A>は完全なデータ ストリームではなくデータのブロックを頻繁にこれらの操作を処理するためにネットワーク転送と、ファイル操作に便利です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>既定の実装を返します、<see cref="T:System.Text.Encoder" />を呼び出す、<see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />と<see cref="M:System.Text.Encoding.GetBytes(System.Char[])" />メソッドは、現在の<see cref="T:System.Text.Encoding" />します。 返すには、このメソッドをオーバーライドする必要があります、<see cref="T:System.Text.Encoder" />呼び出しの間の状態を保持します。</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したコード ページのエンコーディングを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">使用するエンコーディングのコード ページ ID。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、コード ページの列にリストされています。  
  
- または - 
既定のエンコーディングを使用する場合は 0。</param>
        <summary>指定したコード ページ ID に関連付けられたエンコーディングを返します。</summary>
        <returns>指定したコード ページに関連付けられたエンコーディング。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 エンコーディングの種類によって異なります、フォールバック ハンドラー`codepage`します。 場合`codepage`はコード ページまたは 2 バイト文字セット (DBCS) のエンコーディング、最適フォールバック ハンドラーが使用されます。 それ以外の場合、置換フォールバック ハンドラーが使用されます。 これらのフォールバック ハンドラーは、アプリが適さない場合があります。 指定するエンコードで使用されるフォールバック ハンドラーを指定する`codepage`、呼び出すことができます、<xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>オーバー ロードします。  
  
 .NET Framework で、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは、ほとんどのコード ページをサポートするために、基になるプラットフォームに依存します。 ただし、.NET Framework では、一部のエンコーディングをネイティブにサポートします。 コード ページの一覧は、次を参照してください。、<xref:System.Text.Encoding>クラスに関するトピック。 .NET Core で、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは .NET Core でネイティブにサポートされているエンコーディングを返します。 両方の .NET 実装で呼び出すことができます、<xref:System.Text.Encoding.GetEncodings%2A>の配列を取得するメソッドを<xref:System.Text.EncodingInfo>使用可能なすべてのエンコーディングに関する情報を含むオブジェクト。 

 .NET Core でネイティブに使用できる、または本質的に、.NET Framework の特定のプラットフォームのバージョンでサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは、を登録することで利用できるその他のエンコーディングを返します<xref:System.Text.EncodingProvider>オブジェクト。 同じエンコードを複数、登録されている場合<xref:System.Text.EncodingProvider>オブジェクトの場合、このメソッドには、登録されている最後の 1 つが返されます。  

値 0 を指定することも、`codepage`引数。 正確な動作は異なるかどうか、エンコーディング利用可能な登録することによって、<xref:System.Text.EncodingProvider>オブジェクト。

- 返す場合にエンコーディングが選択した最後の登録済みのプロバイダーのエンコーディングを返す、1 つまたは複数のエンコーディング プロバイダーが登録されている場合、<xref:System.Text.Encoding.GetEncoding%2A>メソッドに渡されますが、`codepage`引数 0 を指定します。     

- .NET Framework の場合はエンコードなしプロバイダーが登録されたら場合、<xref:System.Text.CodePagesEncodingProvider>登録済みのエンコーディング プロバイダーは、登録済みのエンコーディング プロバイダーを処理しない場合、または、`codepage`値 0 の場合のオペレーティング システムの現在のコード ページを返します。 Windows システム上のアクティブなコード ページを確認するのには Windows を呼び出す[GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Windows デスクトップ上の .NET Framework からの関数。

- .NET Core、エンコーディング プロバイダーが登録されているか、登録済みのエンコーディング プロバイダーを処理しない場合に、`codepage`値 0 を返します、<xref:System.Text.UTF8Encoding>します。
  
> [!NOTE]
>  いくつかサポートされていないコード ページの原因を<xref:System.ArgumentException>がスローされる他のユーザーが発生する一方、<xref:System.NotSupportedException>します。 そのため、コードでキャッチする必要がありますすべて例外セクションに示されている例外。  
  
> [!NOTE]
>  ANSI コード ページは、別のコンピューターによって異なる場合、データの破損につながる 1 台のコンピューターで変更できます。 このため場合は、アクティブなコード ページは、ANSI コード ページ エンコーディングと既定のコード ページを使用してデータをデコードすることによって返される`Encoding.GetEncoding(0)`はお勧めしません。 結果を得る最も一貫性のある、Unicode のエンコード (コード ページ 65001) を utf-8 や utf-16 など特定のコード ページではなくを使用する必要があります。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 既定の設定でキャッシュされたインスタンスを返します。 派生クラスのコンス トラクターを使用して、異なる設定でインスタンスを取得する必要があります。 たとえば、<xref:System.Text.UTF32Encoding>クラスには、エラーの検出を有効にできるコンス トラクターが用意されています。  

   
  
## Examples  
 次の例では、(コード ページで 1 つ)、もう一方は名前をエンコードするには、同じ 2 つのインスタンスを取得し、等しいかどうかを確認します。  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> が 0 未満か、65535 を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">使用するエンコーディングのコード ページ名。 <see cref="P:System.Text.Encoding.WebName" /> プロパティが返す値はすべて有効です。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、名前の列にリストされています。</param>
        <summary>指定したコード ページ名に関連付けられたエンコーディングを返します。</summary>
        <returns>指定したコード ページに関連付けられたエンコード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 エンコーディングの種類によって異なります、フォールバック ハンドラー`name`します。 場合`name`はコード ページまたは 2 バイト文字セット (DBCS) のエンコーディング、最適フォールバック ハンドラーが使用されます。 それ以外の場合、置換フォールバック ハンドラーが使用されます。 これらのフォールバック ハンドラーは、アプリが適さない場合があります。 指定するエンコードで使用されるフォールバック ハンドラーを指定する`name`、呼び出すことができます、<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29>オーバー ロードします。  

.NET Framework で、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは、ほとんどのコード ページをサポートするために、基になるプラットフォームに依存します。 ただし、.NET Framework では、一部のエンコーディングをネイティブにサポートします。 コード ページの一覧は、次を参照してください。、<xref:System.Text.Encoding>クラスに関するトピック。 .NET Core で、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは .NET Core でネイティブにサポートされているエンコーディングを返します。 両方の .NET 実装で呼び出すことができます、<xref:System.Text.Encoding.GetEncodings%2A>の配列を取得するメソッドを<xref:System.Text.EncodingInfo>使用可能なすべてのエンコーディングに関する情報を含むオブジェクト。 

 .NET Core でネイティブに使用できる、または本質的に、.NET Framework の特定のプラットフォームのバージョンでサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは、を登録することで利用できるその他のエンコーディングを返します<xref:System.Text.EncodingProvider>オブジェクト。 同じエンコードを複数、登録されている場合<xref:System.Text.EncodingProvider>オブジェクトの場合、このメソッドには、登録されている最後の 1 つが返されます。  
   
> [!NOTE]
>  ANSI コード ページを使用するか、別々 のコンピューターに異なることができます、データの破損につながる 1 台のコンピューターに変更できます。 一貫性のある結果を得るのためには、特定のコード ページではなく (コード ページ 65001) を utf-8 や utf-16 などの Unicode を使用してください。  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> 既定の設定でキャッシュされたインスタンスを返します。 派生クラスのコンス トラクターを使用して、異なる設定でインスタンスを取得する必要があります。 たとえば、<xref:System.Text.UTF32Encoding>クラスには、エラーの検出を有効にできるコンス トラクターが用意されています。  
  
## Examples  
 次の例では、(コード ページで 1 つ)、もう一方は名前をエンコードするには、同じ 2 つのインスタンスを取得し、等しいかどうかを確認します。  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が有効なコード ページ名ではありません。  
  
- または - 
<paramref name="name" /> が示すコード ページは基になるプラットフォームでサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">使用するエンコーディングのコード ページ ID。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、コード ページの列にリストされています。  
  
- または - 
既定のエンコーディングを使用する場合は 0。</param>
        <param name="encoderFallback">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <param name="decoderFallback">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <summary>指定したコード ページ ID に関連付けられたエンコーディングを返します。 パラメーターには、エンコードできない文字とデコードできないバイト シーケンスのためのエラー ハンドラーを指定します。</summary>
        <returns>指定したコード ページに関連付けられたエンコーディング。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  いくつかサポートされていないコード ページ、例外が発生する<xref:System.ArgumentException>が他のユーザーは、スロー<xref:System.NotSupportedException>します。 そのため、コードでキャッチする必要がありますすべて例外セクションに示されている例外。  

.NET Framework で、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは、ほとんどのコード ページをサポートするために、基になるプラットフォームに依存します。 ただし、.NET Framework では、一部のエンコーディングをネイティブにサポートします。 コード ページの一覧は、次を参照してください。、<xref:System.Text.Encoding>クラスに関するトピック。 .NET Core で、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは .NET Core でネイティブにサポートされているエンコーディングを返します。 両方の .NET 実装で呼び出すことができます、<xref:System.Text.Encoding.GetEncodings%2A>の配列を取得するメソッドを<xref:System.Text.EncodingInfo>使用可能なすべてのエンコーディングに関する情報を含むオブジェクト。 

 .NET Core でネイティブに使用できる、または本質的に、.NET Framework の特定のプラットフォームのバージョンでサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは、を登録することで利用できるその他のエンコーディングを返します<xref:System.Text.EncodingProvider>オブジェクト。 同じエンコードを複数、登録されている場合<xref:System.Text.EncodingProvider>オブジェクトの場合、このメソッドには、登録されている最後の 1 つが返されます。  

値 0 を指定することも、`codepage`引数。 正確な動作は異なるかどうか、エンコーディング利用可能な登録することによって、<xref:System.Text.EncodingProvider>オブジェクト。

- 返す場合にエンコーディングが選択した最後の登録済みのプロバイダーのエンコーディングを返す、1 つまたは複数のエンコーディング プロバイダーが登録されている場合、<xref:System.Text.Encoding.GetEncoding%2A>メソッドに渡されますが、`codepage`引数 0 を指定します。     

- .NET Framework の場合はエンコードなしプロバイダーが登録されたら場合、<xref:System.Text.CodePagesEncodingProvider>登録済みのエンコーディング プロバイダーは、登録済みのエンコーディング プロバイダーを処理しない場合、または、`codepage`値は 0、現在のコード ページを返します。

- .NET Core、エンコーディング プロバイダーが登録されているか、登録済みのエンコーディング プロバイダーを処理しない場合に、`codepage`値 0 を返します、<xref:System.Text.UTF8Encoding>エンコードします。

> [!NOTE]
>  ANSI コード ページは、別のコンピューターによって異なる場合、データの破損につながる 1 台のコンピューターで変更できます。 このため場合は、アクティブなコード ページは、ANSI コード ページ エンコーディングと既定のコード ページを使用してデータをデコードすることによって返される`Encoding.GetEncoding(0)`はお勧めしません。 一貫性のある結果を得るのためには、特定のコード ページではなく (コード ページ 65001) を utf-8 や utf-16 などの Unicode を使用してください。 
  
 アクティブなコード ページに関連付けられたエンコーディングを取得する、0 の値を指定することができますか、`codepage`引数または、コードが Windows デスクトップ上の .NET Framework で実行している場合は、値を取得、<xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>プロパティ。 現在のアクティブなコード ページを確認するのには Windows を呼び出す[GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) Windows デスクトップ上の .NET Framework からの関数。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 既定の設定でキャッシュされたインスタンスを返します。 派生クラスのコンス トラクターを使用して、異なる設定でインスタンスを取得する必要があります。 たとえば、<xref:System.Text.UTF32Encoding>クラスには、エラーの検出を有効にできるコンス トラクターが用意されています。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>メソッド。  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> が 0 未満か、65535 を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> は、基になるプラットフォームでサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">使用するエンコーディングのコード ページ名。 <see cref="P:System.Text.Encoding.WebName" /> プロパティが返す値はすべて有効です。 使用可能な値は、<see cref="T:System.Text.Encoding" /> クラスのトピックに記載されている表の、名前の列にリストされています。</param>
        <param name="encoderFallback">現在のエンコーディングで文字をエンコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <param name="decoderFallback">現在のエンコーディングでバイト シーケンスをデコードできない場合にエラー処理プロシージャを提供するオブジェクト。</param>
        <summary>指定したコード ページ名に関連付けられたエンコーディングを返します。 パラメーターには、エンコードできない文字とデコードできないバイト シーケンスのためのエラー ハンドラーを指定します。</summary>
        <returns>指定したコード ページに関連付けられたエンコーディング。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

.NET Framework で、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは、ほとんどのコード ページをサポートするために、基になるプラットフォームに依存します。 ただし、.NET Framework では、一部のエンコーディングをネイティブにサポートします。 コード ページの一覧は、次を参照してください。、<xref:System.Text.Encoding>クラスに関するトピック。 .NET Core で、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは .NET Core でネイティブにサポートされているエンコーディングを返します。 両方の .NET 実装で呼び出すことができます、<xref:System.Text.Encoding.GetEncodings%2A>の配列を取得するメソッドを<xref:System.Text.EncodingInfo>使用可能なすべてのエンコーディングに関する情報を含むオブジェクト。 

 .NET Core でネイティブに使用できる、または本質的に、.NET Framework の特定のプラットフォームのバージョンでサポートされているエンコーディングに加えて、<xref:System.Text.Encoding.GetEncoding%2A>メソッドは、を登録することで利用できるその他のエンコーディングを返します<xref:System.Text.EncodingProvider>オブジェクト。 同じエンコードを複数、登録されている場合<xref:System.Text.EncodingProvider>オブジェクトの場合、このメソッドには、登録されている最後の 1 つが返されます。  
  
> [!NOTE]
>  ANSI コード ページは、別のコンピューターによって異なる場合、データの破損につながる 1 台のコンピューターで変更できます。 結果を得る最も一貫性のある、Unicode のエンコード (コード ページ 65001) を utf-8 や utf-16 など特定のコード ページではなくを使用する必要があります。  
  
 <xref:System.Text.Encoding.GetEncoding%2A> 既定の設定でキャッシュされたインスタンスを返します。 派生クラスのコンス トラクターを使用して、異なる設定でインスタンスを取得する必要があります。 たとえば、<xref:System.Text.UTF32Encoding>クラスには、エラーの検出を有効にできるコンス トラクターが用意されています。  
  
   
  
## Examples  
 次の例で、<xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType>メソッド。  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が有効なコード ページ名ではありません。  
  
- または - 
<paramref name="name" /> が示すコード ページは基になるプラットフォームでサポートされていません。</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>すべてのエンコーディングを格納した配列を返します。</summary>
        <returns>すべてのエンコーディングを格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、サポートされているエンコーディングでは、コード ページによって一意に識別の一覧を返します。 サポートされているエンコーディングを示す表を参照してください、<xref:System.Text.Encoding>クラスに関するトピック。  
  
> [!NOTE]
>  によって返される、サポートされているエンコーディングの一覧、<xref:System.Text.Encoding.GetEncodings%2A>メソッドでは、いずれかで利用できるその他のエンコーディングは含まれません<xref:System.Text.EncodingProvider>実装への呼び出しによって登録された、<xref:System.Text.Encoding.RegisterProvider%2A>メソッド。  
  
 .NET Framework、50220 と 50222 は"iso-2022-jp"、名前に関連付けられている両方が同じではありません。 50220 をエンコード、半角カタカナの文字を全角カタカナ文字に変換します。、エンコード 50222 一方は、半角カタカナの文字をエンコードする shift/シフト アウト シーケンスを使用します。 50222 をエンコードするための表示名は"日本語 (Jis 1 バイト カタカナ -、/SI)"50220、表示のあるエンコーディングから区別するために"日本語 (JIS)"という名前です。  
  
 50220 をエンコードする .NET Framework を返します、エンコード名"iso-2022-jp"を要求するかどうか。 ただし、アプリの適切なエンコードは、半角カタカナ文字は、優先される処理によって異なります。  
  
 特定のエンコーディングを取得するには、使用する必要があります、<xref:System.Text.Encoding.GetEncoding%2A>メソッド。  
  
 <xref:System.Text.Encoding.GetEncodings%2A> ユーザー ファイルのエンコーディングの一覧に表示される場合もあります**として保存** ダイアログ ボックス。 ただし、多くの非 Unicode エンコーディングは、いずれかの不完全な多くの文字と"?"、微妙に異なる動作をさまざまなプラットフォームであるか。 既定として utf-8 または utf-16 を使用してください。  
  
   
  
## Examples  
 次の例は、各エンコードのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスのハッシュ コードを返します。</summary>
        <returns>現在のインスタンスのハッシュ コード。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">エンコードする文字数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定した文字数をエンコードすることによって生成される最大バイト数を計算します。</summary>
        <returns>指定した文字数をエンコードすることによって生成される最大バイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `charCount`パラメーターの数を実際に指定する<xref:System.Char>.NET が内部的に utf-16 を使用して、Unicode 文字を表すため、エンコードする Unicode 文字を表すオブジェクト。 ほとんどの Unicode 文字を表すいずれかでその結果、<xref:System.Char>オブジェクトがサロゲート ペアで表される Unicode 文字の 2 つ必要<xref:System.Char>オブジェクト。  
  
 必要な正確な配列のサイズを計算する<xref:System.Text.Encoding.GetBytes%2A>結果のバイトを格納するを使用する必要があります、<xref:System.Text.Encoding.GetByteCount%2A>メソッド。 配列の最大サイズを計算するには、使用、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッド。 <xref:System.Text.Encoding.GetByteCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxByteCount%2A>メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> 現在選択されているは、最悪のケースを含む、最悪の数を取得<xref:System.Text.EncoderFallback>します。 フォールバックが大きくなる可能性の文字列で選択されている場合<xref:System.Text.Encoding.GetMaxByteCount%2A>エンコーディングの最悪の場合は、すべての文字のモードを切り替える場合に特に、大きな値を取得します。 たとえば、ISO-2022-JP のこれが発生することができます。 詳細については、ブログ記事を参照してください"[Encoding.GetMaxByteCount() Encoding.GetMaxCharCount() とは何ですか?](https://go.microsoft.com/fwlink/?LinkId=153702)"。 (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 ほとんどの場合は、このメソッドは、短い文字列で妥当な値を取得します。 大きな文字列の場合に、非常に大きなバッファーを使用してより適切なバッファーが小さすぎる場合にまれなケースでエラーのキャッチを選択する必要があります。 使用して、別のアプローチを検討する可能性がありますも<xref:System.Text.Encoding.GetByteCount%2A>または<xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>します。  
  
 使用する場合<xref:System.Text.Encoding.GetMaxByteCount%2A>、入力バッファーの最大サイズに基づいて、出力バッファーを割り当てる必要があります。 出力バッファーがサイズに制約されている場合、使用、<xref:System.Text.Encoding.Convert%2A>メソッド。  
  
 なお<xref:System.Text.Encoding.GetMaxByteCount%2A>前デコーダー操作から潜在的なサロゲートが残っていると見なします。 デコーダーのため、メソッドに 1 の値を渡す、1 バイトのエンコード ASCII などの 2 を取得します。 使用する必要があります、<xref:System.Text.ASCIIEncoding.IsSingleByte%2A>プロパティがこの情報が必要な場合。  
  
> [!NOTE]
>  `GetMaxByteCount(N)` 同じ値とは限りません`N* GetMaxByteCount(1)`します。  
  
   
  
## Examples  
 次の例は、文字配列をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.EncoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> が <see cref="T:System.Text.EncoderExceptionFallback" /> に設定されます。</exception>
        <block subset="none" type="overrides">
          <para>すべて<see cref="T:System.Text.Encoding" />実装の場合、このメソッドの計算の結果はバッファー サイズが、バッファー オーバーフロー例外によって発生しないことを保証する必要があります。</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト数をデコードすることによって生成される最大文字数を計算します。</summary>
        <returns>指定したバイト数をデコードすることによって生成される最大文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要な正確な配列のサイズを計算する<xref:System.Text.Encoding.GetChars%2A>、結果の文字を保存するには、使用する必要があります、<xref:System.Text.Encoding.GetCharCount%2A>メソッド。 配列の最大サイズを計算するには、使用、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッド。 <xref:System.Text.Encoding.GetCharCount%2A>メソッドは、一般に、メモリの割り当てを使用するときに、<xref:System.Text.Encoding.GetMaxCharCount%2A>メソッドは通常、高速に実行されます。  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 現在選択されているは、最悪のケースを含む、最悪の数を取得<xref:System.Text.DecoderFallback>します。 フォールバックが大きくなる可能性の文字列で選択されている場合<xref:System.Text.Encoding.GetMaxCharCount%2A>大きな値を取得します。  
  
 ほとんどの場合は、このメソッドは、短い文字列では適切な数値を取得します。 大きな文字列の場合は、非常に大きなバッファーを使用してより適切なバッファーが小さすぎるまれなケースでのエラーのキャッチを選択する必要があります。 使用して、別のアプローチを検討する可能性がありますも<xref:System.Text.Encoding.GetCharCount%2A>または<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>します。  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> 関係を持たない<xref:System.Text.Encoding.GetBytes%2A>します。 同様の機能を使用する必要がある場合<xref:System.Text.Encoding.GetBytes%2A>、使用する必要があります<xref:System.Text.Encoding.GetMaxByteCount%2A>します。  
  
 使用する場合<xref:System.Text.Encoding.GetMaxCharCount%2A>、入力バッファーの最大サイズに基づいて、出力バッファーを割り当てる必要があります。 出力バッファーがサイズに制約されている場合、使用、<xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>メソッド。  
  
 なお<xref:System.Text.Encoding.GetMaxCharCount%2A>前のエンコーダー操作から残っているバイトの最悪のケースを考慮します。 ほとんどのコード ページに、このメソッドに値 0 を渡すと、1 以上の値を取得します。  
  
> [!NOTE]
>  `GetMaxCharCount(N)` 同じ値とは限りません`N* GetMaxCharCount(1)`します。  
  
   
  
## Examples  
 次の例では、(バイト単位) の配列に文字列をエンコードし、文字の配列にバイトをデコードします。  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <block subset="none" type="overrides">
          <para>すべて<see cref="T:System.Text.Encoding" />実装の場合、このメソッドの計算の結果はバッファー サイズが、バッファー オーバーフロー例外によって発生しないことを保証する必要があります。</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、使用するエンコーディングを指定するバイト シーケンスを返します。</summary>
        <returns>使用するエンコーディングを指定するバイト シーケンスを格納するバイト配列。  
  
- または - 
プリアンブルが不要な場合は、長さ 0 のバイト配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必要に応じて、<xref:System.Text.Encoding>オブジェクトは、エンコード プロセスの結果のバイトのシーケンスに付けるバイトの配列である preamble を提供します。 プリアンブルに (Unicode コード ポイント U+FEFF) でバイト順マークが含まれている場合は、バイト順と変換形式または UTF デコーダーが役立ちます。  
  
 Unicode バイト順マーク (BOM) が (16 進数) で、次のようにシリアル化されます。  
  
-   UTF 8: EF BB BF  
  
-   Utf-16 ビッグ エンディアン バイト順: FE FF  
  
-   Utf-16 リトル エンディアン バイト順: FF FE  
  
-   Utf-32 ビッグ エンディアン バイト順: 00 00 FE FF  
  
-   Utf-32 リトル エンディアン バイト順: FF FE 00 00  
  
 特定の id への参照が失われている場合はそのファイルのエンコーディングのほとんどを提供するために、BOM を使用する必要があります、<xref:System.Text.Encoding>オブジェクト、たとえば、タグなしまたは web データを不適切なタグまたはときに、ビジネスに格納されるランダムなテキスト ファイルではありませんでした国際的な懸念事項やその他のデータがあります。 データが一貫して適切にタグ付け、可能であれば utf-8 または utf-16 とは、多くの場合、ユーザーの問題を回避できる可能性があります。  
  
 エンコードの種類を提供する標準では、BOM は、少し冗長です。 ただし、server を正しくエンコード ヘッダーを送信するために使用できます。 または、そのできますフォールバックとして、エンコードを紛失するそれ以外の場合。  
  
 BOM を使用するいくつかのデメリットがあります。 たとえば、BOM を使用するデータベース フィールドを制限する方法を知ることは困難なできます。 ファイルの連結問題になる可能性も、たとえば、ファイルを結合するように、不要な文字データの途中で終了できるようにします。 いくつかの短所にもかかわらずただし、部品表の使用が強くお勧めします。  
  
 バイト オーダーとバイト順マークの詳細については、Unicode 標準を参照してください、 [Unicode ホーム ページ](https://go.microsoft.com/fwlink/?LinkId=37123)します。  
  
> [!CAUTION]
>  エンコードされたバイトが正しくデコードするためには、エンコード済みバイトのプリアンブルとプレフィックスにする必要があります。 ただし、ほとんどのエンコーディングでは、preamble は提供されません。 エンコードされたバイトを正しくデコードは、する必要がありますを使用して、Unicode のエンコードは、 <xref:System.Text.UTF8Encoding>、 <xref:System.Text.UnicodeEncoding>、または<xref:System.Text.UTF32Encoding>プリアンブルとします。  
  
   
  
## Examples  
 次の例では、プリアンブルに基づくエンコードのバイト順を決定します。  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスを文字列にデコードします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているすべてのバイトを文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>によって返されるオブジェクト、<xref:System.Text.Encoding.GetDecoder%2A>派生のメソッドved クラスです。  
  
 「解説」を参照してください、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>デコード手法および考慮事項の詳細については、リファレンス トピック。  
  
 注意の動作の詳細、<xref:System.Text.Encoding.GetString%2A>特定のメソッド<xref:System.Text.Encoding>実装によって異なりますが定義されているフォールバック ストラテジ<xref:System.Text.Encoding>オブジェクト。 詳細については、「フォールバック ストラテジを選択する」セクションを参照してください、 [.NET における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)トピック。  
  
   
  
## Examples  
 次の例では、utf-8 でエンコードされた文字列を読み取りますで表されるバイナリ ファイルから、<xref:System.IO.FileStream>オブジェクト。 バイト配列と呼び出しにファイル全体の内容を読み取り、2,048 バイト未満のファイルの場合、<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29>デコードを実行するメソッド。 大きなファイルの場合、2,048 バイト一度にを配列に読み取ったバイト、呼び出し、<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>文字の数を決定する方法が、配列内に含まれているしを呼び出して、<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>デコードを実行するメソッド。  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 次のテキストを Utf8Example.txt をという名前の utf-8 でエンコードされたファイルに保存する必要がありますを使用します。  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このバイト配列には、無効な Unicode コード ポイントが含まれています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">バイト配列へのポインター。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したアドレスで始まる指定したバイト数を文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetString%2A>メソッドはバイト配列へのネイティブ ポインターがある場合は、パフォーマンスを最適化するために設計されています。 マネージ バイト配列を作成し、それをデコードし、代わりに、中間オブジェクトを作成することがなく、代わりにこのメソッドを呼び出すことができます。  
  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>によって返されるオブジェクト、<xref:System.Text.Encoding.GetDecoder%2A>派生のメソッドved クラスです。  
  
 「解説」を参照してください、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>デコード手法および考慮事項の詳細については、リファレンス トピック。  
  
 注意の動作の詳細、<xref:System.Text.Encoding.GetString%2A>特定のメソッド<xref:System.Text.Encoding>実装によって異なりますが定義されているフォールバック ストラテジ<xref:System.Text.Encoding>オブジェクト。 詳細については、「フォールバック ストラテジを選択する」セクションを参照してください、 [.NET における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)トピック。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> が null ポインターです。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスを文字列にデコードします。</summary>
        <returns>指定したバイト シーケンスのデコード結果が格納されている文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 変換されるデータがストリームから読み取られたデータ) などの連続したブロック内でのみ使用可能な場合、またはデータの量が非常に大きいので、小さなブロックに分割する必要がある、使用する必要があります、<xref:System.Text.Decoder>または<xref:System.Text.Encoder>によって提供される、 <xref:System.Text.Encoding.GetDecoder%2A>メソッドまたは<xref:System.Text.Encoding.GetEncoder%2A>メソッドでは、派生クラスのそれぞれに、します。  
  
 「解説」を参照してください、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>デコード手法および考慮事項の詳細については、リファレンス トピック。  
  
   
  
## Examples  
 次の例では、utf-8 でエンコードされた文字列を読み取りますで表されるバイナリ ファイルから、<xref:System.IO.FileStream>オブジェクト。 バイト配列と呼び出しにファイル全体の内容を読み取り、2,048 バイト未満のファイルの場合、<xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29>デコードを実行するメソッド。 大きなファイルの場合、2,048 バイト一度にを配列に読み取ったバイト、呼び出し、<xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType>文字の数を決定する方法が、配列内に含まれているしを呼び出して、<xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType>デコードを実行するメソッド。  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 次のテキストを Utf8Example.txt をという名前の utf-8 でエンコードされたファイルに保存する必要がありますを使用します。  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このバイト配列には、無効な Unicode コード ポイントが含まれています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
- または - 
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET での文字エンコード](~/docs/standard/base-types/character-encoding.md)」をご覧ください) 
および 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール エージェント ヘッダー タグと共に使用できる現在のエンコーディングの名前を取得します。</summary>
        <value>メール エージェント ヘッダー タグと共に使用する、現在の <see cref="T:System.Text.Encoding" /> の名前。  
  
- または - 
現在の <see cref="T:System.Text.Encoding" /> が使用できない場合は、空の文字列 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ヘッダー名のエンコードが必要な場合を呼び出す必要があります、<xref:System.Text.Encoding.GetEncoding%2A>メソッドを<xref:System.Text.Encoding.HeaderName%2A>プロパティ。 多くの場合、メソッドの呼び出しで提供されるテストのエンコーディングから別のエンコーディングを取得します。 一般にのみ電子メール アプリケーションでは、このようなエンコーディングを取得する必要があります。  
  
 場合によっては、値で、<xref:System.Text.Encoding.BodyName%2A>プロパティは、そのエンコーディングを定義する国際標準に対応します。 これは、実装は、その標準に完全に準拠しているという意味しません。  
  
 なお<xref:System.Text.Encoding.WebName%2A>エンコーディングの記述に使用する名前を返します。 <xref:System.Text.Encoding.HeaderName%2A>プロパティがよりよく機能する電子メール アプリケーションは、たとえば別のエンコードを定義します。 ただし、エンコードを定義するプロパティの使用は推奨されません。  
  
   
  
## Examples  
 次の例は、エンコーディングごとに異なる名前を取得し、エンコーディングとは異なる 1 つまたは複数の名前を表示します。<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>します。 表示されます<xref:System.Text.Encoding.EncodingName%2A>が、それに対しては比較されません。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のエンコーディングが常に正規化されるかどうかを示す値を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のエンコーディングが、既定の正規形を使用して常に正規化されるかどうかを示す値。</summary>
        <returns>現在の <see cref="T:System.Text.Encoding" /> が常に正規化される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定の正規化フォームは<xref:System.Text.NormalizationForm.FormC>、可能であれば、シーケンスをプライマリの複合文字の置換後に、完全標準分解を使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">
          <see cref="T:System.Text.NormalizationForm" /> 値のいずれか 1 つ。</param>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングが、指定した正規形を使用して常に正規化されるかどうかを示す値を取得します。</summary>
        <returns>現在の <see langword="true" /> オブジェクトが、指定した <see cref="T:System.Text.Encoding" /> 値を使用して常に正規化される場合は <see cref="T:System.Text.NormalizationForm" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定の正規化フォームは<xref:System.Text.NormalizationForm.FormC>、可能であれば、シーケンスをプライマリの複合文字の置換後に、完全標準分解を使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、ブラウザー クライアントが現在のエンコーディングを使用してコンテンツを表示できるかどうかを示す値を取得します。</summary>
        <value>ブラウザー クライアントが現在の <see cref="T:System.Text.Encoding" /> を使用してコンテンツを表示できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、各エンコードのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、ブラウザー クライアントが現在のエンコーディングを使用してコンテンツを保存できるかどうかを示す値を取得します。</summary>
        <value>ブラウザー クライアントが現在の <see cref="T:System.Text.Encoding" /> を使用してコンテンツを保存できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、各エンコードのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール クライアントおよびニュース クライアントが現在のエンコーディングを使用してコンテンツを表示できるかどうかを示す値を取得します。</summary>
        <value>メール クライアントおよびニュース クライアントが現在の <see cref="T:System.Text.Encoding" /> を使用してコンテンツを表示できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、各エンコードのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、メール クライアントおよびニュース クライアントが現在のエンコーディングを使用してコンテンツを保存できるかどうかを示す値を取得します。</summary>
        <value>メール クライアントおよびニュース クライアントが現在の <see langword="true" /> を使用してコンテンツを保存できる場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例は、各エンコードのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングが読み取り専用かどうかを示す値を取得します。</summary>
        <value>現在の <see langword="true" /> が読み取り専用の場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングが 1 バイトのコード ポイントを使用するかどうかを示す値を取得します。</summary>
        <value>現在の <see langword="true" /> が 1 バイトのコード ポイントを使用する場合は <see cref="T:System.Text.Encoding" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 バイトのエンコード、たとえば、 <xref:System.Text.ASCIIEncoding>、このプロパティを取得`true`します。  
  
> [!CAUTION]
>  アプリケーションの機能の値で十分に注意しおく必要がある<xref:System.Text.Encoding.IsSingleByte%2A>します。 エンコードの続行方法であると仮定は、正しくない可能性があります。 たとえば、Windows 1252 がの値を持つ`true`の<xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>Encoding.GetMaxByteCount(1) 2 が返されます。 これは、メソッドは以前デコーダー操作から潜在的なサロゲートが残っているためにです。  
  
   
  
## Examples  
 次の例は、各エンコードのブール型プロパティの値を確認します。  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">追加の文字エンコーディングへのアクセスを提供する <see cref="T:System.Text.EncodingProvider" /> のサブクラス。</param>
        <summary>エンコーディング プロバイダーを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.RegisterProvider%2A>メソッドから派生したクラスを登録できます。<xref:System.Text.EncodingProvider>文字エンコーディングがサポートされていない場合はそれらのプラットフォームで利用を使用します。 エンコーディング プロバイダーを登録すると、サポートしているエンコーディングは、いずれかを呼び出すことによって取得できます<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType>オーバー ロードします。 複数のエンコーディング プロバイダーがある場合、<xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType>メソッドは各プロバイダーが登録されている最も最近のものからから指定されたエンコーディングを取得しようとしています。

使用して、エンコーディング プロバイダーを登録、<xref:System.Text.Encoding.RegisterProvider%2A>メソッドの動作を変更も、 [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>)と[EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback)](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback))メソッドの引数が渡されるときに`0`:

- 登録済みのプロバイダーがある場合、<xref:System.Text.CodePagesEncodingProvider>メソッドは、Windows オペレーティング システムで実行されているときに、システムのアクティブなコード ページに一致するエンコーディングを返します。

- カスタム エンコーディング プロバイダーの場合に返されるエンコーディングを選択できますいずれ<xref:System.Text.Encoding.GetEncoding%2A>メソッドのオーバー ロードの引数を渡される`0`します。 プロバイダーには返さないことで、エンコードすることもできます、<xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType>メソッドの戻り値`null`します。 
  
.NET Framework、.NET Framework 4.6 以降では、1 つのエンコーディング プロバイダーを含む<xref:System.Text.CodePagesEncodingProvider>、により、利用可能なエンコーディングが、完全な .NET framework に存在するが、ユニバーサル Windows プラットフォームでは使用できません。 ユニバーサル Windows プラットフォームで既定では、Unicode エンコーディング、ASCII、およびコード ページ 28591 がのみサポートします。  
  
 複数の呼び出しで同じエンコーディング プロバイダーを使用するかどうか、<xref:System.Text.Encoding.RegisterProvider%2A>メソッドでは、最初のメソッド呼び出しのみが、プロバイダーを登録します。 後続の呼び出しは無視されます。  
  
 場合、<xref:System.Text.Encoding.RegisterProvider%2A>に同じエンコードを処理する複数のプロバイダーを登録するメソッドは、最後の登録済みのプロバイダーは、すべてのエンコードおよびデコード操作で使用されます。 以前に登録されたプロバイダーは無視されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> は <see langword="null" /> です。</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リトル エンディアン バイト順を使用する UTF-16 形式のエンコーディングを取得します。</summary>
        <value>リトル エンディアンのバイト順を使用する UTF-16 形式のエンコーディング。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET を使用するエンコーディングを Unicode の詳細についてはサポートされているエンコーディングの詳細については、次を参照してください。 [.NET における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)します。  
  
 <xref:System.Text.UnicodeEncoding>このプロパティによって返されるオブジェクトで、アプリの適切な動作がない可能性があります。 置換フォールバックを使用して、各エンコードできない文字列とデコードできないバイトがごとに疑問符 () を置き換えます ("?") 文字。 代わりに、呼び出すことができます、 <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> 、リトル エンディアンのインスタンスを作成するコンス トラクター<xref:System.Text.UnicodeEncoding>がフォールバックであるか、オブジェクト、<xref:System.Text.EncoderFallbackException>または<xref:System.Text.DecoderFallbackException>次の例に示すように、します。  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 次の例は、文字配列をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リトル エンディアン バイト順を使用する UTF-32 形式のエンコーディングを取得します。</summary>
        <value>リトル エンディアンのバイト順を使用する UTF-32 形式のエンコーディング オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding>このプロパティによって返されるオブジェクトで、アプリの適切な動作がない可能性があります。 各エンコードできない文字列とデコードできないバイトがごとに、Unicode REPLACEMENT CHARACTER (U + FFFE) を置き換えて、置換フォールバックを使用します。 代わりに、呼び出すことができます、<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>インスタンスを作成するコンス トラクター、<xref:System.Text.UTF32Encoding>がフォールバックであるか、オブジェクト、<xref:System.Text.EncoderFallbackException>または<xref:System.Text.DecoderFallbackException>次の例に示すように、します。  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 リトル エンディアン バイト順の詳細については、次を参照してください。、<xref:System.Text.Encoding>クラスに関するトピック。  
  
 .NET を使用するエンコーディングを Unicode の詳細についてはサポートされているエンコーディングの詳細については、次を参照してください。 [.NET における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)します。  
  
   
  
## Examples  
 次の例は、文字配列をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UTF-7 形式のエンコーディングを取得します。</summary>
        <value>UTF-7 形式のエンコード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utf-7 エンコードは、7 ビットは、NNTP など、一部の電子メール アプリケーションをこれまでに制限された環境で主に使用されます。 堅牢性とセキュリティの問題のためする必要がありますエンコードを使用しない UTF7 8 ビット環境で、utf-8 エンコードを使用できます。  
  
   
  
## Examples  
 次の例は、文字配列をエンコードするために必要なバイト数を決定の文字をエンコードし、結果のバイトを表示します。  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UTF-8 形式のエンコーディングを取得します。</summary>
        <value>UTF-8 形式のエンコード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します、 <xref:System.Text.UTF8Encoding> (UTF-16-エンコード) の Unicode 文字を 1 文字を 1 ~ 4 バイトのシーケンスにエンコードして、Unicode (UTF-16-エンコード) 文字に UTF 8 エンコードされたバイト配列をデコードするオブジェクト。 .NET を使用するエンコーディングを Unicode の詳細についてはサポートされている文字エン コードの詳細については、次を参照してください。 [.NET における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)します。  
  
 <xref:System.Text.UTF8Encoding>このプロパティによって返されるオブジェクトは、アプリの適切な動作がありません。  
  
-   返します、 <xref:System.Text.UTF8Encoding> Unicode バイト順マーク (BOM) を提供するオブジェクト。 、BOM を提供しない UTF8 エンコードをインスタンス化するには、のすべてのオーバー ロードを呼び出し、<xref:System.Text.UTF8Encoding.%23ctor%2A>コンス トラクター。  
  
-   返されます、<xref:System.Text.UTF8Encoding>疑問符 () に置き換えます各エンコードできない文字列とデコードできないバイトがごとに置換フォールバックを使用するオブジェクト ("?") 文字。 代わりに、呼び出すことができます、<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>インスタンスを作成するコンス トラクター、<xref:System.Text.UTF8Encoding>がフォールバックであるか、オブジェクト、<xref:System.Text.EncoderFallbackException>または<xref:System.Text.DecoderFallbackException>次の例に示すように、します。  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 次の例では、次の文字で構成される配列を定義します。  
  
-   ラテン文字 Z (U + 007A)  
  
-   小規模のラテン文字の (U + 0061)  
  
-   結合ドリップ (U + 0306)  
  
-   鋭角 (U + 01FD) でラテン文字の小さな AE  
  
-   ギリシャ文字 Β (U + 03B2)  
  
-   ギリシャ語 ACROPHONIC ATTIC 1 桁 STATERS (U + 10154) を形成するサロゲート ペア (u+d800 U + DD54)。  
  
 各文字の utf-16 コード単位を表示し、文字配列をエンコードする utf-8 エンコーダーで必要なバイト数を決定します。 文字をエンコードし、結果として得られる UTF で 8 でエンコードされたバイト数を表示します。  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングの IANA (Internet Assigned Numbers Authority) に登録されている名前を取得します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> の IANA 名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.WebName%2A>プロパティと同じ、<xref:System.Text.EncodingInfo.Name%2A>プロパティ。  
  
 なお<xref:System.Text.Encoding.WebName%2A>エンコーディングの IANA 登録名を返します。 その値は、標準の名前が、エンコーディングの実装がその標準に完全に準拠していません。 <xref:System.Text.Encoding.HeaderName%2A>プロパティは、電子メールのヘッダーの方が適切な場合があります別のエンコードを定義します。 ただし、ほとんどのアプリを使用する必要があります<xref:System.Text.Encoding.WebName%2A>代わりにします。  
  
 IANA の詳細についてを参照してください[www.iana.org](https://www.iana.org/)します。  
  
 <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType>と同じ、<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>によって返される<xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>します。 Web の名前の一部は、重複しています。「解説」を参照してください。<xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>詳細についてはします。  
  
   
  
## Examples  
 次の例が含まれています、 <xref:System.Text.Encoding.WebName%2A> HTML ヘッダーにします。  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 次の例は、エンコーディングごとに異なる名前を取得し、エンコーディングとは異なる 1 つまたは複数の名前を表示します。<xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>します。 表示されます<xref:System.Text.Encoding.EncodingName%2A>が、それに対しては比較されません。  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、現在のエンコーディングに最も厳密に対応する Windows オペレーティング システムのコード ページを取得します。</summary>
        <value>現在の <see cref="T:System.Text.Encoding" /> に最も厳密に対応する、Windows オペレーティング システムのコード ページ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、フォント ファミリを決定するなど、Windows の多言語 (MLang) Api との互換性が提供されます。 グローバリゼーション、Unicode エンコーディングのいずれかの使用は代わりにで推奨します。 使用することもお勧めします<xref:System.Text.Encoding.WebName%2A>の代わりに<xref:System.Text.Encoding.WindowsCodePage%2A>コード ページを識別するためにします。  
  
   
  
## Examples  
 次の例では、各エンコードに最も密接に対応する Windows コード ページを決定します。  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>