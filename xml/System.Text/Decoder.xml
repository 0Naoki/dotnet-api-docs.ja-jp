<Type Name="Decoder" FullName="System.Text.Decoder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="600c115406fed10a59102dd671054ef32d0bc6f6" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56405450" /></Metadata><TypeSignature Language="C#" Value="public abstract class Decoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Decoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Decoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Decoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Decoder abstract" />
  <TypeSignature Language="F#" Value="type Decoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>エンコード済みバイト シーケンスを文字のセットに変換します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 実装のインスタンスを取得する、<xref:System.Text.Decoder>クラス、アプリケーションを使用する必要があります、<xref:System.Text.Encoding.GetDecoder%2A>のメソッド、<xref:System.Text.Encoding>実装します。  
  
 <xref:System.Text.Decoder.GetCharCount%2A>メソッドでは、文字数が発生するシーケンス (バイト単位) をデコードするかを判断します。 および<xref:System.Text.Decoder.GetChars%2A>メソッドは、実際のデコードを実行します。 これらのメソッドの両方のいくつかのバージョンがあるで使用できる、<xref:System.Text.Decoder>クラス。 詳細については、「<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>」を参照してください。 A<xref:System.Text.Decoder>オブジェクトへの連続呼び出し間で状態情報を保持する`GetChars`または<xref:System.Text.Decoder.Convert%2A>メソッド ブロックをまたぐバイト シーケンスが正しくデコードできるようにします。 <xref:System.Text.Decoder>もデータ ブロックの末尾にある後続バイトが保持され、[次へ] のデコード操作で末尾のバイトを使用します。 そのため、<xref:System.Text.Encoding.GetDecoder%2A>と<xref:System.Text.Encoding.GetEncoder%2A>は完全なデータ ストリームではなくデータのブロックを頻繁にこれらの操作を処理するためにネットワーク転送とファイルの操作のために便利です。  
  
> [!NOTE]
>  アプリケーションでは、データ ストリームの処理が終わったらことを確認してください、状態情報を設定してフラッシュされる、`flush`パラメーターを`true`適切なメソッド呼び出しで。 例外が発生した場合または場合は、アプリケーションは、ストリームの切り替えを呼び出す必要が<xref:System.Text.Decoder.Reset%2A>の内部状態をクリアする、`Decoder`オブジェクト。  
  
## <a name="version-considerations"></a>バージョンの考慮事項  
 A<xref:System.Text.Decoder>または<xref:System.Text.Encoder>変換操作中にオブジェクトをシリアル化することができます。 オブジェクトの状態が同じバージョンの .NET Framework で逆シリアル化された場合に保持されますが、別のバージョンで逆シリアル化された場合に失われます。  
  
   
  
## Examples  
 次の例では、使用、<xref:System.Text.Decoder>文字配列に 2 つの異なるバイト配列に変換します。 いずれかの文字のバイト範囲の配列。 これと同様に、<xref:System.IO.StreamReader>オブジェクトは、ストリームを読み取るときに、内部的にします。  
  
 [!code-cpp[Classic Decoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Decoder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Decoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Decoder Example/CS/source.cs#1)]
 [!code-vb[Classic Decoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Decoder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>アプリケーションは、このクラスから継承、ときに、すべてのメンバーをオーバーライドする必要があります。</para></block>
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Decoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Decoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Text.Decoder" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスの実装のインスタンスを取得するアプリケーションを使用する必要があります、<xref:System.Text.Encoding.GetDecoder%2A>のメソッド、<xref:System.Text.Encoding>実装します。  
  
   
  
## Examples  
 次の例では、新しい初期化するための 2 つの手法<xref:System.Text.Decoder>インスタンス。  
  
 [!code-cpp[System.Text.Decoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Decoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Decoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>エンコード済みバイト シーケンスを文字列または文字配列に変換します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool *  *  *  -&gt; unit&#xA;override this.Convert : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, chars, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, byteCount, chars, charCount, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">変換するバイト シーケンスを格納しているバッファーのアドレス。</param>
        <param name="byteCount"><paramref name="bytes" /> にある変換対象のバイト数。</param>
        <param name="chars">変換後の文字を格納するバッファーのアドレス。</param>
        <param name="charCount">変換に使用する <paramref name="chars" /> 内の最大文字数。</param>
        <param name="flush">これ以上データの変換を行わないことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="bytesUsed">このメソッドから制御が戻るときに、変換の結果生成されたバイト数を格納します。 このパラメーターは初期化せずに渡されます。</param>
        <param name="charsUsed">このメソッドから制御が戻るときに、<paramref name="chars" /> で変換に使用された文字数を格納します。 このパラメーターは初期化せずに渡されます。</param>
        <param name="completed">このメソッドから制御が戻るときに、<paramref name="byteCount" /> で指定したすべての文字が変換された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このパラメーターは初期化せずに渡されます。</param>
        <summary>バッファーに格納されているエンコード済みバイトを UTF-16 エンコード文字に変換し、その結果を別のバッファーに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 注意、<xref:System.Text.Decoder>オブジェクトへの呼び出しの間で状態を保存します<xref:System.Text.Decoder.Convert%2A>します。 設定する必要がありますが、アプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`状態情報がフラッシュされるかどうかを確認します。 この設定では、デコーダーは、データ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。 サロゲート ペアの上位サロゲートなどの論理ユニットの一部である残りの処理されたデータは、現在のフォールバックの設定に従って変換されます。  
  
 `Convert`メソッドは、入力の任意の大きさをデコードするループ内で使用する設計されています。 ファイルまたはストリームから読み取られるデータなどです。 固定サイズのバッファーにデコード操作の出力を格納します。 <xref:System.Text.Decoder.GetChars%2A> 出力バッファーが十分でない場合、例外がスローされますが、<xref:System.Text.Decoder.Convert%2A>はできるだけ多くの領域を入力し、読み取られたバイトと書き込まれる文字を返します。 参照してください、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>コメントの詳細についてはトピック。  
  
 `completed`出力パラメーターは、入力バッファー内のすべてのデータが変換され、出力バッファーに格納されているかどうかを示します。 このパラメーターに設定されて`false`でバイト数が指定されている場合、`byteCount`パラメーターで指定された文字数を超えずに変換できない、`charCount`パラメーター。 ような状況では、アプリケーション出力バッファーの内容を使用してか、新しい出力バッファーを提供インクリメント、`bytes`パラメーターで指定したバイト数で、`bytesUsed`パラメーターを呼び出して、`Convert`をもう一度メソッド残りの入力を処理します。  
  
 `completed`パラメーターを設定することも`false`場合でも、`bytesUsed`と`byteCount`パラメーターが等しい。 このような状況は、まだ内のデータがある場合に発生します。、<xref:System.Text.Decoder>内に保存されていないオブジェクト、`bytes`バッファー。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> または <paramref name="bytes" /> が <see langword="null" /> (<see langword="Nothing" />) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> または <paramref name="byteCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException">出力バッファーが小さすぎて、変換した入力を格納できません。 出力バッファーは、<see cref="Overload:System.Text.Decoder.GetCharCount" /> メソッドで示されるサイズ以上である必要があります。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET Framework における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)」をご覧ください)。 
および 
 <see cref="P:System.Text.Decoder.Fallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, charCount As Integer, flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : byte[] * int * int * char[] * int * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : byte[] * int * int * char[] * int * int * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, byteIndex, byteCount, chars, charIndex, charCount, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">変換するバイト配列。</param>
        <param name="byteIndex">変換する <paramref name="bytes" /> の最初の要素。</param>
        <param name="byteCount">変換する <paramref name="bytes" /> の要素の数。</param>
        <param name="chars">変換後の文字を格納する配列。</param>
        <param name="charIndex">データを格納する <paramref name="chars" /> の最初の要素。</param>
        <param name="charCount">変換に使用する <paramref name="chars" /> 内の最大要素数。</param>
        <param name="flush">これ以上データの変換を行わないことを示す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="bytesUsed">このメソッドから制御が戻るときに、変換に使用されたバイト数を格納します。 このパラメーターは初期化せずに渡されます。</param>
        <param name="charsUsed">このメソッドから制御が戻るときに、変換によって生成された <paramref name="chars" /> の文字数を格納します。 このパラメーターは初期化せずに渡されます。</param>
        <param name="completed">このメソッドから制御が戻るときに、<paramref name="byteCount" /> で指定したすべての文字が変換された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 このパラメーターは初期化せずに渡されます。</param>
        <summary>配列に格納されているエンコード済みバイトを UTF-16 エンコード文字に変換し、その結果を文字配列に格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 注意、<xref:System.Text.Decoder>オブジェクトへの呼び出しの間で状態を保存します<xref:System.Text.Decoder.Convert%2A>します。 設定する必要がありますが、アプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`状態情報がフラッシュされるかどうかを確認します。 この設定では、デコーダーは、データ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。 サロゲート ペアの上位サロゲートなどの論理ユニットの一部である残りの処理されたデータは、現在のフォールバックの設定に従って変換されます。  
  
 `Convert`メソッドは、入力の任意の大きさをデコードするループ内で使用する設計されています。 ファイルまたはストリームから読み取られるデータなどです。 固定サイズのバッファーにデコード操作の出力を格納します。 <xref:System.Text.Decoder.GetChars%2A> 出力バッファーが十分でない場合、例外がスローされますが、<xref:System.Text.Decoder.Convert%2A>はできるだけ多くの領域を入力し、読み取られたバイトと書き込まれる文字を返します。 参照してください、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>コメントの詳細についてはトピック。  
  
 `completed`出力パラメーターは、入力バッファー内のすべてのデータが変換され、出力バッファーに格納されているかどうかを示します。 このパラメーターに設定されて`false`でバイト数が指定されている場合、`byteCount`パラメーターで指定された文字数を超えずに変換できない、`charCount`パラメーター。 ような状況では、アプリケーション出力バッファーの内容を使用してか、新しい出力バッファーを提供インクリメント、`bytes`パラメーターで指定したバイト数で、`bytesUsed`パラメーターを呼び出して、`Convert`をもう一度メソッド残りの入力を処理します。  
  
 `completed`パラメーターを設定することも`false`場合でも、`bytesUsed`と`byteCount`パラメーターが等しい。 このような状況は、まだ内のデータがある場合に発生します。、<xref:System.Text.Decoder>内に保存されていないオブジェクト、`bytes`バッファー。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Text.Encoder.Convert%2A> utf-16 文字のファイルを utf-8 に変換します。 次を使用して、 <xref:System.Text.Decoder.Convert%2A> utf-16 文字を utf-8 文字に変換します。  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> または <paramref name="bytes" /> が <see langword="null" /> (<see langword="Nothing" />) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />、<paramref name="charCount" />、<paramref name="byteIndex" />、または <paramref name="byteCount" /> が 0 未満です。  
  
または 
<paramref name="chars" /> - <paramref name="charIndex" /> の長さは <paramref name="charCount" /> 未満です。  
  
または 
<paramref name="bytes" /> - <paramref name="byteIndex" /> の長さは <paramref name="byteCount" /> 未満です。</exception>
        <exception cref="T:System.ArgumentException">出力バッファーが小さすぎて、変換した入力を格納できません。 出力バッファーは、<see cref="Overload:System.Text.Decoder.GetCharCount" /> メソッドで示されるサイズ以上である必要があります。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET Framework における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)」をご覧ください)。 
および 
 <see cref="P:System.Text.Decoder.Fallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ Fallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Fallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Decoder.Fallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.DecoderFallback" /> オブジェクトの <see cref="T:System.Text.Decoder" /> オブジェクトを取得または設定します。</summary>
        <value><see cref="T:System.Text.DecoderFallback" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallback>オブジェクトは、エンコード済みバイト シーケンスを文字に変換できないときに呼び出されるエラー ハンドラーを表します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">設定操作の値が <see langword="null" /> (<see langword="Nothing" />) です。</exception>
        <exception cref="T:System.ArgumentException">現在の <see cref="T:System.Text.DecoderFallbackBuffer" /> オブジェクトにまだデコードされていないデータが含まれるため、設定操作に新しい値を代入できません。</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">エンコーディングの理解</related>
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As DecoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallbackBuffer ^ FallbackBuffer { System::Text::DecoderFallbackBuffer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FallbackBuffer : System.Text.DecoderFallbackBuffer" Usage="System.Text.Decoder.FallbackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Text.DecoderFallbackBuffer" /> オブジェクトに関連付けられている <see cref="T:System.Text.Decoder" /> オブジェクトを取得します。</summary>
        <value><see cref="T:System.Text.DecoderFallbackBuffer" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.DecoderFallbackBuffer>オブジェクトによって使用されるデータを表す、<xref:System.Text.DecoderFallback>オブジェクト。 <xref:System.Text.DecoderFallback>オブジェクトは、エンコード済みバイト シーケンスを文字に変換できないときに呼び出されるエラー ハンドラーを表します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.ReadOnlySpan{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; * bool -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; * bool -&gt; int" Usage="decoder.GetCharCount (bytes, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int * bool -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int * bool -&gt; int" Usage="decoder.GetCharCount (bytes, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="count">デコードするバイト数。</param>
        <param name="flush">計算後にエンコーダーの内部状態をクリアするようシミュレートする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト ポインターから始まるバイト シーケンスをデコードすることによって生成される文字数を計算します。 パラメーターは、計算後に、デコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns>指定したバイト シーケンスと内部バッファー内のバイトをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、デコーダーの状態は影響しません。  
  
 計算する正確な配列のサイズを<xref:System.Text.Decoder.GetChars%2A>が必要です、結果の文字を格納するアプリケーションを使用する必要があります<xref:System.Text.Decoder.GetCharCount%2A>します。  
  
 場合`GetChars`を使用して呼び出した`flush`に設定`false`デコーダーが内部バッファーにデータ ブロックの末尾にある後続バイトを格納し、[次へ] のデコード操作でそれらを使用します。 アプリケーションを呼び出す必要があります`GetCharCount`呼び出す前にすぐにデータのブロックで`GetChars`ブロックは同じで、前のブロックからの後続バイトが計算に含まれるようにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> が <see langword="null" /> (Visual Basic .NET の場合は <see langword="Nothing" />) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> が 0 未満です。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET Framework における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)」をご覧ください)。 
および 
 <see cref="P:System.Text.Decoder.Fallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="decoder.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスをデコードすることによって生成される文字数を計算します。</summary>
        <returns>指定したバイト シーケンスと内部バッファー内のバイトをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、デコーダーの状態は影響しません。  
  
 計算する正確な配列のサイズを<xref:System.Text.Decoder.GetChars%2A>が必要です、結果の文字を格納するアプリケーションを使用する必要があります<xref:System.Text.Decoder.GetCharCount%2A>します。  
  
 場合`GetChars`を使用して呼び出した`flush`に設定`false`デコーダーが内部バッファーにデータ ブロックの末尾にある後続バイトを格納し、[次へ] のデコード操作でそれらを使用します。 アプリケーションを呼び出す必要があります`GetCharCount`呼び出す前にすぐにデータのブロックで`GetChars`ブロックは同じで、前のブロックからの後続バイトが計算に含まれるようにします。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します、<xref:System.Text.Decoder.GetCharCount%2A>メソッドを指定された配列内のバイトの範囲をデコードするために必要な文字の数を計算します。  
  
 [!code-cpp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> が <see langword="null" /> (<see langword="Nothing" />) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
- または - 
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET Framework における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)」をご覧ください)。 
および 
 <see cref="P:System.Text.Decoder.Fallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int * bool -&gt; int&#xA;override this.GetCharCount : byte[] * int * int * bool -&gt; int" Usage="decoder.GetCharCount (bytes, index, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="index">デコードする最初のバイトのインデックス。</param>
        <param name="count">デコードするバイト数。</param>
        <param name="flush">計算後にエンコーダーの内部状態をクリアするようシミュレートする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンスをデコードすることによって生成される文字数を計算します。 パラメーターは、計算後に、デコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns>指定したバイト シーケンスと内部バッファー内のバイトをデコードすることによって生成される文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、デコーダーの状態は影響しません。  
  
 計算する正確な配列のサイズを<xref:System.Text.Decoder.GetChars%2A>が必要です、結果の文字を格納するアプリケーションを使用する必要があります<xref:System.Text.Decoder.GetCharCount%2A>します。  
  
 場合`GetChars`を使用して呼び出した`flush`に設定`false`デコーダーが内部バッファーにデータ ブロックの末尾にある後続バイトを格納し、[次へ] のデコード操作でそれらを使用します。 アプリケーションを呼び出す必要があります`GetCharCount`呼び出す前にすぐにデータのブロックで`GetChars`ブロックは同じで、前のブロックからの後続バイトが計算に含まれるようにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> が <see langword="null" /> (<see langword="Nothing" />) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> または <paramref name="count" /> が 0 未満です。  
  
- または - 
 <paramref name="index" /> および <paramref name="count" /> は <paramref name="bytes" /> において有効な範囲を表していません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET Framework における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)」をご覧ください)。 
および 
 <see cref="P:System.Text.Decoder.Fallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、バイト シーケンスを文字のセットにデコードします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool -&gt; int" Usage="decoder.GetChars (bytes, chars, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool -&gt; int" Usage="decoder.GetChars (bytes, byteCount, chars, charCount, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">デコードする最初のバイトへのポインター。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字セットの書き込みを開始する位置へのポインター。</param>
        <param name="charCount">書き込む文字の最大数。</param>
        <param name="flush">変換後にデコーダーの内部状態をクリアする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト ポインターで始まるバイト シーケンス、および内部バッファー内のバイトを、指定した文字ポインターを開始位置として格納される文字のセットにエンコードします。 パラメーターでは、変換後にデコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns><paramref name="chars" /> パラメーターによって示される位置に書き込む実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 注意、<xref:System.Text.Decoder>オブジェクトへの呼び出しの間で状態を保存します<xref:System.Text.Decoder.GetChars%2A>します。 設定する必要がありますが、アプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`状態情報がフラッシュされるかどうかを確認します。 この設定では、デコーダーは、データ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。  
  
 計算する正確なバッファーのサイズを`GetChars`が必要です、結果の文字を格納するアプリケーションを使用する必要があります<xref:System.Text.Decoder.GetCharCount%2A>します。  
  
 場合`GetChars`を使用して呼び出した`flush`に設定`false`デコーダーが内部バッファーにデータ ブロックの末尾にある後続バイトを格納し、[次へ] のデコード操作でそれらを使用します。 アプリケーションを呼び出す必要があります`GetCharCount`呼び出す前にすぐにデータのブロックで`GetChars`ブロックは同じで、前のブロックからの後続バイトが計算に含まれるようにします。  
  
 入力ストリームのセグメントに変換する、アプリケーションがある場合は、使用を検討して、<xref:System.Text.Decoder.Convert%2A>メソッド。 <xref:System.Text.Decoder.GetChars%2A> 出力バッファーが十分でない場合、例外がスローされますが、<xref:System.Text.Decoder.Convert%2A>はできるだけ多くの領域を入力し、読み取られたバイトと書き込まれる文字を返します。 参照してください、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>コメントの詳細についてはトピック。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> が <see langword="null" /> (<see langword="Nothing" />) です。  
  
または 
 <paramref name="chars" /> が <see langword="null" /> (<see langword="Nothing" />) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> または <paramref name="charCount" /> が 0 未満です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="charCount" /> が結果の文字数より少なくなっています。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET Framework における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)」をご覧ください)。 
および 
 <see cref="P:System.Text.Decoder.Fallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="decoder.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="byteIndex">デコードする最初のバイトのインデックス。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字のセットを格納する文字配列。</param>
        <param name="charIndex">結果の文字のセットを書き込む開始位置のインデックス。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンス、および内部バッファー内のバイトを、指定した文字配列にデコードします。</summary>
        <returns><paramref name="chars" /> に書き込まれた実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 注意、<xref:System.Text.Decoder>オブジェクトへの呼び出しの間で状態を保存します<xref:System.Text.Decoder.GetChars%2A>します。 設定する必要がありますが、アプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`状態情報がフラッシュされるかどうかを確認します。 この設定では、デコーダーは、データ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。  
  
 計算する正確な配列のサイズを`GetChars`が必要です、結果の文字を格納するアプリケーションを使用する必要があります<xref:System.Text.Decoder.GetCharCount%2A>します。  
  
 場合`GetChars`を使用して呼び出した`flush`に設定`false`デコーダーが内部バッファーにデータ ブロックの末尾にある後続バイトを格納し、[次へ] のデコード操作でそれらを使用します。 アプリケーションを呼び出す必要があります`GetCharCount`呼び出す前にすぐにデータのブロックで`GetChars`ブロックは同じで、前のブロックからの後続バイトが計算に含まれるようにします。  
  
 入力ストリームのセグメントに変換する、アプリケーションがある場合は、使用を検討して、<xref:System.Text.Decoder.Convert%2A>メソッド。 <xref:System.Text.Decoder.GetChars%2A> 出力バッファーが十分でない場合、例外がスローされますが、<xref:System.Text.Decoder.Convert%2A>はできるだけ多くの領域を入力し、読み取られたバイトと書き込まれる文字を返します。 参照してください、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>コメントの詳細についてはトピック。  
  
   
  
## Examples  
 次の例では、バイト配列から要素の範囲をデコードし、Unicode 文字配列に格納する方法を示します。 <xref:System.Text.Decoder.GetCharCount%2A>メソッドを使用して、配列にデコードされた要素を格納するために必要な文字の数を計算`bytes`します。 <xref:System.Text.Decoder.GetChars%2A>メソッドは、バイト配列内の指定の要素をデコードし、新しい文字配列に格納します。  
  
 [!code-cpp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> が <see langword="null" /> (<see langword="Nothing" />) です。  
  
または 
 <paramref name="chars" /> が <see langword="null" /> (<see langword="Nothing" />) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />、<paramref name="byteCount" />、または <paramref name="charIndex" /> が 0 未満です。  
  
- または - 
 <paramref name="byteindex" /> および <paramref name="byteCount" /> は <paramref name="bytes" /> において有効な範囲を表していません。  
  
- または - 
 <paramref name="charIndex" /> が <paramref name="chars" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" /> には、<paramref name="charIndex" /> から配列の末尾までに十分なサイズがなく、結果の文字を格納できません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET Framework における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)」をご覧ください)。 
および 
 <see cref="P:System.Text.Decoder.Fallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int * bool -&gt; int&#xA;override this.GetChars : byte[] * int * int * char[] * int * bool -&gt; int" Usage="decoder.GetChars (bytes, byteIndex, byteCount, chars, charIndex, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">デコード対象のバイト シーケンスが格納されたバイト配列。</param>
        <param name="byteIndex">デコードする最初のバイトのインデックス。</param>
        <param name="byteCount">デコードするバイト数。</param>
        <param name="chars">結果の文字のセットを格納する文字配列。</param>
        <param name="charIndex">結果の文字のセットを書き込む開始位置のインデックス。</param>
        <param name="flush">変換後にデコーダーの内部状態をクリアする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>派生クラスでオーバーライドされた場合、指定したバイト配列に格納されているバイト シーケンス、および内部バッファー内のバイトを、指定した文字配列にデコードします。 パラメーターでは、変換後にデコーダーの内部状態をクリアするかどうかを示します。</summary>
        <returns><paramref name="chars" /> パラメーターに書き込まれた実際の文字数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 注意、<xref:System.Text.Decoder>オブジェクトへの呼び出しの間で状態を保存します<xref:System.Text.Decoder.GetChars%2A>します。 設定する必要がありますが、アプリケーションでは、データ ストリームの処理が終わったら、`flush`パラメーターを`true`状態情報がフラッシュされるかどうかを確認します。 この設定では、デコーダーは、データ ブロックの末尾に無効なバイトを無視し、内部バッファーをクリアします。  
  
 計算する正確な配列のサイズを`GetChars`が必要です、結果の文字を格納するアプリケーションを使用する必要があります<xref:System.Text.Decoder.GetCharCount%2A>します。  
  
 場合`GetChars`を使用して呼び出した`flush`に設定`false`デコーダーが内部バッファーにデータ ブロックの末尾にある後続バイトを格納し、[次へ] のデコード操作でそれらを使用します。 アプリケーションを呼び出す必要があります`GetCharCount`呼び出す前にすぐにデータのブロックで`GetChars`ブロックは同じで、前のブロックからの後続バイトが計算に含まれるようにします。  
  
 入力ストリームのセグメントに変換する、アプリケーションがある場合は、使用を検討して、<xref:System.Text.Decoder.Convert%2A>メソッド。 <xref:System.Text.Decoder.GetChars%2A> 出力バッファーが十分でない場合、例外がスローされますが、<xref:System.Text.Decoder.Convert%2A>はできるだけ多くの領域を入力し、読み取られたバイトと書き込まれる文字を返します。 参照してください、<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>コメントの詳細についてはトピック。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> が <see langword="null" /> (<see langword="Nothing" />) です。  
  
または 
 <paramref name="chars" /> が <see langword="null" /> (<see langword="Nothing" />) です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" />、<paramref name="byteCount" />、または <paramref name="charIndex" /> が 0 未満です。  
  
- または - 
 <paramref name="byteindex" /> および <paramref name="byteCount" /> は <paramref name="bytes" /> において有効な範囲を表していません。  
  
- または - 
 <paramref name="charIndex" /> が <paramref name="chars" /> の有効なインデックスではありません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" /> には、<paramref name="charIndex" /> から配列の末尾までに十分なサイズがなく、結果の文字を格納できません。</exception>
        <exception cref="T:System.Text.DecoderFallbackException">フォールバックが発生しました (詳細な説明は、「[.NET Framework における文字エンコーディング](~/docs/standard/base-types/character-encoding.md)」をご覧ください)。 
および 
 <see cref="P:System.Text.Decoder.Fallback" /> が <see cref="T:System.Text.DecoderExceptionFallback" /> に設定されます。</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="decoder.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされた場合、デコーダーを初期状態に戻します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの内部状態をクリアします、<xref:System.Text.Decoder>オブジェクト。 メソッドは、以前の呼び出しから保存された任意の状態情報をクリアします。<xref:System.Text.Decoder.GetChars%2A>または<xref:System.Text.Decoder.Convert%2A>など、末尾の前のデータ ブロックの最後のバイト数。  
  
 アプリケーションを呼び出す必要があります、<xref:System.Text.Decoder.Reset%2A>メソッドによって例外がスローされた後も同じデコーダーを再利用する必要がある場合<xref:System.Text.Decoder.GetChars%2A>、 <xref:System.Text.Decoder.Convert%2A>、または<xref:System.Text.Decoder.GetCharCount%2A>、またはデコーダーがストリームに切り替え、別のストリームのデコードを開始します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>