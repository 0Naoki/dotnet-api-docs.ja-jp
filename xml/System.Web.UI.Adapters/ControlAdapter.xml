<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="32931f959545fbccc955d499802e8801510a11d2" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70702017" /></Metadata><TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>既定のマークアップ、または特定のブラウザーに対する動作を変更するために、アダプターの割り当て先の派生コントロールの表示をカスタマイズします。すべてのコントロール アダプターの継承元となる基本クラスです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールアダプターは、特定<xref:System.Web.UI.Control>のクラスメソッドとその実行ライフサイクル内のイベントをオーバーライドして、ブラウザーやマークアップ固有の処理を可能にするコンポーネントです。 .NET Framework は、1つの派生コントロールアダプターを<xref:System.Web.UI.Control>クライアント要求ごとにオブジェクトにマップします。  
  
 アダプターは、ブラウザーの特定のブラウザーまたはクラスのコントロールを変更するか、一部の機能に対して任意のフィルターとして機能します。 通常、アダプターは、ブラウザーが使用するマークアップ言語 (XHTML、HTML 3.2 など) によって定義されます。 レンダリング動作の適応性の多くは、 <xref:System.Web.UI.HtmlTextWriter>クラスから派生した特殊なクラスにカプセル化できます。 したがって、多くのブラウザークラスの動作で1つのアダプターが使用される可能性があります。また、 <xref:System.Web.UI.HtmlTextWriter>クラスに適応性が含まれていると、コントロールアダプターを使用する必要がなくなります。  
  
 コントロールクラスのアダプターは、特化されたアダプターが存在しない限り、そのクラスから継承されるすべてのコントロールに適用されます。 たとえば、 <xref:System.Web.UI.WebControls.BaseValidator>クラスのアダプターは、すべて`Validator`のオブジェクトに対して使用できます。  
  
 通常、アダプターは<xref:System.Web.UI.Adapters.ControlAdapter>クラスから直接継承しませんが、ターゲット固有のアダプター基底クラスの1つから、コントロールの種類とターゲットブラウザーに固有の追加機能を提供するか、必要なレンダリングを指定します。  
  
 コントロール自体は、必ずしもアダプターを必要としません。 コントロールがコンポジションによって拡張されている場合、一般に子コントロールアダプターで十分です。  
  
 各コントロールには、ブラウザー定義ファイルを介してアダプターへの明示的なマッピングがあります。 このため、 <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType>プロパティへのアクセスでは<xref:System.Web.HttpBrowserCapabilities> 、ブラウザー定義ファイルから抽出されたオブジェクトを使用して、アダプターが制御するマッピングの参照を実行します。  
  
 処理中、.NET Framework は、ターゲット固有である可能性があるコントロールのオーバーライド可能なメソッドへの呼び出しをインターセプトします。 コントロールアダプターがアタッチされている場合、.NET Framework は、関連付けられているアダプターメソッドを呼び出します。  
  
 アダプターは、 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>メソッドを使用してコントロールのレンダリングを実行します。 オーバーライドされ<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>た場合、は<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>メソッドでコールバックを実行するため、基底クラスの実装を呼び出さないようにする必要があります。 これにより、アダプターによって1回、コントロールによってレンダリングが2回発生する可能性があります。  
  
 基本<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>メソッドは、コントロールの<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>メソッドをコールバックします。 したがって、をオーバーライド<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>する場合は、実装するレンダリングがコントロールのによっ<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>て提供されるものに加えられていない限り、基本クラスの実装を呼び出さないでください。  
  
 .NET Framework が子コントロールのアダプターに対してインターセプトを実行するようにする必要があります。 これを行うには、 <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>オーバーライドから、コントロールの<xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType>メソッドを呼び出す基本メソッドを呼び出します。  
  
 メソッド<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>と<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>メソッドは、コントロールがメソッドを呼び出す前後に、コントロールによって呼び出されます。 レンダリング前とレンダリング後の処理タスクのみが必要な場合は、とを使用<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>する<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>と、のオーバーライド<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>が不要になることがあります。 メソッド<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> <xref:System.Web.UI.HtmlTextWriter>と<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>メソッドの既定の動作では、の対応するメソッドを呼び出します。  
  
 独自の状態情報を保持するために、コントロールアダプターは<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>、 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>、、および<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>の各メソッドをオーバーライドできます。 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>、  <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> 、  、および <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> は、プライベートコントロールとビューステートがそれぞれ保存および読み込みされるときに呼び出されます。 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> 、 <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> 、  <xref:System.Web.UI.Control> 、およびの各基本メソッドは、対応するクラスメソッドに対してコールバックします。 <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>  <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> したがって、オーバーライドさ<xref:System.Web.UI.Adapters.ControlAdapter>れたこれらのメソッドはいずれも、基本メソッドを呼び出す必要があり<xref:System.Web.UI.Control>ます。それ以外の場合、クラスメソッドに関連付けられているイベントは発生しません。  
  
 コントロールとアダプターは、必要<xref:System.Web.UI.IPostBackDataHandler>に<xref:System.Web.UI.IPostBackEventHandler>応じて、およびインターフェイスを実装します。 .NET Framework は、アダプターが存在するかどうか、およびアダプターがこれらのインターフェイスを実装するかどうかを判断します。 このような場合は、必要に応じ<xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>て<xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>、、 <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> 、およびの各メソッドをアダプターでオーバーライドする必要があります。 ポストバックデータがアダプターで認識されない場合は、そのデータを処理するためにコントロールでコールバックする必要があります。 後続のイベントハンドラーも、コントロールでコールバックする必要があります。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスから継承する場合、一般的なアダプターの機能を必要とするコントロールには、対応するアダプターの基本クラス<paramref name="ControlType" /> <see langword="Adapter" />が含まれている<see langword="TextBoxAdapter" />必要があります (たとえば、)。 アダプターは、少なくとも、 <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" />プロパティを使用してコントロールの厳密に型指定されたインスタンスを返す必要があります。  
  
1.  特定のコントロール型とマークアップ言語のコントロールアダプターは、パターン<paramref name="MarkupControlType" /> <see langword="Adapter" />で名前を付ける必要が<see langword="XhtmlTextBoxAdapter" />あります (たとえば、)。 コントロールのアダプターは、 <see langword="Adapters" /> subnamespace に実装する必要があります。  
  
コントロールアダプターは、適切な基底クラスから継承し、コントロールと同じ継承モデルに従う必要があります。 たとえば、 <see cref="T:System.Web.UI.Control" />基底クラスから継承するコントロールのアダプターは、 <see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスまたは関連<paramref name="ControlType" /> <see langword="Adapter" />するクラスから継承する必要があります。  
  
特殊化されたアダプターは、構成のブラウザーファイル内のすべてのデバイスノードにある特殊なコントロールに対して定義する必要があります。  
  
適切に実装されたコントロールは、アダプターがアタッチされていること、またはアタッチされたアダプターが特定のインターフェイスを実装していることを想定してはいけません。 代わりに、を呼び出す前に、これらのチェックボックスをオンにする必要があります。  
  
のメソッド <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> など、コントロール内の保護されたイベントメソッドのオーバーライドをシミュレートすることができます。 <see cref="T:System.Web.UI.WebControls.LinkButton" /> まず、 <c>OnClick</c>メソッドを使用してアダプタークラスを作成します。 次に、から<see cref="T:System.Web.UI.WebControls.LinkButton" />派生した新しいコントロールを作成し、メソッドを<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />オーバーライドします。 オーバーライド<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />されたメソッドは、アダプターの<c>OnClick</c>メソッドを呼び出します。 アダプターオブジェクトは、 <see cref="P:System.Web.UI.Control.Adapter" /> <see cref="T:System.Web.UI.Control" />クラスの protected プロパティを介して使用できます。 コントロールの<see langword="null" />プロパティは、関連付けられたアダプターが存在しない場合に、アダプターのメソッドを呼び出す前に、その条件をすべてのコードでチェックする必要があることを示します。 <see cref="P:System.Web.UI.Control.Adapter" /></para></block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Web.UI.Adapters.ControlAdapter" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework は、対応する<xref:System.Web.UI.Control>オブジェクトを作成するときに、このアダプターを内部的に構築します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ターゲット固有の出力を表示するメソッドを持つ <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>コントロールの表示前に呼び出されます。 派生アダプター クラスで、HTML ブラウザーには必要ではなくても特定のターゲットには必要な開始タグを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドは、 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>メソッドの直前に呼び出され、コントロールのレンダリング前にターゲット固有のプリプロセスを実行するために使用されます。 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> メソッド <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> とメソッドを組み合わせて使用して、タグの一貫性を開始および終了するようにします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスから継承する場合、基本メソッド<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />は<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />メソッドを呼び出します。 したがって、 <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />メソッドのオーバーライドでは、 <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />メソッドではなく、その処理がに加えられた場合にのみ、基本メソッドを呼び出す必要があります。</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求の作成元であるクライアントのブラウザー機能への参照を取得します。</summary>
        <value>クライアントのブラウザーとマークアップ機能を指定する <see cref="T:System.Web.HttpBrowserCapabilities" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オブジェクト<xref:System.Web.UI.Adapters.ControlAdapter>は、 <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>プロパティによって返される<xref:System.Web.HttpBrowserCapabilities>オブジェクトからクライアントのブラウザー機能を決定します。 これにより<xref:System.Web.UI.Adapters.ControlAdapter> 、オブジェクトはブラウザー固有<xref:System.Web.UI.Control>のマークアップをレンダリングでき、それ以外の場合はの動作を変更できます。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>プロパティを使用して、要求元のブラウザーの詳細にアクセスする方法を示しています。 この例では、コードはブラウザーが JavaScript と互換性があるかどうかを確認し、カスタマイズされた出力を開発者がそのケースでレンダリングできるようにします。  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロール アダプターの割り当て先コントロールへの参照を取得します。</summary>
        <value>この <see cref="T:System.Web.UI.Control" /> の割り当て先である <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生コントロールアダプターがコントロールにアタッチされている場合、.NET Framework は、コントロールメンバーではなく特定のアダプターメンバーを呼び出します。  
  
   
  
## Examples  
 次のコード例は、 <xref:System.Web.UI.Control>クラスからカスタムコントロールを派生させ、 <xref:System.Web.UI.Adapters.ControlAdapter>クラスから継承する対応するアダプターを作成する方法を示しています。 アダプターは<xref:System.Web.UI.Adapters.ControlAdapter.Control%2A>プロパティをオーバーライドし、厳密に型指定されたコントロールへの参照を返します。  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスから継承する場合は、少なくとも、「例」の<see langword="Control" />セクションに示すように、厳密に型指定されたコントロールのインスタンスを返すプロパティを実装する必要があります。</para></block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>複合コントロールのターゲット固有の子コントロールを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生コントロールアダプターが<xref:System.Web.UI.Control>オブジェクトにアタッチされ<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>ていて、メソッドがオーバーライドされている場合、 <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType>メソッドの代わりにオーバーライドが呼び出されます。 したがって<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> 、を使用して、ターゲット固有の子コントロールセットを作成できます。  
  
 コントロールを組み合わせて新しいコントロールを作成する方法の詳細については、「[複合コントロール](https://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0)」を参照してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>継承クラスを作成し、 <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />メソッドをオーバーライドする場合、基本メソッドによって作成されたコントロールにコントロールを追加するのでない限り、基本メソッドを呼び出さないでください。 それ以外の場合は、2つの子コントロールのセットを作成できます。</para></block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ターゲット固有の出力を表示するメソッドを持つ <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>コントロールの表示後に呼び出されます。 派生アダプター クラスで、HTML ブラウザーには必要ではなくても特定のターゲットには必要な終了タグを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドはメソッドの<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>直後に呼び出され、コントロールのレンダリング後に、ターゲット固有の後処理を実行するために使用されます。 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> メソッド <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> とメソッドを組み合わせて使用して、タグの一貫性を開始および終了するようにします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスから継承する場合、基本メソッド<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />は<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />メソッドを呼び出します。 したがって、 <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />メソッドのオーバーライドでは、 <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />メソッドではなく、その処理がに加えられた場合にのみ、基本メソッドを呼び出す必要があります。</para></block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">アダプターのコントロールの状態情報を <see cref="T:System.Object" /> として格納している <see cref="T:System.Web.UI.StateBag" />。</param>
        <summary>このコントロール アダプターに関連付けられたコントロールが配置されているページに対する以前の要求時に <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> によって保存された、アダプターのコントロール状態情報を読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの状態は、ビューステートが無効になっている場合でも必要な状態情報です。 アダプターが独自のコントロール状態情報を保持する必要がある場合は、 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>メソッド<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>とメソッドをオーバーライドできます。  
  
 アダプターは、関連付けられたコントロールの状態とは独立して、状態を保持する必要がある機能がある場合に、コントロールの状態情報を保持する必要があります。 たとえば、大きなテキスト表示とコントロールの<xref:System.Web.UI.WebControls.RadioButton>グループで構成される複合コントロールは、デスクトップコンピューターのブラウザー上で1つのビューとして表示される場合があります。 その他のブラウザーでは、表示を分割して、テキストの表示と、ラジオボタングループの表示を分割する場合があります。 アダプターは、現在アクティブなビューに関する固有のターゲット固有の情報を保持する必要があります。  
  
 メソッドは、メソッドの<xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType>直後、 `LoadState`ライフサイクルステージで呼び出されます。 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> アダプターコントロールの状態は、コントロールのコントロールの状態に加えて分離されています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Object" /> としてアダプターのビューステート情報を格納している <see cref="T:System.Web.UI.StateBag" />。</param>
        <summary>このコントロール アダプターに関連付けられたコントロールが配置されているページに対する以前の要求時に <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> によって保存された、アダプターのビューステートを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アダプターが独自のビューステート情報を保持する必要がある場合は、 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>メソッド<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>とメソッドをオーバーライドできます。  
  
 アダプターは、関連付けられたコントロールのビューステートとは独立して、要求間で管理する必要があるデータがある場合に、ビューステート情報を保持する必要があります。 たとえば、デスクトップコンピューターのブラウザー上のグリッドコントロールは、値の行と列の1つのビューとして表示される場合があります。 その他のブラウザーでは、行の一覧や単一行の詳細など、表示が複数の個別のビューに分割される場合があります。 アダプターは、ビューステートで現在アクティブでないビューのデータを維持する必要があります。  
  
 メソッドは、 `LoadState`ライフサイクルステージの<xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType>メソッドの直前に呼び出されます。 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> アダプターのビューステートは、コントロールのビューステートに加えて分離されています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>関連付けられたコントロールの <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> メソッドをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control>オブジェクトに接続され<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>ているアダプターがあり、メソッドがオーバーライドされている場合は、 <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType>メソッドの代わりにオーバーライドメソッドが呼び出されます。  
  
 を<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>オーバーライドして、コントロールのライフサイクル`Initialize`の段階でターゲット固有の処理を実行します。 通常、これらは、コントロールが作成されるときに実行される関数です。  
  
   
  
## Examples  
 次のコードサンプルでは、 <xref:System.Web.UI.Adapters.ControlAdapter>クラスからカスタムコントロールアダプターを派生させることができます。 次に、 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>メソッドをオーバーライドして、関連付けられているコントロールのプロパティを設定し、基本メソッドを呼び出してコントロールの初期化を完了します。  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスから継承し、アダプターが<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />メソッドをオーバーライドする場合、アダプターは、対応する基底クラスのメソッドを呼び出す必要があり<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />ます。このメソッドは、メソッドを呼び出します。 メソッドが呼び出さ<see cref="E:System.Web.UI.Control.Init" />れなかった場合、イベントは発生しません。 <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /></para></block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>関連付けられたコントロールの <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> メソッドをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control>オブジェクトに接続され<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>ているアダプターがあり、メソッドがオーバーライドされている場合は、 <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType>メソッドの代わりにオーバーライドメソッドが呼び出されます。  
  
 メソッドをオーバーライドして、コントロールのライフサイクルの`Load`段階でターゲット固有の処理を実行します。 <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> 通常、これらの関数は、各クライアント要求に対して実行する必要があります。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスから継承し、アダプターが<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />メソッドをオーバーライドする場合、アダプターは、対応する基底クラスのメソッドを呼び出す必要があり<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />ます。このメソッドは、メソッドを呼び出します。 が<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />呼び出されていない<see cref="E:System.Web.UI.Control.Load" />場合、イベントは発生しません。</para></block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>関連付けられたコントロールの <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> メソッドをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control>オブジェクトに接続され<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>ているアダプターがあり、メソッドがオーバーライドされている場合は、 <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType>メソッドの代わりにオーバーライドメソッドが呼び出されます。  
  
 メソッドをオーバーライドして、コントロールのライフサイクルの`PreRender`段階でターゲット固有の処理を実行します。 <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> 通常、これらは、コントロール出力のレンダリングの直前に配置される関数です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスから継承し、アダプターが<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />メソッドをオーバーライドする場合、アダプターは、対応する基底クラスのメソッドを呼び出す必要があり<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />ます。このメソッドは、メソッドを呼び出します。 メソッドが呼び出さ<see cref="E:System.Web.UI.Control.PreRender" />れなかった場合、イベントは発生しません。 <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /></para></block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>関連付けられたコントロールの <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> メソッドをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control>オブジェクトに接続され<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>ているアダプターがあり、メソッドがオーバーライドされている場合は、 <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType>メソッドの代わりにオーバーライドメソッドが呼び出されます。  
  
 メソッドをオーバーライドして、コントロールのライフサイクルの`Unload`段階でターゲット固有の処理を実行します。 <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> 通常、これらは、コントロールを破棄する前のクリーンアップ関数です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスから継承し、アダプターが<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />メソッドをオーバーライドする場合、アダプターは、対応する基底クラスのメソッドを呼び出す必要があり<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />ます。このメソッドは、メソッドを呼び出します。 が<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />呼び出されていない<see cref="E:System.Web.UI.Control.Unload" />場合、イベントは発生しません。</para></block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアダプターに関連付けられたコントロールが配置されているページへの参照を取得します。</summary>
        <value>関連付けられたコントロールが配置されているページ インスタンスにアクセスできるようにする <see cref="T:System.Web.UI.Page" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.Adapters.ControlAdapter.Page%2A>は、コントロールが置か<xref:System.Web.UI.Page?displayProperty=nameWithType>れているオブジェクトへのアクセスを提供します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたコントロールが配置されているページのページ アダプターへの参照を取得します。</summary>
        <value>現在の <see cref="T:System.Web.UI.Adapters.PageAdapter" /> に関連付けられたコントロールが配置されているページの <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ<xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>は、現在<xref:System.Web.UI.Page> <xref:System.Web.UI.Control> <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> のオブジェクトに関連付けられているオブジェクトが置かれているオブジェクトのオブジェクトへのアクセスを提供します。 <xref:System.Web.UI.Adapters.ControlAdapter>  
  
 プロパティ<xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>は、ページアダプターレベルの他の項目にアクセスするために使用できます。たとえば、ページ上の複数のコントロール型に適用できる一般的なターゲット固有の関数などです。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ターゲット固有の出力を表示するために使用する <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>コントロール アダプターがアタッチされるコントロール用にターゲット固有のマークアップを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドを<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>オーバーライドして、クライアントブラウザーに送信するターゲット固有のマークアップを生成します。 オブジェクト<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> <xref:System.Web.UI.Adapters.ControlAdapter>がオブジェクト <xref:System.Web.UI.Control> にアタッチされている場合は、メソッドの代わりにメソッドが呼び出されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスから継承する場合、基本メソッド<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />は<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />メソッドを呼び出します。 したがって、 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />メソッドのオーバーライドでは、 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />メソッドではなく、その処理がに加えられた場合にのみ、基本メソッドを呼び出す必要があります。  
  
複合コントロールの場合、アダプター開発者は子コントロールがレンダリングされていることを確認する必要があります。 メソッドによって子コントロールがレンダリングされるが、マークアップが生成されない場合は、 <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />メソッドがその基本メソッドを呼び出すことが適切な場合があります。 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> 子コントロールのターゲット固有のレンダリングが必要な場合は、アダプターがメソッドを<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />実装し、メソッド<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />から<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />メソッドを呼び出す必要があります。</para></block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ターゲット固有の出力を表示するために使用する <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>コントロール アダプターの割り当て先である複合コントロールに含まれる子コントロールのターゲット固有のマークアップを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 個々の<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>子コントロールのマークアップに加えて、複合コントロールの子コントロールセットのターゲット固有のマークアップを生成する必要がある場合は、メソッドをオーバーライドします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスから継承する場合、複合コントロールの場合、アダプター開発者は子コントロールがレンダリングされることを確認する必要があります。 アダプターが<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />メソッドをオーバーライドする場合は、メソッドの<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />オーバーライドからメソッドを呼び出す必要があります。  
  
メソッドによって子コントロールがレンダリングされるが、それ自体がマークアップを生成しない場合は<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> 、メソッドがその基本<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />メソッドを呼び出すことが適切な場合があります。このメソッドは、のオーバーライドを実装するのではなく、メソッドを呼び出します。 <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /><see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />メソッド。</para></block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロール アダプターのコントロール状態情報を保存します。</summary>
        <returns>アダプターのコントロールの状態情報を <see cref="T:System.Object" /> として格納している <see cref="T:System.Web.UI.StateBag" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの状態は、ビューステートが無効になっている場合でも必要な状態情報です。 アダプターが独自のコントロール状態情報を保持する必要がある場合は、 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>メソッド<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>とメソッドをオーバーライドできます。  
  
 アダプターは、関連付けられたコントロールの状態とは独立して、状態を保持する必要がある機能がある場合に、コントロールの状態情報を保持する必要があります。 たとえば、大きなテキスト表示とコントロールの<xref:System.Web.UI.WebControls.RadioButton>グループで構成される複合コントロールは、デスクトップコンピューターのブラウザー上で1つのビューとして表示される場合があります。 その他のブラウザーでは、表示を分割して、テキストの表示と、ラジオボタングループの表示を分割する場合があります。 アダプターは、現在アクティブなビューに関する固有のターゲット固有の情報を保持する必要があります。  
  
 メソッドは、 `SaveState`ライフサイクルステージの<xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType>メソッドの直後に呼び出されます。 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> アダプターコントロールの状態は、コントロールのコントロールの状態に加えて分離されています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロール アダプターのビューステート情報を保存します。</summary>
        <returns><see cref="T:System.Object" /> としてアダプターのビューステート情報を格納している <see cref="T:System.Web.UI.StateBag" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アダプターが独自のビューステート情報を保持する必要がある場合は、 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>メソッド<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>とメソッドをオーバーライドできます。  
  
 アダプターでは、コントロールの関連付けられたビューステートから独立して、要求間で管理する必要があるデータがある場合に、ビューステート情報を保持する必要があります。 たとえば、デスクトップコンピューターのブラウザー上のグリッドコントロールは、値の行と列の1つのビューとして表示される場合があります。 その他のブラウザーでは、行の一覧や単一行の詳細など、表示が複数の個別のビューに分割される場合があります。 アダプターは、ビューステートで現在アクティブでないビューのデータを維持する必要があります。  
  
 メソッドは、 `SaveState`ライフサイクルステージの<xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType>メソッドの直前に呼び出されます。 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> アダプターのビューステートは、コントロールのビューステートに加えて分離されています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>
