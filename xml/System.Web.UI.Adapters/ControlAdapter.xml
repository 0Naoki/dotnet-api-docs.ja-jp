<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="92d5994d2f6188d664ca43f6b7dc75d96c4d81fd" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36394654" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>既定のマークアップ、または特定のブラウザーに対する動作を変更するために、アダプターの割り当て先の派生コントロールの表示をカスタマイズします。すべてのコントロール アダプターの継承元となる基本クラスです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 管理アダプターは、特定のオーバーライド コンポーネント<xref:System.Web.UI.Control>クラス メソッドやブラウザーまたはマークアップ固有の処理を許可する実行のライフ サイクルのイベントです。 .NET Framework がマップに 1 つの派生コントロール アダプター、<xref:System.Web.UI.Control>クライアント要求ごとのオブジェクト。  
  
 アダプターでは、特定のブラウザーまたはブラウザーのクラスのコントロールを変更するか、一部の機能に対しては任意のフィルターとして機能します。 通常、アダプターは、(たとえば、XHTML または HTML 3.2) ブラウザーで使用するマークアップ言語によって定義されます。 派生する特殊なクラスにカプセル化できますレンダリング動作に適応性の多く、<xref:System.Web.UI.HtmlTextWriter>クラスです。 したがって、さまざまなブラウザー クラスの動作、またはその信頼に適応性の 1 つのアダプターを使用できることが可能性が、<xref:System.Web.UI.HtmlTextWriter>クラスを不要なコントロール アダプターの使用して使用する可能性があります。  
  
 コントロール クラスのアダプターは、専用のアダプターが存在しない限り、そのクラスから継承するすべてのコントロールに適用されます。 たとえば、アダプターを<xref:System.Web.UI.WebControls.BaseValidator>すべてのクラスを使用できます`Validator`オブジェクト。  
  
 アダプター通常から継承しない直接、<xref:System.Web.UI.Adapters.ControlAdapter>コントロール型とターゲットのブラウザーに固有の追加機能を提供するクラスを基本からターゲット固有のアダプターのいずれかがクラス、または特定の表示が必要です。  
  
 コントロール自体では、アダプターは必ずしも必要はありません。 コントロールは、コンポジションを介して拡張は場合、通常、子コントロールのアダプターで十分です。  
  
 各コントロールには、.browser 定義ファイルからアダプターへの明示的なマッピングがあります。 したがって、いずれかへのアクセスを<xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType>プロパティの使用、<xref:System.Web.HttpBrowserCapabilities>コントロール アダプターのマッピングの参照を実行するブラウザー定義ファイルから抽出されるオブジェクト。  
  
 処理中には、.NET Framework は、ターゲット固有の可能性があるコントロールのオーバーライド可能なメソッドの呼び出しを受け取ります。 コントロール アダプターが接続されている場合、.NET Framework は、関連付けられているアダプターのメソッドを呼び出します。  
  
 アダプターを使用してコントロールのレンダリングを実行する、<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>メソッドです。 オーバーライドされると場合、<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>可能性のある呼び出さないでください。 基本クラスの実装に呼び出しを実行するため、<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>メソッドです。 アダプターの 1 回で 1 回、およびコントロールで 2 回、発生するレンダリングする可能性があります。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>メソッドの呼び出しをに基づいて、<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>コントロールのメソッドです。 したがって、オーバーライドする場合は<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>を実装するレンダリングはでさらに提供する場合を除き、基本クラスの実装を呼び出す必要がありますいない<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>コントロールのです。  
  
 .NET Framework 実行するインターセプション子コントロールのアダプターを確認する必要があります。 呼び出すことによってこれを行う、<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>呼び出すメソッドの基本、 <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> 、コントロールのメソッドから、<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>をオーバーライドします。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>と<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>メソッドがコントロールによって呼び出される直前と直後にコントロールの呼び出し (それぞれ)、<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>メソッドです。 前と後のレンダリングはのみブラウザー固有の処理を使用して、必要なタスク<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>と<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>をオーバーライドする必要がない可能性がある<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>です。 既定の動作、<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>と<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>の対応するメソッドを呼び出すには、メソッド、<xref:System.Web.UI.HtmlTextWriter>です。  
  
 コントロール アダプターには、独自の状態情報を維持するには、オーバーライド、 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>、 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>、 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>、および<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>メソッドです。 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>、 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>、 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>、および<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>プライベート コントロールとビューの状態が保存され、それぞれ読み込まれるときに呼び出されます。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>、 <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>、 <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>、および<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>base 対応に戻すメソッドの呼び出し<xref:System.Web.UI.Control>クラスのメソッドです。 したがって、これらのいずれか<xref:System.Web.UI.Adapters.ControlAdapter>オーバーライドされたメソッドは、その基本メソッドを呼び出す必要があります以外の場合は、イベントに関連付けられているそれ以外の場合、<xref:System.Web.UI.Control>クラスのメソッドは発生しません。  
  
 コントロールとアダプターが必要に応じて実装の<xref:System.Web.UI.IPostBackDataHandler>と<xref:System.Web.UI.IPostBackEventHandler>インターフェイスです。 .NET Framework は、アダプターが存在するかどうかと、アダプターがこれらのインターフェイスを実装するかどうかを判断します。 場合は、アダプターをオーバーライドする必要があります、 <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>、 <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>、および<xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A>メソッドは、必要に応じて、します。 ポストバック データが、アダプターで認識されない場合は、それを処理するコントロールにコールバックする必要があります。 後続のイベント ハンドラーは、コントロールに戻る呼び出す必要があります。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>継承する場合、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラス、一般的なアダプターの機能を必要とするコントロールは基底クラス、パターンのという名前の対応するアダプターが必要<paramref name="ControlType" /><see langword="Adapter" /> (たとえば、 <see langword="TextBoxAdapter" />)。アダプター返す必要がありますには、少なくとも、厳密に型指定されたインスタンスを使用してコントロールの<see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" />プロパティです。1.パターン内で特定のコントロール型とマークアップ言語の名前を付けるためのアダプターを制御<paramref name="MarkupControlType" /><see langword="Adapter" /> (たとえば、 <see langword="XhtmlTextBoxAdapter" />)。コントロール用のアダプターを実装する必要があります、 <see langword="Adapters" /> subnamespace です。コントロール アダプターは、適切な基本クラスから継承し、コントロールと同じ継承モデルに従う必要があります。継承するコントロール用のアダプターなど、<see cref="T:System.Web.UI.Control" />からいずれかの基本クラスを継承する必要があります、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスまたは関連する<paramref name="ControlType" /><see langword="Adapter" />クラスです。すべて .browser 構成ファイル内のデバイス ノードの下にある特殊なコントロールに対して、専用のアダプターを定義する必要があります。適切に実装されたコントロールは、アダプターが接続されているか、割り当てられているアダプターが特定のインターフェイスを実装すると想定する必要があります。代わりに、これらの呼び出しの前にチェックインします。などのコントロールでは、保護されたイベント メソッドをオーバーライドするをシミュレートすることは、<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />のメソッド、<see cref="T:System.Web.UI.WebControls.LinkButton" />です。最初に、アダプター クラスを作成、 <c>OnClick</c>メソッドです。派生した新しいコントロールを作成し、<see cref="T:System.Web.UI.WebControls.LinkButton" />をオーバーライドし、<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />メソッドです。オーバーライドされた<see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" />メソッドの呼び出し、 <c>OnClick</c>アダプターのメソッドです。アダプター オブジェクトは、保護されたを通じて使用可能な<see cref="P:System.Web.UI.Control.Adapter" />のプロパティ、<see cref="T:System.Web.UI.Control" />クラスです。<see cref="P:System.Web.UI.Control.Adapter" /> 、コントロールのプロパティが<see langword="null" />関連付けられているアダプターがない場合は、任意のコードする必要がありますをチェックする条件、アダプターのメソッドを呼び出す前にします。</para>
    </block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework は、対応する、作成時に内部的にこのアダプターを構築<xref:System.Web.UI.Control>オブジェクト。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ターゲット固有の出力を表示するメソッドを持つ <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>コントロールの表示前に呼び出されます。 派生アダプター クラスで、HTML ブラウザーには必要ではなくても特定のターゲットには必要な開始タグを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>メソッドが直前に呼び出されます、<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>メソッド、コントロールのレンダリングの前にターゲット固有の処理を実行するために使用します。  
  
 使用して、<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>メソッドと組み合わせて、<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>メソッドを開始タグと終了タグの整合性を確認してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>継承する場合、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラス、<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />基本メソッドの呼び出し、<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />メソッドです。ため、オーバーライド、<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />メソッドを呼び出す必要があります、<see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />メソッドを基本の代わりではなく、ほかに、その処理が場合にのみ、<see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />メソッドです。</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の HTTP 要求の作成元であるクライアントのブラウザー機能への参照を取得します。</summary>
        <value>クライアントのブラウザーとマークアップ機能を指定する <see cref="T:System.Web.HttpBrowserCapabilities" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Web.UI.Adapters.ControlAdapter>オブジェクトからクライアント ブラウザーの性能を決定する、<xref:System.Web.HttpBrowserCapabilities>によって返されるオブジェクト、<xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>プロパティです。 これにより、<xref:System.Web.UI.Adapters.ControlAdapter>ブラウザー固有のマークアップを表示するか、それ以外の場合の動作を変更するオブジェクト、<xref:System.Web.UI.Control>です。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A>要求側のブラウザーの詳細にアクセスするプロパティです。 この例では、コードは、ブラウザーが JavaScript と互換性し、し、そのケースでカスタマイズされた出力を表示するために、開発者は、かどうかを判断するを確認します。  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロール アダプターの割り当て先コントロールへの参照を取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.Control" /> の割り当て先である <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生コントロール アダプターがコントロールに関連付けられている場合、.NET Framework は、コントロールのメンバーではなく特定のアダプター メンバーを呼び出します。  
  
   
  
## Examples  
 次のコード例をからカスタム コントロールを派生させる方法を示しています、<xref:System.Web.UI.Control>クラス、および継承された対応するアダプターを作成、<xref:System.Web.UI.Adapters.ControlAdapter>クラスです。 アダプターの上書き、<xref:System.Web.UI.Adapters.ControlAdapter.Control%2A>プロパティを厳密に型指定されたコントロールへの参照を返します。  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>継承する場合、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスを実装する必要がありますには、少なくとも、<see langword="Control" />例」のセクションで示すように、コントロールの厳密に型指定されたインスタンスを取得するプロパティです。</para>
        </block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>複合コントロールのターゲット固有の子コントロールを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生コントロール アダプターに接続がある場合、<xref:System.Web.UI.Control>オブジェクトおよび<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>メソッドはオーバーライドが呼び出されての代わりに、<xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType>メソッドです。 したがって、<xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A>ターゲット固有の子コントロールのセットを作成するために使用できます。  
  
 詳細については、新しいコントロールを作成するコントロールを組み合わせて、次を参照してください。[複合コントロール](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0)です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>継承するクラスを作成し、オーバーライドする場合、<see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />メソッドでは、基本メソッドにコントロールを追加する場合を除き、によって作成された基本メソッドの呼び出しできません。それ以外の場合のコントロールの子の 2 つのセットを作成できます。</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ターゲット固有の出力を表示するメソッドを持つ <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>コントロールの表示後に呼び出されます。 派生アダプター クラスで、HTML ブラウザーには必要ではなくても特定のターゲットには必要な終了タグを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>メソッドは、直後後に呼び出されますが、<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>メソッド、コントロールのレンダリング後にターゲット固有の後処理を実行するために使用されます。  
  
 使用して、<xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A>メソッドと組み合わせて、<xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A>メソッドを開始タグと終了タグの整合性を確認してください。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>継承する場合、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラス、<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />基本メソッドの呼び出し、<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />メソッドです。ため、オーバーライド、<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />メソッドを呼び出す必要があります、<see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />メソッドを基本の代わりではなく、ほかに、その処理が場合にのみ、<see cref="M:System.Web.UI.HtmlTextWriter.EndRender" />メソッドです。</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">アダプターのコントロールの状態情報を <see cref="T:System.Object" /> として格納している <see cref="T:System.Web.UI.StateBag" />。</param>
        <summary>このコントロール アダプターに関連付けられたコントロールが配置されているページに対する以前の要求時に <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> によって保存された、アダプターのコントロール状態情報を読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの状態は、重要な状態情報のビュー ステートが無効になっている場合でも必要です。 アダプターは、独自のコントロールの状態情報を維持する必要があります場合、これをオーバーライドできます、<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>と<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>メソッドです。  
  
 アダプターは、状態を要求、関連付けられたコントロールの状態から独立して間で維持する必要がある機能がある場合は、コントロールの状態情報を維持する必要があります。 大規模なテキスト形式で表示およびのグループから成る複合コントロールなど、<xref:System.Web.UI.WebControls.RadioButton>コントロールは、デスクトップ コンピューター ブラウザー上で 1 つのビューとしてレンダリング可能性があります。 他のブラウザーで分割、レンダリング-テキストの表示は、もう一方のラジオ ボタン グループの 1 つのビューです。 アダプターは、現在アクティブなビューに関する独自のターゲット固有情報を保持する必要があります。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>直後後にメソッドが呼び出される、<xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType>メソッドで、`LoadState`ライフ サイクルの段階です。 アダプターのコントロールの状態は、独立したコントロールのコントロールの状態だけでなくです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> としてアダプターのビューステート情報を格納している <see cref="T:System.Web.UI.StateBag" />。</param>
        <summary>このコントロール アダプターに関連付けられたコントロールが配置されているページに対する以前の要求時に <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> によって保存された、アダプターのビューステートを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アダプターは、独自の状態情報を維持する必要があります場合、これをオーバーライドできます、<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>と<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>メソッドです。  
  
 アダプターは、データが関連付けられたコントロールのビューステートから独立しての要求にわたって保持する必要があるときに、ビュー状態情報を維持する必要があります。 たとえば、デスクトップ コンピューター ブラウザー上のグリッド コントロールは、行の 1 つのビューと値の列としてレンダリング可能性があります。 他のブラウザーで、レンダリングの行と 1 つの行の詳細の一覧などの複数のビューに分割します。 アダプターは、ビューいない現在アクティブな状態にあるビューのデータを維持する必要があります。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>メソッドは、直前に呼び出されますが、<xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType>メソッドで、`LoadState`ライフ サイクルの段階です。 アダプターのビュー状態とは別されてだけでなく、コントロールのビュー ステート。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>関連付けられたコントロールの <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> メソッドをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アダプターが接続がある場合、<xref:System.Web.UI.Control>オブジェクトおよび<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>メソッドはオーバーライド メソッドが呼び出されての代わりに、<xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType>メソッドです。  
  
 オーバーライド<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>でターゲット固有の処理を実行する、`Initialize`コントロール ライフ サイクルの段階です。 通常、これらは、コントロールが作成されるときに実行される関数です。  
  
   
  
## Examples  
 次のコード サンプル、カスタム コントロール アダプターからの派生、<xref:System.Web.UI.Adapters.ControlAdapter>クラスです。 よりも優先、<xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>を関連付けられたコントロールのプロパティを設定し、コントロールの初期化を完了する基本メソッドを呼び出すメソッド。  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>継承する場合、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスとアダプターの上書き、<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />メソッド、アダプターは、対応する基本クラス メソッドを呼び出してを呼び出す必要があります、<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />メソッドです。場合、<see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />メソッドは呼び出されません、<see cref="E:System.Web.UI.Control.Init" />イベントは発生しません。</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>関連付けられたコントロールの <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> メソッドをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アダプターが接続がある場合、<xref:System.Web.UI.Control>オブジェクトおよび<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>メソッドはオーバーライド メソッドが呼び出されての代わりに、<xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType>メソッドです。  
  
 上書き、<xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>でターゲット固有の処理を実行するメソッドを`Load`コントロール ライフ サイクルの段階です。 通常、これらは、クライアント要求ごとに実行する必要がある機能です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>継承する場合、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスとアダプターの上書き、<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />メソッド、アダプターは、対応する基本クラス メソッドを呼び出してを呼び出す必要があります、<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />メソッドです。場合<see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />は呼び出されません、<see cref="E:System.Web.UI.Control.Load" />イベントは発生しません。</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>関連付けられたコントロールの <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> メソッドをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アダプターが接続がある場合、<xref:System.Web.UI.Control>オブジェクトおよび<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>メソッドはオーバーライド メソッドが呼び出されての代わりに、<xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType>メソッドです。  
  
 上書き、<xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>でターゲット固有の処理を実行するメソッドを`PreRender`コントロール ライフ サイクルの段階です。 通常、これらは、コントロールの出力の表示の直前にある機能です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>継承する場合、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスとアダプターの上書き、<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />メソッド、アダプターは、対応する基本クラス メソッドを呼び出してを呼び出す必要があります、<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />メソッドです。場合、<see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />メソッドは呼び出されません、<see cref="E:System.Web.UI.Control.PreRender" />イベントは発生しません。</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>関連付けられたコントロールの <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> メソッドをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アダプターが接続がある場合、<xref:System.Web.UI.Control>オブジェクトおよび<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>メソッドはオーバーライド メソッドが呼び出されての代わりに、<xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType>メソッドです。  
  
 上書き、<xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A>ターゲット固有の処理を実行するメソッド、`Unload`コントロール ライフ サイクルの段階です。 通常、これらは、コントロールの破棄を直前のクリーンアップ機能です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>継承する場合、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラスとアダプターの上書き、<see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />メソッド、アダプターは、対応する基本クラス メソッドを呼び出してを呼び出す必要があります、<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />メソッドです。場合<see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />は呼び出されません、<see cref="E:System.Web.UI.Control.Unload" />イベントは発生しません。</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアダプターに関連付けられたコントロールが配置されているページへの参照を取得します。</summary>
        <value>関連付けられたコントロールが配置されているページ インスタンスにアクセスできるようにする <see cref="T:System.Web.UI.Page" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A>プロパティへのアクセスを提供する、<xref:System.Web.UI.Page?displayProperty=nameWithType>コントロールが置かれているオブジェクト。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたコントロールが配置されているページのページ アダプターへの参照を取得します。</summary>
        <value>現在の <see cref="T:System.Web.UI.Adapters.PageAdapter" /> に関連付けられたコントロールが配置されているページの <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>プロパティへのアクセスを提供する、<xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType>オブジェクトに対する、<xref:System.Web.UI.Page>オブジェクト場所、<xref:System.Web.UI.Control>に現在関連付けられているオブジェクト<xref:System.Web.UI.Adapters.ControlAdapter>オブジェクトを配置します。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A>  ページで、いくつかのコントロール型に適用できる共通のターゲットに固有の機能など、ページ アダプター レベルであるその他の項目にアクセスするプロパティを使用できます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ターゲット固有の出力を表示するために使用する <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>コントロール アダプターがアタッチされるコントロール用にターゲット固有のマークアップを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 上書き、<xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>クライアントのブラウザーに送信するターゲット固有マークアップを生成するメソッド。 <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>の代わりにメソッドが呼び出された、<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>メソッド場合、<xref:System.Web.UI.Adapters.ControlAdapter>オブジェクトにアタッチされて、<xref:System.Web.UI.Control>オブジェクト。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>継承する場合、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />クラス、<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />基本メソッドの呼び出し、<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />メソッドです。ため、オーバーライド、<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />メソッドを呼び出す必要があります、<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />メソッドを基本の代わりではなく、ほかに、その処理が場合にのみ、<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />メソッドです。複合コントロールの場合は、アダプター開発者は必要があります、子コントロールが表示されることを確認します。場合、<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />メソッドの原因が子レンダリングを制御しますが、マークアップを生成しませんありますに適した、<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />にその基本メソッドを呼び出すメソッド。子コントロールのターゲット固有のレンダリングが必要な場合は、アダプターを実装する必要があります、<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />メソッドを呼び出し、<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />メソッドから、<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />メソッドです。</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ターゲット固有の出力を表示するために使用する <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>コントロール アダプターの割り当て先である複合コントロールに含まれる子コントロールのターゲット固有のマークアップを生成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 上書き、<xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A>メソッドは、個々 の子コントロールのマークアップにさらに複合コントロールの子コントロール セットのターゲット固有マークアップを生成する必要があるとします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>継承する場合、<see cref="T:System.Web.UI.Adapters.ControlAdapter" />複合コントロール、アダプター開発者用のクラスが子コントロールが表示されることを確認する必要があります。アダプターをオーバーライドする場合、<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />メソッドを呼び出して、<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />メソッドのオーバーライドから、<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />メソッドです。場合、<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />メソッドの原因が子を表示を制御しますがそれ自体が、マークアップを生成しませんありますに適した、<see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />メソッドを呼び出してその基本メソッドを呼び出す、<see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />のオーバーライドを実装する代わりに、メソッド<see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />メソッドです。</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロール アダプターのコントロール状態情報を保存します。</summary>
        <returns>アダプターのコントロールの状態情報を <see cref="T:System.Object" /> として格納している <see cref="T:System.Web.UI.StateBag" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの状態は、重要な状態情報のビュー ステートが無効になっている場合でも必要です。 アダプターは、独自のコントロールの状態情報を維持する必要があります場合、これをオーバーライドできます、<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>と<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>メソッドです。  
  
 アダプターは、状態を要求、関連付けられたコントロールの状態から独立して間で維持する必要がある機能がある場合は、コントロールの状態情報を維持する必要があります。 大規模なテキスト形式で表示およびのグループから成る複合コントロールなど、<xref:System.Web.UI.WebControls.RadioButton>コントロールは、デスクトップ コンピューター ブラウザー上で 1 つのビューとしてレンダリング可能性があります。 他のブラウザーで分割、レンダリング-テキストの表示は、もう一方のラジオ ボタン グループの 1 つのビューです。 アダプターは、現在アクティブなビューに関する独自のターゲット固有情報を保持する必要があります。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>直後後にメソッドが呼び出される、<xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType>メソッドで、`SaveState`ライフ サイクルの段階です。 アダプターのコントロールの状態は、独立したコントロールのコントロールの状態だけでなくです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロール アダプターのビューステート情報を保存します。</summary>
        <returns>
          <see cref="T:System.Object" /> としてアダプターのビューステート情報を格納している <see cref="T:System.Web.UI.StateBag" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アダプターは、独自の状態情報を維持する必要があります場合、これをオーバーライドできます、<xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>と<xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A>メソッドです。  
  
 アダプターは、データがコントロールの関連するビュー状態から独立しての要求にわたって保持する必要があるときに状態情報を維持する必要があります。 たとえば、デスクトップ コンピューター ブラウザー上のグリッド コントロールは、行の 1 つのビューと値の列としてレンダリング可能性があります。 他のブラウザーで、レンダリングの行と 1 つの行の詳細の一覧などの複数のビューに分割します。 アダプターは、ビューいない現在アクティブな状態にあるビューのデータを維持する必要があります。  
  
 <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>メソッドは、直前に呼び出されますが、<xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType>メソッドで、`SaveState`ライフ サイクルの段階です。 アダプターのビュー状態とは別されてだけでなく、コントロールのビュー ステート。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>