<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CriticalHandle.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac556d9d023a154981435b37666fa081861ca0100c2.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">56d9d023a154981435b37666fa081861ca0100c2</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Represents a wrapper class for handle resources.</source>
          <target state="translated">ハンドル リソースのラッパー クラスを表します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class is similar to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, except that <ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> implements reference counting.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>クラスがに似ていますが、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>点を除いて、クラス<ph id="ph3">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>参照カウントを実装します。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>You can use <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> to address performance considerations when you can provide the necessary synchronization more efficiently yourself.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>の代わりに<ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>必要な同期の詳細を提供するときに、アドレスのパフォーマンスに関する考慮事項を効率的に自分でします。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Because the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class does not perform reference counting, it does not provide protection from handle recycling security attacks.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>クラスは、参照カウントを実行していない、ハンドル リサイクルのセキュリティ攻撃から保護は提供されません。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Because the reference counting algorithm implicitly serializes operations, a certain amount of thread safety is also lost.</source>
          <target state="translated">参照カウント アルゴリズムは暗黙的には、操作がシリアル化、ため、一定量のスレッドの安全性は失われますも。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>If you call the <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> method while an operation that is using the handle is outstanding on another thread, or if you call <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> from two threads at the same time, the results are non-deterministic.</source>
          <target state="translated">呼び出す場合は、<ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph>メソッドを呼び出す場合は別のスレッドで未処理のハンドルを使用している処理の実行中または<ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph4">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph>同時に 2 つのスレッドからは、結果は非決定的です。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class still provides the guaranteed critical finalization provided by the <ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>クラスがまだによって提供される、保証された重要な終了処理を提供、<ph id="ph2">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>for full trust for inheritors.</source>
          <target state="translated">継承時の完全な信頼。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">このメンバーは、部分的に信頼されたコードでは継承できません。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>This class cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このクラスは、部分的に信頼されているまたは透過的なコードでは使用できません。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>The value of an invalid handle (usually 0 or -1).</source>
          <target state="translated">無効なハンドルの値 (通常は 0 または -1)。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> class with the specified invalid handle value.</source>
          <target state="translated">指定した無効なハンドル値を使用して、<ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>The derived class resides in an assembly without unmanaged code access permission.</source>
          <target state="translated">派生クラスがアンマネージ コードのアクセス許可なしにアセンブリに存在しています。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>for full trust for inheritors.</source>
          <target state="translated">継承時の完全な信頼。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>This member cannot be inherited by partially trusted code.</source>
          <target state="translated">このメンバーは、部分的に信頼されたコードでは継承できません。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)">
          <source>This class cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このクラスは、部分的に信頼されているまたは透過的なコードでは使用できません。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">リソースを解放するためのハンドルをマークします。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph>メソッドにより、リソースを解放します。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</source>
          <target state="translated">異なり、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>クラス、これは常に他のスレッドがこのハンドルを使用していることを示すために参照カウントがないためにすぐにします。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method.</source>
          <target state="translated">そのため、安全に呼び出すことを確認する同期メカニズムを採用する必要があります、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">ほとんどのクラスを使用するが、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>クラスは、この操作は、必要に応じて、ファイナライザーを用意する必要はありません (たとえば、ファイル バッファーをフラッシュするかを記述するいくつかのデータ バックアップをメモリに)。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">この例では、クラスが前に実行することが保証が不要なファイナライザーを提供できます、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>クリティカル ファイナライザーを実行します。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph>が完了したら、メソッドを使用して、<ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>メソッドによって、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>使用不可の状態オブジェクト。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> Always call <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>注<ept id="p1">**</ept>常に呼び出し<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph>への参照を解放する前に、<ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Close">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">そうしないと、ガベージ コレクターが <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> オブジェクトの <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> メソッドを呼び出すまで、使用されているリソースは解放されません。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="T:System.Runtime.InteropServices.CriticalHandle">
          <source>Marks the handle for releasing and freeing resources.</source>
          <target state="translated">リソースを解放するためのハンドルをマークします。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Releases all resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph>.</source>
          <target state="translated">
          <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> によって使用されているすべてのリソースを解放します。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Calling the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph>メソッドにより、リソースを解放します。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class, this will always happen immediately since there is no reference count to indicate that other threads are using this handle.</source>
          <target state="translated">異なり、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>クラス、これは常に他のスレッドがこのハンドルを使用していることを示すために参照カウントがないためにすぐにします。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Therefore, you must employ a synchronization mechanism to ensure it is safe to call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method.</source>
          <target state="translated">そのため、安全に呼び出すことを確認する同期メカニズムを採用する必要があります、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Although most classes that use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</source>
          <target state="translated">ほとんどのクラスを使用するが、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>クラスは、この操作は、必要に応じて、ファイナライザーを用意する必要はありません (たとえば、ファイル バッファーをフラッシュするかを記述するいくつかのデータ バックアップをメモリに)。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>In this case, the class can provide a finalizer that is guaranteed to run before the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> critical finalizer runs.</source>
          <target state="translated">この例では、クラスが前に実行することが保証が不要なファイナライザーを提供できます、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>クリティカル ファイナライザーを実行します。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph>が完了したら、メソッドを使用して、<ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object in an unusable state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>メソッドによって、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>使用不可の状態オブジェクト。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> Always call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method before you release your last reference to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>注<ept id="p1">**</ept>常に呼び出し、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph>メソッドへの参照を解放する前に、<ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">そうしないと、ガベージ コレクターが <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> オブジェクトの <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> メソッドを呼び出すまで、使用されているリソースは解放されません。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> for a normal dispose operation; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to finalize the handle.</source>
          <target state="translated">通常の破棄操作を実行する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。ハンドルを終了する場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> class specifying whether to perform a normal dispose operation.</source>
          <target state="translated">通常の破棄操作を実行するかどうかを指定して、<ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.CriticalHandle" /&gt;</ph> クラスによって使用されているアンマネージ リソースを解放します。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)">
          <source>You should never explicitly call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method with the <ph id="ph2">`disposing`</ph> parameter set to <ph id="ph3">`false`</ph>.</source>
          <target state="translated">明示的に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph>メソッドを<ph id="ph2">`disposing`</ph>パラメーターに設定<ph id="ph3">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>Frees all resources associated with the handle.</source>
          <target state="translated">ハンドルに関連付けられたすべてのリソースを解放します。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph> method is the destructor for the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A&gt;</ph>メソッドは、デストラクター、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.Finalize">
          <source>Application code should not call this method directly.</source>
          <target state="translated">アプリケーション コードでは、このメソッドを直接呼び出さないでください。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="F:System.Runtime.InteropServices.CriticalHandle.handle">
          <source>Specifies the handle to be wrapped.</source>
          <target state="translated">ラップするハンドルを指定します。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Runtime.InteropServices.CriticalHandle.handle">
          <source>Do not expose the handle publicly (that is, outside of the derived class).</source>
          <target state="translated">ハンドルをパブリックに公開しません (つまり、派生クラスの外部で)。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>Gets a value indicating whether the handle is closed.</source>
          <target state="translated">ハンドルが閉じているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">ハンドルが閉じている場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a value indicating whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object's handle is no longer associated with a native resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph>メソッドを示す値を返すかどうか、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>オブジェクトのハンドルは、ネイティブ リソースに関連付けが不要になった。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>This differs from the definition of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property, which computes whether a given handle is always considered invalid.</source>
          <target state="translated">これの定義とは異なります、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph>プロパティで、かどうか、指定されたハンドルは常に無効とみなさを計算します。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> method returns a <ph id="ph2">`true`</ph> value in the following cases:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph>メソッドを返します、<ph id="ph2">`true`</ph>値は、次の場合。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method was called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph>メソッドが呼び出されました。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsClosed">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method or <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> method was called and there are no references to the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object on other threads.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph>メソッドまたは<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>メソッドが呼び出されへの参照がない、<ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>他のスレッド上のオブジェクト。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>When overridden in a derived class, gets a value indicating whether the handle value is invalid.</source>
          <target state="translated">派生クラスでオーバーライドされると、ハンドル値が無効かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is valid; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">ハンドルが有効な場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Derived classes must implement the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property so that the common language runtime can determine whether critical finalization is required.</source>
          <target state="translated">派生クラスを実装する必要があります、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph>プロパティ、共通言語ランタイムでは、重要な終了処理が必要かどうかを確認できるようにします。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</source>
          <target state="translated">派生クラスは、一般的な種類のハンドルをサポートするのに適した実装を提供する必要があります (0 または-1 が無効)。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>These classes can then be further derived for specific safe handle types.</source>
          <target state="translated">これらのクラスは、特定のセーフ ハンドルの種類をさらに派生します。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property, which reports whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> object has finished using the underlying handle, the <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property calculates whether the given handle value is always considered invalid.</source>
          <target state="translated">異なり、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph>プロパティで、報告するかどうか、 <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> 、基になるハンドルを使用してオブジェクトが完了した、<ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph>プロパティを計算するかどうか、指定したハンドルの値は常に無効とみなさです。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> property always returns the same value for any one handle value.</source>
          <target state="translated">したがって、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph>プロパティは常に任意の 1 つのハンドル値に対して同じ値を返します。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>When overridden in a derived class, executes the code required to free the handle.</source>
          <target state="translated">派生クラスでオーバーライドされると、ハンドルを解放するために必要なコードを実行します。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">ハンドルが正常に解放された場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。深刻なエラーが発生した場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In this case, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">この場合、<bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> マネージ デバッグ アシスタントが生成されます。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method is guaranteed to be called only once, provided that you employ proper synchronization mechanisms to ensure that only one call to the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph> method is made.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>を 1 つだけ呼び出すことを確認する適切な同期メカニズムを採用することは、メソッドを 1 回だけ呼び出される保証、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Close%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A&gt;</ph>メソッドが行われます。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method will not be called if the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph> property is <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>場合、メソッドは呼び出されません、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A&gt;</ph>プロパティは<ph id="ph4">`true`</ph>します。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Implement this method in your <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> derived classes to execute any code that is required to free the handle.</source>
          <target state="translated">このメソッドの実装、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>ハンドルを解放するために必要なすべてのコードを実行するクラスを派生します。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Because one of the functions of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph> is to guarantee prevention of resource leaks, the code in your implementation of <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> must never fail.</source>
          <target state="translated">の関数の 1 つ<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle&gt;</ph>、コードの実装で、リソース リークの防止を保証するためには、<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>失敗しない必要があります。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>The garbage collector calls <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> after normal finalizers have been run for objects that were garbage collected at the same time, and guarantees the resources to invoke it and that it will not be interrupted while it is in progress.</source>
          <target state="translated">ガベージ コレクター<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>ガベージ コレクション、同時になったオブジェクトの通常のファイナライザーが実行されているし、リソースを呼び出すことは中断されず while、保証が進行中です。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</source>
          <target state="translated">このメソッドは、(その静的に確定呼び出し先のすべてのメソッド) およびインスタンスの構築時に、制約された実行領域 (CER) として準備されます。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method.</source>
          <target state="translated">オーバーライドされたどのエラー パスを導入しないように注意する必要がありますが、これには、スレッドの中止割り込みが防止されますが、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In particular, apply the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute to any methods you call from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>.</source>
          <target state="translated">具体的には、適用、<ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph>から呼び出すメソッドが存在する属性<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>In most cases this code should be:</source>
          <target state="translated">ほとんどの場合、このコードがあります。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>Additionally, for simple cleanup (for example, calling the Win32 API <ph id="ph1">`CloseHandle`</ph> on a file handle) you can check the return value for the single platform invoke call.</source>
          <target state="translated">簡単なクリーンアップをさらに、(たとえば、Win32 API の呼び出し<ph id="ph1">`CloseHandle`</ph>ファイル ハンドルの) 1 つのプラットフォーム呼び出しの戻り値を確認することができます。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</source>
          <target state="translated">複雑なクリーンアップは、多くのプログラム ロジックとこれらの一部が失敗する多くのメソッド呼び出しがあります。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>You must ensure that your program logic has fallback code for each of those cases.</source>
          <target state="translated">プログラム ロジックでこのような場合の各フォールバック コードはことを確認する必要があります。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle">
          <source>If the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph> method returns <ph id="ph2">`false`</ph> for any reason, it generates a <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A&gt;</ph>メソッドを返します。<ph id="ph2">`false`</ph>生成何らかの理由で、 <bpt id="p1">[</bpt>releaseHandleFailed<ept id="p1">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept>マネージ デバッグ アシスタントします。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>The pre-existing handle to use.</source>
          <target state="translated">使用する既存のハンドル。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>Sets the handle to the specified pre-existing handle.</source>
          <target state="translated">ハンドルを指定した既存のハンドルに設定します。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)">
          <source>Use the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling handles in a structure.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph>構造体のメソッドは .NET Framework の COM 相互運用インフラストラクチャは、マーシャ リングをサポートしていないため (たとえば、ハンドルは、構造体で返される) 場合、既存のハンドルをサポートする必要がある場合にのみを処理します。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Marks a handle as invalid.</source>
          <target state="translated">ハンドルを無効としてマークします。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> method only when you know that your handle is invalid and you want to mark it as such.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph>メソッド ハンドルが無効であり、そのようなマークすることがわかっている場合のみです。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>Doing so does not change the value of the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph> field; it only marks the handle as invalid.</source>
          <target state="translated">これは、値を変更しない、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.handle&gt;</ph>フィールド; 無効なハンドルをマークするだけです。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>The handle might then contain a potentially stale value.</source>
          <target state="translated">ハンドルは、値が古い可能性のある値を含めるし可能性があります。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>The effect of this call is that no attempt is made to free the resources.</source>
          <target state="translated">この呼び出しの影響は、ことは行われません、リソースを解放します。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid">
          <source>As with the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph> only if you need to support a pre-existing handle.</source>
          <target state="translated">同様、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A&gt;</ph>メソッドを使用して<ph id="ph2">&lt;xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A&gt;</ph>を既存のハンドルをサポートする必要がある場合のみです。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>