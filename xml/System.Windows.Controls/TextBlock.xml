<Type Name="TextBlock" FullName="System.Windows.Controls.TextBlock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="328de6cf4487f0e412778bbbbecf1caf7cbe3100" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36365829" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextBlock : System.Windows.FrameworkElement, IServiceProvider, System.Windows.IContentHost" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi TextBlock extends System.Windows.FrameworkElement implements class System.IServiceProvider, class System.Windows.IContentHost, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.TextBlock" />
  <TypeSignature Language="VB.NET" Value="Public Class TextBlock&#xA;Inherits FrameworkElement&#xA;Implements IContentHost, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextBlock : System::Windows::FrameworkElement, IServiceProvider, System::Windows::IContentHost" />
  <TypeSignature Language="F#" Value="type TextBlock = class&#xA;    inherit FrameworkElement&#xA;    interface IContentHost&#xA;    interface IAddChild&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IContentHost</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Inlines")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides a lightweight control for displaying small amounts of flow content.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Controls.TextBlock>で文字列を含めることができます、<xref:System.Windows.Controls.TextBlock.Text%2A>プロパティまたは<xref:System.Windows.Documents.Inline>フロー コンテンツ要素をなど<xref:System.Windows.Documents.Bold>、 <xref:System.Windows.Documents.Hyperlink>、および<xref:System.Windows.Documents.InlineUIContainer>で、その<xref:System.Windows.Controls.TextBlock.Inlines%2A>プロパティです。  
  
 <xref:System.Windows.Controls.TextBlock> 軽量のように設計されておりへのフロー コンテンツの一部を統合する場合に特に適していますが、[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]です。  <xref:System.Windows.Controls.TextBlock> 単一行の表示に最適なし、最大でいくつかの行のコンテンツを表示するための適切なパフォーマンスを提供します。  
  
 <xref:System.Windows.Controls.TextBlock> コンテンツの複数の線を表示する必要があるシナリオについては最適化されません。そのようなシナリオ、<xref:System.Windows.Documents.FlowDocument>よりも適した選択肢には、適切な表示コントロールと組み合わせると<xref:System.Windows.Controls.TextBlock>パフォーマンスの観点からです。  後に<xref:System.Windows.Controls.TextBlock>、<xref:System.Windows.Controls.FlowDocumentScrollViewer>フロー コンテンツを表示するための次の最も低い加重値コントロールは、最小限に抑えてスクロール コンテンツ領域を提供するだけ[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]です。  <xref:System.Windows.Controls.FlowDocumentPageViewer> フロー コンテンツの「ページで、-タイム」の表示モードの周囲に最適化されています。  最後に、<xref:System.Windows.Controls.FlowDocumentReader>フロー コンテンツを表示するための機能豊富なセットをサポートしていますが、それに応じて重みで高い負荷に対応します。  
  
 内のテキストを水平方向に整列、<xref:System.Windows.Controls.TextBlock>処理が終わったら、<xref:System.Windows.Controls.TextBlock.TextAlignment%2A>プロパティです。 整列、<xref:System.Windows.Controls.TextBlock>のページ レイアウト内で行われます、<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>と<xref:System.Windows.FrameworkElement.VerticalAlignment%2A>プロパティです。  
  
   
  
## Examples  
 <xref:System.Windows.Controls.TextBlock> 要素を使用する方法を次の例に示します。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockSimpleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblocksimplexaml)]  
  
 この例の表示結果を次の図に示します。  
  
 ![スクリーン ショット: Textblock とボタン](~/add/media/textblock-simple.png "スクリーン ショット: Textblock とボタン")  
  
 次の例では、方法を表示させるためのような結果方法プログラムでを示します。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblocksimple)]
 [!code-vb[FlowDocumentSnippets#_TextBlockSimple](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblocksimple)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Label" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Controls.TextBlock" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextBlock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Controls.TextBlock" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TextBlock (System.Windows.Documents.Inline inline);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.Inline inline) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.#ctor(System.Windows.Documents.Inline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TextBlock(System::Windows::Documents::Inline ^ inline);" />
      <MemberSignature Language="F#" Value="new System.Windows.Controls.TextBlock : System.Windows.Documents.Inline -&gt; System.Windows.Controls.TextBlock" Usage="new System.Windows.Controls.TextBlock inline" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="inline" Type="System.Windows.Documents.Inline" />
      </Parameters>
      <Docs>
        <param name="inline">An object deriving from the abstract <see cref="T:System.Windows.Documents.Inline" /> class, to be added as the initial content.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Controls.TextBlock" /> class, adding a specified <see cref="T:System.Windows.Documents.Inline" /> element as the initial display content.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有効な入力の種類の`inline`含める<xref:System.Windows.Documents.AnchoredBlock>、 <xref:System.Windows.Documents.InlineUIContainer>、 <xref:System.Windows.Documents.LineBreak>、 <xref:System.Windows.Documents.Run>、および<xref:System.Windows.Documents.Span>です。  
  
   
  
## Examples  
 次の例では、このコンス トラクターの使用を示します。  ここで、 <xref:System.Windows.Controls.TextBlock> 、テキストを含む<xref:System.Windows.Documents.Run>です。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockConstructorSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockconstructorsimple)]
 [!code-vb[FlowDocumentSnippets#_TextBlockConstructorSimple](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockconstructorsimple)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inline" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size ArrangeOverride (System.Windows.Size arrangeSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function ArrangeOverride (arrangeSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeSize);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="textBlock.ArrangeOverride arrangeSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeSize">A <see cref="T:System.Windows.Size" /> within the hosting parent element that the <see cref="T:System.Windows.Controls.TextBlock" /> should use to arrange itself and its child elements. Sizing constraints may affect this requested size.</param>
        <summary>Positions child elements and determines a size for the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>The actual <see cref="T:System.Windows.Size" /> used to arrange the element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは<xref:System.Windows.FrameworkElement.ArrangeOverride%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Background" />
      <MemberSignature Language="VB.NET" Value="Public Property Background As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Background { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Background : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.TextBlock.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Media.Brush" /> used to fill the background of content area.</summary>
        <value>コンテンツ エリアの背景の塗りつぶしに使用するブラシまたは<see langword="null" />背景ブラシを使用しないようにします。 既定値は <see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 どの<xref:System.Windows.Controls.TextBlock.Background%2A>子要素がこの最上位レベルの設定を上書きします。  
  
 使用可能な定義済みのブラシの色の表は、次を参照してください。<xref:System.Windows.Media.Brushes>です。  
  
<a name="dependencyPropertyInfo_Background"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.BackgroundProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.Background%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.Background%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.BackgroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BackgroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BackgroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BackgroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.Background" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaselineOffset">
      <MemberSignature Language="C#" Value="public double BaselineOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 BaselineOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BaselineOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property BaselineOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double BaselineOffset { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.BaselineOffset : double with get, set" Usage="System.Windows.Controls.TextBlock.BaselineOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the amount by which each line of text is offset from the baseline.</summary>
        <value>テキストの各行がベースラインからオフセットされる量 (デバイスに依存しないピクセル単位)。 <see cref="F:System.Double.NaN" /> 最適なベースラインのオフセットが現在のフォント特性から自動的に計算されることを示します。 既定値は <see cref="F:System.Double.NaN" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ベースラインは、行のテキスト内の各文字の基数が揃えられる虚数部の水平方向です。  
  
 この依存関係プロパティには、添付プロパティの使用方法もあります。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、使い方が`<`*オブジェクト* <xref:System.Windows.Controls.TextBlock.BaselineOffset%2A?displayProperty=nameWithType> `="`*二重*`".../>`ここで、*オブジェクト*オブジェクト要素 (通常、フロー要素内に含まれる)、<xref:System.Windows.Controls.TextBlock>です。 コードでは、添付プロパティの使用がサポートされている<xref:System.Windows.Controls.TextBlock.GetBaselineOffset%2A>と<xref:System.Windows.Controls.TextBlock.SetBaselineOffset%2A>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaselineOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BaselineOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BaselineOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.BaselineOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BaselineOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BaselineOffsetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BaselineOffsetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.BaselineOffsetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BreakAfter">
      <MemberSignature Language="C#" Value="public System.Windows.LineBreakCondition BreakAfter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineBreakCondition BreakAfter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BreakAfter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BreakAfter As LineBreakCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineBreakCondition BreakAfter { System::Windows::LineBreakCondition get(); };" />
      <MemberSignature Language="F#" Value="member this.BreakAfter : System.Windows.LineBreakCondition" Usage="System.Windows.Controls.TextBlock.BreakAfter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineBreakCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.LineBreakCondition" /> that indicates how content should break after the current element.</summary>
        <value>現在の要素の後に重大なコンテンツの条件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは常に <xref:System.Windows.LineBreakCondition.BreakDesired> を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.BreakBefore" />
      </Docs>
    </Member>
    <Member MemberName="BreakBefore">
      <MemberSignature Language="C#" Value="public System.Windows.LineBreakCondition BreakBefore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineBreakCondition BreakBefore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.BreakBefore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BreakBefore As LineBreakCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineBreakCondition BreakBefore { System::Windows::LineBreakCondition get(); };" />
      <MemberSignature Language="F#" Value="member this.BreakBefore : System.Windows.LineBreakCondition" Usage="System.Windows.Controls.TextBlock.BreakBefore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineBreakCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.LineBreakCondition" /> that indicates how content should break before the current element.</summary>
        <value>現在の要素の後に重大なコンテンツの条件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは常に <xref:System.Windows.LineBreakCondition.BreakDesired> を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.BreakAfter" />
      </Docs>
    </Member>
    <Member MemberName="ContentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer ContentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer ContentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.ContentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ ContentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Controls.TextBlock.ContentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Documents.TextPointer" /> to the end of content in the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>A<see cref="T:System.Windows.Documents.TextPointer" />内のコンテンツの最後に、<see cref="T:System.Windows.Controls.TextBlock" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテンツの最後が採用される次の最後の文字の直接挿入位置、<xref:System.Windows.Controls.TextBlock>です。  
  
 <xref:System.Windows.Documents.TextPointer>このプロパティによって返されるが常にその<xref:System.Windows.Documents.LogicalDirection>'éý'<xref:System.Windows.Documents.LogicalDirection.Forward>です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.ContentStart" />
      </Docs>
    </Member>
    <Member MemberName="ContentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer ContentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer ContentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.ContentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ ContentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Controls.TextBlock.ContentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Windows.Documents.TextPointer" /> to the beginning of content in the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>A<see cref="T:System.Windows.Documents.TextPointer" />内のコンテンツの先頭に、<see cref="T:System.Windows.Controls.TextBlock" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンテンツの先頭があると見なされますの最初の文字の直前の挿入位置、<xref:System.Windows.Controls.TextBlock>です。  
  
 <xref:System.Windows.Documents.TextPointer>このプロパティによって返されるが常にその<xref:System.Windows.Documents.LogicalDirection>'éý'<xref:System.Windows.Documents.LogicalDirection.Backward>です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.TextBlock.ContentEnd" />
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontFamily" />
      <MemberSignature Language="VB.NET" Value="Public Property FontFamily As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::FontFamily ^ FontFamily { System::Windows::Media::FontFamily ^ get(); void set(System::Windows::Media::FontFamily ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FontFamily : System.Windows.Media.FontFamily with get, set" Usage="System.Windows.Controls.TextBlock.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the preferred top-level font family for the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>A<see cref="T:System.Windows.Media.FontFamily" />優先フォント ファミリ、または優先されるプライマリ フォント ファミリと 1 つ以上の代替フォント ファミリを指定するオブジェクト。 既定値はによって決まるフォント、<see cref="P:System.Windows.SystemFonts.MessageFontFamily" />値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 どの<xref:System.Windows.Controls.TextBlock.FontFamily%2A>子要素がこの最上位レベルの設定を上書きします。  
  
 複数のファミリを指定すると、2 回目以降のフォント ファミリは、プライマリ フォント ファミリを使用または適用できない場合に使用されるフォールバック ファミリとして機能します。  
  
 このプロパティは、優先度だけを指定します。  指定したフォント ファミリが使用できない場合、<xref:System.Windows.Controls.TextBlock>サイレントによって決まるフォントにフォールバック、<xref:System.Windows.SystemFonts.MessageFontFamily%2A>値。  
  
 この依存関係プロパティには、添付プロパティの使用方法もあります。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、使い方が`<`*オブジェクト* <xref:System.Windows.Controls.TextBlock.FontFamily%2A?displayProperty=nameWithType> `="`*値*`".../>`ここで、*オブジェクト*オブジェクト要素(通常はフロー要素) 内に含まれる、 <xref:System.Windows.Controls.TextBlock>、および*値*XAML 値で説明したようには文字列形式の値のいずれか。 コードでは、添付プロパティの使用がサポートされている<xref:System.Windows.Controls.TextBlock.GetFontFamily%2A>と<xref:System.Windows.Controls.TextBlock.SetFontFamily%2A>です。 添付プロパティの使用ではありません一般的では、ほとんどの要素をことができますに含まれている、<xref:System.Windows.Controls.TextBlock>非添付と似ています、サポート`FontFamily`プロパティを<xref:System.Windows.Controls.TextBlock>レンダリングに使用します。  
  
<a name="xamlAttributeUsage_FontFamily"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object FontFamily="fontFamilyName"/>  
- or -  
<object FontFamily="fontFamilyNamesList"/>  
- or -  
<object FontFamily="fontFamilyFolderReference"/>  
- or -  
<object FontFamily="fontFamilyUriReference"/>  
```  
  
<a name="xamlValues_FontFamily"></a>   
## <a name="xaml-values"></a>XAML 値  
 *fontFamilyName*  
 フォント ファミリ名を指定する文字列。  たとえば、`"Arial"` または `"Century Gothic"` のようにします。  
  
 *fontFamilyNamesList*  
 (コンマの後の空白は無視されます)、コンマで区切って複数のフォント ファミリ名を指定する文字列、します。  指定した最初のフォント ファミリを果たすプライマリ フォント ファミリ。以降のフォント ファミリは、プライマリ フォント ファミリが使用または適用できない場合に使用するフォールバック ファミリとして機能します。  たとえば、`"Arial, Century Gothic"`世紀ゴートとして代替フォント ファミリと、プライマリ フォント ファミリと Arial を指定します。  
  
 *fontFamilyFolderReference*  
 フォント ファミリ名と共に、フォントを含むフォルダーを指定する文字列。  フォント ファミリ名とフォルダーは、# 文字で区切られます。  フォルダーの参照は、絶対または相対パスにあります。  たとえば、`"Custom Fonts\#My Custom Font"` のようにします。  
  
 *fontFamilyUriReference*  
 指定する文字列、[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]のフォント、フォント ファミリ名とします。  [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]し、フォント ファミリ名は、# 文字で区切られます。  たとえば、`"http://MyFontServer/Fonts/#My Custom Font"` のようにします。  
  
<a name="dependencyPropertyInfo_FontFamily"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.FontFamilyProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.FontFamily%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.FontFamily%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontFamilyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontFamilyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontFamilyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontFamilyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontSize" />
      <MemberSignature Language="VB.NET" Value="Public Property FontSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double FontSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.FontSize : double with get, set" Usage="System.Windows.Controls.TextBlock.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the top-level font size for the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>使用する目的のフォント サイズ (デバイス非依存のピクセル単位)。 既定値はによって決定されます、<see cref="P:System.Windows.SystemFonts.MessageFontSize" />値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 どの<xref:System.Windows.Controls.TextBlock.FontSize%2A>子要素がこの最上位レベルの設定を上書きします。  
  
 この依存関係プロパティには、添付プロパティの使用方法もあります。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、使い方が`<`*オブジェクト* <xref:System.Windows.Controls.TextBlock.FontSize%2A?displayProperty=nameWithType> `="`*値*`".../>`ここで、*オブジェクト*オブジェクト要素(通常はフロー要素) 内に含まれる、 <xref:System.Windows.Controls.TextBlock>、および*値*XAML 値で説明したようには文字列形式の値のいずれか。 コードでは、添付プロパティの使用がサポートされている<xref:System.Windows.Controls.TextBlock.GetFontSize%2A>と<xref:System.Windows.Controls.TextBlock.SetFontSize%2A>です。 添付プロパティの使用ではありません一般的では、ほとんどの要素をことができますに含まれている、<xref:System.Windows.Controls.TextBlock>非添付と似ています、サポート`FontSize`プロパティを<xref:System.Windows.Controls.TextBlock>レンダリングに使用します。  
  
<a name="xamlAttributeUsage_FontSize"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object FontSize="double"/>  
- or -  
<object FontSize="qualifiedDouble"/>  
```  
  
<a name="xamlValues_FontSize"></a>   
## <a name="xaml-values"></a>XAML 値  
 *double*  
 <xref:System.Double>  
  
 文字列表現を<xref:System.Double>値より小さくなります 0.0 以上<xref:System.Double.PositiveInfinity>です。 修飾されていない値は、デバイス非依存ピクセル単位で計測されます。 明示的に、文字列では、小数点を含める必要がありますされません。  
  
 *qualifiedDouble*  
 A*二重*値、上記と続けて次の単位指定子のいずれかの: `px`、 `in`、 `cm`、`pt`です。  
  
 `px` (既定値) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px を = =  
  
 `cm` センチメートル; は、します。1cm==(96/2.54) px  
  
 `pt` ポイントです。1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_FontSize"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.FontSizeProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.FontSize%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.FontSize%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretch">
      <MemberSignature Language="C#" Value="public System.Windows.FontStretch FontStretch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStretch FontStretch" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontStretch" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStretch As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStretch FontStretch { System::Windows::FontStretch get(); void set(System::Windows::FontStretch value); };" />
      <MemberSignature Language="F#" Value="member this.FontStretch : System.Windows.FontStretch with get, set" Usage="System.Windows.Controls.TextBlock.FontStretch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the top-level font-stretching characteristics for the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>メンバー、<see cref="T:System.Windows.FontStretch" />クラスを使用する目的のフォント伸縮特性を指定します。 既定値は <see cref="P:System.Windows.FontStretches.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 どの<xref:System.Windows.Controls.TextBlock.FontStretch%2A>子要素がこの最上位レベルの設定を上書きします。  
  
 この依存関係プロパティには、添付プロパティの使用方法もあります。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、使い方が`<`*オブジェクト* <xref:System.Windows.Controls.TextBlock.FontStretch%2A?displayProperty=nameWithType> `="`*値*`".../>`ここで、*オブジェクト*オブジェクト要素(通常はフロー要素) 内に含まれる、 <xref:System.Windows.Controls.TextBlock>、および*値*のプロパティ名の文字列形式のいずれかが、<xref:System.Windows.FontStretch>クラスです。 コードでは、添付プロパティの使用がサポートされている<xref:System.Windows.Controls.TextBlock.GetFontStretch%2A>と<xref:System.Windows.Controls.TextBlock.SetFontStretch%2A>です。 添付プロパティの使用ではありません一般的では、ほとんどの要素をことができますに含まれている、<xref:System.Windows.Controls.TextBlock>非添付と似ています、サポート`FontStretch`プロパティを<xref:System.Windows.Controls.TextBlock>レンダリングに使用します。  
  
<a name="dependencyPropertyInfo_FontStretch"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.FontStretchProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.FontStretch%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.FontStretch%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStretchProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStretchProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStretchProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontStretchProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStretchProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStretchProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontStretchProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.FontStretchProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyle">
      <MemberSignature Language="C#" Value="public System.Windows.FontStyle FontStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontStyle FontStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FontStyle As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontStyle FontStyle { System::Windows::FontStyle get(); void set(System::Windows::FontStyle value); };" />
      <MemberSignature Language="F#" Value="member this.FontStyle : System.Windows.FontStyle with get, set" Usage="System.Windows.Controls.TextBlock.FontStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the top-level font style for the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>メンバー、<see cref="T:System.Windows.FontStyles" />目的のフォント スタイルを指定するクラス。 既定値はによって決定されます、<see cref="P:System.Windows.SystemFonts.MessageFontStyle" />値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 どの<xref:System.Windows.Controls.TextBlock.FontStyle%2A>子要素がこの最上位レベルの設定を上書きします。  
  
 この依存関係プロパティには、添付プロパティの使用方法もあります。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、使い方が`<`*オブジェクト* <xref:System.Windows.Controls.TextBlock.FontStyle%2A?displayProperty=nameWithType> `="`*値*`".../>`ここで、*オブジェクト*オブジェクト要素(通常はフロー要素) 内に含まれる、 <xref:System.Windows.Controls.TextBlock>、および*値*は文字列形式の 1 つのプロパティ名、<xref:System.Windows.FontStyles>クラスです。 コードでは、添付プロパティの使用がサポートされている<xref:System.Windows.Controls.TextBlock.GetFontStyle%2A>と<xref:System.Windows.Controls.TextBlock.SetFontStyle%2A>です。 添付プロパティの使用ではありません一般的では、ほとんどの要素をことができますに含まれている、<xref:System.Windows.Controls.TextBlock>非添付と似ています、サポート`FontStyle`プロパティを<xref:System.Windows.Controls.TextBlock>レンダリングに使用します。  
  
<a name="dependencyPropertyInfo_FontStyle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.FontStyleProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.FontStyle%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.FontStyle%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.FontStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeight">
      <MemberSignature Language="C#" Value="public System.Windows.FontWeight FontWeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FontWeight FontWeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.FontWeight" />
      <MemberSignature Language="VB.NET" Value="Public Property FontWeight As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FontWeight FontWeight { System::Windows::FontWeight get(); void set(System::Windows::FontWeight value); };" />
      <MemberSignature Language="F#" Value="member this.FontWeight : System.Windows.FontWeight with get, set" Usage="System.Windows.Controls.TextBlock.FontWeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the top-level font weight for the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>メンバー、<see cref="T:System.Windows.FontWeights" />フォントの太さを指定します。 既定値はによって決定されます、<see cref="P:System.Windows.SystemFonts.MessageFontWeight" />値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 どの<xref:System.Windows.Controls.TextBlock.FontWeight%2A>子要素がこの最上位レベルの設定を上書きします。  
  
 フォントの太さの有効な値の一覧は、次を参照してください。、<xref:System.Windows.FontWeights>クラスです。  
  
 この依存関係プロパティには、添付プロパティの使用方法もあります。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、使い方が`<`*オブジェクト* <xref:System.Windows.Controls.TextBlock.FontWeight%2A?displayProperty=nameWithType> `="`*値*`".../>`ここで、*オブジェクト*オブジェクト要素(通常はフロー要素) 内に含まれる、 <xref:System.Windows.Controls.TextBlock>、および*値*はのプロパティの文字列形式の値の 1 つ、<xref:System.Windows.FontWeights>クラスです。 コードでは、添付プロパティの使用がサポートされている<xref:System.Windows.Controls.TextBlock.GetFontWeight%2A>と<xref:System.Windows.Controls.TextBlock.SetFontWeight%2A>です。 添付プロパティの使用ではありません一般的では、ほとんどの要素をことができますに含まれている、<xref:System.Windows.Controls.TextBlock>非添付と似ています、サポート`FontWeight`プロパティを<xref:System.Windows.Controls.TextBlock>レンダリングに使用します。  
  
<a name="dependencyPropertyInfo_FontWeight"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.FontWeightProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.FontWeight%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.FontWeight%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontWeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontWeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontWeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.FontWeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FontWeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FontWeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FontWeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.FontWeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Foreground" />
      <MemberSignature Language="VB.NET" Value="Public Property Foreground As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ Foreground { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Foreground : System.Windows.Media.Brush with get, set" Usage="System.Windows.Controls.TextBlock.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.Media.Brush" /> to apply to the text contents of the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>テキスト コンテンツに適用するために使用するブラシ。 既定値は <see cref="P:System.Windows.Media.Brushes.Black" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用可能な事前定義されたブラシの色の表は、次を参照してください。<xref:System.Windows.Media.Brushes>です。  
  
 どの<xref:System.Windows.Controls.TextBlock.Foreground%2A>子要素がこの最上位レベルの設定を上書きします。  
  
 この依存関係プロパティには、添付プロパティの使用方法もあります。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、使い方が`<`*オブジェクト* <xref:System.Windows.Controls.TextBlock.Foreground%2A?displayProperty=nameWithType> `="`*値*`".../>`ここで、*オブジェクト*オブジェクト要素(通常はフロー要素) 内に含まれる、 <xref:System.Windows.Controls.TextBlock>、および*値*に解決される文字列には、<xref:System.Windows.Media.Brush>実装値。 コードでは、添付プロパティの使用がサポートされている<xref:System.Windows.Controls.TextBlock.GetForeground%2A>と<xref:System.Windows.Controls.TextBlock.SetForeground%2A>です。 添付プロパティの使用ではありません一般的では、ほとんどの要素をことができますに含まれている、<xref:System.Windows.Controls.TextBlock>非添付と似ています、サポート`Foreground`プロパティを<xref:System.Windows.Controls.TextBlock>レンダリングに使用します。  
  
<a name="dependencyPropertyInfo_Foreground"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.ForegroundProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.Foreground%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.Foreground%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.ForegroundProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForegroundProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForegroundProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForegroundProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaselineOffset">
      <MemberSignature Language="C#" Value="public static double GetBaselineOffset (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetBaselineOffset(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetBaselineOffset(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetBaselineOffset (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetBaselineOffset(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetBaselineOffset : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Controls.TextBlock.GetBaselineOffset element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object from which to retrieve the value of the <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> attached property.</param>
        <summary>Returns the value of the <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> attached property for a specified dependency object.</summary>
        <returns>The current value of the <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> attached property on the specified dependency object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetBaselineOffset(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontFamily">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.FontFamily GetFontFamily (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.FontFamily GetFontFamily(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontFamily(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontFamily (element As DependencyObject) As FontFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::FontFamily ^ GetFontFamily(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFontFamily : System.Windows.DependencyObject -&gt; System.Windows.Media.FontFamily" Usage="System.Windows.Controls.TextBlock.GetFontFamily element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object from which to retrieve the value of the <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> attached property.</param>
        <summary>Returns the value of the <see cref="F:System.Windows.Controls.TextBlock.FontFamilyProperty" /> attached property for a specified dependency object.</summary>
        <returns>The current value of the <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> attached property on the specified dependency object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontFamily(System.Windows.DependencyObject,System.Windows.Media.FontFamily)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontSize">
      <MemberSignature Language="C#" Value="public static double GetFontSize (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetFontSize(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontSize(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontSize (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetFontSize(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFontSize : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Controls.TextBlock.GetFontSize element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object from which to retrieve the value of the <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> attached property.</param>
        <summary>Returns the value of the <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> attached property for a specified dependency object.</summary>
        <returns>The current value of the <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> attached property on the specified dependency object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontStretch">
      <MemberSignature Language="C#" Value="public static System.Windows.FontStretch GetFontStretch (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontStretch GetFontStretch(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontStretch(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontStretch (element As DependencyObject) As FontStretch" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontStretch GetFontStretch(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFontStretch : System.Windows.DependencyObject -&gt; System.Windows.FontStretch" Usage="System.Windows.Controls.TextBlock.GetFontStretch element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStretch</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object from which to retrieve the value of the <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> attached property.</param>
        <summary>Returns the value of the <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> attached property for a specified dependency object.</summary>
        <returns>The current value of the <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> attached property on the specified dependency object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontStretch(System.Windows.DependencyObject,System.Windows.FontStretch)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontStyle">
      <MemberSignature Language="C#" Value="public static System.Windows.FontStyle GetFontStyle (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontStyle GetFontStyle(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontStyle(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontStyle (element As DependencyObject) As FontStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontStyle GetFontStyle(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFontStyle : System.Windows.DependencyObject -&gt; System.Windows.FontStyle" Usage="System.Windows.Controls.TextBlock.GetFontStyle element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontStyle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object from which to retrieve the value of the <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> attached property.</param>
        <summary>Returns the value of the <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> attached property for a specified dependency object.</summary>
        <returns>The current value of the <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> attached property on the specified dependency object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontStyle(System.Windows.DependencyObject,System.Windows.FontStyle)" />
      </Docs>
    </Member>
    <Member MemberName="GetFontWeight">
      <MemberSignature Language="C#" Value="public static System.Windows.FontWeight GetFontWeight (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FontWeight GetFontWeight(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetFontWeight(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFontWeight (element As DependencyObject) As FontWeight" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FontWeight GetFontWeight(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFontWeight : System.Windows.DependencyObject -&gt; System.Windows.FontWeight" Usage="System.Windows.Controls.TextBlock.GetFontWeight element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FontWeight</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object from which to retrieve the value of the <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> attached property.</param>
        <summary>Returns the value of the <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> attached property for a specified dependency object.</summary>
        <returns>The current value of the <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> attached property on the specified dependency object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontWeight(System.Windows.DependencyObject,System.Windows.FontWeight)" />
      </Docs>
    </Member>
    <Member MemberName="GetForeground">
      <MemberSignature Language="C#" Value="public static System.Windows.Media.Brush GetForeground (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Media.Brush GetForeground(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetForeground(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetForeground (element As DependencyObject) As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Media::Brush ^ GetForeground(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetForeground : System.Windows.DependencyObject -&gt; System.Windows.Media.Brush" Usage="System.Windows.Controls.TextBlock.GetForeground element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object from which to retrieve the value of the <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> attached property.</param>
        <summary>Returns the value of the <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> attached property for a specified dependency object.</summary>
        <returns>The current value of the <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> attached property on the specified dependency object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetForeground(System.Windows.DependencyObject,System.Windows.Media.Brush)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineHeight">
      <MemberSignature Language="C#" Value="public static double GetLineHeight (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetLineHeight(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetLineHeight(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLineHeight (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetLineHeight(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetLineHeight : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Controls.TextBlock.GetLineHeight element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object from which to retrieve the value of the <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> attached property.</param>
        <summary>Returns the value of the <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> attached property for a specified dependency object.</summary>
        <returns>The current value of the <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> attached property on the specified dependency object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetLineHeight(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineStackingStrategy">
      <MemberSignature Language="C#" Value="public static System.Windows.LineStackingStrategy GetLineStackingStrategy (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.LineStackingStrategy GetLineStackingStrategy(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetLineStackingStrategy(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLineStackingStrategy (element As DependencyObject) As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::LineStackingStrategy GetLineStackingStrategy(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetLineStackingStrategy : System.Windows.DependencyObject -&gt; System.Windows.LineStackingStrategy" Usage="System.Windows.Controls.TextBlock.GetLineStackingStrategy element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object from which to retrieve the value of the <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> attached property.</param>
        <summary>Returns the value of the <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> attached property for a specified dependency object.</summary>
        <returns>The current value of the <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> attached property on the specified dependency object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetLineStackingStrategy(System.Windows.DependencyObject,System.Windows.LineStackingStrategy)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionFromPoint (System.Windows.Point point, bool snapToText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionFromPoint(valuetype System.Windows.Point point, bool snapToText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetPositionFromPoint(System.Windows.Point,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionFromPoint(System::Windows::Point point, bool snapToText);" />
      <MemberSignature Language="F#" Value="member this.GetPositionFromPoint : System.Windows.Point * bool -&gt; System.Windows.Documents.TextPointer" Usage="textBlock.GetPositionFromPoint (point, snapToText)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="snapToText" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="point">A <see cref="T:System.Windows.Point" /> in the coordinate space of the <see cref="T:System.Windows.Controls.TextBlock" /> for which to return a <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <param name="snapToText">
          <see langword="true" /> to return a <see cref="T:System.Windows.Documents.TextPointer" /> to the insertion point closest to <c>point</c>, whether or not <c>point</c> is inside a character's bounding box; <see langword="false" /> to return <see langword="null" /> if <c>point</c> is not inside a character's bounding box.</param>
        <summary>Returns a <see cref="T:System.Windows.Documents.TextPointer" /> to the position closest to a specified <see cref="T:System.Windows.Point" />.</summary>
        <returns>A <see cref="T:System.Windows.Documents.TextPointer" /> to the specified point, or <see langword="null" /> if <paramref name="snapToText" /> is <see langword="false" /> and the specified point does not fall within a character bounding box in the <see cref="T:System.Windows.Controls.TextBlock" /> content area.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは常に有効な返します<xref:System.Windows.Documents.TextPointer>とき`snapToText`は`true`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Current, valid layout information for the control is unavailable.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRectanglesCore">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt; GetRectanglesCore (System.Windows.ContentElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Rect&gt; GetRectanglesCore(class System.Windows.ContentElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetRectanglesCore(System.Windows.ContentElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRectanglesCore (child As ContentElement) As ReadOnlyCollection(Of Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Rect&gt; ^ GetRectanglesCore(System::Windows::ContentElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member GetRectanglesCore : System.Windows.ContentElement -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;&#xA;override this.GetRectanglesCore : System.Windows.ContentElement -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;" Usage="textBlock.GetRectanglesCore child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.ContentElement" />
      </Parameters>
      <Docs>
        <param name="child">A <see cref="T:System.Windows.ContentElement" /> for which to generate and return a collection of bounding rectangles.</param>
        <summary>Returns a read-only collection of bounding rectangles for a specified <see cref="T:System.Windows.ContentElement" />.</summary>
        <returns>A read-only collection of bounding rectangles for the specified <see cref="T:System.Windows.ContentElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内のコンテンツの行に対応するコレクション内で各外接する四角形、<xref:System.Windows.ContentElement>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="child" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTextAlignment">
      <MemberSignature Language="C#" Value="public static System.Windows.TextAlignment GetTextAlignment (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.TextAlignment GetTextAlignment(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetTextAlignment(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTextAlignment (element As DependencyObject) As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::TextAlignment GetTextAlignment(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTextAlignment : System.Windows.DependencyObject -&gt; System.Windows.TextAlignment" Usage="System.Windows.Controls.TextBlock.GetTextAlignment element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object from which to retrieve the value of the <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> attached property.</param>
        <summary>Returns the value of the <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> attached property for a specified dependency object.</summary>
        <returns>The current value of the <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> attached property on the specified dependency object.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetTextAlignment(System.Windows.DependencyObject,System.Windows.TextAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="textBlock.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A zero-based index specifying the <see cref="T:System.Windows.Media.Visual" /> child to return.  This value must be between 0 and (<see cref="P:System.Windows.Controls.TextBlock.VisualChildrenCount" /> minus 1)</param>
        <summary>Returns the <see cref="T:System.Windows.Media.Visual" /> child at a specified index.</summary>
        <returns>The <see cref="T:System.Windows.Media.Visual" /> child at the specified index.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは<xref:System.Windows.FrameworkElement.GetVisualChild%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is not between 0 and (<see cref="P:System.Windows.Controls.TextBlock.VisualChildrenCount" /> minus 1)</exception>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="textBlock.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">A <see cref="T:System.Windows.Media.PointHitTestParameters" /> object specifying the parameters to hit test for.</param>
        <summary>Returns a <see cref="T:System.Windows.Media.PointHitTestResult" /> for specified <see cref="T:System.Windows.Media.PointHitTestParameters" />.</summary>
        <returns>A <see cref="T:System.Windows.Media.PointHitTestResult" /> for the specified hit test parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、表示される内容の正確なヒット テストを有効にします。  
  
 このメソッドは<xref:System.Windows.UIElement.HitTestCore%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hitTestParameters" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostedElementsCore">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt; HostedElementsCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.IInputElement&gt; HostedElementsCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.HostedElementsCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property HostedElementsCore As IEnumerator(Of IInputElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ HostedElementsCore { System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HostedElementsCore : System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt;" Usage="System.Windows.Controls.TextBlock.HostedElementsCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an enumerator that can be used iterate the elements hosted by this <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>これによってホストされている要素を反復処理できる列挙子<see cref="T:System.Windows.Controls.TextBlock" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Inlines">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.InlineCollection Inlines { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.InlineCollection Inlines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Inlines" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Inlines As InlineCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::InlineCollection ^ Inlines { System::Windows::Documents::InlineCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Inlines : System.Windows.Documents.InlineCollection" Usage="System.Windows.Controls.TextBlock.Inlines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.InlineCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an <see cref="T:System.Windows.Documents.InlineCollection" /> containing the top-level <see cref="T:System.Windows.Documents.Inline" /> elements that comprise the contents of the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>
          <see cref="T:System.Windows.Documents.InlineCollection" />を含む、<see cref="T:System.Windows.Documents.Inline" />要素の内容を構成する、<see cref="T:System.Windows.Controls.TextBlock" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Documents.InlineCollection>列挙またはの内容を操作するには、このプロパティによって返される、<xref:System.Windows.Controls.TextBlock>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputHitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.IInputElement InputHitTestCore (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.IInputElement InputHitTestCore(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.InputHitTestCore(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::IInputElement ^ InputHitTestCore(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="abstract member InputHitTestCore : System.Windows.Point -&gt; System.Windows.IInputElement&#xA;override this.InputHitTestCore : System.Windows.Point -&gt; System.Windows.IInputElement" Usage="textBlock.InputHitTestCore point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">A <see cref="T:System.Windows.Point" />, in the coordinate space of the <see cref="T:System.Windows.Controls.TextBlock" />, for which to return the corresponding <see cref="T:System.Windows.IInputElement" />.</param>
        <summary>Returns the <see cref="T:System.Windows.IInputElement" /> at a specified <see cref="T:System.Windows.Point" /> within the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>The <see cref="T:System.Windows.IInputElement" /> found at the specified Point, or <see langword="null" /> if no such <see cref="T:System.Windows.IInputElement" /> can be found.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabled">
      <MemberSignature Language="C#" Value="public bool IsHyphenationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHyphenationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.IsHyphenationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHyphenationEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHyphenationEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsHyphenationEnabled : bool with get, set" Usage="System.Windows.Controls.TextBlock.IsHyphenationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether automatic hyphenation of words is enabled or disabled.</summary>
        <value>
          <see langword="true" /> その自動を示すために改行と単語のハイフネーションが有効です。それ以外の場合、<see langword="false" />です。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 自動単語ハイフネーション機能により、<xref:System.Windows.Controls.TextBlock>を自動的に中断し、現在のレイアウトの条件に基づいて、単語を単語を区切るです。  これにより、長い単語を 1 行で開始し、その次のまま続行して、揃えのテキスト内の空白のより均等に配分を実現する傾向があります。  単語が分割され、標準の文法規則に従って設定されます。  
  
<a name="dependencyPropertyInfo_IsHyphenationEnabled"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.IsHyphenationEnabledProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.IsHyphenationEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHyphenationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHyphenationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.IsHyphenationEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHyphenationEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHyphenationEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsHyphenationEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.IsHyphenationEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.IsHyphenationEnabled" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineHeight">
      <MemberSignature Language="C#" Value="public double LineHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LineHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LineHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property LineHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double LineHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.LineHeight : double with get, set" Usage="System.Windows.Controls.TextBlock.LineHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the height of each line of content.</summary>
        <value>行の高さ (単位はデバイスに依存しないピクセル数)。範囲は 0.0034 ～ 160000 です。 値<see cref="F:System.Double.NaN" />(属性値に相当"<c>自動</c>")、行の高さを現在のフォント特性から自動的に決定することを示します。 既定値は <see cref="F:System.Double.NaN" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値を変更しても、関連付けられているテキストの高さは変更されません。代わりに、テキストを含む行の高さを変更します。 テキストのサイズを変更するには、使用、<xref:System.Windows.Controls.TextBlock.FontSize%2A>プロパティです。  
  
 このプロパティでは、内の行のレイアウトだけでなく、<xref:System.Windows.Controls.TextBlock>の影響を受けるその<xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A>プロパティです。  
  
 この依存関係プロパティには、添付プロパティの使用方法もあります。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、使い方が`<`*オブジェクト* <xref:System.Windows.Controls.TextBlock.LineHeight%2A?displayProperty=nameWithType> `="`*値*`".../>`ここで、*オブジェクト*オブジェクト要素(通常はフロー要素) 内に含まれる、 <xref:System.Windows.Controls.TextBlock>、および*値*XAML 値で説明したようです。 コードでは、添付プロパティの使用がサポートされている<xref:System.Windows.Controls.TextBlock.GetLineHeight%2A>と<xref:System.Windows.Controls.TextBlock.SetLineHeight%2A>です。 添付プロパティの使用が一般的ではありません。  
  
<a name="xamlAttributeUsage_LineHeight"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object LineHeight="double"/>  
- or -  
<object LineHeight="qualifiedDouble"/>  
- or -  
<object LineHeight="Auto"/>  
```  
  
<a name="xamlValues_LineHeight"></a>   
## <a name="xaml-values"></a>XAML 値  
 *double*  
 <xref:System.Double>  
  
 文字列表現を<xref:System.Double>値以上になると`0.0034`と以下、`160000`です。 修飾されていない値は、デバイス非依存ピクセル単位で計測されます。 明示的に、文字列では、小数点を含める必要がありますされません。  
  
 *qualifiedDouble*  
 A*二重*、上記で説明したように値 (ドキュメントを除く`Auto`) 後に、次の単位指定子の 1 つ: `px`、 `in`、 `cm`、`pt`です。  
  
 `px` (既定値) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px を = =  
  
 `cm` センチメートル; は、します。1cm==(96/2.54) px  
  
 `pt` ポイントです。1pt==(96/72) px  
  
 自動  
 現在のフォント特性から自動的に決定される行の高さが発生します。  プロパティの値に相当<xref:System.Double.NaN?displayProperty=nameWithType>です。  
  
<a name="dependencyPropertyInfo_LineHeight"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.LineHeightProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.LineHeight%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.LineHeight%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> is set to a non-positive value.</exception>
        <altmember cref="P:System.Windows.Documents.FlowDocument.LineHeight" />
      </Docs>
    </Member>
    <Member MemberName="LineHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.LineHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.LineHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategy">
      <MemberSignature Language="C#" Value="public System.Windows.LineStackingStrategy LineStackingStrategy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineStackingStrategy LineStackingStrategy" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LineStackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Property LineStackingStrategy As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineStackingStrategy LineStackingStrategy { System::Windows::LineStackingStrategy get(); void set(System::Windows::LineStackingStrategy value); };" />
      <MemberSignature Language="F#" Value="member this.LineStackingStrategy : System.Windows.LineStackingStrategy with get, set" Usage="System.Windows.Controls.TextBlock.LineStackingStrategy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the mechanism by which a line box is determined for each line of text within the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>内のテキストの行ごとに行ボックスを決定するメカニズム、<see cref="T:System.Windows.Controls.TextBlock" />です。 既定値は <see cref="F:System.Windows.LineStackingStrategy.MaxHeight" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この依存関係プロパティには、添付プロパティの使用方法もあります。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、使い方が`<`*オブジェクト* <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A?displayProperty=nameWithType> `="`*値*`".../>`ここで、*オブジェクト*オブジェクト要素(通常はフロー要素) 内に含まれる、<xref:System.Windows.Controls.TextBlock>と*値*の文字列値が、<xref:System.Windows.LineStackingStrategy>列挙します。 コードでは、添付プロパティの使用がサポートされている<xref:System.Windows.Controls.TextBlock.GetLineStackingStrategy%2A>と<xref:System.Windows.Controls.TextBlock.SetLineStackingStrategy%2A>です。 添付プロパティの使用が一般的ではありません。  
  
<a name="dependencyPropertyInfo_LineStackingStrategy"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.LineStackingStrategyProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 次の例を使用する方法を示しています、<xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A>のテキスト行に行ボックスを作成する方法を決定するプロパティ、<xref:System.Windows.Controls.TextBlock>です。 最初の<xref:System.Windows.Controls.TextBlock>が、<xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A>値<xref:System.Windows.LineStackingStrategy.MaxHeight>、2 番目<xref:System.Windows.Controls.TextBlock>の値を持つ<xref:System.Windows.LineStackingStrategy.BlockLineHeight>します。  
  
 [!code-xaml[FlowMiscSnippets_snip#LineStackingStrategyExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowMiscSnippets_snip/cs/linestackingstrategyexample.xaml#linestackingstrategyexamplewholepage)]  
  
 次の図は、上記のコードの結果を示します。  
  
 ![スクリーン ショット: LineStackingStrategy 値の比較](~/add/media/flow-linestackingstrategy.gif "スクリーン ショット: LineStackingStrategy の比較値")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineStackingStrategyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineStackingStrategyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.LineStackingStrategyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineStackingStrategyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineStackingStrategyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineStackingStrategyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.LineStackingStrategyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Controls.TextBlock.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an enumerator that can iterate the logical children of the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>論理上の子の列挙子。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureOverride (constraint As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size constraint);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="textBlock.MeasureOverride constraint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">A <see cref="T:System.Windows.Size" /> structure specifying any constraints on the size of the <see cref="T:System.Windows.Controls.TextBlock" />.</param>
        <summary>Called to re-measure the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>A <see cref="T:System.Windows.Size" /> structure indicating the new size of the <see cref="T:System.Windows.Controls.TextBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタムのサイズ変更動作を実装するには、このメソッドをオーバーライドします。  
  
 このメソッドは<xref:System.Windows.FrameworkElement.MeasureOverride%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChildDesiredSizeChangedCore">
      <MemberSignature Language="C#" Value="protected virtual void OnChildDesiredSizeChangedCore (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChildDesiredSizeChangedCore(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnChildDesiredSizeChangedCore(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChildDesiredSizeChangedCore (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChildDesiredSizeChangedCore(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member OnChildDesiredSizeChangedCore : System.Windows.UIElement -&gt; unit&#xA;override this.OnChildDesiredSizeChangedCore : System.Windows.UIElement -&gt; unit" Usage="textBlock.OnChildDesiredSizeChangedCore child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">The child <see cref="T:System.Windows.UIElement" /> element whose <see cref="P:System.Windows.UIElement.DesiredSize" /> has changed.</param>
        <summary>Called when a child element deriving from <see cref="T:System.Windows.UIElement" /> changes its <see cref="P:System.Windows.UIElement.DesiredSize" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="textBlock.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates and returns an <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> object for this <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <returns>An <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> object for this <see cref="T:System.Windows.Controls.TextBlock" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは<xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override sealed void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="textBlock.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Arguments for the associated event.</param>
        <summary>Called when the value one or more hosted dependency properties changes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyPropertyChangedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="OnRender">
      <MemberSignature Language="C#" Value="protected override sealed void OnRender (System.Windows.Media.DrawingContext ctx);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRender(class System.Windows.Media.DrawingContext ctx) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.OnRender(System.Windows.Media.DrawingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub OnRender (ctx As DrawingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRender(System::Windows::Media::DrawingContext ^ ctx);" />
      <MemberSignature Language="F#" Value="override this.OnRender : System.Windows.Media.DrawingContext -&gt; unit" Usage="textBlock.OnRender ctx" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctx" Type="System.Windows.Media.DrawingContext" />
      </Parameters>
      <Docs>
        <param name="ctx">The <see cref="T:System.Windows.Media.DrawingContext" /> to render the control on.</param>
        <summary>Renders the contents of a <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、システムによって呼び出される、レイアウトの内容を表示するために、<xref:System.Windows.Controls.TextBlock>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ctx" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Padding { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Thickness with get, set" Usage="System.Windows.Controls.TextBlock.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates the thickness of padding space between the boundaries of the content area, and the content displayed by a <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>A<see cref="T:System.Windows.Thickness" />デバイス非依存ピクセルで、適用するパディングの量を指定する構造体。 既定値は <see cref="F:System.Double.NaN" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.TextBlock.Padding%2A> すべての方向に一様として記述できます (`Padding="10"`)、4 つの値を表す左、として top、right、上下のパディングを個別にまたは (`Padding="5,0,10,20"`)。  
  
 指定されたパディングの厚みが対応するコンテンツ領域のサイズを超える場合 (たとえば、左と右余白の幅の合計がコンテンツ領域の幅を超える場合)、パディングの厚みが比率に応じて、関連するよりも長い値を指定する縮小ディメンションのコンテンツ領域です。  
  
<a name="xamlAttributeUsage_Padding"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object Padding="uniformThickness"/>  
- or -  
<object Padding="independentThickness"/>  
- or -  
<object Padding="qualifiedUniformThickness"/>  
- or -  
<object Padding="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Padding"></a>   
## <a name="xaml-values"></a>XAML 値  
 *uniformThickness*  
 1 つの文字列表現<xref:System.Double>4 つすべての厚みを一様に適用する値。  たとえば、値の`"10"`はの値に相当`"10,10,10,10"`です。  修飾されていない値は、デバイス非依存ピクセル単位で計測されます。 明示的に、文字列では、小数点を含める必要がありますされません。  
  
 *independentThickness*  
 順序付けに 4 つの文字列表現<xref:System.Double>左、上の太さの独立したディメンションに対応する値が右、および下には、この順序で。  4 つの値をコンマで区切る必要があります。スペースは使用できません。  たとえば、「5,10,15,20」結果パディングの 5 ピクセル コンテンツ、コンテンツの上の余白の 10 のピクセル、右の余白の 15 ピクセルおよびコンテンツの下の余白の 20 ピクセルの左側にします。  
  
 *qualifiedUniformThickness*  
 記述された値*uniformThickness*後に、次の単位指定子の 1 つ: `px`、`in`です。  
  
 `px` (既定値) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px を = =  
  
 たとえば、`"1in"`すべての方向に 1 インチの統一されたパディングを提供します。  
  
 *qualifiedIndependentThickness*  
 記述された値*independentThickness*、後に、次の単位指定子の 1 つの独立した各値を持つ: `px`、`in`です。  
  
 `px` (既定値) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` インチです。1 96px を = =  
  
 たとえば、`"1.5in,0.8in,1.5in,0.8in"` のようにします。  単位指定子は、混合または 1 つまたは複数の値からを省略すると場合があります。  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.PaddingProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.Padding%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.Padding%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.PaddingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PaddingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PaddingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PaddingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.PaddingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.Padding" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBaselineOffset">
      <MemberSignature Language="C#" Value="public static void SetBaselineOffset (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBaselineOffset(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetBaselineOffset(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBaselineOffset (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBaselineOffset(System::Windows::DependencyObject ^ element, double value);" />
      <MemberSignature Language="F#" Value="static member SetBaselineOffset : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetBaselineOffset (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object on which to set the value of the <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> property.</param>
        <param name="value">The new value to set the property to.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> attached property on a specified dependency object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetBaselineOffset(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontFamily">
      <MemberSignature Language="C#" Value="public static void SetFontFamily (System.Windows.DependencyObject element, System.Windows.Media.FontFamily value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontFamily(class System.Windows.DependencyObject element, class System.Windows.Media.FontFamily value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontFamily(System.Windows.DependencyObject,System.Windows.Media.FontFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontFamily (element As DependencyObject, value As FontFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontFamily(System::Windows::DependencyObject ^ element, System::Windows::Media::FontFamily ^ value);" />
      <MemberSignature Language="F#" Value="static member SetFontFamily : System.Windows.DependencyObject * System.Windows.Media.FontFamily -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetFontFamily (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.Media.FontFamily" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object on which to set the value of the <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> property.</param>
        <param name="value">The new value to set the property to.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.Controls.TextBlock.FontFamily" /> attached property on a specified dependency object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontFamily(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontSize">
      <MemberSignature Language="C#" Value="public static void SetFontSize (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontSize(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontSize (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontSize(System::Windows::DependencyObject ^ element, double value);" />
      <MemberSignature Language="F#" Value="static member SetFontSize : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetFontSize (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object on which to set the value of the <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> property.</param>
        <param name="value">The new value to set the property to.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.Controls.TextBlock.FontSize" /> attached property on a specified dependency object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontSize(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontStretch">
      <MemberSignature Language="C#" Value="public static void SetFontStretch (System.Windows.DependencyObject element, System.Windows.FontStretch value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontStretch(class System.Windows.DependencyObject element, valuetype System.Windows.FontStretch value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontStretch(System.Windows.DependencyObject,System.Windows.FontStretch)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontStretch (element As DependencyObject, value As FontStretch)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontStretch(System::Windows::DependencyObject ^ element, System::Windows::FontStretch value);" />
      <MemberSignature Language="F#" Value="static member SetFontStretch : System.Windows.DependencyObject * System.Windows.FontStretch -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetFontStretch (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontStretch" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object on which to set the value of the <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> property.</param>
        <param name="value">The new value to set the property to.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.Controls.TextBlock.FontStretch" /> attached property on a specified dependency object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontStretch(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontStyle">
      <MemberSignature Language="C#" Value="public static void SetFontStyle (System.Windows.DependencyObject element, System.Windows.FontStyle value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontStyle(class System.Windows.DependencyObject element, valuetype System.Windows.FontStyle value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontStyle(System.Windows.DependencyObject,System.Windows.FontStyle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontStyle (element As DependencyObject, value As FontStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontStyle(System::Windows::DependencyObject ^ element, System::Windows::FontStyle value);" />
      <MemberSignature Language="F#" Value="static member SetFontStyle : System.Windows.DependencyObject * System.Windows.FontStyle -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetFontStyle (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontStyle" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object on which to set the value of the <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> property.</param>
        <param name="value">The new value to set the property to.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.Controls.TextBlock.FontStyle" /> attached property on a specified dependency object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontStyle(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetFontWeight">
      <MemberSignature Language="C#" Value="public static void SetFontWeight (System.Windows.DependencyObject element, System.Windows.FontWeight value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFontWeight(class System.Windows.DependencyObject element, valuetype System.Windows.FontWeight value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetFontWeight(System.Windows.DependencyObject,System.Windows.FontWeight)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFontWeight (element As DependencyObject, value As FontWeight)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFontWeight(System::Windows::DependencyObject ^ element, System::Windows::FontWeight value);" />
      <MemberSignature Language="F#" Value="static member SetFontWeight : System.Windows.DependencyObject * System.Windows.FontWeight -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetFontWeight (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FontWeight" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object on which to set the value of the <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> property.</param>
        <param name="value">The new value to set the property to.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.Controls.TextBlock.FontWeight" /> attached property on a specified dependency object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetFontWeight(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetForeground">
      <MemberSignature Language="C#" Value="public static void SetForeground (System.Windows.DependencyObject element, System.Windows.Media.Brush value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetForeground(class System.Windows.DependencyObject element, class System.Windows.Media.Brush value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetForeground(System.Windows.DependencyObject,System.Windows.Media.Brush)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetForeground (element As DependencyObject, value As Brush)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetForeground(System::Windows::DependencyObject ^ element, System::Windows::Media::Brush ^ value);" />
      <MemberSignature Language="F#" Value="static member SetForeground : System.Windows.DependencyObject * System.Windows.Media.Brush -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetForeground (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.Media.Brush" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object on which to set the value of the <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> property.</param>
        <param name="value">The new value to set the property to.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.Controls.TextBlock.Foreground" /> attached property on a specified dependency object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetForeground(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetLineHeight">
      <MemberSignature Language="C#" Value="public static void SetLineHeight (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLineHeight(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetLineHeight(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLineHeight (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLineHeight(System::Windows::DependencyObject ^ element, double value);" />
      <MemberSignature Language="F#" Value="static member SetLineHeight : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetLineHeight (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object on which to set the value of the <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> property.</param>
        <param name="value">The new value to set the property to.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> attached property on a specified dependency object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> is set to a non-positive value.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetLineHeight(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetLineStackingStrategy">
      <MemberSignature Language="C#" Value="public static void SetLineStackingStrategy (System.Windows.DependencyObject element, System.Windows.LineStackingStrategy value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLineStackingStrategy(class System.Windows.DependencyObject element, valuetype System.Windows.LineStackingStrategy value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetLineStackingStrategy(System.Windows.DependencyObject,System.Windows.LineStackingStrategy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLineStackingStrategy (element As DependencyObject, value As LineStackingStrategy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLineStackingStrategy(System::Windows::DependencyObject ^ element, System::Windows::LineStackingStrategy value);" />
      <MemberSignature Language="F#" Value="static member SetLineStackingStrategy : System.Windows.DependencyObject * System.Windows.LineStackingStrategy -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetLineStackingStrategy (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.LineStackingStrategy" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object on which to set the value of the <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> property.</param>
        <param name="value">The new value to set the property to.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.Controls.TextBlock.LineStackingStrategy" /> attached property on a specified dependency object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.SetFontSize(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SetTextAlignment">
      <MemberSignature Language="C#" Value="public static void SetTextAlignment (System.Windows.DependencyObject element, System.Windows.TextAlignment value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTextAlignment(class System.Windows.DependencyObject element, valuetype System.Windows.TextAlignment value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.SetTextAlignment(System.Windows.DependencyObject,System.Windows.TextAlignment)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTextAlignment (element As DependencyObject, value As TextAlignment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTextAlignment(System::Windows::DependencyObject ^ element, System::Windows::TextAlignment value);" />
      <MemberSignature Language="F#" Value="static member SetTextAlignment : System.Windows.DependencyObject * System.Windows.TextAlignment -&gt; unit" Usage="System.Windows.Controls.TextBlock.SetTextAlignment (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.TextAlignment" />
      </Parameters>
      <Docs>
        <param name="element">The dependency object on which to set the value of the <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> property.</param>
        <param name="value">The new value to set the property to.</param>
        <summary>Sets the value of the <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> attached property on a specified dependency object.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> is <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Controls.TextBlock.GetTextAlignment(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeBaselineOffset">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeBaselineOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeBaselineOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeBaselineOffset" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeBaselineOffset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeBaselineOffset();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeBaselineOffset : unit -&gt; bool" Usage="textBlock.ShouldSerializeBaselineOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a value that indicates whether the effective value of the <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> property should be serialized during serialization of a <see cref="T:System.Windows.Controls.TextBlock" /> object.</summary>
        <returns>
          <see langword="true" /> if the <see cref="P:System.Windows.Controls.TextBlock.BaselineOffset" /> property should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInlines">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInlines (System.Windows.Markup.XamlDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInlines(class System.Windows.Markup.XamlDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeInlines(System.Windows.Markup.XamlDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInlines (manager As XamlDesignerSerializationManager) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInlines(System::Windows::Markup::XamlDesignerSerializationManager ^ manager);" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInlines : System.Windows.Markup.XamlDesignerSerializationManager -&gt; bool" Usage="textBlock.ShouldSerializeInlines manager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.Windows.Markup.XamlDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">A serialization service manager object for this object.</param>
        <summary>Returns a value that indicates whether the effective value of the <see cref="P:System.Windows.Controls.TextBlock.Inlines" /> property should be serialized during serialization of a <see cref="T:System.Windows.Controls.TextBlock" /> object.</summary>
        <returns>
          <see langword="true" /> if the <see cref="P:System.Windows.Controls.TextBlock.Inlines" /> property should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="manager" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeText">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.ShouldSerializeText" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeText () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeText();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeText : unit -&gt; bool" Usage="textBlock.ShouldSerializeText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a value that indicates whether the effective value of the <see cref="P:System.Windows.Controls.TextBlock.Text" /> property should be serialized during serialization of a <see cref="T:System.Windows.Controls.TextBlock" /> object.</summary>
        <returns>
          <see langword="true" /> if the <see cref="P:System.Windows.Controls.TextBlock.Text" /> property should be serialized; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (serviceType As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ serviceType) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">An object that specifies the type of service object to get.</param>
        <summary>This method supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <returns>A service object of type <paramref name="serviceType" />, or <see langword="null" /> if there is no service object of type <paramref name="serviceType" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.GetRectangles">
      <MemberSignature Language="C#" Value="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt; IContentHost.GetRectangles (System.Windows.ContentElement child);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;valuetype System.Windows.Rect&gt; System.Windows.IContentHost.GetRectangles(class System.Windows.ContentElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#GetRectangles(System.Windows.ContentElement)" />
      <MemberSignature Language="VB.NET" Value="Function GetRectangles (child As ContentElement) As ReadOnlyCollection(Of Rect) Implements IContentHost.GetRectangles" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::Windows::Rect&gt; ^ System.Windows.IContentHost.GetRectangles(System::Windows::ContentElement ^ child) = System::Windows::IContentHost::GetRectangles;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.GetRectangles(System.Windows.ContentElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.ContentElement" />
      </Parameters>
      <Docs>
        <param name="child">A <see cref="T:System.Windows.ContentElement" /> for which to generate and return a collection of bounding rectangles.</param>
        <summary>This method supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.  Use the type-safe <see cref="M:System.Windows.Controls.TextBlock.GetRectanglesCore(System.Windows.ContentElement)" /> method instead.</summary>
        <returns>A read-only collection of bounding rectangles for the specified <see cref="T:System.Windows.ContentElement" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.HostedElements">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt; System.Windows.IContentHost.HostedElements { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.IInputElement&gt; System.Windows.IContentHost.HostedElements" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.System#Windows#IContentHost#HostedElements" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HostedElements As IEnumerator(Of IInputElement) Implements IContentHost.HostedElements" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ System.Windows.IContentHost.HostedElements { System::Collections::Generic::IEnumerator&lt;System::Windows::IInputElement ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Windows.Controls.TextBlock.System.Windows.IContentHost.HostedElements" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IContentHost.HostedElements</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.IInputElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This type or member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.  Use the type-safe <see cref="P:System.Windows.Controls.TextBlock.HostedElementsCore" /> property instead.</summary>
        <value>コンテンツ ホストによってホストされている要素です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.InputHitTest">
      <MemberSignature Language="C#" Value="System.Windows.IInputElement IContentHost.InputHitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Windows.IInputElement System.Windows.IContentHost.InputHitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#InputHitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Windows::IInputElement ^ System.Windows.IContentHost.InputHitTest(System::Windows::Point point) = System::Windows::IContentHost::InputHitTest;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.InputHitTest(System.Windows.Point)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">Mouse coordinates relative to the content host.</param>
        <summary>This method supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.  Use the type-safe <see cref="M:System.Windows.Controls.TextBlock.InputHitTestCore(System.Windows.Point)" /> method instead.</summary>
        <returns>The element that has been hit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.IContentHost.OnChildDesiredSizeChanged">
      <MemberSignature Language="C#" Value="void IContentHost.OnChildDesiredSizeChanged (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.IContentHost.OnChildDesiredSizeChanged(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#IContentHost#OnChildDesiredSizeChanged(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Sub OnChildDesiredSizeChanged (child As UIElement) Implements IContentHost.OnChildDesiredSizeChanged" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.IContentHost.OnChildDesiredSizeChanged(System::Windows::UIElement ^ child) = System::Windows::IContentHost::OnChildDesiredSizeChanged;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IContentHost.OnChildDesiredSizeChanged(System.Windows.UIElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">The child <see cref="T:System.Windows.UIElement" /> element whose <see cref="P:System.Windows.UIElement.DesiredSize" /> has changed.</param>
        <summary>This method supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.  Use the type-safe <see cref="M:System.Windows.Controls.TextBlock.OnChildDesiredSizeChangedCore(System.Windows.UIElement)" /> method instead.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">An object to add as a child.</param>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.TextBlock.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">A string to add to the object.</param>
        <summary>This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Controls.TextBlock.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the text contents of a <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>このテキストの内容<see cref="T:System.Windows.Controls.TextBlock" />です。 テキスト以外のすべてのコンテンツは削除されて、out のプレーン テキスト形式で結果として得られるに注意してください、<see cref="T:System.Windows.Controls.TextBlock" />内容。 既定値は <see cref="F:System.String.Empty" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プレーン テキストで表示するときに、このプロパティを使用して、<xref:System.Windows.Controls.TextBlock>です。  テキストの書式設定する必要がある場合は、追加<xref:System.Windows.Documents.Inline>オブジェクトを<xref:System.Windows.Controls.TextBlock.Inlines%2A>プロパティです。  
  
<a name="dependencyPropertyInfo_Text"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.TextProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.Text%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[SpanSnippets#_TextBlock_Text1XAML](~/samples/snippets/csharp/VS_Snippets_Wpf/SpanSnippets/CSharp/Window1.xaml#_textblock_text1xaml)]  
  
 代わりに、実行テキストの内容がだけに含まれる<xref:System.Windows.Controls.TextBlock>要素タグ。  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.Text%2A>プロパティ プログラムでします。  
  
 [!code-csharp[SpanSnippets#_TextBlock_Text](~/samples/snippets/csharp/VS_Snippets_Wpf/SpanSnippets/CSharp/Window1.xaml.cs#_textblock_text)]
 [!code-vb[SpanSnippets#_TextBlock_Text](~/samples/snippets/visualbasic/VS_Snippets_Wpf/SpanSnippets/visualbasic/window1.xaml.vb#_textblock_text)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlignment As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextAlignment TextAlignment { System::Windows::TextAlignment get(); void set(System::Windows::TextAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.TextAlignment : System.Windows.TextAlignment with get, set" Usage="System.Windows.Controls.TextBlock.TextAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates the horizontal alignment of text content.</summary>
        <value>1 つ、<see cref="T:System.Windows.TextAlignment" />目的の配置を指定する値。 既定値は <see cref="F:System.Windows.TextAlignment.Left" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この依存関係プロパティには、添付プロパティの使用方法もあります。 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、使い方が`<`*オブジェクト* <xref:System.Windows.Controls.TextBlock.TextAlignment%2A?displayProperty=nameWithType> `="`*値*`".../>`ここで、*オブジェクト*オブジェクト要素(通常はフロー要素) 内に含まれる、<xref:System.Windows.Controls.TextBlock>と*値*の文字列値が、<xref:System.Windows.TextAlignment>列挙します。 コードでは、添付プロパティの使用がサポートされている<xref:System.Windows.Controls.TextBlock.GetTextAlignment%2A>と<xref:System.Windows.Controls.TextBlock.SetTextAlignment%2A>です。 添付プロパティの使用が一般的ではありません。  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.TextAlignmentProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.TextAlignment%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.TextAlignment%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.TextAlignment" />
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.TextAlignment" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorations">
      <MemberSignature Language="C#" Value="public System.Windows.TextDecorationCollection TextDecorations { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TextDecorationCollection TextDecorations" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextDecorations" />
      <MemberSignature Language="VB.NET" Value="Public Property TextDecorations As TextDecorationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextDecorationCollection ^ TextDecorations { System::Windows::TextDecorationCollection ^ get(); void set(System::Windows::TextDecorationCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TextDecorations : System.Windows.TextDecorationCollection with get, set" Usage="System.Windows.Controls.TextBlock.TextDecorations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextDecorationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Windows.TextDecorationCollection" /> that contains the effects to apply to the text of a <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>A<see cref="T:System.Windows.TextDecorationCollection" />をこの要素に適用するテキスト装飾を含むコレクション。 既定値は<see langword="null" />(テキスト装飾は適用されません)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.TextDecoration>オブジェクトがテキストに追加できるビジュアルの装飾します。 文字の装飾の 4 つの種類があります: 下線、基準、取り消し線、および上線。  テキスト装飾の詳細については、次を参照してください。[する方法: テキスト装飾を作成する](~/docs/framework/wpf/advanced/how-to-create-a-text-decoration.md)です。  
  
 既定では、このプロパティに設定`null`持たない<xref:System.Windows.TextDecorationCollection>関連付けられています。  文字列の効果を追加する前に、新しい作成<xref:System.Windows.TextDecorationCollection>し、このプロパティに割り当てます。  
  
<a name="dependencyPropertyInfo_TextDecorations"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.TextDecorationsProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.TextDecorations%2A>属性。  
  
 [!code-xaml[InlineSnippets#_TextBlock_TextDecXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InlineSnippets/CSharp/Window1.xaml#_textblock_textdecxaml)]  
  
 この例の表示結果を次の図に示します。  
  
 ![スクリーン ショット: 既定の取り消し線が適用されたテキスト](~/add/media/inline-textdec-strike.png "スクリーン ショット: 既定取り消し線が適用されたテキスト")  
  
 次の図が、どのように<xref:System.Windows.TextDecorations.OverLine%2A>、 <xref:System.Windows.TextDecorations.Baseline%2A>、および<xref:System.Windows.TextDecorations.Underline%2A>、それぞれします。  
  
 ![スクリーン ショット: TextDecorator を上線](~/add/media/inline-textdec-over.png "スクリーン ショット: TextDecorator の上線")  
  
 ![スクリーン ショット: 既定のテキストのベースライン効果](~/add/media/inline-textdec-base.png "スクリーン ショット: 既定のテキストのベースライン効果")  
  
 ![スクリーン ショット: 既定の下線が適用されたテキスト](~/add/media/inline-textdec-under.png "スクリーン ショット: 既定の下線が適用されたテキスト")  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.TextDecorations%2A>プロパティ プログラムでします。  
  
 [!code-csharp[InlineSnippets#_TextBlock_TextDec](~/samples/snippets/csharp/VS_Snippets_Wpf/InlineSnippets/CSharp/Window1.xaml.cs#_textblock_textdec)]
 [!code-vb[InlineSnippets#_TextBlock_TextDec](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InlineSnippets/visualbasic/window1.xaml.vb#_textblock_textdec)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextDecorationsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextDecorationsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextDecorationsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextDecorationsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextDecorationsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextDecorationsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextDecorationsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextDecorationsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.TextDecorations" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffects">
      <MemberSignature Language="C#" Value="public System.Windows.Media.TextEffectCollection TextEffects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.TextEffectCollection TextEffects" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextEffects" />
      <MemberSignature Language="VB.NET" Value="Public Property TextEffects As TextEffectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::TextEffectCollection ^ TextEffects { System::Windows::Media::TextEffectCollection ^ get(); void set(System::Windows::Media::TextEffectCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TextEffects : System.Windows.Media.TextEffectCollection with get, set" Usage="System.Windows.Controls.TextBlock.TextEffects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextEffectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the effects to apply to the text content in this element.</summary>
        <value>A <see cref="T:System.Windows.Media.TextEffectCollection" /> 1 つ以上含む<see cref="T:System.Windows.Media.TextEffect" />のテキストに適用する効果を定義するオブジェクト、<see cref="T:System.Windows.Controls.TextBlock" />です。 既定値は<see langword="null" />(効果は適用されません)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、このプロパティに設定`null`持たない<xref:System.Windows.Media.TextEffectCollection>関連付けられています。  文字列の効果を追加する前に、新しい作成<xref:System.Windows.Media.TextEffectCollection>し、このプロパティに割り当てます。  
  
<a name="dependencyPropertyInfo_TextEffects"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.TextEffectsProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 次の例は、単純なテキスト効果を作成しのテキストに適用する方法を示しています、<xref:System.Windows.Controls.TextBlock>です。  
  
 [!code-csharp[TextElementSnippets#_TextBlock_TextEffects](~/samples/snippets/csharp/VS_Snippets_Wpf/TextElementSnippets/CSharp/Window1.xaml.cs#_textblock_texteffects)]
 [!code-vb[TextElementSnippets#_TextBlock_TextEffects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextElementSnippets/visualbasic/window1.xaml.vb#_textblock_texteffects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextEffectsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextEffectsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextEffectsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextEffectsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextEffectsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextEffectsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextEffectsProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextEffectsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.TextEffects" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.Text" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextTrimming">
      <MemberSignature Language="C#" Value="public System.Windows.TextTrimming TextTrimming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextTrimming TextTrimming" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextTrimming" />
      <MemberSignature Language="VB.NET" Value="Public Property TextTrimming As TextTrimming" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextTrimming TextTrimming { System::Windows::TextTrimming get(); void set(System::Windows::TextTrimming value); };" />
      <MemberSignature Language="F#" Value="member this.TextTrimming : System.Windows.TextTrimming with get, set" Usage="System.Windows.Controls.TextBlock.TextTrimming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextTrimming</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the text trimming behavior to employ when content overflows the content area.</summary>
        <value>1 つ、<see cref="T:System.Windows.TextTrimming" />使用するテキストのトリミング動作を指定する値。 既定値は <see cref="F:System.Windows.TextTrimming.None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextTrimming"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.TextTrimmingProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextTrimmingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextTrimmingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextTrimmingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextTrimmingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextTrimmingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextTrimmingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextTrimmingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextTrimmingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.TextTrimming" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrapping">
      <MemberSignature Language="C#" Value="public System.Windows.TextWrapping TextWrapping { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextWrapping TextWrapping" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.TextWrapping" />
      <MemberSignature Language="VB.NET" Value="Public Property TextWrapping As TextWrapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextWrapping TextWrapping { System::Windows::TextWrapping get(); void set(System::Windows::TextWrapping value); };" />
      <MemberSignature Language="F#" Value="member this.TextWrapping : System.Windows.TextWrapping with get, set" Usage="System.Windows.Controls.TextBlock.TextWrapping" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextWrapping</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets how the <see cref="T:System.Windows.Controls.TextBlock" /> should wrap text.</summary>
        <value>
          <see cref="T:System.Windows.TextWrapping" /> 値のいずれか 1 つ。 既定値は <see cref="F:System.Windows.TextWrapping.NoWrap" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextWrapping"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子のフィールド|<xref:System.Windows.Controls.TextBlock.TextWrappingProperty>|  
|メタデータ プロパティに設定します。 `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.TextWrapping%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.TextWrapping%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextWrappingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextWrappingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextWrappingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.TextBlock.TextWrappingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextWrappingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextWrappingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextWrappingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.TextBlock.TextWrappingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.TextBlock.TextWrapping" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Typography">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Typography Typography { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Typography Typography" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.Typography" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Typography As Typography" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Typography ^ Typography { System::Windows::Documents::Typography ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Typography : System.Windows.Documents.Typography" Usage="System.Windows.Controls.TextBlock.Typography" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Typography</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the currently effective typography variations for the contents of this element.</summary>
        <value>A<see cref="T:System.Windows.Documents.Typography" />現在有効な文字体裁のバリエーションを指定するオブジェクト。 既定の文字体裁の値の一覧は、次を参照してください。<see cref="T:System.Windows.Documents.Typography" />です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.TextBlock.Typography%2A>プロパティにのみ適用されます[!INCLUDE[TLA#tla_opentype](~/includes/tlasharptla-opentype-md.md)]フォントです。 文字体裁のバリエーションには影響しません、バリアント型をサポートしないフォントです。  このトピックの詳細については、次を参照してください。 [WPF のタイポグラフィ](~/docs/framework/wpf/advanced/typography-in-wpf.md)です。  
  
   
  
## Examples  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.Typography%2A>の属性、<xref:System.Windows.Controls.TextBlock>要素。  
  
 [!code-xaml[FlowDocumentSnippets#_TextBlockPropsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml#_textblockpropsxaml)]  
  
 次の例は、設定する方法を示します、<xref:System.Windows.Controls.TextBlock.Typography%2A>プロパティ プログラムでします。  
  
 [!code-csharp[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowDocumentSnippets/CSharp/Window1.xaml.cs#_textblockprops)]
 [!code-vb[FlowDocumentSnippets#_TextBlockProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FlowDocumentSnippets/visualbasic/window1.xaml.vb#_textblockprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.FlowDocument.Typography" />
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.TextBlock.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Controls.TextBlock.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of <see cref="T:System.Windows.Media.Visual" /> children hosted by the <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
        <value>によってホストされている visual の子の数、<see cref="T:System.Windows.Controls.TextBlock" />です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>