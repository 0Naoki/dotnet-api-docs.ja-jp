<Type Name="Page" FullName="System.Web.UI.Page">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b65c377cb9b1c281d1a229b674c0e23ee51b2a3a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36576933" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Page : System.Web.UI.TemplateControl, System.Web.IHttpHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Web.UI.TemplateControl implements class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Page" />
  <TypeSignature Language="VB.NET" Value="Public Class Page&#xA;Inherits TemplateControl&#xA;Implements IHttpHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class Page : System::Web::UI::TemplateControl, System::Web::IHttpHandler" />
  <TypeSignature Language="F#" Value="type Page = class&#xA;    inherit TemplateControl&#xA;    interface IHttpHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.TemplateControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("ASPXCodeBehind")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ASP.NET Web アプリケーションのホストであるサーバーから要求される .aspx ファイル (Web フォーム ページとも呼ばれる) を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page>クラスは、.aspx 拡張子を持つファイルに関連付けられています。 これらのファイルは実行時としてコンパイル<xref:System.Web.UI.Page>オブジェクトし、サーバーのメモリにキャッシュします。  
  
 コードの分離手法を使用して、Web フォーム ページを作成する場合は、このクラスから派生します。 Microsoft Visual Studio などのアプリケーションの迅速な development (RAD) デザイナーは、Web フォーム ページを作成するのに、このモデルを自動的に使用します。  
  
 <xref:System.Web.UI.Page>オブジェクトを実装するものを除く、ページ内のすべてのサーバー コントロールの名前付けコンテナーとして機能、<xref:System.Web.UI.INamingContainer>インターフェイスや、このインターフェイスを実装するコントロールの子コントロールは、します。  
  
 <xref:System.Web.UI.Page>クラスは、コントロールを Web アプリケーションのユーザー インターフェイスとして機能し、そのためのセキュリティで保護されたコードの記述およびアプリケーションのセキュリティ保護が後に確認のベスト プラクティスを調査する必要があります。 これらのトピックの概要については、次を参照してください。[概要の Web アプリケーション セキュリティの脅威](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a)、 [NIB: セキュリティ ポリシーのベスト プラクティス](http://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05)、および[セキュリティの基本概念](~/docs/standard/security/key-security-concepts.md)です。 詳細については、次を参照してください[標準コントロールのセキュリティで保護する](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8)、[する方法: 安全なエラー メッセージを表示](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa)、[する方法: 保護に対してにおけるスクリプトによる攻略 HTML を適用することによって、Web アプリケーション。文字列をエンコード](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b)、および[検証コントロールの概要](http://msdn.microsoft.com/library/3c0e7514-cff2-4bed-936d-ee3f7b740190)です。  
  
   
  
## Examples  
 Visual Studio の Web サイト プロジェクトとソース コードは、このトピックで使用可能な:[ダウンロード](http://go.microsoft.com/fwlink/?LinkId=192425)です。  
  
 次のコード例を示していますが、どのように<xref:System.Web.UI.Page>クラスは、分離コード ページ モデルで使用します。 分離コードのソース ファイルが、ページの基本クラスから継承する部分クラスを宣言することに注意してください。 ベース ページのクラスを指定できます<xref:System.Web.UI.Page>、または別のクラスから派生したできます<xref:System.Web.UI.Page>です。 さらに、部分クラスは、フィールドのメンバーとして定義する必要はありません ページで定義されているコントロールを使用する分離コード ファイルに注意してください。  
  
 [!code-csharp[System.Web.UI.Page_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx.cs#2)]
 [!code-vb[System.Web.UI.Page_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx.vb#2)]  
  
 次のコード例では、上記のコード ビハインド ソース ファイルに対応する .aspx ファイルを示します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx#1)]  
  
 ディレクティブを使用して、使用する必要があります、`Inherits`と`CodeFile`.aspx ファイルに分離コード ファイルをリンクする属性。 この例では、`Inherits`属性を示します、`MyCodeBehind`クラスおよび`CodeFile`属性がクラスを含む言語固有のファイルへのパスを示します。  
  
 次のコード例は、単一ファイル ページ モデルおよびへのアクセス方法を示しています、<xref:System.Web.UI.Page.IsPostBack%2A>プロパティおよび<xref:System.Web.UI.Page.Response%2A>のプロパティ、<xref:System.Web.UI.Page>です。  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/vb/pageexample.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Page();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Page" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のコンス トラクターは、すべてのフィールドを既定値を初期化します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddContentTemplate">
      <MemberSignature Language="C#" Value="protected internal void AddContentTemplate (string templateName, System.Web.UI.ITemplate template);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddContentTemplate(string templateName, class System.Web.UI.ITemplate template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddContentTemplate(System.String,System.Web.UI.ITemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddContentTemplate (templateName As String, template As ITemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddContentTemplate(System::String ^ templateName, System::Web::UI::ITemplate ^ template);" />
      <MemberSignature Language="F#" Value="member this.AddContentTemplate : string * System.Web.UI.ITemplate -&gt; unit" Usage="page.AddContentTemplate (templateName, template)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateName" Type="System.String" />
        <Parameter Name="template" Type="System.Web.UI.ITemplate" />
      </Parameters>
      <Docs>
        <param name="templateName">追加するコンテンツ テンプレートの名前。</param>
        <param name="template">コンテンツ テンプレート</param>
        <summary>現在のページまたは現在のマスター ページがマスター ページを参照している場合に、ページの初期化中に呼び出され、マスター ページに渡すコンテンツのコレクションを (コンテンツ コントロールから) 作成します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">同一の名前を持つ既存のコンテンツ テンプレート。</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOnPreRenderCompleteAsync">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>非同期ページの開始イベント ハンドラー デリゲートおよび終了イベント ハンドラー デリゲートを登録します。</summary>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler);" />
      <MemberSignature Language="F#" Value="member this.AddOnPreRenderCompleteAsync : System.Web.BeginEventHandler * System.Web.EndEventHandler -&gt; unit" Usage="page.AddOnPreRenderCompleteAsync (beginHandler, endHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
      </Parameters>
      <Docs>
        <param name="beginHandler">
          <see cref="T:System.Web.BeginEventHandler" /> メソッドへのデリゲート。</param>
        <param name="endHandler">
          <see cref="T:System.Web.EndEventHandler" /> メソッドへのデリゲート。</param>
        <summary>非同期ページの状態情報を必要としない開始イベント ハンドラー デリゲートおよび終了イベント ハンドラー デリゲートを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A>非同期 Web ページにハンドラーを追加します。  
  
 複数の非同期ハンドラーを登録することができます。ただし、一度に 1 つだけのハンドラーが実行されます。 同時に複数の非同期メソッドを処理する場合は、1 つを使用する必要があります<xref:System.Web.BeginEventHandler>メソッドとそのハンドラーからの複数の非同期操作を起動します。  
  
 間で非同期のハンドラーが呼び出される、<xref:System.Web.UI.Control.PreRender>と<xref:System.Web.UI.Page.PreRenderComplete>イベント。  
  
 最初に、すべて<xref:System.Web.UI.Page>イベント (を通じて、<xref:System.Web.UI.Control.PreRender>イベント) は、実行、および各し、登録されている<xref:System.Web.BeginEventHandler>メソッドが呼び出されます。 ときに、ハンドラーが完了したら、対応する<xref:System.Web.EndEventHandler>メソッドが呼び出されます。 複数の非同期ハンドラーがある場合は、[次へ] のハンドラーが呼び出されます。  
  
 登録済みの非同期イベント ハンドラーが呼び出された後、残りのページのイベントが呼び出されると、以降で、<xref:System.Web.UI.Page.PreRenderComplete>イベント。  
  
   
  
## Examples  
 次のコード例では、非同期要求を使ってのローカル Web サーバーの既定のページの HTML ソース コードを表示する、<xref:System.Web.UI.WebControls.TextBox>コントロール。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="&lt;async&gt;" /> ページ ディレクティブが、<see langword="true" /> に設定されていません。  \- - または -  <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> メソッドは、<see cref="E:System.Web.UI.Control.PreRender" /> イベントの後で呼び出されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> または <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Web.UI.MasterPage" />
        <altmember cref="T:System.Web.UI.WebControls.Content" />
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOnPreRenderCompleteAsync (beginHandler As BeginEventHandler, endHandler As EndEventHandler, state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOnPreRenderCompleteAsync(System::Web::BeginEventHandler ^ beginHandler, System::Web::EndEventHandler ^ endHandler, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddOnPreRenderCompleteAsync : System.Web.BeginEventHandler * System.Web.EndEventHandler * obj -&gt; unit" Usage="page.AddOnPreRenderCompleteAsync (beginHandler, endHandler, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginHandler">
          <see cref="T:System.Web.BeginEventHandler" /> メソッドへのデリゲート。</param>
        <param name="endHandler">
          <see cref="T:System.Web.EndEventHandler" /> メソッドへのデリゲート。</param>
        <param name="state">イベント ハンドラーの状態情報を格納しているオブジェクト。</param>
        <summary>非同期ページの開始イベント ハンドラー デリゲートおよび終了イベント ハンドラー デリゲートを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A>メソッドを非同期の Web ページに状態情報を必要とするハンドラーを追加します。 渡されたオブジェクト、`state`パラメーターで指定されたイベント ハンドラー デリゲートの間で情報を転送するアプリケーションに必要な任意のオブジェクトを指定できます、`beginHandler`と`endHandler`パラメーター。  
  
 複数の非同期ハンドラーを登録することができます。ただし、一度に 1 つだけのハンドラーが実行されます。 同時に複数の非同期メソッドを処理する場合は、1 つを使用する必要があります<xref:System.Web.BeginEventHandler>メソッドとそのハンドラーからの複数の非同期操作を起動します。  
  
 間で非同期のハンドラーが呼び出される、<xref:System.Web.UI.Control.PreRender>と<xref:System.Web.UI.Page.PreRenderComplete>イベント。  
  
 最初に、すべて<xref:System.Web.UI.Page>イベント (を通じて、<xref:System.Web.UI.Control.PreRender>イベント) は、実行、および各し、登録されている<xref:System.Web.BeginEventHandler>メソッドが呼び出されます。 ときに、ハンドラーが完了したら、対応する<xref:System.Web.EndEventHandler>メソッドが呼び出されます。 複数の非同期ハンドラーがある場合は、[次へ] のハンドラーが呼び出されます。  
  
 登録済みの非同期イベント ハンドラーが呼び出された後、残りのページのイベントが呼び出されると、以降で、<xref:System.Web.UI.Page.PreRenderComplete>イベント。  
  
   
  
## Examples  
 次のコード例では、非同期要求を使ってのローカル Web サーバーの既定のページの HTML ソース コードを表示する、<xref:System.Web.UI.WebControls.TextBox>コントロール。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="&lt;async&gt;" /> ページ ディレクティブが、<see langword="true" /> に設定されていません。  \- - または -  <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> メソッドは、<see cref="E:System.Web.UI.Control.PreRender" /> イベントの後で呼び出されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> または <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="AddWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected internal void AddWrappedFileDependencies (object virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddWrappedFileDependencies(object virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddWrappedFileDependencies(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddWrappedFileDependencies (virtualFileDependencies As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddWrappedFileDependencies(System::Object ^ virtualFileDependencies);" />
      <MemberSignature Language="F#" Value="member this.AddWrappedFileDependencies : obj -&gt; unit" Usage="page.AddWrappedFileDependencies virtualFileDependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">ファイル名の一覧を含んでいる <see cref="T:System.Object" />。</param>
        <summary>現在のページを構成している依存ファイルの一覧を追加します。 このメソッドは、ASP.NET ページ フレームワークによって内部的に使用されるメソッドであり、コードから直接呼び出すためのものではありません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.AddWrappedFileDependencies%2A>メソッドは、現在のページを構成するユーザー コントロール ファイルなどのファイルの一覧を追加します。 これらのページのいずれかを変更する場合、ページ全体には、要求時に、[次へ] がコンパイルされます。 このメソッドは、.NET Framework インフラストラクチャをサポートします。独自に作成したコードから直接使用するためのものではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.UI.Page.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の Web 要求に対する <see cref="T:System.Web.HttpApplicationState" /> オブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Web.HttpApplicationState" /> クラス内の現在のデータ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page.Application_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Application_Sample1/CS/applicationcs.aspx#1)]
 [!code-vb[Page.Application_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Application_Sample1/VB/applicationvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpApplicationState" />
      </Docs>
    </Member>
    <Member MemberName="AspCompatBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AspCompatBeginProcessRequest (System.Web.HttpContext context, AsyncCallback cb, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AspCompatBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback cb, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AspCompatBeginProcessRequest (context As HttpContext, cb As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AspCompatBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ cb, System::Object ^ extraData);" />
      <MemberSignature Language="F#" Value="member this.AspCompatBeginProcessRequest : System.Web.HttpContext * AsyncCallback * obj -&gt; IAsyncResult" Usage="page.AspCompatBeginProcessRequest (context, cb, extraData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="cb" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">現在の要求に関する情報が含まれている <see cref="T:System.Web.HttpContext" />。</param>
        <param name="cb">コールバック メソッド。</param>
        <param name="extraData">要求を ASP 要求と同様に処理する必要があるその他のデータ。</param>
        <summary>Active Server Page (ASP) リソースに対する要求を開始します。 このメッソドは、レガシ ASP アプリケーションとの互換性のために用意されています。</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出さないでください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AspCompatEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AspCompatEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AspCompatEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AspCompatEndProcessRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.AspCompatEndProcessRequest : IAsyncResult -&gt; unit" Usage="page.AspCompatEndProcessRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">要求によって生成された ASP ページ。</param>
        <summary>Active Server Page (ASP) リソースに対する要求を終了します。 このメッソドは、レガシ ASP アプリケーションとの互換性のために用意されています。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出さないでください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatMode">
      <MemberSignature Language="C#" Value="protected bool AspCompatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AspCompatMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AspCompatMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AspCompatMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AspCompatMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AspCompatMode : bool with get, set" Usage="System.Web.UI.Page.AspCompatMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページをシングルスレッド アパートメント (STA: Single-Threaded Apartment) スレッドで実行できるかどうかを示す値を設定します。</summary>
        <value>ページが Active Server Pages (ASP) コードをサポートする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定すると`true`、このプロパティは、シングル スレッド アパートメント (STA) スレッドで実行するページを使用します。 これにより、ページから Visual Basic 6.0 で開発したコンポーネントなどの STA コンポーネントを呼び出すことができます。 このプロパティを設定`true`ページから、そのアンマネージ ASP 組み込みオブジェクトへのアクセスを必要とする COM + コンポーネントを呼び出すことができます。 これらは、ASP 経由でアクセスできる`ObjectContext`オブジェクトまたは`OnStartPage`メソッドです。  
  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`aspcompat`属性を`true`.aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncMode">
      <MemberSignature Language="C#" Value="protected bool AsyncMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property AsyncMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AsyncMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncMode : bool with get, set" Usage="System.Web.UI.Page.AsyncMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページが同期して処理されるのか、非同期に処理されるのかを示す値を設定します。</summary>
        <value>ページが非同期に処理される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.AsyncMode%2A>プロパティで設定されて、<xref:System.Web.UI.Page>パーサーのページのコードが生成されたときにします。 使用して、`Async`この値を設定するディレクティブ内の属性です。  
  
 非同期ページがうまくできない場合に、`AspCompat`属性に設定されている`true`または`Transaction`属性が以外の値に設定が`Disabled`ディレクティブにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AsyncPageBeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AsyncPageBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function AsyncPageBeginProcessRequest (context As HttpContext, callback As AsyncCallback, extraData As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IAsyncResult ^ AsyncPageBeginProcessRequest(System::Web::HttpContext ^ context, AsyncCallback ^ callback, System::Object ^ extraData);" />
      <MemberSignature Language="F#" Value="member this.AsyncPageBeginProcessRequest : System.Web.HttpContext * AsyncCallback * obj -&gt; IAsyncResult" Usage="page.AsyncPageBeginProcessRequest (context, callback, extraData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">要求の <see cref="T:System.Web.HttpContext" />。</param>
        <param name="callback">処理がいつ完了するのかを知らせるコールバック メソッド。</param>
        <param name="extraData">非同期メソッドの状態データ。</param>
        <summary>非同期のページ要求の処理を開始します。</summary>
        <returns>非同期の要求を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AsyncPageEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AsyncPageEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageEndProcessRequest(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AsyncPageEndProcessRequest (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AsyncPageEndProcessRequest(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="member this.AsyncPageEndProcessRequest : IAsyncResult -&gt; unit" Usage="page.AsyncPageEndProcessRequest result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">保留中の非同期の要求を参照している <see cref="T:System.IAsyncResult" />。</param>
        <summary>非同期のページ要求の処理を終了します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan AsyncTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AsyncTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan AsyncTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncTimeout : TimeSpan with get, set" Usage="System.Web.UI.Page.AsyncTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>取得または非同期タスクを処理するときに使用されるタイムアウト間隔を示す値を設定します。</summary>
        <value>非同期操作を完了するまでの、許容される時間間隔を格納している <see cref="T:System.TimeSpan" />。 既定の時間間隔は 45 秒です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページの非同期のタイムアウトは、非同期タスクを実行するページが待機する時間を表します。 ほとんどの状況では、コードでこのプロパティを設定しないでください。 ページ非同期のタイムアウト間隔を使用して、設定、または Web 構成ファイルのディレクティブにします。 ページ ディレクティブでは、ページの構成セクションで設定された値が上書きされます。  
  
 使用して、非同期タスクを定義する、<xref:System.Web.UI.PageAsyncTask>クラスし、開始、終了、およびタイムアウトのハンドラーを登録します。 指定された時間間隔で、非同期タスクが完了しない場合、タイムアウトのハンドラーが呼び出されます。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.AsyncTimeout%2A>を持つプロパティ、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>と<xref:System.Web.UI.Page.RegisterAsyncTask%2A>メソッドです。 先頭、末尾、およびタイムアウト ハンドラーの使用に注意してください。 指定されているタスクの割り当て時刻を超えた場合、非同期タスクのような状況を示す例では、人為的な遅延が導入された、<xref:System.Web.UI.Page.AsyncTimeout%2A>プロパティです。 現実のシナリオで非同期タスクは、データベースの呼び出しまたはイメージの生成を実行するために使用可能性がありますなどとタイムアウト ハンドラーは、一定の時間で、タスクは実行されない場合に下げるを提供します。 なお、 <xref:System.Web.UI.Page.AsyncTimeout%2A> page ディレクティブでプロパティを設定します。  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">プロパティは負の値に設定されていました。</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="AutoPostBackControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control AutoPostBackControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control AutoPostBackControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AutoPostBackControl" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoPostBackControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ AutoPostBackControl { System::Web::UI::Control ^ get(); void set(System::Web::UI::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AutoPostBackControl : System.Web.UI.Control with get, set" Usage="System.Web.UI.Page.AutoPostBackControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ポストバックの実行に使用されるページ内のコントロールを取得または設定します。</summary>
        <value>ポストバックの実行に使用されるコントロール。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.UI.Page.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ出力がバッファリングされるかどうかを示す値を設定します。</summary>
        <value>ページ出力がバッファリングされる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、<xref:System.Web.UI.Page.Buffer%2A>属性を`true`.aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.Buffer%2A>設定および取得するプロパティ、<xref:System.Web.HttpResponse.BufferOutput%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.UI.Page.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページが存在するアプリケーションに関連付けられた <see cref="T:System.Web.Caching.Cache" /> オブジェクトを取得します。</summary>
        <value>ページのアプリケーションに関連付けられた <see cref="T:System.Web.Caching.Cache" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションの<xref:System.Web.Caching.Cache>オブジェクトでは、格納および後続の要求に任意のデータを取得することができます。 キャッシュ専用に関連付けられていないページやユーザーのセッションです。 アプリケーションのパフォーマンスを強化するには、主に使用されます。 詳細については、次を参照してください。[アプリケーション データをキャッシュ](http://msdn.microsoft.com/library/206f977d-7860-4d20-bdd5-c3b3d8479f3d)です。 アプリケーションのキャッシュとページ出力キャッシュの違いの詳細については、次を参照してください。 [ASP.NET のキャッシュの概要](http://msdn.microsoft.com/library/5ec28012-4972-4dc3-b3e8-9d20401fe11d)です。  
  
   
  
## Examples  
 次のコード例に 2 つの整数の合計の挿入、<xref:System.Web.Caching.Cache?displayProperty=nameWithType>オブジェクトを使用して、<xref:System.Web.UI.Page.Cache%2A?displayProperty=nameWithType>プロパティです。 さらを使用して値を取得、<xref:System.Web.Caching.Cache.Get%2A?displayProperty=nameWithType>メソッドに書き込むと、 <xref:System.Web.UI.WebControls.Label> Web サーバー コントロールです。  
  
 [!code-csharp[System.Web.Page.Cache_Replacement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/CS/pagecachecs.aspx#1)]
 [!code-vb[System.Web.Page.Cache_Replacement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/VB/pagecachevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="T:System.Web.Caching.Cache" /> のインスタンスが作成されていません。</exception>
        <altmember cref="T:System.Web.Caching.Cache" />
      </Docs>
    </Member>
    <Member MemberName="ClientQueryString">
      <MemberSignature Language="C#" Value="public string ClientQueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientQueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientQueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientQueryString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientQueryString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientQueryString : string" Usage="System.Web.UI.Page.ClientQueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求された URL のクエリ文字列部分を取得します。</summary>
        <value>要求された URL のクエリ文字列部分。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.ClientQueryString%2A>プロパティには、ブラウザーが要求された URL のクエリ文字列の部分が含まれています。 たとえば、要求された url"http://www.contoso.com/default.aspx?id=100"では、<xref:System.Web.UI.Page.ClientQueryString%2A>プロパティが格納されます"id = 100"です。 <xref:System.Web.UI.Page.ClientQueryString%2A>でエンコードされたプロパティを使用して、<xref:System.Web.HttpServerUtility.UrlDecode%2A?displayProperty=nameWithType>クエリ文字列をデコードするメソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.ClientScriptManager ClientScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ClientScriptManager ClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientScript" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientScript As ClientScriptManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ClientScriptManager ^ ClientScript { System::Web::UI::ClientScriptManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientScript : System.Web.UI.ClientScriptManager" Usage="System.Web.UI.Page.ClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientScriptManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スクリプトの管理と登録、およびページへの追加に使用する <see cref="T:System.Web.UI.ClientScriptManager" /> オブジェクトを取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.ClientScriptManager" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.ClientScript%2A>を取得するプロパティ、<xref:System.Web.UI.ClientScriptManager>管理、登録、およびスクリプトを Web ページに追加するために使用できるオブジェクト。 詳細については、<xref:System.Web.UI.ClientScriptManager> クラスを参照してください。  
  
 <xref:System.Web.UI.ClientScriptManager>クラスはで新しく[!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]置き換えます<xref:System.Web.UI.Page>クラスは使用されなくなりましたスクリプトを管理するためのメソッドです。  
  
   
  
## Examples  
 例については、次を参照してください。、<xref:System.Web.UI.ClientScriptManager>クラスの概要に関するトピック。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="ClientTarget">
      <MemberSignature Language="C#" Value="public string ClientTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientTarget" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientTarget As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ClientTarget { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClientTarget : string with get, set" Usage="System.Web.UI.Page.ClientTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブラウザーの自動検出機能をオーバーライドし、ページが特定のブラウザー クライアントでどのように表示されるかを指定できるようにする値を取得または設定します。</summary>
        <value>オーバーライドするブラウザー機能を指定する <see cref="T:System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定しない場合、 <xref:System.Web.UI.Page.ClientTarget%2A> 、プロパティ、<xref:System.Web.HttpBrowserCapabilities>オブジェクトに関連付けられている、<xref:System.Web.UI.Page.Request%2A?displayProperty=nameWithType>プロパティには、クライアント ブラウザーの機能が反映されます。 このプロパティを設定すると、クライアント ブラウザーの検出が無効になり、ページは、指定した値 (エイリアス) に関連付けられているブラウザーの機能を使用します。  
  
 Web サーバー コンピューター上のルート Web.config 構成ファイルには、一般的なユーザー エージェント文字列の代わりに使用できる次の既定のエイリアスを定義します。  
  
-   `uplevel`、Internet Explorer 6.0 と同じブラウザーの機能を指定します。  
  
-   `downlevel`、クライアント スクリプトをサポートしていない古いブラウザーと同じブラウザーの機能を指定します。 このエイリアスを使用して、Web ページがクライアント スクリプトが無効になっているブラウザーでどのように動作する方法を決定することができます。  
  
 このプロパティを使用してプログラムからエイリアスを設定することも設定を使用して宣言できるは、`ClientTarget`ディレクティブの属性です。  
  
 追加のエイリアスを定義することができます、`clientTarget`アプリケーション レベルの Web.config ファイルのセクションです。 詳細については、次を参照してください。 [clientTarget 要素 (ASP.NET 設定スキーマ)](http://msdn.microsoft.com/library/17a0fa6e-a065-49cc-b900-ef73eda6a922)です。  
  
   
  
## Examples  
 次のコード例を定義、`ie302`エイリアス、Web.config ファイルでアプリケーションを構成するために必要なセクションがあります。 このエイリアスを使用して設定できます、<xref:System.Web.UI.Page.ClientTarget%2A>プロパティを`ie302`および Internet Explorer 3.02 ブラウザーの専用のページをカスタマイズします。  
  
```  
<configuration>  
  <system.web>  
   <clientTarget>  
    <add alias="ie302" useragent="Mozilla/2.0 (compatible; MSIE 3.02; Windows NT 3.5)" />  
   </clientTarget>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public int CodePage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CodePage { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int with get, set" Usage="System.Web.UI.Page.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Web.UI.Page" /> のコード ページ ID を設定します。</summary>
        <value>現在の <see cref="T:System.Web.UI.Page" /> のコード ページ ID を表す整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`CodePage`属性を .aspx ファイルで、ディレクティブを使用する値にします。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.UI.Page.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページに関連付けられている <see cref="T:System.Web.HttpResponse" /> オブジェクトの HTTP MIME 型を設定します。</summary>
        <value>現在のページに関連付けられている HTTP MIME 型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`ContentType`属性の .aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal override System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Context : System.Web.HttpContext" Usage="System.Web.UI.Page.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページに関連付けられている <see cref="T:System.Web.HttpContext" /> オブジェクトを取得します。</summary>
        <value>現在のページに関連付けられた情報が格納されている <see cref="T:System.Web.HttpContext" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、要求、応答、セッション、およびアプリケーションに関する情報など、ページの実行コンテキストにプログラムでアクセスを提供します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.Context%2A>プロパティへのアクセスを<xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType>と<xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType>メソッドおよび<xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType>プロパティです。 使用して 3 つのカスタム例外を作成、<xref:System.Web.HttpContext.AddError%2A>メソッドを使用して、<xref:System.Web.HttpContext.AllErrors%2A>プロパティ配列へのこれらの例外を読み込めません。 次に、配列を含むページに書き込み、使用して、<xref:System.Web.HttpContext.ClearError%2A>からすべてのエラーをクリアする方法、<xref:System.Web.UI.Page.Context%2A>プロパティです。  
  
 [!code-csharp[System.Web.UI.Page.Context#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Context/CS/pagecontextcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Context#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Context/VB/pagecontextvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriter">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.UI.HtmlTextWriter CreateHtmlTextWriter (System.IO.TextWriter tw);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Web.UI.HtmlTextWriter CreateHtmlTextWriter(class System.IO.TextWriter tw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateHtmlTextWriter (tw As TextWriter) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriter(System::IO::TextWriter ^ tw);" />
      <MemberSignature Language="F#" Value="abstract member CreateHtmlTextWriter : System.IO.TextWriter -&gt; System.Web.UI.HtmlTextWriter&#xA;override this.CreateHtmlTextWriter : System.IO.TextWriter -&gt; System.Web.UI.HtmlTextWriter" Usage="page.CreateHtmlTextWriter tw" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="tw">
          <see cref="T:System.IO.TextWriter" /> を作成するために使用する <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>ページの内容を表示する <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトを作成します。</summary>
        <returns>
          <see cref="T:System.Web.UI.HtmlTextWriter" />または<see cref="T:System.Web.UI.Html32TextWriter" />です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A>メソッドを作成、<xref:System.IO.TextWriter>を通じて、<xref:System.Web.HttpRequest.Browser%2A>のプロパティ、<xref:System.Web.HttpContext.Request%2A>ページ要求に関連付けられているオブジェクト。 参照を追加することができます、<xref:System.Web.UI.HtmlTextWriter>で、`browserCaps`構成セクション。 上書き、<xref:System.Web.UI.Page.CreateHtmlTextWriter%2A>カスタム検索を実行するメソッド。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> 、カスタムのインスタンスを作成するメソッド<xref:System.Web.UI.HtmlTextWriter>という名前のオブジェクト`MyHtmlTextWriter`です。 <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A>でメソッドがオーバーライドされる、`MyPage`から派生したクラス<xref:System.Web.UI.Page>できるように、`MyHtmlTextWriter`ページが要求されたときに、ASP.NET サーバー コントロールをレンダリングします。 この例はアダプターしないようにすることに注意してください<xref:System.IO.TextWriter>動作します。  
  
 [!code-csharp[Page_CreateHtmlTextWriter#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/CS/page_createhtmltextwriter.cs#2)]
 [!code-vb[Page_CreateHtmlTextWriter#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/VB/page_createhtmltextwriter.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Html32TextWriter" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriterFromType">
      <MemberSignature Language="C#" Value="public static System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType (System.IO.TextWriter tw, Type writerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType(class System.IO.TextWriter tw, class System.Type writerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateHtmlTextWriterFromType (tw As TextWriter, writerType As Type) As HtmlTextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::HtmlTextWriter ^ CreateHtmlTextWriterFromType(System::IO::TextWriter ^ tw, Type ^ writerType);" />
      <MemberSignature Language="F#" Value="static member CreateHtmlTextWriterFromType : System.IO.TextWriter * Type -&gt; System.Web.UI.HtmlTextWriter" Usage="System.Web.UI.Page.CreateHtmlTextWriterFromType (tw, writerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
        <Parameter Name="writerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tw">
          <see cref="T:System.IO.TextWriter" /> を作成するために使用する <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <param name="writerType">作成するテキスト ライターの型。</param>
        <summary>ページの内容を表示するために指定された <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトを作成します。</summary>
        <returns>ページの内容を表示する <see cref="T:System.Web.UI.HtmlTextWriter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ページ アダプターで内部的に使用されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="writerType" /> プロパティが無効な型に設定されています。</exception>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public string Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Culture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Culture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Culture : string with get, set" Usage="System.Web.UI.Page.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページに関連付けられている <see cref="T:System.Threading.Thread" /> オブジェクトのカルチャ ID を設定します。</summary>
        <value>有効なカルチャ ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定、 `Culture` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されたときに、動的に生成されたクラスは、このプロパティの値を設定します。 値を明示的に設定するさらに、<xref:System.Web.UI.Page.Culture%2A>ファイル プログラムから、または Web.config の要素のプロパティです。  
  
 <xref:System.Web.UI.Page.Culture%2A>ヘルプ ページのコンテンツをローカライズするプロパティを使用します。 任意の有効なカルチャ ID を設定することができます。 たとえば、`en-us`カルチャ ID では、アメリカ英語、while にページを設定、`fr`カルチャ ID では、フランス語にページを設定します。 値を設定することもできます。`auto`の優先言語と設定するには、ブラウザーの自動検出を実行します。 言語の自動検出をなど、既定値で修飾できます`auto:en-us`です。  
  
 詳細については、次を参照してください。、<xref:System.Globalization.CultureInfo>クラスの概要です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
      </Docs>
    </Member>
    <Member MemberName="DesignerInitialize">
      <MemberSignature Language="C#" Value="public void DesignerInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DesignerInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DesignerInitialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub DesignerInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DesignerInitialize();" />
      <MemberSignature Language="F#" Value="member this.DesignerInitialize : unit -&gt; unit" Usage="page.DesignerInitialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>RAD デザイナーによって要求される <see cref="T:System.Web.UI.Page" /> クラスのインスタンスの初期化を実行します。 このメソッドは、デザイン時にだけ使用されます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.UserControl.DesignerInitialize" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackMode">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackMode () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackMode();" />
      <MemberSignature Language="F#" Value="abstract member DeterminePostBackMode : unit -&gt; System.Collections.Specialized.NameValueCollection&#xA;override this.DeterminePostBackMode : unit -&gt; System.Collections.Specialized.NameValueCollection" Usage="page.DeterminePostBackMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ポストバックされたデータの <see cref="T:System.Collections.Specialized.NameValueCollection" /> を、POST コマンドまたは GET コマンドのいずれかを使用してページに返します。</summary>
        <returns>フォーム データを格納している <see cref="T:System.Collections.Specialized.NameValueCollection" /> オブジェクト。 ポストバックが POST コマンドを使用する場合は、フォーム情報が <see cref="P:System.Web.UI.Page.Context" /> オブジェクトから返されます。 ポストバックが GET コマンドを使用する場合は、クエリ文字列情報が返されます。 初めてページの要求が行われた場合は、<see langword="null" /> が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.DeterminePostBackMode%2A>メソッドを返します、<xref:System.Collections.Specialized.NameValueCollection>データを格納しているオブジェクトにポスト バックされたページ。 ページが存在するには、ポストバック イベントが発生したかどうかを決定するために使用される VIEWSTATE と EVENTTARGET フィールドが表示されません。 <xref:System.Web.UI.Page.IsPostBack%2A>場合、プロパティが設定、<xref:System.Web.UI.Page.DeterminePostBackMode%2A>メソッドが呼び出されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackModeUnvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackModeUnvalidated" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function DeterminePostBackModeUnvalidated () As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Collections::Specialized::NameValueCollection ^ DeterminePostBackModeUnvalidated();" />
      <MemberSignature Language="F#" Value="abstract member DeterminePostBackModeUnvalidated : unit -&gt; System.Collections.Specialized.NameValueCollection&#xA;override this.DeterminePostBackModeUnvalidated : unit -&gt; System.Collections.Specialized.NameValueCollection" Usage="page.DeterminePostBackModeUnvalidated " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要求に対して ASP.NET 要求の検証を実行せずに、POST また GET コマンドを使用して、ページにポストされたデータの名前と値のコレクションを返します。</summary>
        <returns>未検証のフォーム データを格納するオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、<xref:System.Web.UnvalidatedRequestValues> クラスを参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEventValidation">
      <MemberSignature Language="C#" Value="public virtual bool EnableEventValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableEventValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableEventValidation" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableEventValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableEventValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableEventValidation : bool with get, set" Usage="System.Web.UI.Page.EnableEventValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページがポストバック イベントとコールバック イベントを検証するかどうかを示す値を取得または設定します。</summary>
        <value>ページがポストバック イベントとコールバック イベントを検証する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Web.UI.Page.EnableEventValidation%2A>プロパティに設定されている`true`ASP.NET では、コントロールのイベントがそのコントロールによって表示されたユーザー インターフェイスから送られたことを検証します。 レンダリング時にイベントを登録し、イベントをポストバックまたはコールバックの処理中に検証コントロールです。 たとえば、リスト コントロールには、オプション ポストバックの要求が受信した場合は、オプション番号 4 を指定する場合と、ページが表示されると、1、2、または 3 の番号にはが含まれている場合、ASP.NET には、例外が発生します。 ASP.NET のすべてのイベント ドリブン コントロールは、既定ではこの機能を使用します。  
  
 実行時に、クライアントのコントロールを変更するクライアント スクリプトを記述する場合は、使用する必要があります、 <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> false イベント妥当性確認エラーを回避するためにメソッドです。  
  
> [!IMPORTANT]
>  この機能は、不正なまたは悪意のあるポストバック要求とコールバックのリスクを軽減します。 イベントの検証を無効にしないことを強くお勧めします。  
  
 設定する、<xref:System.Web.UI.Page.EnableEventValidation%2A>プロパティを設定して、`enableEventValidation`ディレクティブの属性または`enableEventValidation`Web.config ファイル内の要素の属性です。 コードでこのプロパティを設定した場合、ページが初期化される前に設定する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ページの初期化後に <see cref="P:System.Web.UI.Page.EnableEventValidation" /> プロパティが設定されました。</exception>
        <altmember cref="M:System.Web.UI.ClientScriptManager.RegisterForEventValidation(System.String)" />
        <altmember cref="T:System.Web.UI.SupportsEventValidationAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public override bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewState : bool with get, set" Usage="System.Web.UI.Page.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のページ要求が終了したとき、ページがそのビューステート、および格納しているサーバー コントロールのビューステートを維持するかどうかを示す値を取得または設定します。</summary>
        <value>ページがビューステートを維持する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビュー ステートを無効にする理由については、次を参照してください。<xref:System.Web.UI.Control.EnableViewState%2A?displayProperty=nameWithType>です。  
  
 場合でも<xref:System.Web.UI.Page.EnableViewState%2A>は`false`ページがポストバックを検出するために、ASP.NET によって使用される非表示のビュー状態フィールドを含めることがあります。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Web.UI.Page.EnableViewState%2A>プロパティを`false`ページが読み込まれるときにします。 ビュー ステートが無効になります、<xref:System.Web.UI.Page>オブジェクト、どちらも、ページのビュー ステート情報もページに含まれるすべてのコントロールを保存することを意味します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/CS/page_enableviewstate.cs#1)]
 [!code-vb[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/VB/page_enableviewstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewStateMac" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewStateMac">
      <MemberSignature Language="C#" Value="public bool EnableViewStateMac { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewStateMac" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewStateMac" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableViewStateMac As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableViewStateMac { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableViewStateMac : bool with get, set" Usage="System.Web.UI.Page.EnableViewStateMac" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページがクライアントからポストバックされたときに、ASP.NET がページのビューステートのメッセージ認証コード (MAC: Message Authentication Code) をチェックする必要があるかどうかを示す値を取得または設定します。</summary>
        <value>ビューステートを MAC でチェックしエンコードする必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビュー ステート MAC は、ページがブラウザーに送信されるときに、ページのビュー状態が保存されている非表示の変数の暗号化されたバージョンです。 このプロパティに設定するときに`true`、暗号化されたビュー ステートがオンになっていることが改ざんされていないクライアントのことを確認します。  
  
 コードでこのプロパティを設定できません。 設定、`EnableViewStateMac`属性の .aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
> [!IMPORTANT]
>  この属性設定しないで`false`実稼働 Web サイトで、アプリケーションまたはページがビュー ステートを使用していない場合でもです。 により、MAC のビューステートは、ビュー ステートに加えその他の ASP.NET 機能のセキュリティを確保します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.EnableViewState" />
      </Docs>
    </Member>
    <Member MemberName="ErrorPage">
      <MemberSignature Language="C#" Value="public string ErrorPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ErrorPage" />
      <MemberSignature Language="VB.NET" Value="Public Property ErrorPage As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ErrorPage { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ErrorPage : string with get, set" Usage="System.Web.UI.Page.ErrorPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>処理されていないページ例外が発生した場合に、要求側のブラウザーがリダイレクトされる対象のエラー ページを取得または設定します。</summary>
        <value>ブラウザーがリダイレクトされる対象のエラー ページ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page_ErrorPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_ErrorPage/CS/page_errorpage.cs.aspx#1)]
 [!code-vb[Page_ErrorPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_ErrorPage/VB/page_errorpage.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteRegisteredAsyncTasks">
      <MemberSignature Language="C#" Value="public void ExecuteRegisteredAsyncTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteRegisteredAsyncTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecuteRegisteredAsyncTasks ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecuteRegisteredAsyncTasks();" />
      <MemberSignature Language="F#" Value="member this.ExecuteRegisteredAsyncTasks : unit -&gt; unit" Usage="page.ExecuteRegisteredAsyncTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>非同期操作の実行を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、非同期タスクを定義する、<xref:System.Web.UI.PageAsyncTask>クラスです。 タスクが定義され、ページを使用して、登録した後、 <xref:System.Web.UI.Page.RegisterAsyncTask%2A> 、メソッド、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>非同期タスクを開始するメソッドを呼び出すことができます。  
  
 <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>メソッドが自動的に呼び出される非同期以外のページ、ページときの処理に存在する場合、非同期タスクは、登録されているいずれかの時点は呼び出されます。 この自動呼び出し<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>直前に発生する、<xref:System.Web.UI.Page.PreRenderComplete>イベント。 呼び出す、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>タスクをこのメソッドが自動的に呼び出されないときに起動するためのメソッドです。 ただし、非同期タスクがのみ 1 回も実行される<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>も複数回呼び出すことができます。  
  
 <xref:System.Web.UI.Page.AsyncTimeout%2A>プロパティはリセットを呼び出すたびに、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>メソッドです。 最後の値、<xref:System.Web.UI.Page.AsyncTimeout%2A>を呼び出す前に、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>メソッドが優先されます。 非同期タスクが受け取る場合よりも多く<xref:System.Web.UI.Page.AsyncTimeout%2A>、後続のタスクを中に呼び出される<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>呼び出しがすぐにタイムアウトします。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.AsyncTimeout%2A>を持つプロパティ、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>と<xref:System.Web.UI.Page.RegisterAsyncTask%2A>メソッドです。 先頭、末尾、およびタイムアウト ハンドラーの使用に注意してください。 指定されているタスクの割り当て時刻を超えた場合、非同期タスクのような状況を示す例では、人為的な遅延が導入された、<xref:System.Web.UI.Page.AsyncTimeout%2A>プロパティです。 現実のシナリオで非同期タスクは、データベースの呼び出しまたはイメージの生成を実行するために使用可能性がありますなどとタイムアウト ハンドラーは、一定の時間で、タスクは実行されない場合に下げるを提供します。  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">非同期操作での例外です。</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="FileDependencies">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList FileDependencies { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList FileDependencies" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.FileDependencies" />
      <MemberSignature Language="VB.NET" Value="Protected Property FileDependencies As ArrayList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::ArrayList ^ FileDependencies {  void set(System::Collections::ArrayList ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FileDependencies : System.Collections.ArrayList" Usage="System.Web.UI.Page.FileDependencies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is HttpResponse.AddFileDependencies. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Web.HttpResponse" /> オブジェクトが依存しているファイルの配列を設定します。</summary>
        <value>現在の <see cref="T:System.Web.HttpResponse" /> オブジェクトが依存しているファイルの配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは非推奨とされました。 使用して、<xref:System.Web.HttpResponse.AddFileDependencies%2A>メソッドまたは<xref:System.Web.HttpResponse.AddFileDependency%2A>のメソッド、<xref:System.Web.HttpResponse>クラスの代わりにします。  
  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`FileDependencies`属性を`true`.aspx ファイルで、ディレクティブを使用します。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public override System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberSignature Language="F#" Value="override this.FindControl : string -&gt; System.Web.UI.Control" Usage="page.FindControl id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">検索されるコントロールの識別子。</param>
        <summary>指定した識別子を使用して、サーバー コントロールについてページの名前付けコンテナーを検索します。</summary>
        <returns>指定したコントロール。指定したコントロールがない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.FindControl%2A>メソッドは、コントロールにアクセスするために使用できますが<xref:System.Web.UI.Control.ID%2A>デザイン時に使用できません。 メソッドのみ、ページの即時更新サブスクリプションまたは最上位レベル、コンテナーを検索です。これは、ページに含まれている名前付けコンテナーでのコントロールの再帰的に検索をしません。 下位の名前付けコンテナー内のコントロールにアクセスするには、呼び出し、`FindControl`そのコンテナーのメソッドです。  
  
   
  
## Examples  
 次のコード例を使用する方法を示しています、<xref:System.Web.UI.Page.FindControl%2A>テンプレート内部のコントロールを検索します。 この例では 2 つ<xref:System.Web.UI.WebControls.Repeater>コントロールが定義されます。 キャッチするさまざまな方法を示していますそれぞれ、<xref:System.Web.UI.WebControls.LinkButton.Click>のイベント、<xref:System.Web.UI.WebControls.LinkButton>リピータ項目テンプレートの内部です。  
  
 [!code-aspx-csharp[System.Web.UI.Page_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/cs/pagefindcontrolcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/vb/pagefindcontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlForm Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As HtmlForm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlForm ^ Form { System::Web::UI::HtmlControls::HtmlForm ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Web.UI.HtmlControls.HtmlForm" Usage="System.Web.UI.Page.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの HTML フォームを取得します。</summary>
        <value>ページと関連付けられた <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.Form%2A>プロパティ、メソッドとプロパティのアクセスを<xref:System.Web.UI.HtmlControls.HtmlForm>ページ コントロール階層の基本であるオブジェクト。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlForm" />
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected override void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FrameworkInitialize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub FrameworkInitialize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void FrameworkInitialize();" />
      <MemberSignature Language="F#" Value="override this.FrameworkInitialize : unit -&gt; unit" Usage="page.FrameworkInitialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページの生成中に、ページの宣言の性質に基づいてコントロール ツリーを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.FrameworkInitialize%2A>メソッドの初期化、<xref:System.Web.UI.Page>オブジェクトし、ページの宣言型の特性に基づきコントロール ツリーを作成します。 <xref:System.Web.UI.Page.FrameworkInitialize%2A>メソッドは、ページの解析中のコード生成や、<xref:System.Web.UI.Page>宣言型のページのクラスです。 通常、このメソッドをオーバーライドする必要が上にありません必要があります。 をオーバーライドする場合、基本クラスの呼び出しを必ず<xref:System.Web.UI.Page.FrameworkInitialize%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      </Docs>
    </Member>
    <Member MemberName="GetDataItem">
      <MemberSignature Language="C#" Value="public object GetDataItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetDataItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetDataItem" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDataItem () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetDataItem();" />
      <MemberSignature Language="F#" Value="member this.GetDataItem : unit -&gt; obj" Usage="page.GetDataItem " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>データ バインディング コンテキスト スタックの最上部のデータ項目を取得します。</summary>
        <returns>データ バインディング コンテキスト スタックの最上部のオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">ページのデータ バインディング コンテキストがありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientEvent">
      <MemberSignature Language="C#" Value="public string GetPostBackClientEvent (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientEvent(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientEvent(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientEvent(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientEvent : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackClientEvent (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">クライアント イベントのポストバックを受信するサーバー コントロール。</param>
        <param name="argument">
          <see cref="T:System.String" /> に渡される<see cref="M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)" />。</param>
        <summary>指定されたイベント引数を使用して指定したコントロールのサーバーにポストバックするクライアント イベントで使用できる参照を取得します。</summary>
        <returns>クライアント イベントを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照してください、<xref:System.Web.UI.ClientScriptManager>代替方法についてはこのメンバーのクラスです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.Button.OnClientClick" />
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackClientHyperlink(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackClientHyperlink : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackClientHyperlink (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackClientHyperlink. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">ポストバックを処理するサーバー コントロール。</param>
        <param name="argument">サーバー コントロールに渡されたパラメーター。</param>
        <summary>
          <see langword="javascript:" /> を参照の先頭に追加した上で参照を取得します。この参照をクライアント イベントで使用して、指定したコントロールを、指定したイベント引数を使用してサーバーにポストバックできます。</summary>
        <returns>対象のコントロールの ID とイベント引数を保持しているポストバック関数に対する JavaScript 呼び出しを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照してください、<xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A>のこのメンバーを使用します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPostBackEventReference">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>クライアント イベントで使用できる、サーバーにポストバックするための文字列を返します。 このメソッドの使用は非推奨とされました。 代わりに <see cref="Overload:System.Web.UI.ClientScriptManager.GetPostBackEventReference" /> クラスの <see cref="T:System.Web.UI.ClientScriptManager" /> メソッドを使用してください。</summary>
        <altmember cref="T:System.Web.UI.ClientScriptManager" />
        <altmember cref="M:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control -&gt; string" Usage="page.GetPostBackEventReference control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">サーバー上でポストバックを処理するサーバー コントロール。</param>
        <summary>クライアント イベントで使用できる、サーバーにポストバックするための文字列を返します。 この参照文字列は、指定した <see cref="T:System.Web.UI.Control" /> オブジェクトによって定義されます。</summary>
        <returns>クライアントでスクリプトとして扱われた場合に、ポストバックを初期化する文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの使用は非推奨とされました。 代わりに <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> クラスの <xref:System.Web.UI.ClientScriptManager> メソッドを使用してください。  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#2)]
 [!code-vb[Page_GetPostBackEventReference#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPostBackEventReference(System::Web::UI::Control ^ control, System::String ^ argument);" />
      <MemberSignature Language="F#" Value="member this.GetPostBackEventReference : System.Web.UI.Control * string -&gt; string" Usage="page.GetPostBackEventReference (control, argument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">ポストバックを処理するサーバー コントロール。</param>
        <param name="argument">サーバー コントロールに渡されたパラメーター。</param>
        <summary>クライアント イベントで使用できる、サーバーにポストバックするための文字列を返します。 この参照文字列は、ポストバックと追加のイベント情報の文字列引数を処理する、指定したコントロールによって定義されます。</summary>
        <returns>クライアントでスクリプトとして扱われた場合に、ポストバックを初期化する文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの使用は非推奨とされました。 代わりに <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> クラスの <xref:System.Web.UI.ClientScriptManager> メソッドを使用してください。  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#1)]
 [!code-vb[Page_GetPostBackEventReference#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetTypeHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetTypeHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetTypeHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetTypeHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeHashCode : unit -&gt; int&#xA;override this.GetTypeHashCode : unit -&gt; int" Usage="page.GetTypeHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>実行時に生成された <see cref="T:System.Web.UI.Page" /> オブジェクトによって生成されるハッシュ コードを取得します。 このハッシュ コードは、<see cref="T:System.Web.UI.Page" /> オブジェクトのコントロール階層に固有のハッシュ コードです。</summary>
        <returns>実行時に生成されたハッシュ コード。 既定値は 0 です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドをオーバーライドしないでください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValidators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection GetValidators (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ValidatorCollection GetValidators(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetValidators(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValidators (validationGroup As String) As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::ValidatorCollection ^ GetValidators(System::String ^ validationGroup);" />
      <MemberSignature Language="F#" Value="member this.GetValidators : string -&gt; System.Web.UI.ValidatorCollection" Usage="page.GetValidators validationGroup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">既定の検証グループを返す検証グループまたは <see langword="null" />。</param>
        <summary>指定した検証グループの検証コントロールのコレクションを返します。</summary>
        <returns>指定した検証グループの検証コントロールを格納している <see cref="T:System.Web.UI.ValidatorCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.GetValidators%2A>メソッドは、特定の検証グループに関連付けられているすべての検証オブジェクトを取得します。 既定の検証グループを返すことができます (せずコントロールに関連付けられているすべての検証コントロール、`ValidationGroup`プロパティ セット) を設定して、`validationGroup`パラメーターを`null`です。  
  
 検証グループのメンバーを検証するには、コレクションと呼び出しを列挙することができます、<xref:System.Web.UI.IValidator.Validate%2A>各検証メソッドが返されます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.GetValidators%2A>を既定の検証グループを返すメソッド。  
  
 [!code-csharp[PageGetValidators#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageGetValidators/CS/pagegetvalidatorscs.aspx#1)]
 [!code-vb[PageGetValidators#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageGetValidators/VB/pagegetvalidatorsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.Validate(System.String)" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
      </Docs>
    </Member>
    <Member MemberName="GetWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected object GetWrappedFileDependencies (string[] virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetWrappedFileDependencies(string[] virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetWrappedFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetWrappedFileDependencies (virtualFileDependencies As String()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetWrappedFileDependencies(cli::array &lt;System::String ^&gt; ^ virtualFileDependencies);" />
      <MemberSignature Language="F#" Value="member this.GetWrappedFileDependencies : string[] -&gt; obj" Usage="page.GetWrappedFileDependencies virtualFileDependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">仮想ファイルの場所の文字列配列。</param>
        <summary>仮想ファイルの場所の一覧に対応する物理ファイル名の一覧を返します。</summary>
        <returns>物理ファイルの場所の一覧を格納しているオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.GetWrappedFileDependencies%2A>メソッドは、現在のページを構成するユーザー コントロール ファイルなどのファイルの一覧を取得します。 これらのページのいずれかが変更された場合、ページ全体には、要求時に、[次へ] がコンパイルされます。 このメソッドをオーバーライドしないでください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlHead Header { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlHead Header" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Header" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Header As HtmlHead" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::HtmlControls::HtmlHead ^ Header { System::Web::UI::HtmlControls::HtmlHead ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Header : System.Web.UI.HtmlControls.HtmlHead" Usage="System.Web.UI.Page.Header" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlHead</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの宣言で <see langword="head" /> 要素が <see langword="runat=server" /> を使用して定義されている場合に、ドキュメントのヘッダーを取得します。</summary>
        <value>ページ ヘッダーを格納している <see cref="T:System.Web.UI.HtmlControls.HtmlHead" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Header%2A>プロパティへの参照を取得する、<xref:System.Web.UI.HtmlControls.HtmlHead>オブジェクト、ページのドキュメントのヘッダー情報の設定を使用することです。 <xref:System.Web.UI.HtmlControls.HtmlHead>スタイル シート、スタイル ルール、タイトル、およびメタデータをなどの情報を追加することができます、`head`要素。  
  
> [!NOTE]
>  メソッドを使用してプログラムからスタイルを追加する、<xref:System.Web.UI.IStyleSheet>非同期ポストバック中のインターフェイスはサポートされていません。 Web ページに AJAX 機能を追加すると、非同期ポストバックはページ全体を更新することがなく、ページの領域を更新します。 詳細については、次を参照してください。 [Microsoft Ajax 概要](http://msdn.microsoft.com/library/be84d9b3-b7cd-47d7-8494-be4abfaad9cb)です。  
  
   
  
## Examples  
 次のコード例は、アクセスする方法を示します、<xref:System.Web.UI.HtmlControls.HtmlHead>を使用したプログラムの制御、<xref:System.Web.UI.Page.Header%2A>プロパティです。 A`title`要素および`style`に要素を追加、`head`ページの要素。  
  
 [!code-aspx-csharp[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/CS/htmlheadclasscs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/VB/htmlheadclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlHead" />
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlLink" />
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public override string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ID : string with get, set" Usage="System.Web.UI.Page.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Page" /> クラスの特定のインスタンスの識別子を取得または設定します。</summary>
        <value>
          <see cref="T:System.Web.UI.Page" /> クラスのインスタンスの識別子。 既定値は '_Page' です。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="public virtual char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char IdSeparator { char get(); };" />
      <MemberSignature Language="F#" Value="member this.IdSeparator : char" Usage="System.Web.UI.Page.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの特定のコントロールに対して一意の ID を作成するときに、コントロールの ID を区別するために使用する文字を取得します。</summary>
        <value>コントロールの ID を区別するために使用する文字。 既定値は、ページをレンダリングする <see cref="T:System.Web.UI.Adapters.PageAdapter" /> インスタンスによって設定されます。 <see cref="P:System.Web.UI.Page.IdSeparator" /> はサーバー側のフィールドなので、変更しないでください。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.Page.ID" />
      </Docs>
    </Member>
    <Member MemberName="InitComplete">
      <MemberSignature Language="C#" Value="public event EventHandler InitComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InitComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.InitComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InitComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ InitComplete;" />
      <MemberSignature Language="F#" Value="member this.InitComplete : EventHandler " Usage="member this.InitComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの初期化が完了したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.InitComplete>イベントは、ページの初期化段階の最後に呼び出されます。 ページのライフ サイクルのこの段階で宣言されたすべて、ページ上のコントロールが初期化されるが、ページの状態はまだ設定します。 サーバー コントロールにアクセスできますが、それらがまだ含まれていませんユーザーから返される情報には。  
  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="InitializeCulture">
      <MemberSignature Language="C#" Value="protected virtual void InitializeCulture ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeCulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitializeCulture" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeCulture ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeCulture();" />
      <MemberSignature Language="F#" Value="abstract member InitializeCulture : unit -&gt; unit&#xA;override this.InitializeCulture : unit -&gt; unit" Usage="page.InitializeCulture " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページの現在のスレッドの <see cref="P:System.Web.UI.Page.Culture" /> と <see cref="P:System.Web.UI.Page.UICulture" /> を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.InitializeCulture%2A>メソッドにはコード ロジックは含まれません。 機能を拡張する開発者の制御、<xref:System.Web.UI.Page>クラスをオーバーライドして、<xref:System.Web.UI.Page.InitializeCulture%2A>初期化するメソッドを<xref:System.Web.UI.Page.Culture%2A>と<xref:System.Web.UI.Page.UICulture%2A>ページの情報です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.Web.UI.Page.FrameworkInitialize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InitOutputCache">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のページ要求の出力キャッシュを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはコードから直接使用するためのものではありません。 を有効にして、ページの出力キャッシュを操作するには、これらのアプローチのいずれかを使用します。  
  
-   .Aspx ファイルで宣言によって、ディレクティブを使用してオプションを設定します。  
  
-   メソッドとプロパティの使用、<xref:System.Web.HttpCachePolicy>によって公開される、クラス、`Response.Cache`ページのコード内のオブジェクト。  
  
 詳細については、次を参照してください。 [ASP.NET ページのキャッシュ](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected internal virtual void InitOutputCache (System.Web.UI.OutputCacheParameters cacheSettings);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitOutputCache(class System.Web.UI.OutputCacheParameters cacheSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Web.UI.OutputCacheParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub InitOutputCache (cacheSettings As OutputCacheParameters)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void InitOutputCache(System::Web::UI::OutputCacheParameters ^ cacheSettings);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : System.Web.UI.OutputCacheParameters -&gt; unit&#xA;override this.InitOutputCache : System.Web.UI.OutputCacheParameters -&gt; unit" Usage="page.InitOutputCache cacheSettings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheSettings" Type="System.Web.UI.OutputCacheParameters" />
      </Parameters>
      <Docs>
        <param name="cacheSettings">キャッシュの設定を格納している <see cref="T:System.Web.UI.OutputCacheParameters" />。</param>
        <summary>現在のページ要求の出力キャッシュを <see cref="T:System.Web.UI.OutputCacheParameters" /> オブジェクトに基づいて初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す必要はありません。 を有効にして、ページの出力キャッシュを操作するには、.aspx ファイルまたはメソッドとプロパティのいずれか、ディレクティブを使用、<xref:System.Web.HttpCachePolicy>クラスです。 後者はを通してアクセス`Response.Cache`ページのコード宣言ブロックまたは分離コード ファイル内の構文。 詳細については、次を参照してください。 [ASP.NET ページのキャッシュ](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">キャッシュのプロファイルが見つかりませんでした。  \- - または -  存在しないディレクティブまたは存在しない構成設定プロファイル属性です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">出力キャッシュ設定の位置が無効です。</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : int * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit&#xA;override this.InitOutputCache : int * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit" Usage="page.InitOutputCache (duration, varyByHeader, varyByCustom, location, varyByParam)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">出力キャッシュに格納されているオブジェクトが有効である時間。</param>
        <param name="varyByHeader">出力キャッシュの内容の変更に使用されるヘッダーのセミコロン区切りのリスト。</param>
        <param name="varyByCustom">
          <see langword="Vary" /> HTTP ヘッダー。</param>
        <param name="location">
          <see cref="T:System.Web.UI.OutputCacheLocation" /> 値のいずれか 1 つ。</param>
        <param name="varyByParam">出力キャッシュの内容の変更に使用され、GET メソッドまたは POST メソッドが受け取るパラメーターのセミコロン区切りのリスト。</param>
        <summary>現在のページ要求の出力キャッシュを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す必要はありません。 を有効にして、ページの出力キャッシュを操作するには、.aspx ファイルまたはメソッドとプロパティのいずれか、ディレクティブを使用、<xref:System.Web.HttpCachePolicy>クラスです。 後者はを通してアクセス`Response.Cache`ページのコードの構文。 詳細については、次を参照してください。 [ASP.NET ページのキャッシュ](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="location" /> に無効な値が指定されています。</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitOutputCache (duration As Integer, varyByContentEncoding As String, varyByHeader As String, varyByCustom As String, location As OutputCacheLocation, varyByParam As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitOutputCache(int duration, System::String ^ varyByContentEncoding, System::String ^ varyByHeader, System::String ^ varyByCustom, System::Web::UI::OutputCacheLocation location, System::String ^ varyByParam);" />
      <MemberSignature Language="F#" Value="abstract member InitOutputCache : int * string * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit&#xA;override this.InitOutputCache : int * string * string * string * System.Web.UI.OutputCacheLocation * string -&gt; unit" Usage="page.InitOutputCache (duration, varyByContentEncoding, varyByHeader, varyByCustom, location, varyByParam)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByContentEncoding" Type="System.String" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">出力キャッシュに格納されているオブジェクトが有効である時間。</param>
        <param name="varyByContentEncoding">出力キャッシュの内容の変更に使用される文字セット (コンテンツ エンコーディング) のセミコロン区切りのリスト。</param>
        <param name="varyByHeader">出力キャッシュの内容の変更に使用されるヘッダーのセミコロン区切りのリスト。</param>
        <param name="varyByCustom">
          <see langword="Vary" /> HTTP ヘッダー。</param>
        <param name="location">
          <see cref="T:System.Web.UI.OutputCacheLocation" /> 値のいずれか 1 つ。</param>
        <param name="varyByParam">出力キャッシュの内容の変更に使用され、GET メソッドまたは POST メソッドが受け取るパラメーターのセミコロン区切りのリスト。</param>
        <summary>現在のページ要求の出力キャッシュを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す必要はありません。 を有効にして、ページの出力キャッシュを操作するには、.aspx ファイル、またはメソッドとプロパティのいずれか、ディレクティブを使用、<xref:System.Web.HttpCachePolicy>クラスです。 後者はを通してアクセス`Response.Cache`ページのコードの構文。 詳細については、次を参照してください。 [ASP.NET ページのキャッシュ](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="location" /> に無効な値が指定されています。</exception>
        <altmember cref="T:System.Web.HttpCachePolicy" />
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.Web.UI.Page.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページが非同期に処理されるかどうかを示す値を取得します。</summary>
        <value>ページが非同期モードである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、 <xref:System.Web.UI.Page.IsAsync%2A> Web ページが非同期モードで実行されているかどうかを決定するプロパティです。 この情報は、ページのコントロールまたはコード ページが非同期かに応じて、動作を変更する必要がある場合に便利です。 非同期プログラミングの詳細については、次を参照してください。[非同期操作](~/docs/framework/data/adonet/sql/asynchronous-operations.md)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCallback">
      <MemberSignature Language="C#" Value="public bool IsCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCallback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCallback { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCallback : bool" Usage="System.Web.UI.Page.IsCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ要求がコールバックの結果であるかどうかを示す値を取得します。</summary>
        <value>ページ要求がコールバックの結果である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。[ポストバックなしクライアント コールバックの実装](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsClientScriptBlockRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsClientScriptBlockRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsClientScriptBlockRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsClientScriptBlockRegistered : string -&gt; bool" Usage="page.IsClientScriptBlockRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsClientScriptBlockRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">検索対象のクライアント スクリプトの文字列キー。</param>
        <summary>指定したキーを持つクライアント スクリプト ブロックがページに登録されているかどうかを判断します。</summary>
        <returns>スクリプト ブロックが登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す前に呼び出します<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A?displayProperty=nameWithType>をクライアント側スクリプトを不必要にまとめることを回避します。 これは、スクリプトを作成するサーバーのリソースの消費量が必要な場合に特に重要です。  
  
 <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> メソッドの使用は非推奨とされました。 使用して、<xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスです。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>メソッドと組み合わせて、<xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>メソッドです。 コード宣言ブロックで記述された ECMAScript が既に登録されていない場合、によって決定される<xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>、<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>呼び出しが行われます。  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsCrossPagePostBack">
      <MemberSignature Language="C#" Value="public bool IsCrossPagePostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCrossPagePostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCrossPagePostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCrossPagePostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCrossPagePostBack : bool" Usage="System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページが、ページ間のポストバックに関与しているかどうかを示す値を取得します。</summary>
        <value>ページが、ページ間の要求に関与している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET では、別の 1 つのページからコントロールを転送するための 2 つのメカニズムを提供します。 使用することができます、<xref:System.Web.HttpServerUtility.Transfer%2A>ページ、または間での処理を転送する方法は、ページの URL を割り当てることでページ間の要求をすることができます、<xref:System.Web.UI.WebControls.IButtonControl.PostBackUrl%2A>を実装するボタン コントロールのプロパティ、<xref:System.Web.UI.WebControls.IButtonControl>インターフェイスです。  
  
 どちらの場合、<xref:System.Web.UI.Page.PreviousPage%2A>ページのプロパティには、前または送信元のページを表すオブジェクトが含まれています。 たとえば、ページ A 投稿ページ B まで、ページの A の場合は、<xref:System.Web.UI.Page.IsCrossPagePostBack%2A>プロパティ (経由でアクセスできる、<xref:System.Web.UI.Page.PreviousPage%2A>プロパティ) は`true`ページ b の<xref:System.Web.UI.Page.PreviousPage%2A>プロパティはページ A の名前になります  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.IButtonControl.PostBackUrl" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBack">
      <MemberSignature Language="C#" Value="public bool IsPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostBack : bool" Usage="System.Web.UI.Page.IsPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>初めてページを表示しているのか、またはポストバックへの応答としてページを読み込んでいるのかを示す値を取得します。</summary>
        <value>ページがクライアント ポストバックへの応答として読み込まれている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ポストバックとコールバックの違いの詳細については、次を参照してください。[ポストバックなしクライアント コールバックの実装](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185)です。  
  
   
  
## Examples  
 次の例の値をテストする方法を示しています、<xref:System.Web.UI.Page.IsPostBack%2A>プロパティ ページが最初に表示しているか、ポストバックに応答してかを判断するために、ページが読み込まれるときにします。 コードを呼び出す場合は、ページが最初にレンダリングされて、<xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>メソッドです。  
  
 (非表示) ページのマークアップを含む<xref:System.Web.UI.WebControls.RequiredFieldValidator>エントリがない場合、必要な入力フィールドにアスタリスクを表示するコントロール。 呼び出す<xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>送信 ボタンをクリックするまで待機しているのではなく、ページの表示する際にすぐに表示されるアスタリスクをによりします。 ポストバックされた後にを呼び出す必要はありません<xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>の一部としてそのメソッドが呼び出されるため、<xref:System.Web.UI.Page>ライフ サイクルです。  
  
 [!code-csharp[System.Web.UI.Page.Validate#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.Page.IsCallback" />
      </Docs>
    </Member>
    <Member MemberName="IsPostBackEventControlRegistered">
      <MemberSignature Language="C#" Value="public bool IsPostBackEventControlRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBackEventControlRegistered" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostBackEventControlRegistered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostBackEventControlRegistered { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostBackEventControlRegistered : bool" Usage="System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ポストバックを実行するページ内のコントロールが登録されているかどうかを示す値を取得します。</summary>
        <value>コントロールが登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsReusable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReusable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReusable : bool" Usage="System.Web.UI.Page.IsReusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.IHttpHandler.IsReusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Page" /> オブジェクトを再利用できるかどうかを示す値を取得します。</summary>
        <value>常に <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Web.IHttpHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsStartupScriptRegistered(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsStartupScriptRegistered (key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsStartupScriptRegistered(System::String ^ key);" />
      <MemberSignature Language="F#" Value="member this.IsStartupScriptRegistered : string -&gt; bool" Usage="page.IsStartupScriptRegistered key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsStartupScriptRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">検索対象の起動スクリプトの文字列キー。</param>
        <summary>クライアント起動スクリプトが <see cref="T:System.Web.UI.Page" /> オブジェクトに登録されているかどうかを判断します。</summary>
        <returns>スタートアップ スクリプトが登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す前に呼び出します<xref:System.Web.UI.Page.RegisterStartupScript%2A?displayProperty=nameWithType>をクライアント側スクリプトを不必要にまとめることを回避します。 これは、スクリプトを作成するサーバーのリソースの消費量が必要な場合に特に重要です。  
  
 <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> メソッドの使用は非推奨とされました。 使用して、<xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスです。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.RegisterStartupScript%2A>メソッドと組み合わせて、<xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>メソッドです。 コード宣言ブロックで記述された ECMAScript が既に登録されていない場合、によって決定される<xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>、<xref:System.Web.UI.Page.RegisterStartupScript%2A>呼び出しが行われます。  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValid : bool" Usage="System.Web.UI.Page.IsValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ検証が成功したかどうかを示す値を取得します。</summary>
        <value>ページ検証が成功した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返すの`true`、現在の検証グループのすべての検証サーバー コントロールが正常に検証する必要があります。 呼び出した後にのみ、このプロパティを確認する必要があります、<xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>メソッド、またはセット、`CausesValidation`プロパティを`true`で、`OnServerClick`フォーム処理を開始する ASP.NET サーバー コントロールのイベント ハンドラー。 これらのサーバー コントロールが含まれて、 <xref:System.Web.UI.WebControls.Button>、 <xref:System.Web.UI.HtmlControls.HtmlButton>、 <xref:System.Web.UI.HtmlControls.HtmlInputButton>、 <xref:System.Web.UI.HtmlControls.HtmlInputImage>、 <xref:System.Web.UI.WebControls.ImageButton>、および<xref:System.Web.UI.WebControls.LinkButton>クラスです。  
  
 使用して検証グループの検証を強制する場合、<xref:System.Web.UI.Page.Validate%2A>メソッドを指定された検証グループ内のすべての検証コントロールも検証する必要がありますが正常にします。  
  
   
  
## Examples  
 次のコード例では、使用方法を示します、<xref:System.Web.UI.Page.IsValid%2A>条件付きステートメントを設定するプロパティです。 プロパティを返す場合`true`、`Text`のプロパティ、 `lblOutput` 「ページが正しく!」に設定します。 それ以外の場合、「一部の必須フィールドが空です」に設定されています。  
  
 [!code-csharp[System.Web.UI.Page.Validate#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Validate#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">検証が行われる前に <see cref="P:System.Web.UI.Page.IsValid" /> プロパティが呼び出されます。</exception>
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="M:System.Web.UI.Page.Validate" />
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.UI.Page.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ コンテキストに格納されているオブジェクトの一覧を取得します。</summary>
        <value>ページ コンテキストに格納されたオブジェクトを格納している <see cref="T:System.Collections.IDictionary" /> への参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.Items%2A>ページの要求と同じ有効期間を持つオブジェクトを格納するプロパティです。 このプロパティは読み取り専用です。ただし、オブジェクトを追加できる、<xref:System.Collections.IDictionary>オブジェクトを返します。  
  
 追加されたオブジェクト、<xref:System.Web.UI.Page.Items%2A>プロパティには、ページの有効期間全体で使用できるオブジェクトを追加できるように、<xref:System.Web.UI.Page.Items%2A>ページ ライフ サイクルの早い段階でイベントのプロパティは、サイクル、後続のイベントでこれらのオブジェクトにアクセスします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.LCID" />
      <MemberSignature Language="VB.NET" Value="Public Property LCID As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LCID { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.LCID : int with get, set" Usage="System.Web.UI.Page.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページと関連付けられている <see cref="T:System.Threading.Thread" /> オブジェクトのロケール識別子を設定します。</summary>
        <value>
          <see cref="T:System.Threading.Thread" /> に渡すロケール識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 `LCID` .Aspx ファイルのディレクティブで属性を設定することができますが、優先ロケール識別子の設定方法を使用すると、<xref:System.Web.UI.Page.Culture%2A>と<xref:System.Web.UI.Page.UICulture%2A>プロパティです。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
        <altmember cref="P:System.Web.UI.Page.UICulture" />
      </Docs>
    </Member>
    <Member MemberName="LoadComplete">
      <MemberSignature Language="C#" Value="public event EventHandler LoadComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LoadComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.LoadComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LoadComplete;" />
      <MemberSignature Language="F#" Value="member this.LoadComplete : EventHandler " Usage="member this.LoadComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの有効期間の読み込み段階が終了するときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.LoadComplete>すべてポストバック データの後にイベントが発生し、ビュー状態データが読み込まれるは、ページと後、<xref:System.Web.UI.Control.OnLoad%2A>ページのすべてのコントロールのメソッドが呼び出されました。  
  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
      </Docs>
    </Member>
    <Member MemberName="LoadPageStateFromPersistenceMedium">
      <MemberSignature Language="C#" Value="protected internal virtual object LoadPageStateFromPersistenceMedium ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object LoadPageStateFromPersistenceMedium() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function LoadPageStateFromPersistenceMedium () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ LoadPageStateFromPersistenceMedium();" />
      <MemberSignature Language="F#" Value="abstract member LoadPageStateFromPersistenceMedium : unit -&gt; obj&#xA;override this.LoadPageStateFromPersistenceMedium : unit -&gt; obj" Usage="page.LoadPageStateFromPersistenceMedium " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存されたすべてのビューステートに関する情報を <see cref="T:System.Web.UI.Page" /> オブジェクトに読み込みます。</summary>
        <returns>保存されたビュー ステート。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A>メソッドを使用、<xref:System.Web.UI.PageStatePersister.Load%2A>のメソッド、<xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType>によって参照されるオブジェクト、<xref:System.Web.UI.Page.PageStatePersister%2A>をロード プロパティのビュー状態情報の保存、<xref:System.Web.UI.Page>オブジェクト。  
  
 ASP.NET には 2 つのサブフォルダーが含まれています、<xref:System.Web.UI.PageStatePersister>クラス、 <xref:System.Web.UI.HiddenFieldPageStatePersister> ASP.NET ページに含まれる非表示フィールドの状態情報を保存するクラスと<xref:System.Web.UI.SessionPageStatePersister>で状態を保存するクラス、<xref:System.Web.UI.Page.Session%2A>オブジェクトに関連付けられている、要求。  
  
 任意の場所で状態を保存する必要がありますを作成する新しいの子孫、<xref:System.Web.UI.PageStatePersister>クラスを保存し、任意の永続メディアへの状態を読み込みます。 新たに作成する例については<xref:System.Web.UI.PageStatePersister>オブジェクトを参照してください、<xref:System.Web.UI.PageStatePersister>クラスです。  
  
 .NET Framework version 1.0 または 1.1 では、ロードする場合は、このメソッドをオーバーライドを使用している場合、<xref:System.Web.UI.Page>状態から非表示フィールド以外のものです。 またをオーバーライドする必要があるように選択した場合、<xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="MaintainScrollPositionOnPostBack">
      <MemberSignature Language="C#" Value="public bool MaintainScrollPositionOnPostBack { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="VB.NET" Value="Public Property MaintainScrollPositionOnPostBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaintainScrollPositionOnPostBack { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MaintainScrollPositionOnPostBack : bool with get, set" Usage="System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ポストバック後に、クライアント ブラウザー内の同じ位置にユーザーを返すかどうかを示す値を取得または設定します。 このプロパティは、使用が推奨されなくなった <see cref="P:System.Web.UI.Page.SmartNavigation" /> プロパティに代わるものです。</summary>
        <value>クライアント ブラウザー内の位置を維持する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web ページは、サーバーにポストバックされる、ユーザーは、ページの上部に返されます。 長い Web ページで、つまり、ユーザーは、ページ上の最後の位置にページをスクロールします。  
  
 ときに、<xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A>プロパティに設定されている`true`ユーザーは、代わりに返される最後の位置 ページでします。  
  
 設定する、<xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A>プロパティに、 [@ Page](http://msdn.microsoft.com/library/f06cf9e5-22bb-461d-8b8f-549e53ff40a4)ディレクティブです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="page.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">仮想パスを表す <see cref="T:System.String" />。</param>
        <summary>仮想パス (絶対パスまたは相対パス)、またはアプリケーション相対パスの割り当て先の物理パスを取得します。</summary>
        <returns>仮想パスまたはアプリケーション相対パスに関連付けられている物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Web.UI.Page.MapPath%2A>プロパティでは、ホスティング環境に関する機密情報を含めることができます可能性があります。 戻り値をユーザーに表示されません必要があります。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.UI.Page.MapPath%2A>サブフォルダーの物理パスを取得します。 読み取られたファイル名を追加し、<xref:System.Web.UI.WebControls.TextBox.Text%2A>のプロパティ、<xref:System.Web.UI.WebControls.TextBox>コントロール。 そのファイルへの絶対物理パスになります。  
  
 [!code-csharp[Page_MapPath_ResponseEncoding#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/CS/page_mappath_responseencoding.cs.aspx#1)]
 [!code-vb[Page_MapPath_ResponseEncoding#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/VB/page_mappath_responseencoding.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Master">
      <MemberSignature Language="C#" Value="public System.Web.UI.MasterPage Master { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.MasterPage Master" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Master" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Master As MasterPage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::MasterPage ^ Master { System::Web::UI::MasterPage ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Master : System.Web.UI.MasterPage" Usage="System.Web.UI.Page.Master" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.MasterPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの全体的な外観を決定するマスター ページを取得します。</summary>
        <value>存在する場合は、このページに関連付けられた <see cref="T:System.Web.UI.MasterPage" />。それ以外の場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Master%2A>プロパティから返される、<xref:System.Web.UI.MasterPage>このページに関連付けられているオブジェクト。 このプロパティは読み取り専用です。ただしでのプロパティを設定することができます、<xref:System.Web.UI.MasterPage>オブジェクトを返します。  
  
 <xref:System.Web.UI.Page.Master%2A>プロパティはマスター ページを参照するページでのみ有効ですが、<xref:System.Web.UI.Page.MasterPageFile%2A>プロパティです。 アクセスする場合、 <xref:System.Web.UI.Page.Master%2A>  プロパティ ページ、マスター ページを参照しないで`null`が返されます。 マスター ページの内容が後までに使用できる、<xref:System.Web.UI.Page.PreInit>イベントが発生しました。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.MasterPageFile" />
      </Docs>
    </Member>
    <Member MemberName="MasterPageFile">
      <MemberSignature Language="C#" Value="public virtual string MasterPageFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MasterPageFile" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MasterPageFile" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MasterPageFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ MasterPageFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MasterPageFile : string with get, set" Usage="System.Web.UI.Page.MasterPageFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マスター ページの仮想パスを取得または設定します。</summary>
        <value>マスター ページの仮想パス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.MasterPageFile%2A>プロパティは、このページに関連付けられているマスター ページファイルのルートから、アプリケーションの) 仮想パス。 <xref:System.Web.UI.Page.MasterPageFile%2A>プロパティでのみ設定できます、<xref:System.Web.UI.Page.PreInit>イベント; を設定しようとすると、<xref:System.Web.UI.Page.MasterPageFile%2A>後にプロパティ、<xref:System.Web.UI.Page.PreInit>イベントがスローされます、<xref:System.InvalidOperationException>例外。 場合、<xref:System.Web.UI.Page.MasterPageFile%2A>プロパティが有効でない型の例外<xref:System.Web.HttpException>ページ ライフ サイクルの後半でスローされるプロパティ設定されている場合に例外がスローされませんが、<xref:System.Web.UI.Page.PreInit>イベント。  
  
 持つページ、<xref:System.Web.UI.Page.MasterPageFile%2A>プロパティ セットのコンテンツ ページされ、したがってされる最上位レベルのみのコントロールを含めることができます<xref:System.Web.UI.WebControls.Content>コントロール。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.MasterPageFile" /> プロパティは <see cref="E:System.Web.UI.Page.PreInit" /> イベントの完了後に設定されます。</exception>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.UI.Page.MasterPageFile" /> プロパティで指定されたファイルが存在しません。  \- - または -  ページに、最上位のコントロールである <see cref="T:System.Web.UI.WebControls.Content" /> コントロールがありません。</exception>
        <altmember cref="P:System.Web.UI.Page.Master" />
      </Docs>
    </Member>
    <Member MemberName="MaxPageStateFieldLength">
      <MemberSignature Language="C#" Value="public int MaxPageStateFieldLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPageStateFieldLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxPageStateFieldLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxPageStateFieldLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxPageStateFieldLength : int with get, set" Usage="System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの状態フィールドの最大長を取得または設定します。</summary>
        <value>ページの状態フィールドの最大長 (バイト単位)。 既定値は -1 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Web.UI.Page.MaxPageStateFieldLength%2A>プロパティが正の数値に設定されている、クライアント ブラウザーに送信されるビュー ステートは、複数の隠しフィールドに分割、および各フィールドの値がで指定されたサイズより小さい、<xref:System.Web.UI.Page.MaxPageStateFieldLength%2A>プロパティです。  
  
 設定、<xref:System.Web.UI.Page.MaxPageStateFieldLength%2A>負の数 (既定値) をプロパティでは、ビュー状態フィールドをチャンクに分割されないことを示します。 設定、<xref:System.Web.UI.Page.MaxPageStateFieldLength%2A>少数のパフォーマンスの低下にあります。  
  
 値を設定、<xref:System.Web.UI.Page.MaxPageStateFieldLength%2A>プロパティに、Web.config ファイルのです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> プロパティが -1 または正の数と等しくありません。</exception>
        <exception cref="T:System.InvalidOperationException">ページの初期化後に <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> プロパティが設定されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaDescription">
      <MemberSignature Language="C#" Value="public string MetaDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MetaDescription : string with get, set" Usage="System.Web.UI.Page.MetaDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="meta" /> 要素の "description" の内容を取得または設定します。</summary>
        <value>
          <see langword="meta" /> 要素の "description" の内容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML`meta`要素は、検索エンジンの番組表を向上させるために使用できます。 「説明」`meta`要素は一覧のプレビューを向上させるために一部の検索エンジンによって使用されます。  
  
 「説明」がある場合`meta`内の要素、`head`ページ マークアップの要素、`meta`ページが表示される場合は、要素をページに追加します。 ページのマークアップは既に"description"場合`meta`要素では、このプロパティを取得または設定、`content`の属性、`meta`要素。  
  
 ディレクティブに、このプロパティを設定することもできます。  
  
   
  
## Examples  
 設定した場合、 <xref:System.Web.UI.Page.MetaDescription%2A> 「ASP.NET の概要」ページのプロパティは、次要素は、レンダリングされる HTML に表示されます。  
  
 `<meta name="description" content="ASP.NET Overview" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ページには、ヘッダー コントロール ("server" に設定された <see langword="head" /> 属性を持つ <see langword="runat" /> 要素) はありません。</exception>
        <altmember cref="P:System.Web.UI.Page.MetaKeywords" />
      </Docs>
    </Member>
    <Member MemberName="MetaKeywords">
      <MemberSignature Language="C#" Value="public string MetaKeywords { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaKeywords" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaKeywords" />
      <MemberSignature Language="VB.NET" Value="Public Property MetaKeywords As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MetaKeywords { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MetaKeywords : string with get, set" Usage="System.Web.UI.Page.MetaKeywords" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see langword="meta" /> 要素の "keywords" の内容を取得または設定します。</summary>
        <value>
          <see langword="meta" /> 要素の "keywords" の内容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML`meta`要素は、検索エンジンの番組表を向上させるために使用できます。 「キーワード」`meta`要素が使用されていないすべてのまたは主要な検索エンジンではほとんどの重みを指定します。  
  
 「キーワード」がある場合`meta`内の要素、`head`ページ マークアップの要素、`meta`ページが表示される場合は、要素をページに追加します。 ページのマークアップは既に「キーワード」場合`meta`要素では、このプロパティを取得または設定、`content`の属性、`meta`要素。  
  
 ディレクティブに、このプロパティを設定することもできます。  
  
   
  
## Examples  
 設定した場合、 <xref:System.Web.UI.Page.MetaKeywords%2A> 「HTML、CSS、JavaScript、XML」をページのプロパティは、次の要素は、レンダリングされる HTML に表示されます。  
  
 `<meta name="keywords" content=" HTML,CSS,XML,JavaScript" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ページには、ヘッダー コントロール ("server" に設定された <see langword="head" /> 属性を持つ <see langword="runat" /> 要素) はありません。</exception>
        <altmember cref="P:System.Web.UI.Page.MetaDescription" />
      </Docs>
    </Member>
    <Member MemberName="ModelBindingExecutionContext">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelBindingExecutionContext As ModelBindingExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelBindingExecutionContext ^ ModelBindingExecutionContext { System::Web::ModelBinding::ModelBindingExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ModelBindingExecutionContext : System.Web.ModelBinding.ModelBindingExecutionContext" Usage="System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelBindingExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モデル バインディングの実行コンテキストを取得します。</summary>
        <value>モデル バインディングの実行コンテキスト。 モデル バインディングの実行コンテキストが <see langword="null" /> の場合は、新しい実行コンテキストが作成され、それが返されます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelState">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelStateDictionary ModelState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelStateDictionary ModelState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModelState As ModelStateDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ModelBinding::ModelStateDictionary ^ ModelState { System::Web::ModelBinding::ModelStateDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ModelState : System.Web.ModelBinding.ModelStateDictionary" Usage="System.Web.UI.Page.ModelState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelStateDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モデルの状態およびモデル バインディングの検証の状態を格納するモデル状態ディクショナリ オブジェクトを取得します。</summary>
        <value>モデル状態ディクショナリ オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="page.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.Init" /> イベントを発生させてページを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnInit%2A>メソッドを作成するために必要な初期化とセットアップの手順を実行、<xref:System.Web.UI.Page>インスタンス。 このページのライフ サイクル ステージで ページで宣言されたサーバー コントロールは既定の状態に初期化されます。ただし、各コントロールのビュー ステートがまだ設定します。 ページ上のコントロールが中に、ページ上の他のサーバー コントロールにアクセスできない、`Page_Init`フェーズでは、他のコントロールの親または子コントロールがかどうかに関係なく、します。 他のサーバー コントロールが作成され、アクセスできる状態である保証はありません。  
  
 <xref:System.Web.UI.Page.OnInit%2A>メソッドは、<xref:System.Web.UI.Page.OnPreInit%2A>メソッドとの前に、<xref:System.Web.UI.Page.OnInitComplete%2A>メソッドです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)です。  
  
 <xref:System.Web.UI.Page.OnInit%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInitComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInitComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitComplete : EventArgs -&gt; unit&#xA;override this.OnInitComplete : EventArgs -&gt; unit" Usage="page.OnInitComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>ページを初期化した後に <see cref="E:System.Web.UI.Page.InitComplete" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnInitComplete%2A>ページの初期化が完了した後にメソッドが呼び出されます。 このページのライフ サイクル ステージで宣言されたすべて、ページ上のコントロールが初期化されるが、ページのビュー ステートがまだ設定します。 サーバー コントロールにアクセスできますが、それらがまだ含まれていませんユーザーから返される情報には。  
  
 <xref:System.Web.UI.Page.OnInitComplete%2A>メソッドは、最後の発生、<xref:System.Web.UI.Page>初期化段階と、負荷のステージの前にします。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)です。  
  
 <xref:System.Web.UI.Page.OnInitComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLoadComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadComplete : EventArgs -&gt; unit&#xA;override this.OnLoadComplete : EventArgs -&gt; unit" Usage="page.OnLoadComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>ページの読み込み段階の終了時に <see cref="E:System.Web.UI.Page.LoadComplete" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnLoadComplete%2A>メソッドは、ページを読み込む段階の最後に呼び出されます。 この時点でページ ライフ サイクルは、すべてのポストバック データとビューステート データが読み込み済みで、ページ上のコントロールにします。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)です。  
  
 <xref:System.Web.UI.Page.OnLoadComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreInit">
      <MemberSignature Language="C#" Value="protected virtual void OnPreInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreInit : EventArgs -&gt; unit&#xA;override this.OnPreInit : EventArgs -&gt; unit" Usage="page.OnPreInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>ページの初期化の開始時に <see cref="E:System.Web.UI.Page.PreInit" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreInit%2A>ページの初期化段階の先頭にメソッドが呼び出されます。  
  
 後に、<xref:System.Web.UI.Page.OnPreInit%2A>メソッドが呼び出される、パーソナル化情報が読み込まれ、ページのテーマが存在する場合は初期化されます。 これは、優先されるステージを動的に定義にも、<xref:System.Web.UI.PageTheme>または<xref:System.Web.UI.MasterPage>ページ。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)です。  
  
 <xref:System.Web.UI.Page.OnPreInit%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnPreLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreLoad : EventArgs -&gt; unit&#xA;override this.OnPreLoad : EventArgs -&gt; unit" Usage="page.OnPreLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>ポストバック データがページ上のサーバー コントロールに読み込まれてから <see cref="E:System.Web.UI.Page.PreLoad" /> イベントが発生するまでの間に <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreLoad%2A>メソッドが呼び出されたユーザーから返されたすべてのポストバック データが読み込まれます。 この段階で、ページのライフ サイクルで、ビュー ステート情報とポストバック データ宣言コントロールと初期化段階で作成されたコントロールがページのコントロールに読み込まれます。  
  
 作成されたコントロール、<xref:System.Web.UI.Page.OnPreLoad%2A>メソッドは、ビューステートとポストバック データを読み込むこともできます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)です。  
  
 <xref:System.Web.UI.Page.OnPreLoad%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRenderComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRenderComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRenderComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreRenderComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreRenderComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRenderComplete : EventArgs -&gt; unit&#xA;override this.OnPreRenderComplete : EventArgs -&gt; unit" Usage="page.OnPreRenderComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>
          <see cref="E:System.Web.UI.Page.PreRenderComplete" /> イベントが発生してからページが表示されるまでの間に <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnPreRenderComplete%2A>プリレンダ リング、ページのライフ サイクルの段階が完了すると、メソッドが呼び出されます。 ページのライフ サイクルのこの段階では、すべてのコントロールが作成され、ページは、出力を表示する準備が。  
  
 これは、最後のページのビュー状態を保存する前に呼び出すイベントです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)です。  
  
 <xref:System.Web.UI.Page.OnPreRenderComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSaveStateComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSaveStateComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSaveStateComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSaveStateComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSaveStateComplete(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSaveStateComplete : EventArgs -&gt; unit&#xA;override this.OnSaveStateComplete : EventArgs -&gt; unit" Usage="page.OnSaveStateComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>ページの状態が永続媒体に保存された後で <see cref="E:System.Web.UI.Page.SaveStateComplete" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.OnSaveStateComplete%2A>メソッドは、コントロールの状態情報がページの永続化中に書き込まれたときに呼び出されます。 永続化中に呼び出すことによって状態情報が書き込まれる、<xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A>メソッドです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)です。  
  
 <xref:System.Web.UI.Page.OnSaveStateComplete%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合<see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />派生クラスでは、基本クラスの呼び出しを必ず<see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />デリゲートを登録するためのメソッドがイベントを受信します。</para>
        </block>
        <altmember cref="E:System.Web.UI.Page.SaveStateComplete" />
        <altmember cref="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="public System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Page.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の要求側のブラウザーのページをレンダリングするアダプターを取得します。</summary>
        <value>ページをレンダリングする <see cref="T:System.Web.UI.Adapters.PageAdapter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PageAdapter%2A>プロパティは、固有の仕様を返します<xref:System.Web.UI.Adapters.PageAdapter>の動作を変更するオブジェクト、<xref:System.Web.UI.Page>要求側のブラウザーのオブジェクト。  
  
 特定<xref:System.Web.UI.Adapters.PageAdapter>オブジェクトは、入力方向の特性を調べることによって決まります<xref:System.Web.UI.Page.Request%2A>オブジェクト。 要求のライフ サイクル イベントをアダプターが選択された場合、<xref:System.Web.UI.Adapters.PageAdapter>オブジェクトに対応するイベントの上書き、<xref:System.Web.UI.Page>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageStatePersister">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.PageStatePersister PageStatePersister { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.PageStatePersister PageStatePersister" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageStatePersister" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property PageStatePersister As PageStatePersister" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::PageStatePersister ^ PageStatePersister { System::Web::UI::PageStatePersister ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageStatePersister : System.Web.UI.PageStatePersister" Usage="System.Web.UI.Page.PageStatePersister" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.PageStatePersister</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページに関連付けられている <see cref="T:System.Web.UI.PageStatePersister" /> オブジェクトを取得します。</summary>
        <value>ページに関連付けられた <see cref="T:System.Web.UI.PageStatePersister" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTTP 要求と応答は、本質的にステートレスです。 HTTP 要求の間で状態を維持するために ASP.NET サーバー ページを格納できます<xref:System.Web.UI.Page>状態です。 ビュー状態と呼ばれる、この状態は、ページとコントロールの設定、およびページとコントロールのようにいる場合、ユーザーがページに最後のラウンド トリップで対話し、ものと同じものを表示できるようにするデータで構成されます。 同じページに後続の要求間でのビュー ステートを格納するいくつかのメカニズムが存在します。 抽象<xref:System.Web.UI.PageStatePersister>クラスは、これらの状態の記憶域メカニズムの基本クラスを表します。  
  
 ページの開発者が通常必要ありませんを使用して、<xref:System.Web.UI.Page.PageStatePersister%2A>プロパティです。 <xref:System.Web.UI.Page.PageStatePersister%2A>プロパティは、主の機能を拡張するコントロールの開発者によって使用、<xref:System.Web.UI.Page>クラスです。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="postEventArgumentID">
      <MemberSignature Language="C#" Value="public const string postEventArgumentID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventArgumentID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventArgumentID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventArgumentID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventArgumentID;" />
      <MemberSignature Language="F#" Value="val mutable postEventArgumentID : string" Usage="System.Web.UI.Page.postEventArgumentID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示されるページの EVENTARGUMENT 非表示フィールドを定義する文字列。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventSourceID" />
      </Docs>
    </Member>
    <Member MemberName="postEventSourceID">
      <MemberSignature Language="C#" Value="public const string postEventSourceID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventSourceID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventSourceID" />
      <MemberSignature Language="VB.NET" Value="Public Const postEventSourceID As String " />
      <MemberSignature Language="C++ CLI" Value="public: System::String ^ postEventSourceID;" />
      <MemberSignature Language="F#" Value="val mutable postEventSourceID : string" Usage="System.Web.UI.Page.postEventSourceID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示されるページの EVENTTARGET 非表示フィールドを定義する文字列。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="F:System.Web.UI.Page.postEventArgumentID" />
      </Docs>
    </Member>
    <Member MemberName="PreInit">
      <MemberSignature Language="C#" Value="public event EventHandler PreInit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreInit" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreInit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreInit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreInit;" />
      <MemberSignature Language="F#" Value="member this.PreInit : EventHandler " Usage="member this.PreInit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの初期化前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントでは、ポストバックへの応答で、ページが読み込まれているかどうかなど、ページ要求の条件を確認することができます。 プロファイルのプロパティの値をチェックすることもできます。  
  
 イベントでは、ページのライフ サイクルの後で使用される値を設定することができます。 動的に、マスター ページまたは、要求されたページのテーマを設定し、ダイナミック コントロールを作成できます。  
  
 方法の詳細については<xref:System.Web.UI.Page.PreInit>イベントに組み込まれて、ASP.NET のライフ サイクルは、「 [ASP.NET ページ ライフ サイクルの概要](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
      </Docs>
    </Member>
    <Member MemberName="PreLoad">
      <MemberSignature Language="C#" Value="public event EventHandler PreLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreLoad" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreLoad As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreLoad;" />
      <MemberSignature Language="F#" Value="member this.PreLoad : EventHandler " Usage="member this.PreLoad : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの<see cref="E:System.Web.UI.Control.Load" /> イベントの前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PreLoad>イベントは、すべてのポストバック データの処理後、および、<xref:System.Web.UI.Control.Load>イベント。 2 回目の試行する前にポストバック データを読み込む、<xref:System.Web.UI.Page.OnLoadComplete%2A>イベント。 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
        <altmember cref="E:System.Web.UI.Page.PreRenderComplete" />
      </Docs>
    </Member>
    <Member MemberName="PreRenderComplete">
      <MemberSignature Language="C#" Value="public event EventHandler PreRenderComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRenderComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreRenderComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRenderComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRenderComplete;" />
      <MemberSignature Language="F#" Value="member this.PreRenderComplete : EventHandler " Usage="member this.PreRenderComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページの内容が表示される前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.PreRenderComplete>ページのライフ サイクルの前のレンダリング段階が完了すると、イベントが発生します。 ページのライフ サイクルのこの段階ですべてのコントロールを作成、必要なすべての改ページが完了したら、およびページは、出力を表示するために準備ができてです。  
  
 これは、最後のページのビュー状態が保存される前に発生するイベントです。  
  
 イベント処理の詳細については、次を参照してください。 [NIB: イベントの利用](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.PreLoad" />
        <altmember cref="E:System.Web.UI.Page.PreInit" />
      </Docs>
    </Member>
    <Member MemberName="PreviousPage">
      <MemberSignature Language="C#" Value="public System.Web.UI.Page PreviousPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page PreviousPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PreviousPage" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousPage As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Page ^ PreviousPage { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousPage : System.Web.UI.Page" Usage="System.Web.UI.Page.PreviousPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のページにコントロールが渡されるページを取得します。</summary>
        <value>現在のページにコントロールが渡されるページを表す <see cref="T:System.Web.UI.Page" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用すると、<xref:System.Web.HttpServerUtility.Transfer%2A>メソッドまたはを使用してページ間に 1 つの ASP.NET ページから別の処理を転送します。 投稿、発生元のページに移動先のページに必要な情報を要求が含まれています。 使用することができます、<xref:System.Web.UI.Page.PreviousPage%2A>プロパティをその情報にアクセスします。  
  
 (、転送や別のページからのクロス post)、直接の要求の結果として、現在のページを表示しているかどうか、<xref:System.Web.UI.Page.PreviousPage%2A>プロパティが含まれます`null`です。  
  
   
  
## Examples  
 次の例では、2 つの部分です。 1 つは、使用する ASP.NET ページ、<xref:System.Web.HttpServerUtility.Transfer%2A>としてページ モデルで公開されるメソッド`Server.Transfer("path")`です。 2 番目の部分は、対象のページを使用して、<xref:System.Web.UI.Page.PreviousPage%2A>最初のページのタイトルを取得するプロパティです。  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Main.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Main.aspx#1)]  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Notify.aspx#2)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Notify.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">現在のユーザーは、前のページにアクセスすることを許可されていません。  または、ASP.NET ルーティングが使用中のため、前のページの URL はルーティング URL です。 ASP.NET がアクセス許可をチェックするときは、その URL がファイルへの実際のパスであることを前提としています。 ルーティングされた URL には該当しないため、チェックは失敗します。</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ProcessRequest (context As HttpContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessRequest(System::Web::HttpContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ProcessRequest : System.Web.HttpContext -&gt; unit&#xA;override this.ProcessRequest : System.Web.HttpContext -&gt; unit" Usage="page.ProcessRequest context" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.IHttpHandler.ProcessRequest(System.Web.HttpContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">HTTP 要求を処理するために使用する、組み込みのサーバー オブジェクト (<see cref="T:System.Web.HttpContext" />、<see cref="P:System.Web.HttpContext.Request" />、<see cref="P:System.Web.HttpContext.Response" /> など) への参照を提供する <see cref="P:System.Web.HttpContext.Session" /> オブジェクト。</param>
        <summary>
          <see cref="T:System.Web.UI.Page" />、<see cref="P:System.Web.UI.Page.Context" />、<see cref="P:System.Web.UI.Page.Request" />、<see cref="P:System.Web.UI.Page.Response" /> の各プロパティなど、<see cref="P:System.Web.UI.Page.Application" /> オブジェクトの組み込みサーバー オブジェクトを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Context" />
        <altmember cref="P:System.Web.UI.Page.Request" />
        <altmember cref="P:System.Web.UI.Page.Response" />
        <altmember cref="P:System.Web.UI.Page.Application" />
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(class System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RaisePostBackEvent(System.Web.UI.IPostBackEventHandler,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RaisePostBackEvent (sourceControl As IPostBackEventHandler, eventArgument As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RaisePostBackEvent(System::Web::UI::IPostBackEventHandler ^ sourceControl, System::String ^ eventArgument);" />
      <MemberSignature Language="F#" Value="abstract member RaisePostBackEvent : System.Web.UI.IPostBackEventHandler * string -&gt; unit&#xA;override this.RaisePostBackEvent : System.Web.UI.IPostBackEventHandler * string -&gt; unit" Usage="page.RaisePostBackEvent (sourceControl, eventArgument)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceControl" Type="System.Web.UI.IPostBackEventHandler" />
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceControl">ポストバックの原因となった ASP.NET サーバー コントロール。 このコントロールは、<see cref="T:System.Web.UI.IPostBackEventHandler" /> インターフェイスを実装している必要があります。</param>
        <param name="eventArgument">ポストバックの引数。</param>
        <summary>ポストバックの原因となったサーバー コントロールに、受信ポストバック イベントを処理するよう通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page>オブジェクトの呼び出し、<xref:System.Web.UI.Page.RaisePostBackEvent%2A>メソッド ポストバックが発生したときにします。 この呼び出しは、読み込みと変更の通知が完了した後は、事前に発生する前に、ページのライフ サイクルで発生します。  
  
   
  
## Examples  
 次の例で、<xref:System.Web.UI.Page.RaisePostBackEvent%2A>ときに、カスタム、ポストバック イベントが発生したことを ASP.NET に通知するメソッド`userButton`サーバー コントロールをクリックします。  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IPostBackEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterArrayDeclaration (arrayName As String, arrayValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterArrayDeclaration(System::String ^ arrayName, System::String ^ arrayValue);" />
      <MemberSignature Language="F#" Value="member this.RegisterArrayDeclaration : string * string -&gt; unit" Usage="page.RegisterArrayDeclaration (arrayName, arrayValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterArrayDeclaration(string arrayName, string arrayValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">値の宣言が行われる配列の名前。</param>
        <param name="arrayValue">配列に代入する値。</param>
        <summary>ページが表示されると、ECMAScript 配列宣言として宣言される値を宣言します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、クライアント スクリプト ライブラリの同じ型のすべてのコントロールが扱えるように配列内における自体を宣言するスクリプト ベースのコントロールで使用できます。  
  
 <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> メソッドの使用は非推奨とされました。 使用して、<xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスです。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> 、配列を宣言するメソッド`myArray`、という 3 つのオブジェクトを格納している`x`、 `y`、および`z`です。 例を定義し、スタートアップ スクリプトを使用して、登録、<xref:System.Web.UI.Page.RegisterStartupScript%2A>メソッドです。 ときに、ECMAScript`doClick`関数はこのコードが含まれるページから呼び出されますが、配列とそのオブジェクトを初期化します。  
  
 [!code-csharp[Page_RegisterArrayDeclaration#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/CS/page_registerarraydeclaration.cs.aspx#1)]
 [!code-vb[Page_RegisterArrayDeclaration#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/VB/page_registerarraydeclaration.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncTask">
      <MemberSignature Language="C#" Value="public void RegisterAsyncTask (System.Web.UI.PageAsyncTask task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterAsyncTask(class System.Web.UI.PageAsyncTask task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAsyncTask (task As PageAsyncTask)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAsyncTask(System::Web::UI::PageAsyncTask ^ task);" />
      <MemberSignature Language="F#" Value="member this.RegisterAsyncTask : System.Web.UI.PageAsyncTask -&gt; unit" Usage="page.RegisterAsyncTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Web.UI.PageAsyncTask" />
      </Parameters>
      <Docs>
        <param name="task">非同期操作を定義する <see cref="T:System.Web.UI.PageAsyncTask" />。</param>
        <summary>新しい非同期操作をページに登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、非同期タスクを定義する、<xref:System.Web.UI.PageAsyncTask>クラスです。 タスクが定義されている場合を使用して、<xref:System.Web.UI.Page.RegisterAsyncTask%2A>ページで、タスクを登録します。 タスクを登録すると、呼び出し、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>メソッドを非同期のタスクを開始します。  
  
 <xref:System.Web.UI.Page.RegisterAsyncTask%2A>メソッドは、同期および非同期の両方のページで使用することができます。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.AsyncTimeout%2A>を持つプロパティ、<xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A>と<xref:System.Web.UI.Page.RegisterAsyncTask%2A>メソッドです。 先頭、末尾、およびタイムアウト ハンドラーの使用に注意してください。 指定されているタスクの割り当て時刻を超えた場合、非同期タスクのような状況を示す例では、人為的な遅延が導入された、<xref:System.Web.UI.Page.AsyncTimeout%2A>プロパティです。 現実のシナリオで非同期タスクは、データベースの呼び出しまたはイメージの生成を実行するために使用可能性がありますなどとタイムアウト ハンドラーは、一定の時間で、タスクは実行されない場合に下げるを提供します。  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">非同期操作は <see langword="null" /> です。</exception>
        <altmember cref="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
        <altmember cref="T:System.Web.UI.PageAsyncTask" />
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public virtual void RegisterClientScriptBlock (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterClientScriptBlock(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterClientScriptBlock (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterClientScriptBlock(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScriptBlock : string * string -&gt; unit&#xA;override this.RegisterClientScriptBlock : string * string -&gt; unit" Usage="page.RegisterClientScriptBlock (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterClientScriptBlock(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">スクリプト ブロックを識別する一意のキー。</param>
        <param name="script">クライアントに送られるスクリプトの内容。</param>
        <summary>応答に対してクライアント側のスクリプト ブロックを出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開始タグの直後に、クライアント側-スクリプトが生成されます、<xref:System.Web.UI.Page>オブジェクトの`<form runat= server>`要素。 必ず開始タグと終了を`<script>`スクリプトの周りに要素のブロックで指定した文字列、`script`パラメーター。  
  
 このメソッドは、スクリプト ブロックを識別するキーを使用するため、スクリプト ブロックが別のサーバー コントロールのインスタンスから要求されるたびに、出力ストリームに出力する必要はありません。 キーを使用すると、別のコントロールのスクリプト ブロックが互いに干渉する可能性も低下します。  
  
 いずれかのスクリプトで、同じブロック`key`パラメーター値が重複と見なされます。  
  
> [!NOTE]
>  要求側のブラウザーがスクリプトをサポートしていない場合は表示されないように、HTML コメント タグで囲みます、スクリプトを含めるに注意してください。  
  
 <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> メソッドの使用は非推奨とされました。 代わりに <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> クラスの <xref:System.Web.UI.ClientScriptManager> メソッドを使用してください。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>メソッドと組み合わせて、<xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>メソッドです。 宣言のコード ブロックに ECMAScript が既に登録されていない場合、によって決定される<xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>、<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>呼び出しが行われます。  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public virtual void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterHiddenField (hiddenFieldName As String, hiddenFieldInitialValue As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterHiddenField(System::String ^ hiddenFieldName, System::String ^ hiddenFieldInitialValue);" />
      <MemberSignature Language="F#" Value="abstract member RegisterHiddenField : string * string -&gt; unit&#xA;override this.RegisterHiddenField : string * string -&gt; unit" Usage="page.RegisterHiddenField (hiddenFieldName, hiddenFieldInitialValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">表示される非表示フィールドの一意の名前。</param>
        <param name="hiddenFieldInitialValue">非表示フォームに出力される値。</param>
        <summary>サーバー コントロールがフォームに非表示フィールドを自動的に登録できるようにします。 <see cref="T:System.Web.UI.Page" /> サーバー コントロールが表示されると、フィールドが <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> オブジェクトに送られます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterHiddenField%2A> メソッドの使用は非推奨とされました。 使用して、<xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスです。  
  
   
  
## Examples  
 次のコード例では、 <xref:System.Web.UI.Page.RegisterHiddenField%2A> ECMAScript コードを作成するためにメソッドが要求側のブラウザーに渡されます。 非表示フィールドの名前に設定されている`myHiddenField`し、その値が「を Microsoft にようこそ!」に設定されています。 <xref:System.Web.UI.Page.RegisterStartupScript%2A>メソッドの呼び出し、`myHiddenField`値のユーザーがページ上のボタンをクリックします。  
  
> [!IMPORTANT]
>  この例では、潜在的なセキュリティ上の脅威が、非表示フィールドがあります。 既定では、テキスト ボックスの値と同様、非表示フィールドの値を検証する必要があります。 ASP.NET Web ページは、ユーザー入力にスクリプトまたは HTML 要素が含まれていないことを検証します。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Page_RegisterHiddenField#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#1)]
 [!code-vb[Page_RegisterHiddenField#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterOnSubmitStatement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterOnSubmitStatement (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterOnSubmitStatement(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="member this.RegisterOnSubmitStatement : string * string -&gt; unit" Usage="page.RegisterOnSubmitStatement (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterOnSubmitStatement(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">スクリプト ブロックを識別する一意のキー。</param>
        <param name="script">クライアントに送られるクライアント側のスクリプト。</param>
        <summary>ページがクライアント <see langword="OnSubmit" /> イベントにアクセスできるようにします。 スクリプトは、他の場所に登録されているクライアント コードへの関数の呼び出しである必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> メソッドの使用は非推奨とされました。 使用して、<xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A>メソッドで、<xref:System.Web.UI.ClientScriptManager>クラスです。  
  
   
  
## Examples  
 次のコード例では、使用方法を示します、<xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A>クライアント側の送信 ボタンがクリックされたときに応答するスクリプトにアクセスします。 このイベントが発生した、クライアントの登録済みの ECMAScript コードが実行されます。  
  
> [!IMPORTANT]
>  この例では、潜在的なセキュリティ上の脅威が、非表示フィールドがあります。 既定では、テキスト ボックスの値と同様、非表示フィールドの値を検証する必要があります。 ASP.NET Web ページは、ユーザー入力にスクリプトまたは HTML 要素が含まれていないことを検証します。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Page_RegisterHiddenField#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#2)]
 [!code-vb[Page_RegisterHiddenField#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void RegisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresControlState : System.Web.UI.Control -&gt; unit" Usage="page.RegisterRequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">登録するコントロール。</param>
        <summary>特定のコントロールを、コントロールの状態を維持する必要があるコントロールとして登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの状態を使用するカスタムのサーバー コントロールを呼び出す必要があります、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッド要求のたびにコントロールの状態のための登録が引き継がれません要求からの要求にポストバック イベントの中であるためです。 登録がで実行することをお勧め、<xref:System.Web.UI.Control.Init>イベント。  
  
   
  
## Examples  
 次のコード例は、カスタム サーバー コントロールの呼び出しを示しています、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッドです。  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">登録するコントロールが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" /> メソッドを呼び出すことができるのは、<see cref="E:System.Web.UI.Control.PreRender" /> イベントの前か中だけです。</exception>
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresPostBack">
      <MemberSignature Language="C#" Value="public void RegisterRequiresPostBack (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresPostBack(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresPostBack(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresPostBack : System.Web.UI.Control -&gt; unit" Usage="page.RegisterRequiresPostBack control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">登録するコントロール。</param>
        <summary>コントロールを、ページがサーバーにポストバックされたときにポストバック処理を必要とするコントロールとして登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 登録するコントロールを実装する必要があります、<xref:System.Web.UI.IPostBackDataHandler>インターフェイスまたは<xref:System.Web.HttpException>が発生します。 コントロールで実装された場合、<xref:System.Web.UI.IPostBackDataHandler>ポストバック データの処理や任意の投稿の生成が可能なインターフェイスが変更されたデータ イベントをバックアップします。 サーバー コントロールのイベント モデルの詳細については、次を参照してください。 [ASP.NET Web フォーム サーバー コントロールのイベント モデル](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3)です。  
  
 以前のページにコントロールを登録、`Page_PreRender`ページのライフ サイクルのイベントです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.RegisterRequiresPostBack%2A>メソッドをテキスト ボックス コントロールを必要とする`myTextBox`、ポストバックされます、テキスト ボックスに関連付けられているすべてのコードを実行前にします。 <xref:System.Web.UI.WebControls.TextBox> コントロールは、実装、<xref:System.Web.UI.IPostBackDataHandler>インターフェイスです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Page_RegisterRequiresPostBack#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/CS/page_registerrequirespostback.cs.aspx#1)]
 [!code-vb[Page_RegisterRequiresPostBack#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/VB/page_registerrequirespostback.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">登録するコントロールが <see cref="T:System.Web.UI.IPostBackDataHandler" /> インターフェイスを実装していません。</exception>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
        <altmember cref="T:System.Web.UI.IPostBackDataHandler" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresRaiseEvent">
      <MemberSignature Language="C#" Value="public virtual void RegisterRequiresRaiseEvent (System.Web.UI.IPostBackEventHandler control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterRequiresRaiseEvent(class System.Web.UI.IPostBackEventHandler control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresRaiseEvent(System.Web.UI.IPostBackEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterRequiresRaiseEvent (control As IPostBackEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterRequiresRaiseEvent(System::Web::UI::IPostBackEventHandler ^ control);" />
      <MemberSignature Language="F#" Value="abstract member RegisterRequiresRaiseEvent : System.Web.UI.IPostBackEventHandler -&gt; unit&#xA;override this.RegisterRequiresRaiseEvent : System.Web.UI.IPostBackEventHandler -&gt; unit" Usage="page.RegisterRequiresRaiseEvent control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.IPostBackEventHandler" />
      </Parameters>
      <Docs>
        <param name="control">登録するコントロール。</param>
        <summary>ASP.NET サーバー コントロールが <see cref="T:System.Web.UI.Page" /> オブジェクトで処理されたときに、このコントロールをイベントの発生を要求するコントロールとして登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページ要求あたり 1 つだけのサーバー コントロールに登録できます。 <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A>コントロールにそのコントロール形式で ID データの投稿にはが含まれていない場合に使用する必要があります。 また、登録されているコントロールを実装する必要があります、<xref:System.Web.UI.IPostBackEventHandler>インターフェイスです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A>を登録するメソッド、 <xref:System.Web.UI.WebControls.Button> Web サーバー コントロールにイベントを発生させる必要であるとします。 最初に登録した後<xref:System.Web.UI.WebControls.Button>コントロール、2 番目になる<xref:System.Web.UI.WebControls.Button>の最初のボタンの結果を投稿するためのコードで宣言されているコントロールがページにイベントをクリックします。  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresViewStateEncryption">
      <MemberSignature Language="C#" Value="public void RegisterRequiresViewStateEncryption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresViewStateEncryption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterRequiresViewStateEncryption ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterRequiresViewStateEncryption();" />
      <MemberSignature Language="F#" Value="member this.RegisterRequiresViewStateEncryption : unit -&gt; unit" Usage="page.RegisterRequiresViewStateEncryption " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールを、ビューステートの暗号化が必要なコントロールとしてページに登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 機密性の高い情報を処理するカスタム コントロールを開発している場合、<xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>ページにコントロールを登録し、コントロールは暗号化の表示状態を保証するメソッド。  
  
 場合、ページ全体の状態を暗号化する、<xref:System.Web.UI.Page.ViewStateEncryptionMode%2A>に設定されている<xref:System.Web.UI.ViewStateEncryptionMode.Auto>または<xref:System.Web.UI.ViewStateEncryptionMode.Always>です。  
  
   
  
## Examples  
 ビュー ステートの暗号化モードを設定する次のコード例を示します、<xref:System.Web.UI.Page>オブジェクトおよびからビュー ステートの暗号化を要求している<xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>です。 この例では、ビュー ステートをデータベースから顧客情報を取得時に暗号化されます。  
  
 [!code-aspx-csharp[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/CS/encryptViewState.cs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/VB/encryptViewState.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" /> メソッドは、ページ ライフ サイクルの <see langword="PreRender" />フェーズの前またはこのフェーズで呼び出す必要があります。</exception>
        <altmember cref="P:System.Web.UI.Page.ViewStateEncryptionMode" />
        <altmember cref="T:System.Web.UI.WebControls.GridView" />
        <altmember cref="T:System.Web.UI.WebControls.DetailsView" />
        <altmember cref="T:System.Web.UI.WebControls.FormView" />
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public virtual void RegisterStartupScript (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterStartupScript(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RegisterStartupScript (key As String, script As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterStartupScript(System::String ^ key, System::String ^ script);" />
      <MemberSignature Language="F#" Value="abstract member RegisterStartupScript : string * string -&gt; unit&#xA;override this.RegisterStartupScript : string * string -&gt; unit" Usage="page.RegisterStartupScript (key, script)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterStartupScript(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">スクリプト ブロックを識別する一意のキー。</param>
        <param name="script">クライアントに送られるスクリプトの内容。</param>
        <summary>ページ応答で、クライアント側のスクリプト ブロックを出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ような<xref:System.Web.UI.Page.RegisterClientScriptBlock%2A>メソッド、<xref:System.Web.UI.Page.RegisterStartupScript%2A>メソッドの終了タグの直前に、スクリプトの生成、<xref:System.Web.UI.Page>オブジェクトの`<form runat= server>`要素。 必ず開始タグと終了を`<script>`スクリプトの周りに要素のブロックで指定した文字列、`script`パラメーター。  
  
 このメソッドは、スクリプト ブロックを識別するキーを使用するため、スクリプト ブロックを別のサーバー コントロールのインスタンスから要求されるたびに出力ストリームに出力する必要はありません。  
  
 いずれかのスクリプトで、同じブロック`key`パラメーター値が重複と見なされます。  
  
> [!NOTE]
>  要求側のブラウザーがスクリプトをサポートしていない場合は表示されないように、HTML コメント タグで囲みます、スクリプトを含めるに注意してください。  
  
 <xref:System.Web.UI.Page.RegisterStartupScript%2A> メソッドの使用は非推奨とされました。 代わりに <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> クラスの <xref:System.Web.UI.ClientScriptManager> メソッドを使用してください。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Web.UI.Page.RegisterStartupScript%2A>メソッドと組み合わせて、<xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>メソッドです。 コード宣言ブロックで記述された ECMAScript が既に登録されていない場合、によって決定される、 <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> 、メソッド、<xref:System.Web.UI.Page.RegisterStartupScript%2A>呼び出しが行われます。  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterViewStateHandler">
      <MemberSignature Language="C#" Value="public void RegisterViewStateHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterViewStateHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterViewStateHandler" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterViewStateHandler ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterViewStateHandler();" />
      <MemberSignature Language="F#" Value="member this.RegisterViewStateHandler : unit -&gt; unit" Usage="page.RegisterViewStateHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出されると、ページのビューステートが解析されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.RegisterViewStateHandler%2A>経由メソッドで自動的に呼び出され、<xref:System.Web.UI.HtmlControls.HtmlForm>サーバー コントロールです。 このメソッドが呼び出されない場合、ページのビュー状態は保持されません。  
  
> [!NOTE]
>  通常、のみ、<xref:System.Web.UI.HtmlControls.HtmlForm>ページのサーバー コントロールは、このメソッドを呼び出します。  
  
   
  
## Examples  
 [!code-csharp[Page_RegisterViewStateHandler#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterViewStateHandler/CS/page_registerviewstatehandler.cs#1)]
 [!code-vb[Page_RegisterViewStateHandler#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterViewStateHandler/VB/page_registerviewstatehandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="page.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">ページの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <summary>
          <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトを初期化して、表示する <see cref="T:System.Web.UI.Page" /> の子コントロールを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Render%2A>メソッドは、テキスト、およびクライアントのブラウザーに送信されるマークアップの作成を担当します。 既定値<xref:System.Web.UI.Page.Render%2A>メソッド呼び出し<xref:System.Web.UI.Control.RenderChildren%2A>テキストと、ページに含まれるコントロールのマークアップを記述します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.UI.Page.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求されたページの <see cref="T:System.Web.HttpRequest" /> オブジェクトを取得します。</summary>
        <value>ページに関連付けられている現在の <see cref="T:System.Web.HttpRequest" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest> オブジェクトには、現在の HTTP 要求に関する情報が含まれています。  
  
   
  
## Examples  
 次の例では、取得する方法、<xref:System.Web.HttpRequest.Headers%2A>コレクションから、<xref:System.Web.HttpRequest>オブジェクトし、ASP.NET ページへの書き込み。  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="T:System.Web.HttpRequest" /> オブジェクトが使用できない場合に発生します。</exception>
        <altmember cref="T:System.Web.HttpException" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="RequiresControlState">
      <MemberSignature Language="C#" Value="public bool RequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.RequiresControlState : System.Web.UI.Control -&gt; bool" Usage="page.RequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">コントロールの状態を要求するかどうかを確認するための <see cref="T:System.Web.UI.Control" />。</param>
        <summary>指定した <see cref="T:System.Web.UI.Control" /> オブジェクトが、コントロールの状態管理ができるように登録されているかどうかを判断します。</summary>
        <returns>指定した <see cref="T:System.Web.UI.Control" /> がコントロールの状態を要求する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの状態は、Web サーバー コントロールが機能するために必要なビューステート データの重要なので構成されるオブジェクトこれは通常のビュー状態から別のオブジェクトに含まれています。  
  
 コントロールの状態を使用してカスタム コントロールを呼び出す必要があります、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>コントロールの状態を保存する前にメソッドです。 使用して、<xref:System.Web.UI.Page.RequiresControlState%2A>コントロールの状態を必要とすると、ページに登録されているコントロールをチェックするメソッド。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="P:System.Web.UI.PageStatePersister.ControlState" />
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.UI.Page.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Page" /> オブジェクトに関連付けられている <see cref="T:System.Web.HttpResponse" /> オブジェクトを取得します。 このオブジェクトでは、HTTP 応答データをクライアントに送信し、その応答に関する情報を含めることができます。</summary>
        <value>ページに関連付けられている現在の <see cref="T:System.Web.HttpResponse" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、cookie を作成してを使用して、ページの HTTP 出力への追加を示しています、<xref:System.Web.HttpResponse>オブジェクト。  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="T:System.Web.HttpResponse" /> オブジェクトが使用できません。</exception>
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="ResponseEncoding">
      <MemberSignature Language="C#" Value="public string ResponseEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResponseEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ResponseEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ResponseEncoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseEncoding : string with get, set" Usage="System.Web.UI.Page.ResponseEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Web.HttpResponse" /> オブジェクトのエンコーディング言語を設定します。</summary>
        <value>現在の <see cref="T:System.Web.HttpResponse" /> のエンコーディング言語を格納する文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`ResponseEncoding`属性を .aspx ファイルで、ディレクティブを使用する値にします。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData RouteData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteData RouteData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.RouteData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RouteData As RouteData" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RouteData ^ RouteData { System::Web::Routing::RouteData ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RouteData : System.Web.Routing.RouteData" Usage="System.Web.UI.Page.RouteData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="P:System.Web.Routing.RequestContext.RouteData" /> インスタンスの <see cref="T:System.Web.Routing.RequestContext" /> 値を取得します。</summary>
        <value>現在の <see cref="P:System.Web.Routing.RequestContext.RouteData" /> インスタンスの <see cref="T:System.Web.Routing.RequestContext" /> 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページが ASP.NET ルーティングを通じて行われた要求に対する応答で実行されている場合、このプロパティは、ルート データとして渡された URL パラメーター値へのアクセスを提供します。 このプロパティは、実行する場合、ページのルート URL ではなく物理 URL への応答、`null`です。 次の例は、という名前は URL パラメーターの値を抽出する方法を示しています。`year`です。  
  
```vb  
Dim year As Integer = Convert.ToInt32(Page.RouteData.Values("year"))  
```  
  
```csharp  
int year = Convert.ToInt32(Page.RouteData.Values["year"])  
```  
  
 ルートが URL パターンを使用して定義されているかどうかは`{locale}/{year}`ドメインの`contoso.com`、および要求された URL が`contoso.com/US/2010`、 `year` 「2010」このコードを実行すると、値が含まれます。  
  
 ASP.NET ルーティングの詳細については、次を参照してください。 [ASP.NET ルーティング](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Routing.RequestContext.RouteData" />
      </Docs>
    </Member>
    <Member MemberName="SavePageStateToPersistenceMedium">
      <MemberSignature Language="C#" Value="protected internal virtual void SavePageStateToPersistenceMedium (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub SavePageStateToPersistenceMedium (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void SavePageStateToPersistenceMedium(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePageStateToPersistenceMedium : obj -&gt; unit&#xA;override this.SavePageStateToPersistenceMedium : obj -&gt; unit" Usage="page.SavePageStateToPersistenceMedium state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">ビューステート情報を格納する <see cref="T:System.Object" />。</param>
        <summary>ページのビューステート情報とコントロールの状態情報を保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A>メソッドを使用、<xref:System.Web.UI.PageStatePersister.Save%2A>のメソッド、<xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType>によって参照されるオブジェクト、<xref:System.Web.UI.Page.PageStatePersister%2A>ページのビュー状態とコントロールの状態情報を格納するプロパティです。  
  
 ASP.NET には 2 つのサブフォルダーが含まれています、<xref:System.Web.UI.PageStatePersister>クラス、 <xref:System.Web.UI.HiddenFieldPageStatePersister> ASP.NET ページに含まれる非表示フィールドの状態情報を保存するクラスと<xref:System.Web.UI.SessionPageStatePersister>で状態を保存するクラス、<xref:System.Web.UI.Page.Session%2A>オブジェクトに関連付けられている、要求。 使用すると、<xref:System.Web.UI.SessionPageStatePersister>クラスがポストバックを決定するのに使用と、非表示の VIEWSTATE フィールドは引き続きレンダリングされます。  
  
 任意の場所で状態を保存する必要がありますを作成する新しいの子孫、<xref:System.Web.UI.PageStatePersister>クラスを保存し、任意の永続メディアへの状態を読み込みます。 新たに作成する例については<xref:System.Web.UI.PageStatePersister>オブジェクトを参照してください、<xref:System.Web.UI.PageStatePersister>クラスです。  
  
 .NET Framework version 1.0 または 1.1 では、保存する場合は、このメソッドをオーバーライドを使用している場合、<xref:System.Web.UI.Page>で非表示フィールド以外の何かの状態。 またをオーバーライドする必要があるように選択した場合、<xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
        <altmember cref="P:System.Web.UI.Page.PageStatePersister" />
        <altmember cref="T:System.Web.UI.PageStatePersister" />
      </Docs>
    </Member>
    <Member MemberName="SaveStateComplete">
      <MemberSignature Language="C#" Value="public event EventHandler SaveStateComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SaveStateComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.SaveStateComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SaveStateComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SaveStateComplete;" />
      <MemberSignature Language="F#" Value="member this.SaveStateComplete : EventHandler " Usage="member this.SaveStateComplete : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページで、そのページおよびそのページに含まれるコントロールのすべてのビューステート情報とコントロールの状態情報が保存された後に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 後に Web ページ上のコントロールの状態情報が保存された、<xref:System.Web.UI.Page.PreRenderComplete>イベント。 <xref:System.Web.UI.Page.SaveStateComplete>ビュー状態とページのコントロールの状態の後にイベントが発生し、ページ上のコントロールは、永続化に使用するメディアに保存されます。  
  
 これは、最後のページが要求側のブラウザーにレンダリングされる前に発生するイベントです。  
  
 イベント処理の詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Page.InitComplete" />
        <altmember cref="E:System.Web.UI.Page.LoadComplete" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.UI.Page.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.HttpServerUtility" /> クラスのインスタンスである <see langword="Server" /> オブジェクトを取得します。</summary>
        <value>ページに関連付けられている現在の <see langword="Server" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、頻繁に使用されるへのアクセスを提供<xref:System.Web.HttpServerUtility.HtmlEncode%2A>と<xref:System.Web.HttpServerUtility.MapPath%2A>の他のメソッドです。  
  
   
  
## Examples  
 次のコード例を使用して、サーバーからエラー情報にアクセスする方法を示しています、`Server`オブジェクト。 具体的から要求された URL の取得の例、`Request`オブジェクトから最新のエラー、`Server`オブジェクト (を使用して、<xref:System.Web.HttpServerUtility.GetLastError%2A>メソッド) と、その両方をクライアントで表示できる文字列に変換します。 1 回、`message`変数が、クライアントに書き込まれるを使用して、エラーを削除、<xref:System.Web.HttpServerUtility.ClearError%2A>メソッドです。  
  
 [!code-csharp[System.Web.UI.Page_Error method#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Error method/CS/sourcecs.aspx#1)]
 [!code-vb[System.Web.UI.Page_Error method#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Error method/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpServerUtility" />
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Session" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.UI.Page.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET が提供している現在の <see langword="Session" /> オブジェクトを取得します。</summary>
        <value>現在のセッション状態データ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、現在の要求のセッションに関する情報を提供します。 A `Session` ASP.NET アプリケーションからのページまたはドキュメントを要求するユーザーごとにオブジェクトが保持されます。 格納されている変数、`Session`ユーザーがアプリケーションでページ間を移動すると、オブジェクトが破棄されません。 ユーザーは、アプリケーション内のページにアクセスする限り、代わりに、これらの変数を永続化します。 セッション状態の詳細については、次を参照してください。 [ASP.NET セッション状態の概要](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc)です。  
  
   
  
## Examples  
 次のコード例を作成、 `GetStyle` Web フォーム ページのセッションの状態で格納されているキーを取得し、その値を文字列に変換する関数。  
  
 [!code-csharp[Page.Session_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Session_Samples1/CS/sessioncs.aspx#1)]
 [!code-vb[Page.Session_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Session_Samples1/VB/sessionvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">セッション情報が <see langword="null" /> に設定されると発生します。</exception>
        <altmember cref="T:System.Web.HttpException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetFocus">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ブラウザーのフォーカスを、指定したコントロールに設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetFocus (clientID As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::String ^ clientID);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : string -&gt; unit" Usage="page.SetFocus clientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">フォーカスを設定するコントロールの ID。</param>
        <summary>ブラウザーのフォーカスを、指定した ID を持つコントロールに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.SetFocus%2A>ブラウザーで表示される Web ページにアクティブなコントロールの文字列を指定した ID を持つコントロールを作成するメソッド。 <xref:System.Web.UI.Page.SetFocus%2A>ページがクライアントに表示用に準備する前に、メソッドを呼び出す必要があります、<xref:System.Web.UI.Control.PreRender>イベント。  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A>メソッドがサポートする ECMAScript バージョン 1.3 またはそれ以降のブラウザーでのみ動作します。  
  
   
  
## Examples  
 次のコード例は、Web ページで、2 つ目のテキスト ボックスに、フォーカスを設定します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-aspx-csharp[PageSetFocus#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbyidcs.aspx#1)]
 [!code-aspx-vb[PageSetFocus#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbyidvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="clientID" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> は、コントロールが Web フォーム ページの一部ではない場合に呼び出されます。  \- - または -  <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> は、<see cref="E:System.Web.UI.Control.PreRender" /> イベントの後に呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetFocus(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.SetFocus : System.Web.UI.Control -&gt; unit" Usage="page.SetFocus control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">フォーカスを受け取るコントロール。</param>
        <summary>ブラウザーのフォーカスを、指定したコントロールに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.SetFocus%2A>を指定したコントロール、ブラウザーで表示される Web ページ上のアクティブ コントロールを作成するメソッド。 <xref:System.Web.UI.Page.SetFocus%2A>ページがクライアントに表示用に準備する前に、メソッドを呼び出す必要があります、<xref:System.Web.UI.Control.PreRender>イベント。  
  
> [!NOTE]
>  <xref:System.Web.UI.Page.SetFocus%2A>メソッドがサポートする ECMAScript バージョン 1.3 またはそれ以降のブラウザーでのみ動作します。  
  
   
  
## Examples  
 次のコード例は、Web ページで、2 つ目のテキスト ボックスに、フォーカスを設定します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-aspx-csharp[PageSetFocus#2](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbycontrolcs.aspx#2)]
 [!code-aspx-vb[PageSetFocus#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbycontrolvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> は、コントロールが Web フォーム ページの一部ではない場合に呼び出されます。  \- - または -  <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> は、<see cref="E:System.Web.UI.Control.PreRender" /> イベントの後に呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipFormActionValidation">
      <MemberSignature Language="C#" Value="public bool SkipFormActionValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipFormActionValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SkipFormActionValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipFormActionValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipFormActionValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipFormActionValidation : bool with get, set" Usage="System.Web.UI.Page.SkipFormActionValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クエリ文字列値が検証されるかどうかを示す値を取得または設定します。</summary>
        <value>クエリ文字列の検証をスキップする場合 (クエリ文字列を検証しません) は <see langword="true" />。それ以外の場合で、クエリ文字列の検証を通常どおりに行う場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SmartNavigation">
      <MemberSignature Language="C#" Value="public bool SmartNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SmartNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SmartNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Property SmartNavigation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SmartNavigation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SmartNavigation : bool with get, set" Usage="System.Web.UI.Page.SmartNavigation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is Page.SetFocus and Page.MaintainScrollPositionOnPostBack. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スマート移動できるかどうかを示す値を取得または設定します。 このプロパティの使用は非推奨とされます。</summary>
        <value>スマート移動が有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`SmartNavigation`属性を`true`.aspx ファイルでは、ディレクティブにします。 ページが要求されたときに、動的に生成されたクラスは、このプロパティを設定します。  
  
> [!NOTE]
>  ASP.NET version 2.0 では、<xref:System.Web.UI.Page.SmartNavigation%2A>プロパティは推奨されなくなりました。 使用して、<xref:System.Web.UI.Page.SetFocus%2A>メソッドおよび<xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A>プロパティ代わりにします。  
  
 Microsoft Internet Explorer 5.5 ブラウザー、または後で、スマート ナビゲーションによってページが要求された場合は、次を実行して、ページのユーザーのエクスペリエンスが向上します。  
  
-   ナビゲーションの原因となった flash を排除します。  
  
-   ページ間を移動するときは、スクロール位置を保持します。  
  
-   ナビゲーションの間で要素のフォーカスを保持します。  
  
-   ブラウザーの履歴の最後のページ状態のみを保持します。  
  
 スマート ナビゲーションは、頻繁なポストバックを必要とする ASP.NET ページではなく、戻り値の大きな変化はない visual のコンテンツを最も効果的です。 このプロパティを設定するかどうかを決定する際に慎重に検討この`true`です。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.Page.SetFocus" />
        <altmember cref="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      </Docs>
    </Member>
    <Member MemberName="StyleSheetTheme">
      <MemberSignature Language="C#" Value="public virtual string StyleSheetTheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StyleSheetTheme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.StyleSheetTheme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property StyleSheetTheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StyleSheetTheme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StyleSheetTheme : string with get, set" Usage="System.Web.UI.Page.StyleSheetTheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ ライフ サイクルの初期段階でページに適用されるテーマの名前を取得または設定します。</summary>
        <value>ページ ライフ サイクルの初期段階でページに適用されるテーマの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、カスケード スタイル シート (CSS) に直接参照していません。 プロパティには、その中の CSS ファイルを含めることができる ASP.NET のテーマの名前が含まれています。  
  
 <xref:System.Web.UI.Page.StyleSheetTheme%2A>一方、プロパティがページのライフ サイクルの早い段階で、ページに適用されているテーマの名前を指定、<xref:System.Web.UI.Page.Theme%2A>プロパティ ページのライフ サイクルの後半のページに適用されているテーマの名前を指定します。 つまり、ページの設定は優先されるスタイル シートのテーマでの設定。 詳細については、次を参照してください。 [ASP.NET のテーマとスキン](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)です。  
  
 通常、ページ ディレクティブまたはプロパティをオーバーライドすることでは、このプロパティの値を設定します。 については、次のトピックを参照してください。  
  
-   [方法: ASP.NET のテーマを適用](http://msdn.microsoft.com/library/f9d72364-4d77-4b73-84be-7630dc63e0fe)  
  
-   [方法: ASP.NET のテーマをプログラムによって適用](http://msdn.microsoft.com/library/02eed7c3-01e8-4e20-8358-df47dbd4f148))  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> メソッドを呼び出した後で <see cref="M:System.Web.UI.Page.FrameworkInitialize" /> プロパティを設定しようとしました。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> が無効なテーマ名に設定されています。 この例外がスローされるのは、<see cref="M:System.Web.UI.Page.FrameworkInitialize" /> メソッドが呼び出されるが、プロパティ Set アクセス操作子によって呼び出されるのではないときです。</exception>
        <altmember cref="P:System.Web.UI.Page.Theme" />
      </Docs>
    </Member>
    <Member MemberName="Theme">
      <MemberSignature Language="C#" Value="public virtual string Theme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Theme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Theme" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Theme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Theme { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Theme : string with get, set" Usage="System.Web.UI.Page.Theme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ テーマの名前を取得または設定します。</summary>
        <value>ページ テーマの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.Theme%2A>プロパティ ページを使用するテーマの名前を設定します。 テーマの設定よりも優先する ページで設定する場合は、使用、<xref:System.Web.UI.Page.StyleSheetTheme%2A>プロパティです。 詳細については、次を参照してください。 [ASP.NET のテーマとスキン](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)です。  
  
 <xref:System.Web.UI.Page.Theme%2A>前にプロパティを設定する必要があります、<xref:System.Web.UI.Page.PreInit>イベント以外の設定、<xref:System.Web.UI.Page.Theme%2A>後プロパティ、<xref:System.Web.UI.Page.PreInit>イベントが発生、<xref:System.InvalidOperationException>例外。  
  
 指定されたテーマは、アプリケーションまたはグローバル テーマのいずれかとして存在する必要があります。 テーマが存在しない場合、<xref:System.Web.HttpException>例外がスローされます。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Web.UI.Page.Theme%2A>クエリ文字列内の名前プロパティに渡されます。  
  
 [!code-csharp[PageTheme#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageTheme/CS/pagethemecs.aspx#1)]
 [!code-vb[PageTheme#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageTheme/VB/pagethemevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.Theme" /> イベントが発生した後、<see cref="E:System.Web.UI.Page.PreInit" /> を設定しようとしました。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.Theme" /> が無効なテーマ名に設定されています。</exception>
        <altmember cref="P:System.Web.UI.Page.StyleSheetTheme" />
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Web.UI.Page.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページのタイトルを取得または設定します。</summary>
        <value>ページのタイトル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Page.Title%2A>プロパティを要求元のブラウザーに送信された HTML ヘッダーのページのタイトルを設定します。  
  
> [!NOTE]
>  ページを含める必要があります、`head`要素、属性を持つ`runat="server"`、それ以外の場合、タイトルが表示されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.Title" /> プロパティには、ページ上のヘッダー コントロールが必要です。</exception>
        <altmember cref="T:System.Web.UI.HtmlControls.HtmlTitle" />
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.UI.Page.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の Web 要求に対する <see cref="T:System.Web.TraceContext" /> オブジェクトを取得します。</summary>
        <value>現在の Web 要求に対する <see cref="T:System.Web.TraceContext" /> オブジェクトのデータ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 トレースは、追跡し、Web 要求に関する実行の詳細を表示します。 トレース データをページに表示する、ページまたはアプリケーション レベルでトレースを有効にする必要があります。  
  
 既定では、ページのトレースが無効です。 ページのトレースを有効にするには、ディレクティブを使って`<% @ Page trace="true" %>`です。 アプリケーション全体のトレースを有効にするには、アプリケーションの構成ファイル、アプリケーションのルート ディレクトリに配置され、web.config ファイルで有効にする必要があります。 詳細については、次を参照してください。 [ASP.NET のトレースの概要](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416)です。  
  
   
  
## Examples  
 次のコード例へのアクセスを示しています、<xref:System.Web.TraceContext.IsEnabled%2A?displayProperty=nameWithType>プロパティおよび<xref:System.Web.TraceContext.Write%2A?displayProperty=nameWithType>メソッドによって、<xref:System.Web.UI.Page.Trace%2A>プロパティです。 このコードを呼び出す、<xref:System.Diagnostics.Trace.Write%2A>メソッドをトレースする場合にのみが有効になって、<xref:System.Web.UI.Page>オブジェクト。 これは有効でない場合、このコードは実行されません、アプリケーションのオーバーヘッドの削減に役立ちます。  
  
 [!code-csharp[System.Web.UI.Page.Trace#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Trace/CS/trace1cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Trace#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Trace/VB/trace1vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceEnabled">
      <MemberSignature Language="C#" Value="public bool TraceEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TraceEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TraceEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TraceEnabled : bool with get, set" Usage="System.Web.UI.Page.TraceEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Page" /> オブジェクトのトレースが有効であるかどうかを示す値を設定します。</summary>
        <value>ページのトレースが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、`Trace`属性を`true`.aspx ファイルでは、ディレクティブにします。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceModeValue" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TraceModeValue">
      <MemberSignature Language="C#" Value="public System.Web.TraceMode TraceModeValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.TraceMode TraceModeValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceModeValue" />
      <MemberSignature Language="VB.NET" Value="Public Property TraceModeValue As TraceMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceMode TraceModeValue { System::Web::TraceMode get(); void set(System::Web::TraceMode value); };" />
      <MemberSignature Language="F#" Value="member this.TraceModeValue : System.Web.TraceMode with get, set" Usage="System.Web.UI.Page.TraceModeValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>トレース ステートメントがページ上に表示されるモードを設定します。</summary>
        <value>
          <see cref="T:System.Web.TraceMode" /> 列挙体メンバーの 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `TraceMode` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.Trace" />
        <altmember cref="P:System.Web.UI.Page.TraceEnabled" />
        <altmember cref="T:System.Web.TraceContext" />
      </Docs>
    </Member>
    <Member MemberName="TransactionMode">
      <MemberSignature Language="C#" Value="protected int TransactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TransactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TransactionMode" />
      <MemberSignature Language="VB.NET" Value="Protected Property TransactionMode As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int TransactionMode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionMode : int with get, set" Usage="System.Web.UI.Page.TransactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページのトランザクション サポートのレベルを設定します。</summary>
        <value>
          <see cref="T:System.EnterpriseServices.TransactionOption" /> 列挙体メンバーの 1 つを表す整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ほとんどの状況では、コードでこのプロパティを設定しないでください。 設定、 `Transaction` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されると、動的に生成されたクラスは、プロパティを設定します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryUpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値プロバイダー内の値を使用して、指定されたモデル インスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model);" />
      <MemberSignature Language="F#" Value="abstract member TryUpdateModel : 'Model -&gt; bool (requires 'Model : null)&#xA;override this.TryUpdateModel : 'Model -&gt; bool (requires 'Model : null)" Usage="page.TryUpdateModel model" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <summary>データ連結コントロール内の値を使用して、指定されたモデル インスタンスを更新します。</summary>
        <returns>モデル バインドが正常に実行された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、データ バインド コントロールの指定されたメソッドからのみ呼び出す必要があります`UpdateMethod`または`InsertMethod`プロパティです。  
  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TryUpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual bool TryUpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberSignature Language="F#" Value="abstract member TryUpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; bool (requires 'Model : null)&#xA;override this.TryUpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; bool (requires 'Model : null)" Usage="page.TryUpdateModel (model, valueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <param name="valueProvider">値プロバイダー。</param>
        <summary>指定された値プロバイダー内の値を使用してモデル インスタンスを更新します。</summary>
        <returns>モデル バインドが正常に実行された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UICulture">
      <MemberSignature Language="C#" Value="public string UICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UICulture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property UICulture As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UICulture { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UICulture : string with get, set" Usage="System.Web.UI.Page.UICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページに関連付けられている <see cref="T:System.Threading.Thread" /> オブジェクトのユーザー インターフェイス (UI: User Interface) ID を設定します。</summary>
        <value>UI ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ショートカットをこのプロパティは、<xref:System.Threading.Thread.CurrentThread%2A>プロパティです。 カルチャは、実行中のスレッドのプロパティ  
  
 設定、 `UICulture` .aspx ファイルでは、ディレクティブの属性です。 ページが要求されたときに、動的に生成されたクラスは、このプロパティの値を設定します。 値を明示的に設定するさらに、<xref:System.Web.UI.Page.UICulture%2A>プロパティに、Web.config ファイルのです。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.LCID" />
        <altmember cref="P:System.Web.UI.Page.Culture" />
      </Docs>
    </Member>
    <Member MemberName="UniqueFilePathSuffix">
      <MemberSignature Language="C#" Value="protected internal virtual string UniqueFilePathSuffix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueFilePathSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property UniqueFilePathSuffix As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::String ^ UniqueFilePathSuffix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueFilePathSuffix : string" Usage="System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブラウザーをキャッシュするためのファイル パスに付加する一意のサフィックスを取得します。</summary>
        <value>ファイル パスに追加する一意のサフィックス。 既定値は "__ufps=" と一意の 6 桁の数字で構成されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.UniqueFilePathSuffix%2A>プロパティ ブラウザーのキャッシュに必要な場合は、ファイル パスの末尾に追加される文字列を返します。 文字列を使用して、特定の要求に関連付けられているファイルのパスを識別します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnobtrusiveValidationMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberSignature Language="VB.NET" Value="Public Property UnobtrusiveValidationMode As UnobtrusiveValidationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::UnobtrusiveValidationMode UnobtrusiveValidationMode { System::Web::UI::UnobtrusiveValidationMode get(); void set(System::Web::UI::UnobtrusiveValidationMode value); };" />
      <MemberSignature Language="F#" Value="member this.UnobtrusiveValidationMode : System.Web.UI.UnobtrusiveValidationMode with get, set" Usage="System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.UnobtrusiveValidationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアント側の検証で控えめな JavaScript が使用されるかどうかを示す値を取得または設定します。</summary>
        <value>控え目な JavaScript が使用されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void UnregisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UnregisterRequiresControlState(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterRequiresControlState(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.UnregisterRequiresControlState : System.Web.UI.Control -&gt; unit" Usage="page.UnregisterRequiresControlState control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">コントロールの状態の永続化を中断する <see cref="T:System.Web.UI.Control" />。</param>
        <summary>指定したコントロールの、コントロールの状態の永続化を中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの状態を使用するカスタムのサーバー コントロールを呼び出す必要があります、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>要求のたびに、状態が永続化します。 コントロールの状態のための登録が引き継がれません要求から要求をポストバック時にします。 使用して、<xref:System.Web.UI.Page.UnregisterRequiresControlState%2A>ポストバックの永続化する必要がなくなったコントロールに対して、コントロールの状態が永続化されないことを確認します。  
  
 内部的には、<xref:System.Web.UI.Page.UnregisterRequiresControlState%2A>を使用する場合、メソッドが呼び出され、<xref:System.Web.UI.Control.RemovedControl%2A>コントロールをコントロール コレクションから削除する方法です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="T:System.Web.UI.Control" /> が <see langword="null" /> です。</exception>
        <altmember cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
        <altmember cref="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値プロバイダー内の値を使用して、指定されたモデル インスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model);" />
      <MemberSignature Language="F#" Value="abstract member UpdateModel : 'Model -&gt; unit (requires 'Model : null)&#xA;override this.UpdateModel : 'Model -&gt; unit (requires 'Model : null)" Usage="page.UpdateModel model" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <summary>データ連結コントロール内の値を使用して、指定されたモデル インスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、データ バインド コントロールの指定されたメソッドからのみ呼び出す必要があります`UpdateMethod`または`InsertMethod`プロパティです。  
  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UpdateModel(Of TModel As Class) (model As TModel, valueProvider As IValueProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TModel&gt;&#xA; where TModel : class virtual void UpdateModel(TModel model, System::Web::ModelBinding::IValueProvider ^ valueProvider);" />
      <MemberSignature Language="F#" Value="abstract member UpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; unit (requires 'Model : null)&#xA;override this.UpdateModel : 'Model * System.Web.ModelBinding.IValueProvider -&gt; unit (requires 'Model : null)" Usage="page.UpdateModel (model, valueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">モデルの型。</typeparam>
        <param name="model">モデル。</param>
        <param name="valueProvider">値プロバイダー。</param>
        <summary>指定された値プロバイダー内の値を使用して、指定されたモデル インスタンスを更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web フォーム モデル バインディングの使用に関するチュートリアル シリーズは、次を参照してください。[モデル バインディング機能と Web フォーム](/aspnet/web-forms/overview/presenting-and-managing-data/model-binding/retrieving-data)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.User" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal" Usage="System.Web.UI.Page.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ要求を行っているユーザーに関する情報を取得します。</summary>
        <value>ページ要求を行っているユーザーを表す <see cref="T:System.Security.Principal.IPrincipal" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Principal.IPrincipal>オブジェクトが、コードが実行されている、そのユーザーの id を含む、ユーザーとが所属するすべての役割のセキュリティ コンテキストを表します。  
  
 このプロパティを使用して、<xref:System.Web.HttpContext>オブジェクトの<xref:System.Web.HttpContext.User%2A>要求の発生源を決定するプロパティです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.User%2A>プロパティを現在のユーザーの認証と id 情報にアクセスします。 ユーザーが認証されていない場合、ログイン ページにリダイレクトします。  
  
 [!code-csharp[Page_User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_User/CS/page_user.cs.aspx#1)]
 [!code-vb[Page_User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_User/VB/page_user.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Security.Principal.IPrincipal" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Validate">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ページに含まれている検証コントロールに対して、割り当てられた情報を検証するように指示します。</summary>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate();" />
      <MemberSignature Language="F#" Value="abstract member Validate : unit -&gt; unit&#xA;override this.Validate : unit -&gt; unit" Usage="page.Validate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページに含まれている検証コントロールに対して、割り当てられた情報を検証するように指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが任意の ASP.NET サーバー コントロールがクリックしたときに、このメソッドが呼び出される、`CausesValidation`プロパティに設定`true`、既定値です。 これらが含まれます、 <xref:System.Web.UI.WebControls.Button>、 <xref:System.Web.UI.WebControls.ImageButton>、および<xref:System.Web.UI.WebControls.LinkButton>Web サーバー コントロールを<xref:System.Web.UI.HtmlControls.HtmlInputButton>、 <xref:System.Web.UI.HtmlControls.HtmlInputImage>、および<xref:System.Web.UI.HtmlControls.HtmlButton>HTML サーバー コントロール、および、など、サーバーに自動的に投稿できるコントロール<xref:System.Web.UI.WebControls.TextBox>、 <xref:System.Web.UI.WebControls.CheckBox>、 <xref:System.Web.UI.WebControls.ListControl>、および<xref:System.Web.UI.WebControls.BulletedList>コントロール。  
  
 ボタン コントロールの設定 ページで、ボタン コントロールの検証を無効にするには、`CausesValidation`プロパティを`false`です。  
  
 このメソッドが呼び出されると、反復に含まれている検証コントロール、<xref:System.Web.UI.ValidatorCollection>オブジェクトに関連付けられている、<xref:System.Web.UI.Page.Validators%2A?displayProperty=nameWithType>プロパティし、現在の検証グループ内の各検証コントロールの検証ロジックを呼び出します。 検証グループは、サーバーに、ページのポストバック コントロールによって決定されます。 検証グループが指定されていない場合は、検証グループは使用されません。  
  
> [!NOTE]
>  ページの検証の動作が変更されました。 [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]、不要になった呼び出しの制御、<xref:System.Web.UI.Page.Validate?displayProperty=nameWithType>メソッド以外の場合を使用して、<xref:System.Web.UI.Page.Validate%28System.String%29?displayProperty=nameWithType>メソッド代わりにします。 使用する場合、<xref:System.Web.UI.Page.Validate?displayProperty=nameWithType>メソッドを[!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] ページで、検証グループは無視され、すべてのコントロールが検証されます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.Validate%2A>メソッドをいくつかの異なる検証グループのシナリオでのページを定義します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Web.UI.Page.Validate" />がメソッドを使用できません [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] です。使用する場合は [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]、オーバーライド、<see cref="M:System.Web.UI.Page.Validate(System.String)" />ページ検証の動作を変更するメソッド。</para>
        </block>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Validate (validationGroup As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Validate(System::String ^ validationGroup);" />
      <MemberSignature Language="F#" Value="abstract member Validate : string -&gt; unit&#xA;override this.Validate : string -&gt; unit" Usage="page.Validate validationGroup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">検証されるコントロールの検証グループ名。</param>
        <summary>指定した検証グループの検証コントロールに対して、割り当てられた情報を検証するように指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーが任意の ASP.NET サーバー コントロールがクリックしたときに、このメソッドが呼び出される、`CausesValidation`プロパティに設定`true`、既定値です。 これらが含まれます、 <xref:System.Web.UI.WebControls.Button>、 <xref:System.Web.UI.WebControls.ImageButton>、および<xref:System.Web.UI.WebControls.LinkButton>Web サーバー コントロールを<xref:System.Web.UI.HtmlControls.HtmlInputButton>、 <xref:System.Web.UI.HtmlControls.HtmlInputImage>、および<xref:System.Web.UI.HtmlControls.HtmlButton>HTML サーバー コントロール、および、など、サーバーに自動的に投稿できるコントロール<xref:System.Web.UI.WebControls.TextBox>、 <xref:System.Web.UI.WebControls.CheckBox>、 <xref:System.Web.UI.WebControls.ListControl>、および<xref:System.Web.UI.WebControls.BulletedList>コントロール。  
  
 ボタン コントロールの設定 ページで、ボタン コントロールの検証を無効にするには、`CausesValidation`プロパティを`false`です。  
  
 <xref:System.Web.UI.Page.Validate%2A>メソッドは、指定された検証グループを検証します。 呼び出した後、<xref:System.Web.UI.Page.Validate%2A>検証グループのメソッド、<xref:System.Web.UI.Page.IsValid%2A>メソッドが返す`true`指定された検証グループと、ページがサーバーにポストの原因となったコントロールの検証グループの両方が有効な場合にのみです。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Web.UI.Page.Validate%2A>メソッドをいくつかの異なる検証グループのシナリオでのページを定義します。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
        <altmember cref="P:System.Web.UI.Page.Validators" />
        <altmember cref="P:System.Web.UI.Page.IsValid" />
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateRequestMode : System.Web.UI.ValidateRequestMode with get, set" Usage="System.Web.UI.Page.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブラウザーからのクライアント入力の安全性をページで調べるかどうかを示す値を取得または設定します。</summary>
        <value>ページがクライアントの入力をチェックするかどうかを示す値。 既定値は、<see cref="F:System.Web.UI.ValidateRequestMode.Enabled" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値<xref:System.Web.UI.ValidateRequestMode.Inherit>で使用されていない、<xref:System.Web.UI.Page>クラスから継承する項目がないためです。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Validators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection Validators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ValidatorCollection Validators" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Validators" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Validators As ValidatorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ValidatorCollection ^ Validators { System::Web::UI::ValidatorCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Validators : System.Web.UI.ValidatorCollection" Usage="System.Web.UI.Page.Validators" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求されたページに含まれているすべての検証コントロールのコレクションを取得します。</summary>
        <value>検証コントロールのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用するには、メソッドとプロパティを操作する、<xref:System.Web.UI.ValidatorCollection>オブジェクトに現在関連付けられている<xref:System.Web.UI.Page>インスタンス。 このコレクションには、ページに含まれているすべての検証サーバー コントロールが含まれています。  
  
 呼び出す、<xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>メソッドは、現在の検証グループ内の各検証サーバー コントロールで実行するための検証ロジックをによりします。 これらのコントロールのいずれかに失敗した場合、<xref:System.Web.UI.Page.IsValid%2A?displayProperty=nameWithType>プロパティから返される`false`です。  
  
 検証コントロールの詳細については、次を参照してください。 [ASP.NET の検証コントロール](http://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ValidatorCollection" />
      </Docs>
    </Member>
    <Member MemberName="VerifyRenderingInServerForm">
      <MemberSignature Language="C#" Value="public virtual void VerifyRenderingInServerForm (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyRenderingInServerForm(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.VerifyRenderingInServerForm(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void VerifyRenderingInServerForm(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member VerifyRenderingInServerForm : System.Web.UI.Control -&gt; unit&#xA;override this.VerifyRenderingInServerForm : System.Web.UI.Control -&gt; unit" Usage="page.VerifyRenderingInServerForm control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">
          <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> コントロール内に配置する必要がある ASP.NET サーバー コントロール。</param>
        <summary>実行時に、指定された ASP.NET サーバー コントロールに <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> コントロールが表示されることを確認します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 内部にある必要があるコントロール`<form runat=server>`タグの外側に配置されるかどうか、エラー メッセージが表示されるように表示されるか前に、タグはこのメソッドを呼び出すことができます。 ポストバックまたは登録されたスクリプト ブロックに依存しているコントロールのオーバーライドでこのメソッドを呼び出す必要があります、<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>メソッドです。 サーバーのフォーム要素の表示方法が異なるページには、さまざまな条件で例外をスローするには、このメソッドをオーバーライドできます。  
  
 それらがで囲まれていない場合、ポストバックまたはクライアント側スクリプトを使用するサーバー コントロールは機能しません、<xref:System.Web.UI.HtmlControls.HtmlForm>サーバー コントロール (<`form runat="server">`) タグ。 囲まれていない、ときに、クリア エラー メッセージを表示するときに、これらのコントロールはこのメソッドを呼び出すことができます、<xref:System.Web.UI.HtmlControls.HtmlForm>コントロール。  
  
 カスタム サーバー コントロールを開発するときにするが一般的をオーバーライドする場合は、このメソッドを呼び出す、 `Render` input タグの任意の種類の方法です。 これは、入力コントロールを呼び出す場合に特に重要<xref:System.Web.UI.Page.GetPostBackEventReference%2A>、またはクライアント スクリプトを出力します。 複合サーバー コントロールは、この呼び出しを行う必要はありません。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Web.UI.Page.Render%2A?displayProperty=nameWithType>カスタム サーバー コントロールのメソッドです。 このコントロールは、ページにそのコンテンツを書き込むを使用して、<xref:System.Web.UI.Page.VerifyRenderingInServerForm%2A>開始タグと終了タグの間、コントロールが表示されることを確認するメソッド、<xref:System.Web.UI.HtmlControls.HtmlForm>コントロール。  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#3)]
 [!code-vb[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/vb/testlinkbutton.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">実行時に、指定されたサーバー コントロールが <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> サーバー コントロールの開始タグと終了タグの間に含まれていません。</exception>
        <exception cref="T:System.ArgumentNullException">検証するコントロールが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateEncryptionMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateEncryptionMode As ViewStateEncryptionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::ViewStateEncryptionMode ViewStateEncryptionMode { System::Web::UI::ViewStateEncryptionMode get(); void set(System::Web::UI::ViewStateEncryptionMode value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateEncryptionMode : System.Web.UI.ViewStateEncryptionMode with get, set" Usage="System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ビューステートの暗号化モードを取得または設定します。</summary>
        <value>
          <see cref="T:System.Web.UI.ViewStateEncryptionMode" /> 値のいずれか。 既定値は <see cref="F:System.Web.UI.ViewStateEncryptionMode.Auto" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A>コードでプロパティを設定することはできません。 のみ設定できますディレクティブまたは、< 構成ファイルの要素。 値は、ディレクティブのオーバーライドで、構成ファイルで設定された値を設定します。  
  
 ディレクティブ内でこのプロパティを設定するための構文は次のとおりです。  
  
```vb  
<%@ Page Language="VB" ViewStateEncryptionMode="Always" %>  
```  
  
```csharp  
<%@ Page Language="C#" ViewStateEncryptionMode="Always" %>  
```  
  
 構成ファイルでこのプロパティを設定するための構文は次のとおりです。  
  
```vb  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
```csharp  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
 カスタム コントロールの開発者は、コントロールの状態を表示する機密性の高いデータを保存する前にコードでこのプロパティの値を確認してみてください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">設定される値は、<see cref="T:System.Web.UI.ViewStateEncryptionMode" /> 列挙体のメンバーではありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Web.UI.Page.ViewStateEncryptionMode" /> プロパティは、ページの有効期間内の <see langword="PreRender" />フェーズで、またはこのフェーズの前でだけ設定できます。</exception>
        <altmember cref="T:System.Web.UI.ViewStateEncryptionMode" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateUserKey">
      <MemberSignature Language="C#" Value="public string ViewStateUserKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ViewStateUserKey" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateUserKey" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewStateUserKey As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ViewStateUserKey { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ViewStateUserKey : string with get, set" Usage="System.Web.UI.Page.ViewStateUserKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のページに関連付けられているビューステート変数で、個別のユーザーに ID を割り当てます。</summary>
        <value>個別のユーザーの ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定、<xref:System.Web.UI.Page.ViewStateUserKey%2A>プロパティを使用して、悪意のあるユーザーからアプリケーションへの攻撃を防止できます。 これは、識別子、ビュー ステートを変数に割り当てる各ユーザーの攻撃を生成する、変数が使用できないようにすることによりします。 Web 攻撃およびそれらを防ぐために何ができるについての詳細については、次を参照してください。[かかるの ASP.NET 組み込み機能を利用 Web 攻撃オフ何とか](http://go.microsoft.com/fwlink/?LinkId=163557)です。  
  
 ユーザーに認証された名前など、このプロパティを任意の文字列値に設定することができます、または<xref:System.Web.SessionState.HttpSessionState.SessionID%2A>値。  
  
> [!NOTE]
>  中にこのプロパティを設定する必要があります、`Page_Init`ページ処理の段階です。 中にこのプロパティの設定、`Page_Load`フェーズが例外をスローします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">ページ処理中、<see cref="P:System.Web.UI.Page.ViewStateUserKey" /> プロパティへのアクセスが遅すぎました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.Page.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Page" /> オブジェクトが表示されているかどうかを示す値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Web.UI.Page" /> が表示される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例のセット、<xref:System.Web.UI.Page.Visible%2A>プロパティを`false`ページの表示内容を非表示にします。 このページが最初に要求されたときに、データ ソースが設定され、ページに表示されます。 ユーザーは、ボタンをクリックしたときに、`HideButton_Click`イベント ハンドラーは、レンダリングされたページのコンテンツ全体を非表示にします。  
  
 [!code-csharp[Page_Visible#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_Visible/CS/page_visible.cs.aspx#1)]
 [!code-vb[Page_Visible#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_Visible/VB/page_visible.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.UI.TemplateControl" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
  </Members>
</Type>