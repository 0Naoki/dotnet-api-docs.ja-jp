<Type Name="Control" FullName="System.Web.UI.Control">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c5e204b7a88d9c05e9f718f5fcc598809702c48c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610876" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Implements IComponent, IControlBuilderAccessor, IControlDesignerAccessor, IDataBindingsAccessor, IDisposable, IExpressionsAccessor, IParserAccessor, IUrlResolutionService" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : IDisposable, System::ComponentModel::IComponent, System::Web::UI::IControlBuilderAccessor, System::Web::UI::IControlDesignerAccessor, System::Web::UI::IDataBindingsAccessor, System::Web::UI::IExpressionsAccessor, System::Web::UI::IParserAccessor, System::Web::UI::IUrlResolutionService" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ID")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Code")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>すべての ASP.NET サーバー コントロールによって共有されるプロパティ、メソッド、およびイベントを定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、カスタム ASP.NET サーバー コントロールを開発するときにから派生する主要なクラスです。 <xref:System.Web.UI.Control> ユーザー インターフェイス (UI) の特定の機能はありません。 派生して、UI がないか、独自の UI をレンダリングするその他のコントロールを結合するコントロールを作成している場合<xref:System.Web.UI.Control>です。 UI コントロールを作成している場合から派生<xref:System.Web.UI.WebControls.WebControl>でいずれかを制御または、<xref:System.Web.UI.WebControls>カスタム コントロールの適切な開始を提供する名前空間をポイントします。  
  
 <xref:System.Web.UI.Control>クラスは、カスタム コントロール、ユーザー コントロール、ページなど、すべての ASP.NET サーバー コントロールの基底クラスです。 ASP.NET ページのインスタンスである、<xref:System.Web.UI.Page>から継承されるクラスが、<xref:System.Web.UI.Control>クラス、およびを .aspx 拡張子を持つファイルに対する要求を処理します。  
  
 <xref:System.Web.UI.Control>クラスできる直接的または間接的のとして使用されるユーザー インターフェイスの一部のセキュリティで保護されたコードの記述およびアプリケーションのセキュリティ保護が後に確認のベスト プラクティスを Web アプリケーション、およびようを調査する必要があります。  
  
 これらのトピックの概要については、次を参照してください。[概要の Web アプリケーション セキュリティの脅威](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a)、 [NIB: セキュリティ ポリシーのベスト プラクティス](http://msdn.microsoft.com/library/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05)、および[セキュリティの基本概念](~/docs/standard/security/key-security-concepts.md)です。 詳細については、次を参照してください。[標準コントロールのセキュリティで保護する](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8)、[する方法: 安全なエラー メッセージを表示](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa)、[する方法: 保護に対してスクリプトによる攻略の文字列を HTML エンコードを適用することによって、Web アプリケーションで](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b)、および[検証コントロールの概要](http://msdn.microsoft.com/library/3c0e7514-cff2-4bed-936d-ee3f7b740190)です。  
  
   
  
## Examples  
 次の例では、カスタム サーバー コントロールから派生した、<xref:System.Web.UI.Control>クラスです。 `InnerContent`クラスのオーバーライド、<xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType>メソッドを確認かどうかクラス ページで子コントロールがあるし、コントロールの最初の子がリテラル コントロールかどうかを判断します。 オーバーライドされたメソッドが HTML 文字列を書き込む 2 つの条件が満たされた場合\<H2 >、メッセージ: literal コントロール、および終了タグの内容\</H2 > タグを Web フォーム ページ。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Classic Control Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.UI.Page" />
    <altmember cref="T:System.Web.UI.TemplateControl" />
    <altmember cref="T:System.Web.UI.LiteralControl" />
    <altmember cref="T:System.Web.UI.WebControls.WebControl" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Control" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Adapter As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::ControlAdapter ^ Adapter { System::Web::UI::Adapters::ControlAdapter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール用のブラウザー固有のアダプターを取得します。</summary>
        <value>このコントロールの <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。 対象のブラウザーでアダプターが不要な場合は <see langword="null" /> が返されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web ページは、さまざまなデバイスや Web サイトから情報を要求できるブラウザーの間で使用可能です。 <xref:System.Web.UI.Control.Adapter%2A>プロパティから返される、<xref:System.Web.UI.Adapters.ControlAdapter>要求元のデバイスまたはブラウザーの画面でコントロールを描画するオブジェクト。  
  
 アダプターの詳細については、次を参照してください。[アーキテクチャの概要のアダプティブ動作を制御](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void AddedControl(System::Web::UI::Control ^ control, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">追加された <see cref="T:System.Web.UI.Control" />。</param>
        <param name="index">このコントロールの <see cref="P:System.Web.UI.Control.Controls" /> コレクション内でのインデックス。</param>
        <summary>子コントロールが <see cref="T:System.Web.UI.Control" /> オブジェクトの <see cref="P:System.Web.UI.Control.Controls" /> コレクションに追加された後に呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.AddedControl%2A>メソッドは、コントロールに追加した直後に、<xref:System.Web.UI.Control.Controls%2A>コレクション。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="control" /> が <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddParsedSubObject (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddParsedSubObject(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">解析された要素を表す <see cref="T:System.Object" />。</param>
        <summary>XML または HTML のいずれかの要素が解析されたことをサーバー コントロールに通知し、サーバー コントロールの <see cref="T:System.Web.UI.ControlCollection" /> オブジェクトに要素を追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッドをオーバーライドする場合を除き、このメソッドは自動的に追加<xref:System.Web.UI.LiteralControl>オブジェクトをサーバー コントロールの<xref:System.Web.UI.ControlCollection>オブジェクト。 このコレクションは経由でアクセスできる<xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType>プロパティです。  
  
   
  
## Examples  
 次の例は、カスタム サーバー コントロールを使用する、<xref:System.Web.UI.Control.AddParsedSubObject%2A>開始タグと終了タグのこのコントロールの間の要素が宣言されているかどうかを決定するメソッドは<xref:System.Web.UI.WebControls.TextBox>Web サーバー コントロールです。 追加される場合は、<xref:System.Collections.ArrayList>オブジェクト、`items`です。 ときに、オーバーライドされた<xref:System.Web.UI.Control.CreateChildControls%2A>を反復処理メソッドが呼び出されると、<xref:System.Collections.ArrayList>に各オブジェクトを追加し、<xref:System.Web.UI.ControlCollection>カスタム サーバー コントロールのです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[Control_AddParsedSubObject#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control_AddParsedSubObject#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyStyleSheetSkin(System::Web::UI::Page ^ page);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">コントロールを格納している <see cref="T:System.Web.UI.Page" />。</param>
        <summary>ページのスタイル シートに定義されたスタイル プロパティをコントロールに適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>メソッドは、テーマのディレクトリに定義されているスキン プロパティに基づいてコントロールのスタイル プロパティを設定します。 適用するスキンのコントロールの既定スキンか、またはスキン指定で、<xref:System.Web.UI.Control.SkinID%2A>プロパティです。 <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>ページに配置されている宣言型のコントロールのメソッドが ASP.NET によって呼び出されます。 呼び出す必要があります、<xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A>メソッドでプログラムによって作成されたすべてのコントロールをランタイムにスタイル シートのスキンをコントロールに適用します。 テーマのスキンは自動的に適用されます。 テーマやカスケード スタイル シートの違いの詳細については、次を参照してください。 [ASP.NET のテーマとスキン](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">スタイル シートが既に適用されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property AppRelativeTemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeTemplateSourceDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールが含まれている <see cref="T:System.Web.UI.Page" /> オブジェクトまたは <see cref="T:System.Web.UI.UserControl" /> オブジェクトのアプリケーション相対の仮想ディレクトリを取得または設定します。</summary>
        <value>このコントロールを格納しているページまたはユーザー コントロールのアプリケーション相対の仮想ディレクトリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>プロパティには、現在のコントロールを含むページやユーザー コントロールへのアプリケーションの相対パスが含まれています。 Web ページが存在する場合など、 http://www.contoso.com/application/subdirectory、<xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>プロパティから返される"~/サブディレクトリ"です。  
  
 仮想パス (「アプリケーション/サブディレクトリ」) を返すを使用して、<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BeginRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BeginRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">トレース データを書き込むオブジェクト。</param>
        <param name="traceObject">トレース オブジェクト。</param>
        <summary>レンダリング データのデザイン時のトレースを開始します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BindingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ BindingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールのデータ バインディングを格納しているコントロールを取得します。</summary>
        <value>このコントロールのデータ バインディングを格納している <see cref="T:System.Web.UI.Control" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.BindingContainer%2A>プロパティにはへの参照が含まれています、<xref:System.Web.UI.Control>を現在のコントロールのデータ バインド情報を含むオブジェクト。  
  
 <xref:System.Web.UI.Control.BindingContainer%2A>プロパティと同じ、<xref:System.Web.UI.Control.NamingContainer%2A>プロパティ、コントロールが、テンプレートの一部が場合を除き、します。 その場合は、<xref:System.Web.UI.Control.BindingContainer%2A>プロパティに設定されている、<xref:System.Web.UI.Control>テンプレートを定義します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BuildProfileTree (parentId As String, calcViewState As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BuildProfileTree(System::String ^ parentId, bool calcViewState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">コントロールの親の識別子。</param>
        <param name="calcViewState">ビューステートのサイズを計算するかどうかを示すブール値。</param>
        <summary>ページのトレースが有効な場合、サーバー コントロールに関する情報を収集し、これを表示するために <see cref="P:System.Web.UI.Page.Trace" /> プロパティに渡します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティ ページの UI の階層構造のために必要な情報を収集し、これをページの[&lt;トレース&gt;](~/docs/framework/configure-apps/file-schema/trace-debug/trace-element.md)プロパティです。 表示される情報のページまたは、アプリケーションのトレースを有効にすると、`Control Tree`トレース出力のセクションです。 ページのトレース出力が末尾に追加するページの中に、アプリケーションのトレース出力は、アプリケーションのルート ディレクトリに格納されているトレース viewer (trace.axd ファイル) から表示することができます。 トレースの詳細については、次を参照してください。 [ASP.NET のトレースの概要](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416)です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberSignature Language="VB.NET" Value="Protected Property ChildControlsCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ChildControlsCreated { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールの子コントロールが作成されたかどうかを示す値を取得します。</summary>
        <value>
          子コントロールが作成された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、オーバーライド、<xref:System.Web.UI.Control.OnDataBinding%2A>カスタム メソッド<xref:System.Web.UI.WebControls.Repeater>コントロール。 データ バインディングが再度発生するまでの子コントロールが作成されないことを確認する、<xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティに設定されている`true`後、<xref:System.Web.UI.WebControls.RepeaterItem>オブジェクトが作成され、コントロールの追加<xref:System.Web.UI.ControlCollection>オブジェクト。  
  
 [!code-csharp[TemplatedDataBoundControl3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]  
  
 次の例では、Web ページでカスタム コントロールを使用する方法を示します。  
  
 [!code-aspx-csharp[TemplatedDataBoundControl3#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-aspx-vb[TemplatedDataBoundControl3#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearCachedClientID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearCachedClientID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キャッシュされた <see cref="P:System.Web.UI.Control.ClientID" /> 値を <see langword="null" /> に設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildControlState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールのすべての子コントロールについて、コントロールの状態情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClearChildControlState%2A>メソッドは、テンプレート化されたデータ バインドされたサーバー コントロールのデータ バインディングの子をコントロールするときなど、新しい子コントロールが作成されると、親コントロールのコントロールの状態に書き込まれる子コントロールの状態情報がオーバーライドされた場合に使用します。 呼び出す、<xref:System.Web.UI.Control.ClearChildControlState%2A>メソッドを呼び出す前に空の子コントロール、<xref:System.Web.UI.Control.SaveControlState%2A>メソッドが格納されているまたは送信される必要があるコントロールの状態情報のサイズを縮小します。  
  
 子コントロールを再作成する場合、<xref:System.Web.UI.Control>オブジェクトを使用して、<xref:System.Web.UI.Control.ClearChildControlState%2A>メソッドには適用されないように、取得、新しいコントロールを誤ってに子コントロールの状態をオフにします。  
  
 両方を削除する子コントロールの状態と表示状態を使用して、<xref:System.Web.UI.Control.ClearChildState%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールのすべての子コントロールのビューステート情報およびコントロールの状態情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClearChildState%2A>メソッドは、子コントロールのすべてのビュー ステートとコントロールの状態情報をクリアします。 両方を呼び出すことに相当する、<xref:System.Web.UI.Control.ClearChildViewState%2A>メソッドおよび<xref:System.Web.UI.Control.ClearChildControlState%2A>メソッドです。  
  
 子コントロールを再作成する場合、<xref:System.Web.UI.Control>オブジェクトを使用して、<xref:System.Web.UI.Control.ClearChildState%2A>メソッドには適用されないように、取得、新しいコントロールを誤って子の状態をオフにします。  
  
   
  
## Examples  
 次のコード例をオーバーライドする方法を示しています、<xref:System.Web.UI.Control.OnDataBinding%2A>テンプレート化されたデータ バインド コントロールのメソッドです。 場合は、コントロールがバインドされるデータ ソースが作成されますが、コントロールの<xref:System.Web.UI.ControlCollection>コレクションは空になるを使用して、<xref:System.Web.UI.ControlCollection.Clear%2A>メソッド、および<xref:System.Web.UI.Control.ClearChildState%2A>子コントロールの保存されていたすべての状態情報を削除するメソッドを使用します。  
  
 [!code-csharp[TemplatedDataBoundControl2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildViewState" />
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChildViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChildViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールのすべての子コントロールのビューステート情報を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーライドする場合、このメソッドは通常使用、<xref:System.Web.UI.Control.DataBind%2A>メソッド テンプレート化されたデータ バインドされたサーバー コントロールを開発するときにします。 このメソッドを呼び出さない場合、子コントロールのビューステート情報が親サーバー コントロール、データがバインドされている場合にオーバーライドされますに書き込まれますことができます。  
  
 子コントロールを再作成する場合、<xref:System.Web.UI.Control>を使用して、<xref:System.Web.UI.Control.ClearChildViewState%2A>メソッドには適用されないように、取得、新しいコントロールを誤って子ビュー ステートをオフにします。  
  
 詳細については、このメソッドを使用して、次を参照してください。[する方法: テンプレートの ASP.NET ユーザー コントロールを作成](http://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
        <altmember cref="M:System.Web.UI.Control.ClearChildControlState" />
        <altmember cref="M:System.Web.UI.Control.ClearChildState" />
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearEffectiveClientIDMode ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearEffectiveClientIDMode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のコントロール インスタンスおよびすべての子コントロールの <see cref="P:System.Web.UI.Control.ClientIDMode" /> プロパティを <see cref="F:System.Web.UI.ClientIDMode.Inherit" /> に設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ClientID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ClientID { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ASP.NET によって生成される HTML マークアップのコントロール ID を取得します。</summary>
        <value>ASP.NET によって生成される HTML マークアップのコントロール ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web サーバー コントロールが、HTML 要素としてレンダリングされるとき、 `id` HTML 要素の属性がの値に設定されている、<xref:System.Web.UI.Control.ClientID%2A>プロパティです。 <xref:System.Web.UI.Control.ClientID%2A>要素にアクセスする、HTML でクライアント スクリプトを使用して値が使用される多くの場合、`document.getElementById`メソッドです。 ID は、要素のスタイルを指定する CSS 規則にもよく使用されます。 たとえば、次の CSS スタイル規則がすべて選択`span`を持つ要素、`id`属性の値の`ProductIDLabel`設定とその`background-color`属性を`white`:  
  
```  
span#ProductIDLabel { background-color: white; }  
```  
  
 ASP.NET には、生成する方法について複数のアルゴリズムが用意されています、<xref:System.Web.UI.Control.ClientID%2A>プロパティの値。 コントロールに設定して使用するアルゴリズムを選択するその<xref:System.Web.UI.Control.ClientIDMode%2A>プロパティです。 アルゴリズムがで識別される、<xref:System.Web.UI.ClientIDMode>次の表に記載されている列挙値。  
  
|[値]|説明|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A> 値は、それぞれの親名前付けコンテナーの <xref:System.Web.UI.Control.ID%2A> 値とコントロールの <xref:System.Web.UI.Control.ID%2A> 値を連結することにより生成されます。 コントロールの複数のインスタンスが表示されるデータ バインディング シナリオでは、コントロールの <xref:System.Web.UI.Control.ID%2A> 値の前にインクリメント値が挿入されます。 各セグメントはアンダースコア文字 (_) で区切られます。 このアルゴリズムは、ASP.NET 4 より前のバージョンの ASP.NET で使用されました。|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> 値は、<xref:System.Web.UI.Control.ID%2A> プロパティの値に設定されます。 コントロールが名前付けコンテナーの場合、そのコントロールは、名前付けコンテナーの階層構造に含まれるすべてのコントロールに対して最上位の階層として使用されます。|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|このアルゴリズムは、データ バインド コントロール内のコントロールに対して使用されます。 <xref:System.Web.UI.Control.ClientID%2A> 値は、親名前付けコンテナーの <xref:System.Web.UI.Control.ClientID%2A> 値とコントロールの <xref:System.Web.UI.Control.ID%2A> 値を連結することにより生成されます。 コントロールが複数の行を生成するデータ バインド コントロールである場合は、<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> プロパティで指定されたデータ フィールドの値が末尾に追加されます。 <xref:System.Web.UI.WebControls.GridView> コントロールの場合は、複数のデータ フィールドを指定できます。 場合、<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A>プロパティが空白である連続番号がデータ フィールドの値ではなく末尾に追加します。 各セグメントはアンダースコア文字 (_) で区切られます。|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|コントロールは、<xref:System.Web.UI.ClientIDMode> コントロールの <xref:System.Web.UI.Control.NamingContainer%2A> 設定を継承します。|  
  
 既定値の<xref:System.Web.UI.Control.ClientIDMode%2A>ページは<xref:System.Web.UI.ClientIDMode.Predictable>します。 既定値の<xref:System.Web.UI.Control.ClientIDMode%2A>コントロールは<xref:System.Web.UI.ClientIDMode.Inherit>します。 コントロールの既定値はため<xref:System.Web.UI.ClientIDMode.Inherit>、モードは既定の世代<xref:System.Web.UI.ClientIDMode.Predictable>です。 (ただし、Visual Studio を使用して以前のバージョンの ASP.NET 4 Web プロジェクトを変換する場合は、Visual Studio に自動的にサイトの既定値を設定<xref:System.Web.UI.ClientIDMode.AutoID>Web.config ファイルにします)。  
  
 詳細については、[ASP.NET Web サーバー コントロールの識別](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)に関する記事をご覧ください。  
  
   
  
## Examples  
 次の例では、マスター ページのコンテンツ ページ内にある Web ユーザー コントロールを示します。 ユーザー コントロールに含まれる、<xref:System.Web.UI.WebControls.DropDownList>コントロールと<xref:System.Web.UI.WebControls.Label>コントロール。 表示されるテキスト、<xref:System.Web.UI.WebControls.Label>コントロールは、ユーザーを選択する値によって決まります、<xref:System.Web.UI.WebControls.DropDownList>コントロール。 Web ページがこの値を設定するのには、サーバーにする必要があるないようにクライアント スクリプトをテキスト値が設定します。 レンダリングされた HTML 要素への参照を取得する、<xref:System.Web.UI.WebControls.Label>コントロール、クライアント スクリプトでのコントロールの値がわかっていなければなりません<xref:System.Web.UI.Control.ClientID%2A>プロパティです。 ただし、ユーザー コントロールは、Web ページで任意の場所に置くことができます、どの名前付けコンテナーは、コントロールを含む事前に知っておくことはできません。 確認する、<xref:System.Web.UI.Control.ClientID%2A>値は同じになります、<xref:System.Web.UI.Control.ID%2A>値に設定するコード セット、<xref:System.Web.UI.Control.ClientIDMode%2A>値を<xref:System.Web.UI.WebControls.ValidatorDisplay.Static>です。  
  
 次の例では、ユーザー コントロールを示します。  
  
  
  
 次の例では、ユーザー コントロールを含むコンテンツ ページを示します。  
  
  
  
 次の例では、コンテンツ ページを含むマスター ページを示します。  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ClientIDMode As ClientIDMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ClientIDMode ClientIDMode { System::Web::UI::ClientIDMode get(); void set(System::Web::UI::ClientIDMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Web.UI.Control.ClientID" /> プロパティの値を生成するために使用されるアルゴリズムを取得または設定します。</summary>
        <value>
          <see cref="P:System.Web.UI.Control.ClientID" /> プロパティの生成方法を示す値。 既定値は、<see cref="F:System.Web.UI.ClientIDMode.Inherit" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET には、生成する方法について複数のアルゴリズムが用意されています、<xref:System.Web.UI.Control.ClientID%2A>プロパティの値。 コントロールに設定して使用するアルゴリズムを選択するその<xref:System.Web.UI.Control.ClientIDMode%2A>プロパティです。 アルゴリズムがで識別される、<xref:System.Web.UI.ClientIDMode>次の表に記載されている列挙値。  
  
|[値]|説明|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|<xref:System.Web.UI.Control.ClientID%2A> 値は、それぞれの親名前付けコンテナーの <xref:System.Web.UI.Control.ID%2A> 値とコントロールの <xref:System.Web.UI.Control.ID%2A> 値を連結することにより生成されます。 コントロールの複数のインスタンスが表示されるデータ バインディング シナリオでは、コントロールの <xref:System.Web.UI.Control.ID%2A> 値の前にインクリメント値が挿入されます。 各セグメントはアンダースコア文字 (_) で区切られます。 このアルゴリズムは、ASP.NET 4 より前のバージョンの ASP.NET で使用されました。|  
|<xref:System.Web.UI.ClientIDMode.Static>|<xref:System.Web.UI.Control.ClientID%2A> 値は、<xref:System.Web.UI.Control.ID%2A> プロパティの値に設定されます。 コントロールが名前付けコンテナーの場合、そのコントロールは、名前付けコンテナーの階層構造に含まれるすべてのコントロールに対して最上位の階層として使用されます。|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|このアルゴリズムは、データ バインド コントロール内のコントロールに対して使用されます。 <xref:System.Web.UI.Control.ClientID%2A> 値は、親名前付けコンテナーの <xref:System.Web.UI.Control.ClientID%2A> 値とコントロールの <xref:System.Web.UI.Control.ID%2A> 値を連結することにより生成されます。 コントロールが複数の行を生成するデータ バインド コントロールである場合は、<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> プロパティで指定されたデータ フィールドの値が末尾に追加されます。 <xref:System.Web.UI.WebControls.GridView> コントロールの場合は、複数のデータ フィールドを指定できます。 場合、<xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A>プロパティが空白である連続番号がデータ フィールドの値ではなく末尾に追加します。 この番号は 0 から始まりますされ、行ごとに 1 ずつインクリメントされます。 各セグメントはアンダースコア文字 (_) で区切られます。|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|コントロールは、<xref:System.Web.UI.ClientIDMode> コントロールの <xref:System.Web.UI.Control.NamingContainer%2A> 設定を継承します。|  
  
 既定値の<xref:System.Web.UI.Control.ClientIDMode%2A>ページは<xref:System.Web.UI.ClientIDMode.Predictable>します。 既定値の<xref:System.Web.UI.Control.ClientIDMode%2A>コントロールは<xref:System.Web.UI.ClientIDMode.Inherit>します。 コントロールの既定値はため<xref:System.Web.UI.ClientIDMode.Inherit>、モードは既定の世代<xref:System.Web.UI.ClientIDMode.Predictable>です。 (ただし、Visual Studio を使用して以前のバージョンの ASP.NET 4 Web プロジェクトを変換する場合は、Visual Studio に自動的にサイトの既定値を設定<xref:System.Web.UI.ClientIDMode.AutoID>Web.config ファイルにします)。  
  
 詳細については、[ASP.NET Web サーバー コントロールの識別](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)に関する記事をご覧ください。  
  
   
  
## Examples  
 次の例は<xref:System.Web.UI.WebControls.Label>コントロールに含まれている、<xref:System.Web.UI.WebControls.ListView>コントロール。 <xref:System.Web.UI.WebControls.ListView>コントロール、<xref:System.Web.UI.Control.ClientIDMode%2A>プロパティに設定されている<xref:System.Web.UI.ClientIDMode.Predictable>と<xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A>プロパティに設定されている`ProductID`です。 レンダリングされる HTML、これは、作成 3 `span` 3 に対応する要素`ProductIDLabel`コントロール。 ページを実行すると、`id`の属性を`span`要素は、次の値に設定します。  
  
-   `ListView1_ProductIDLabel_1`  
  
-   `ListView1_ProductIDLabel_34`  
  
-   `ListView1_ProductIDLabel_43`  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ClientIDSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char ClientIDSeparator { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Web.UI.Control.ClientID" /> プロパティで使用される区切り記号を表す文字値を取得します。</summary>
        <value>常にアンダースコア文字 (_) が返されます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.ClientID%2A>値が連結して生成された、<xref:System.Web.UI.Control.ID%2A>コントロールの値と<xref:System.Web.UI.Control.UniqueID%2A>親コントロールの値。 生成されたの各部分<xref:System.Web.UI.Control.ID%2A>プロパティがで区切られた、<xref:System.Web.UI.Control.ClientIDSeparator%2A>プロパティの値。 値は、常にアンダー スコア (_) を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.ClientID" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.IdSeparator" />
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected internal virtual System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property Context As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Web::HttpContext ^ Context { System::Web::HttpContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の Web 要求に対するサーバー コントロールに関連付けられている <see cref="T:System.Web.HttpContext" /> オブジェクトを取得します。</summary>
        <value>現在の要求に関連付けられている、指定された <see cref="T:System.Web.HttpContext" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティへのアクセスを提供する、<xref:System.Web.HttpContext>の現在の Web 要求のオブジェクト。 オブジェクトにアクセスするプロパティを提供する、 <xref:System.Web.HttpContext.Application%2A>、 <xref:System.Web.HttpContext.Session%2A>、 <xref:System.Web.HttpContext.Request%2A>、<xref:System.Web.HttpContext.Response%2A>と現在の HTTP 要求に関する情報が含まれている他のオブジェクト。 構成情報とセットまたは要求のエラーのクリアを取得することができるようにするメソッドも提供します。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.HttpContext" />
        <altmember cref="T:System.Web.HttpApplication" />
        <altmember cref="T:System.Web.HttpServerUtility" />
        <altmember cref="T:System.Web.HttpRequest" />
        <altmember cref="T:System.Web.HttpResponse" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>UI 階層内の指定されたサーバー コントロールの子コントロールを表す <see cref="T:System.Web.UI.ControlCollection" /> オブジェクトを取得します。</summary>
        <value>指定されたサーバー コントロールの子コントロールのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [ASP.NET] ページでは、コントロールは、開始タグと終了タグのサーバー コントロールの間で宣言によって追加されたときに ASP.NET に自動的に追加のコントロールを含むサーバー コントロールの<xref:System.Web.UI.ControlCollection>します。 HTML タグまたはサーバーで処理されないテキスト文字列として扱われます<xref:System.Web.UI.LiteralControl>オブジェクト。 これらは、その他のサーバー コントロールと同様に、コレクションに追加されます。  
  
 <xref:System.Web.UI.Control.Controls%2A>プロパティがのインスタンスへのプログラムによるアクセスを使用する、<xref:System.Web.UI.ControlCollection>任意のサーバー コントロールのクラスです。 コレクションにコントロールを追加、コントロールをコレクションから削除、またはコレクション内のサーバー コントロールを反復処理することができます。  
  
   
  
## Examples  
 次の例は、サーバー コントロールの子コントロールを追加する方法を示します<xref:System.Web.UI.ControlCollection>オブジェクトを介してその<xref:System.Web.UI.Control.Controls%2A>プロパティです。  
  
 [!code-csharp[Classic Control.Controls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="P:System.Web.UI.Control.Controls" />プロパティ、必ず、<see cref="M:System.Web.UI.Control.EnsureChildControls" />メソッドです。 さらに、コントロールをプログラムによって、その controls コレクションに追加を計画している場合を検討してください、オーバーライドされる、コントロールを追加する<see cref="M:System.Web.UI.Control.CreateChildControls" />メソッドです。</para>
        </block>
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateControlCollection" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ASP.NET ページ フレームワークによって呼び出され、ポストバックまたはレンダリングの準備として、合成ベースの実装を使うサーバー コントロールに対し、それらのコントロールに含まれる子コントロールを作成するように通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 複合またはテンプレート化されたサーバー コントロールを開発する場合は、このメソッドをオーバーライドする必要があります。 そのオーバーライドの制御、<xref:System.Web.UI.Control.CreateChildControls%2A>メソッドを実装する必要があります、<xref:System.Web.UI.INamingContainer>名前付けの競合を回避するインターフェイスです。  
  
 詳細については、次を参照してください。 [Web サーバー コントロールのテンプレート](http://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae)と[カスタム ASP.NET サーバー コントロールの開発](http://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef)です。  
  
   
  
## Examples  
 次の例では、オーバーライドのバージョン、<xref:System.Web.UI.Control.CreateChildControls%2A>メソッドです。 この実装では、複合コントロールが表示されます、 <xref:System.Web.UI.WebControls.TextBox> HTML をレンダリングする 2 つのリテラル コントロールで囲まれたコントロールです。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールの子コントロール (リテラルとサーバーの両方) を保持する新しい <see cref="T:System.Web.UI.ControlCollection" /> オブジェクトを作成します。</summary>
        <returns>現在のサーバー コントロールの子サーバー コントロールを格納する <see cref="T:System.Web.UI.ControlCollection" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生するコレクション オブジェクトを作成した場合は、カスタム サーバー コントロールでこのメソッドをオーバーライドします<xref:System.Web.UI.ControlCollection>クラスです。 このメソッドのオーバーライドでコレクション クラスをインスタンス化できます。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Web.UI.Control.CreateControlCollection%2A>のインスタンスを作成する方法、`CustomControlCollection`から継承されるクラスが、<xref:System.Web.UI.ControlCollection>クラスです。  
  
 [!code-csharp[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]  
  
 次のコード例では、<xref:System.Web.UI.Control.CreateControlCollection%2A>のカスタム サーバー コントロールのメソッドをオーバーライドします<xref:System.Web.UI.Control.CreateChildControls%2A>メソッドです。 新しいコレクションが作成され、2 つの子コントロールが設定されます`firstControl`と`secondControl`です。  
  
 [!code-csharp[Control_Sample_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control_Sample_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DataBind">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>呼び出されたサーバー コントロールとそのすべての子コントロールにデータ ソースをバインドします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DataBind ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DataBind();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出されたサーバー コントロールとそのすべての子コントロールにデータ ソースをバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ソースからデータをサーバー コントロールにバインドするのにには、このメソッドを使用します。 このメソッドは、データベースは、クエリのデータセットの取得後に通常使用されます。 ほとんどのコントロールは、データ、自動的にバインドする必要がある通常はいないこのメソッドを明示的に呼び出すを実行します。  
  
 カスタム テンプレートを使ったデータ バインド コントロールを作成するときに、このメソッドはオーバーライド一般的です。 詳細については、次を参照してください。[する方法: テンプレートの ASP.NET ユーザー コントロールを作成](http://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2)と[Web サーバー コントロールのカスタム データの開発バインド](http://msdn.microsoft.com/library/88fe02a3-957f-4ff7-84f5-2d7ab78db4c1)です。 サーバー コントロールで呼び出されると、このメソッドは、サーバー コントロールおよびその子コントロールのいずれかですべてのデータ バインディング式を解決します。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.DataBind%2A>カスタム ASP.NET サーバー コントロールのメソッドです。 基数を呼び出すことによって開始<xref:System.Web.UI.Control.OnDataBinding%2A>メソッドおよび、使用、<xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType>メソッドはすべての子コントロールを削除して、<xref:System.Web.UI.Control.ClearChildViewState%2A>削除するためのメソッドが、それらの子コントロールのビュー状態の設定を保存します。 最後に、<xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティに設定されている`true`コントロールはで新しく作成されたコントロールのビュー ステートにすべての変更を追跡するように指示し、<xref:System.Web.UI.Control.TrackViewState%2A>メソッド。 これは、新しいデータをコントロールにデータのバインドは、以前から格納されているデータと競合しない場合の一般的な手法<xref:System.Web.UI.Control.DataBind%2A>メソッドの呼び出しです。  
  
 [!code-csharp[Control_StateManagement#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control_StateManagement#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBind (raiseOnDataBinding As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBind(bool raiseOnDataBinding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding">
          <see cref="E:System.Web.UI.Control.DataBinding" /> イベントが発生する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.DataBinding" /> イベントを発生させるオプションを指定して、呼び出されたサーバー コントロールとそのすべての子コントロールにデータ ソースをバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>メソッドにカスタム コントロールをオーバーライドするときに、シナリオ、<xref:System.Web.UI.Control.DataBind%2A>メソッドを実装して、<xref:System.Web.UI.IDataItemContainer>インターフェイスです。 このシナリオでは、カスタム コントロールの呼び出し、<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>メソッドを`raiseOnDataBinding`'éý'`false`ことを確認する、基本クラスの<xref:System.Web.UI.Control.DataBind%2A>メソッドが呼び出されます。  
  
 <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType>メソッドを呼び出して、<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>メソッドを`raiseOnDataBinding`'éý'`true`です。  
  
> [!NOTE]
>  呼び出す、<xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType>メソッドを`raiseOnDataBinding`'éý'`false`任意の子コントロールを使用してバインドされたデータの発生、<xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBindChildren" />
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DataBindChildren ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DataBindChildren();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>データ ソースをサーバー コントロールの子コントロールにバインドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Control.DataBindChildren%2A>サーバー コントロールの子コントロールにデータ ソースをバインドするメソッド。  
  
> [!NOTE]
>  サーバー コントロールで呼び出されると、このメソッドは、コントロールにデータをバインドできません。 サーバー コントロールとそのすべての子コントロールをバインドするには、呼び出し、<xref:System.Web.UI.Control.DataBind%2A>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataBinding As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataBinding;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがデータ ソースに連結すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントに書き込まれたデータのバインド ロジックを実行するサーバー コントロールに通知します。  
  
   
  
## Examples  
 [!code-csharp[ITemplate_Interface#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate_Interface#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataItemContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataItemContainer { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前付けコンテナーが <see cref="T:System.Web.UI.IDataItemContainer" /> を実装している場合、名前付けコンテナーへの参照を取得します。</summary>
        <value>名前付けコンテナー。 <see cref="T:System.Web.UI.IDataItemContainer" /> を実装している名前付けコンテナーの階層では、このプロパティは階層の最上位にある名前付けコンテナーを返します。現在の <see cref="T:System.Web.UI.Control" /> オブジェクトが <see cref="T:System.Web.UI.IDataItemContainer" /> を実装している名前付けコンテナー内にない場合は <see langword="null" /> を返します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataKeysContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::Control ^ DataKeysContainer { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前付けコンテナーが <see cref="T:System.Web.UI.IDataKeysControl" /> を実装している場合、名前付けコンテナーへの参照を取得します。</summary>
        <value>名前付けコンテナー。 <see cref="T:System.Web.UI.IDataKeysControl" /> を実装している名前付けコンテナーの階層では、このプロパティは階層の最上位にある名前付けコンテナーを返します。現在の <see cref="T:System.Web.UI.Control" /> オブジェクトが <see cref="T:System.Web.UI.IDataKeysControl" /> を実装している名前付けコンテナー内にない場合は <see langword="null" /> を返します。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected internal bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DesignMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool DesignMode { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがデザイン サーフェイスで使用されているかどうかを示す値を取得します。</summary>
        <value>
          コントロールがデザイナーで使用されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.DesignMode%2A>プロパティから返される`true`コントロールがデザイナーのコンテキストで使用されていることを示すためにします。 カスタム コントロールは、デザイン時の動作が実行時の動作と異なる場合、このプロパティを使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールが、メモリから解放される前に最終的なクリーンアップを実行できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.Dispose%2A> を使い終わったら <xref:System.Web.UI.Control> を呼び出します。 <xref:System.Web.UI.Control.Dispose%2A> メソッドによって、<xref:System.Web.UI.Control> は使用不可の状態になります。 このメソッドを呼び出した後に使用していたメモリをガベージ コレクションによって再要求できるように、コントロールへのすべての参照を解放する必要があります。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Web.UI.Control.Dispose%2A>を終了するメソッド、<xref:System.Web.UI.HtmlTextWriter>制御、および呼び出しに関連付けられているオブジェクト、<xref:System.Web.UI.Control.Dispose%2A>メソッドを<xref:System.Web.UI.WebControls.Button>という名前のコントロール`myButton`です。 場合、<xref:System.Exception>場合にスローされるこのバージョンの<xref:System.Web.UI.Control.Dispose%2A>メソッドが呼び出されると、コントロール メッセージを書き込みます現在<xref:System.Web.HttpResponse>オブジェクト。  
  
 [!code-csharp[Control_Dispose#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control_Dispose#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Disposed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがメモリから解放されると発生します。これは、ASP.NET ページが要求されている場合のサーバー コントロールの有効期間における最終段階です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントには、データベース接続など、大量のプロセッサ時間を必要とするリソースを解放する必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>テーマがこのコントロールに適用されるかどうかを示す値を取得または設定します。</summary>
        <value>
          テーマを使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.EnableTheming%2A>プロパティは、指定されたコントロールのテーマが有効かどうかを示します。 ときに、<xref:System.Web.UI.Control.EnableTheming%2A>プロパティは`true`、コントロール スキンを適用するテーマのアプリケーションのディレクトリが検索されます。 テーマのディレクトリ内の特定のコントロール スキンが存在しない場合、スキンは適用されません。  
  
 ときに、<xref:System.Web.UI.Control.EnableTheming%2A>プロパティは`false`、テーマのディレクトリは検索されませんの内容、<xref:System.Web.UI.Control.SkinID%2A>プロパティは使用されません。  
  
 テーマは、ページ、コンテナー、または制御レベルで有効にすることができます。 オーバーライドする、<xref:System.Web.UI.Control.EnableTheming%2A>値、親コントロールまたはコントロールを含むページのセット。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="Page_PreInit" /> イベントが既に発生しています。  
  
 \- または  
  
 コントロールが既に <see langword="Controls" /> コレクションに追加されています。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableViewState { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要求元クライアントに対して、サーバー コントロールがそのビュー状態と、そこに含まれる任意の子のコントロールのビュー状態を保持するかどうかを示す値を取得または設定します。</summary>
        <value>
          サーバー コントロールがビュー状態を保持する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビューステートは、HTTP 要求間での状態を維持するためにサーバー コントロールを有効にします。 次の条件をすべて満たしている場合は、コントロールのビュー ステートを有効になっています。  
  
-   <xref:System.Web.UI.Control.EnableViewState%2A>ページのプロパティに設定されて`true`です。  
  
-   <xref:System.Web.UI.Control.EnableViewState%2A>コントロールのプロパティに設定されて`true`です。  
  
-   <xref:System.Web.UI.Control.ViewStateMode%2A>コントロールのプロパティに設定されて<xref:System.Web.UI.ViewStateMode.Enabled>または継承、<xref:System.Web.UI.ViewStateMode.Enabled>設定します。  
  
 詳細については、<xref:System.Web.UI.Control.ViewStateMode%2A> プロパティを参照してください。  
  
 サーバー コントロールのビューステートは、すべてのプロパティ値の累積です。 HTTP 要求間でこれらの値を保持するために、ASP.NET がのインスタンスを使用して、<xref:System.Web.UI.StateBag>プロパティ値を格納するクラス。 値は、後続の要求が処理されるときに、変数として隠しフィールドを渡されます。 ビュー ステートについての詳細については、次を参照してください。 [ASP.NET ビュー状態の概要](http://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818)です。  
  
 アプリケーションのパフォーマンスを向上させるために特にのビュー ステートを無効にする適切な場合もあります。 たとえば、サーバー コントロールにはデータベースの要求を読み込む場合このプロパティ`false`です。 そうしないと場合、データベース クエリによってのみオーバーライドされますのサーバー コントロールにビュー ステートを読み込むプロセッサ時間が消費されます。 場合<xref:System.Web.UI.Control.EnableViewState%2A>は`false`コントロールに固有であり、ビューの state プロパティと同様にオフにすることはできませんあるプロパティの情報を保持するコントロールの状態を使用することができます。 コントロールの状態と表示状態の違いの詳細については、次を参照してください。[コントロールの状態とします。ビュー ステート例](http://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681)です。  
  
 有効にするにまたは ASP.NET ページの宣言のビュー ステートを無効にする方法についてを参照してください。  
  
   
  
## Examples  
 次の例のセット、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティを`false`です。  
  
 [!code-csharp[Control_StateManagement#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control_StateManagement#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EndRenderTracing (writer As TextWriter, traceObject As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EndRenderTracing(System::IO::TextWriter ^ writer, System::Object ^ traceObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">トレース データを書き込むオブジェクト。</param>
        <param name="traceObject">トレース オブジェクト。</param>
        <summary>レンダリング データのデザイン時のトレースを終了します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub EnsureChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void EnsureChildControls();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールに子コントロールが含まれているかどうかを確認します。 含まれていない場合、子コントロールを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、最初の現在の値を確認、<xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティです。 この値が場合`false`、<xref:System.Web.UI.Control.CreateChildControls%2A>メソッドが呼び出されます。  
  
 <xref:System.Web.UI.Control.EnsureChildControls%2A>メソッドが、一部の子コントロールを使用するコントロールは、複合コントロールで通常使用されるか、すべての機能です。 <xref:System.Web.UI.Control.EnsureChildControls%2A>メソッドが子コントロールが作成されているし、データ バインディングを実行する、またはその他のタスクを実行している入力を処理する準備ができているかどうかを確認するために呼び出されます。  
  
 <xref:System.Web.UI.WebControls.GridView>コントロールは複合コントロールの例を示します。 子コントロールを作成など、 <xref:System.Web.UI.WebControls.Table>、 <xref:System.Web.UI.WebControls.TableRow>、 <xref:System.Web.UI.WebControls.TableCell>、 <xref:System.Web.UI.WebControls.Label>、および<xref:System.Web.UI.WebControls.TextBox>コントロールは、HTML を表示するために使用されるテーブルを<xref:System.Web.UI.WebControls.GridView>が生成されます。  
  
 ほとんどの場合、カスタム サーバー コントロールの開発者はこのメソッドをオーバーライドありません。 このメソッドをオーバーライドする場合は、既定の動作と同様の方法で使用します。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.UI.Control.EnsureChildControls%2A>メソッドを現在のサーバー コントロールに子コントロールがあることを確認します。 これを取得または設定、<xref:System.Web.UI.WebControls.TextBox.Text%2A>子に対してプロパティ<xref:System.Web.UI.WebControls.TextBox>、現在のサーバー コントロールのコントロールを Web<xref:System.Web.UI.ControlCollection>オブジェクト。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="P:System.Web.UI.Control.ChildControlsCreated" />
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnsureID ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnsureID();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ID が割り当てられていないコントロールの ID を作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.EnsureID%2A>メソッドは、別のコントロールに含まれるコントロールの識別子を生成します。 割り当てられた値がないコントロールに対してのみ生成された識別子、<xref:System.Web.UI.Control.ID%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Events As EventHandlerList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::EventHandlerList ^ Events { System::ComponentModel::EventHandlerList ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのイベント ハンドラー デリゲートのリストを取得します。 このプロパティは読み取り専用です。</summary>
        <value>イベント ハンドラー デリゲートのリスト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの型は<xref:System.ComponentModel.EventHandlerList>、一方向の検索アルゴリズムを使用して、デリゲートの一覧でエントリを確認します。 多数のエントリを使用する場合、一方向の検索アルゴリズムは効率的ではありません。 そのため、大規模な一覧がある場合は、このプロパティを持つエントリが遅くなりますを検索します。  
  
   
  
## Examples  
 次の例は、という名前のイベントを作成`Click`を追加し、コントロールからハンドラーを削除する<xref:System.ComponentModel.EventHandlerList>コレクション イベントが、ページから呼び出されるとします。  
  
 **注**この例の最適化、コントロールの追加し、イベントをコントロールが維持されることの一覧から削除します。 カスタム コントロールを作成して、イベントを定義する場合は、次のようにコードを使用します。 Visual Basic ではなく、C# の場合に、この手法を使用できます。  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.EventHandlerList" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したサーバー コントロールの現在の名前付けコンテナーを検索します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindControl (id As String) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">検索されるコントロールの識別子。</param>
        <summary>指定した <paramref name="id" /> パラメーターを使用して、サーバー コントロールの現在の名前付けコンテナーを検索します。</summary>
        <returns>指定したコントロール。指定したコントロールがない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して<xref:System.Web.UI.Control.FindControl%2A>分離コード ページの別のコンテナー内にあるコントロールにアクセスする、または対象のコントロールが呼び出し元に直接アクセスできる行われていない他の状況で、関数からコントロールにアクセスします。 このメソッドは、コントロールを検索は、コントロールが直接指定されたコンテナーで格納している場合にのみつまり、メソッドは、コントロール内のコントロールの階層全体では検索されません。 その直接のコンテナーが認識していない場合に、コントロールを検索する方法については、次を参照してください。[する方法: アクセス サーバーのコントロール ID によって](http://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3)です。  
  
   
  
## Examples  
 次の例では定義、`Button1_Click`イベント ハンドラー。 このハンドラーを使用して、呼び出されたときに、<xref:System.Web.UI.Control.FindControl%2A>を使用して、コントロールを探す方法、<xref:System.Web.UI.Control.ID%2A>プロパティの`TextBox2`コンテナー ページ。 使用して、その親を特定のコントロールが見つかった場合、<xref:System.Web.UI.Control.Parent%2A>プロパティと、親コントロールの<xref:System.Web.UI.Control.ID%2A>ページに書き込まれます。 場合`TextBox2`が見つからない「コントロールが見つかりません」が、ページに書き込まれます。  
  
> [!IMPORTANT]
>  この例には、ユーザー入力を受け付けるテキスト ボックスがあります。これにより、セキュリティが脆弱になる可能性があります。 既定では、ASP.NET Web ページによって、ユーザー入力にスクリプトまたは HTML 要素が含まれていないかどうかが検証されます。 詳細については、「[スクリプトによる攻略の概要](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07)」を参照してください。  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FindControl (id As String, pathOffset As Integer) As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Control ^ FindControl(System::String ^ id, int pathOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">検索されるコントロールの識別子。</param>
        <param name="pathOffset">名前付けコンテナーに到達するために必要なページ コントロール階層までのコントロールの数。</param>
        <summary>指定した <paramref name="id" /> および検索に役立つ <paramref name="pathOffset" /> パラメーターに指定された整数を使用して、サーバー コントロールの現在の名前付けコンテナーを検索します。 この形式の <see cref="Overload:System.Web.UI.Control.FindControl" /> メソッドはオーバーライドしないでください。</summary>
        <returns>指定したコントロール。指定したコントロールがない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールに入力フォーカスを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Control.Focus%2A>コントロールに、Web ページの初期フォーカスを設定します。 ページが選択されているコントロールのブラウザーで開きます。  
  
 <xref:System.Web.UI.Control.Focus%2A>メソッドにより、スクリプトの呼び出しをページ フォーカスをページに出力できます。 ページに HTML を持つコントロールが含まれていないかどうかは`ID`コントロールと一致する属性を<xref:System.Web.UI.Control.Focus%2A>メソッドが呼び出されたし、ページのフォーカスは設定されません。 これは発生する例は、ユーザー コントロールの子コントロールにフォーカスを設定する代わりにユーザー コントロールにフォーカスを設定するときです。 このシナリオで使用することができます、<xref:System.Web.UI.Control.FindControl%2A>メソッドは、ユーザー コントロールの子コントロールを見つけ、呼び出しをその<xref:System.Web.UI.Control.Focus%2A>メソッドです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.FindControl(System.String)" />
        <altmember cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetDesignModeState () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IDictionary ^ GetDesignModeState();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのデザイン時データを取得します。</summary>
        <returns>コントロールのデザイン時データを格納する <see cref="T:System.Collections.IDictionary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.GetDesignModeState%2A>メソッドは、コントロールのデザイン時データを返します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Web.UI.Control.GetDesignModeState" />メソッドを返します。<see langword="null" />既定です。 コントロールに必要なデザイン時データを提供するには、このメソッドをオーバーライドする必要があります。</para>
        </block>
        <altmember cref="T:System.Web.UI.IControlDesignerAccessor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ルート パラメーターのセットに対応する URL を取得します。オプションで、ルート名に対応する URL も取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと等価である、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType>メソッドです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Object ^ routeParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeParameters">ルート パラメーター。</param>
        <summary>ルート パラメーターのセットに対応する URL を取得します。</summary>
        <returns>指定されたルート パラメーターに対応する URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと等価である、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドです。 このメソッドに渡されるオブジェクトは変換`routeParameters`を<xref:System.Web.Routing.RouteValueDictionary>オブジェクトを使用して、<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>コンス トラクターです。  
  
   
  
## Examples  
 次の例を呼び出す方法を示します、<xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=nameWithType>は名前付きパラメーターを持つルートの URL を取得するメソッド`productid`と`category`です。 この例では、作成した、<xref:System.Web.UI.WebControls.HyperLink>というコントロール`HyperLink1`です。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeParameters">ルート パラメーター。</param>
        <summary>ルート パラメーターのセットに対応する URL を取得します。</summary>
        <returns>指定されたルート パラメーターに対応する URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと等価である、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドです。  
  
   
  
## Examples  
 次の例は名前付きパラメーターを持つルートの URL を取得するには、このメソッドを呼び出す方法を示しています。`productid`と`category`です。 この例では、作成した、<xref:System.Web.UI.WebControls.HyperLink>というコントロール`HyperLink1`です。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Object ^ routeParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeParameters">ルート パラメーター。</param>
        <summary>ルート パラメーターのセットおよびルート名に対応する URL を取得します。</summary>
        <returns>指定したルート パラメーターおよびルート名に対応する URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと等価である、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドです。 このメソッドに渡されるオブジェクトは変換`routeParameters`を<xref:System.Web.Routing.RouteValueDictionary>オブジェクトを使用して、<xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType>コンス トラクターです。  
  
   
  
## Examples  
 次の例は、という名前のルートの URL を取得するには、このメソッドを呼び出す方法を示しています。`Product`パラメーターに名前が付けられる`productid`と`category`です。 この例では、作成した、<xref:System.Web.UI.WebControls.HyperLink>というコントロール`HyperLink1`です。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRouteUrl (routeName As String, routeParameters As RouteValueDictionary) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetRouteUrl(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeParameters);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">ルートの名前。</param>
        <param name="routeParameters">ルート パラメーター。</param>
        <summary>ルート パラメーターのセットおよびルート名に対応する URL を取得します。</summary>
        <returns>指定したルート パラメーターおよびルート名に対応する URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コーディングの利便性を提供します。 呼び出すことと等価である、<xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType>メソッドです。  
  
   
  
## Examples  
 次の例は、という名前のルートの URL を取得するには、このメソッドを呼び出す方法を示しています。`Product`パラメーターに名前が付けられる`productid`と`category`です。 この例では、作成した、<xref:System.Web.UI.WebControls.HyperLink>というコントロール`HyperLink1`です。  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetUniqueIDRelativeTo(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">名前付けコンテナー内のコントロール。</param>
        <summary>指定されたコントロールの <see cref="P:System.Web.UI.Control.UniqueID" /> プロパティのプレフィックス部分を返します。</summary>
        <returns>指定されたコントロールの <see cref="P:System.Web.UI.Control.UniqueID" /> プロパティのプレフィックス部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.UniqueID%2A>コントロールのプロパティがコントロールのプレフィックスを追加することによって生成される<xref:System.Web.UI.Control.ID%2A>プロパティです。 プレフィックスから成ります、<xref:System.Web.UI.Control.UniqueID%2A>コントロールのプロパティの名前付けコンテナーが区切り文字で連結します。 名前付けコンテナーが、ページの場合、プレフィックスはありません。 このメソッドは、プレフィックス文字列を返します。 かどうか、プレフィックス文字列がないが返されます、<xref:System.Web.UI.Control.UniqueID%2A>コントロールの値。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="control" /> の <see cref="P:System.Web.UI.Control.NamingContainer" /> プロパティが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property HasChildViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool HasChildViewState { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のサーバー コントロールの子コントロールが、保存されたビューステートの設定を持っているかどうかを示す値を取得します。</summary>
        <value>
          子コントロールが、保存されたビューステートの情報を持っている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要な呼び出しを回避することができます、<xref:System.Web.UI.Control.ClearChildViewState%2A>メソッドを使用してこのプロパティをサーバー コントロールの子コントロールがビュー状態情報を格納することを確認してください。  
  
   
  
## Examples  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function HasControls () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasControls();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールに子コントロールが含まれているかどうかを確認します。</summary>
        <returns>
          コントロールに他のコントロールが格納されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが単に不要なを回避することによってパフォーマンスの向上につながります任意の子コントロールが存在する場合を判断するため<xref:System.Web.UI.ControlCollection.Count%2A>プロパティの呼び出しです。 このプロパティへの呼び出しを必要とする<xref:System.Web.UI.ControlCollection>インスタンス化するオブジェクト。 子が存在しない場合、このオブジェクトの作成は、サーバーのリソースを浪費します。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.UI.Control.HasControls%2A>任意のコントロールが使用する前に存在するかどうかは特定のメソッド、<xref:System.Web.UI.ControlCollection.Count%2A>プロパティを反復処理を<xref:System.Web.UI.ControlCollection>オブジェクト。  
  
 [!code-csharp[Classic Control.HasControls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Web.UI.Control.HasControls" />などのメタデータ属性を変更するためだけにメソッドをオーバーライドする必要があります<see cref="T:System.ComponentModel.EditorBrowsableAttribute" />です。 属性の使用方法の詳細については、次を参照してください。[属性](~/docs/standard/attributes/index.md)です。</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="T:System.Web.UI.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Function HasEvents () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool HasEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールまたは子コントロールに対してイベントが登録されているかどうかを示す値を返します。</summary>
        <returns>
          イベントが登録されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールに割り当てられたプログラム ID を取得または設定します。</summary>
        <value>コントロールに割り当てられたプログラム ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバー コントロールでこのプロパティの設定で、サーバー コントロールのプロパティ、イベント、およびメソッドにプログラムでアクセスできます。 このプロパティは、宣言することによって Web 開発者によって設定できる、 <xref:System.Web.UI.Control.ID%2A> ASP.NET サーバー コントロールの開始タグ内の属性です。  
  
 を介して、親コントロールのコントロールへの参照を取得することができる場合、このプロパティが指定されていないサーバー コントロールは、宣言またはプログラムによって、<xref:System.Web.UI.Control.Controls%2A>プロパティです。  
  
> [!NOTE]
>  英数字とアンダー スコア文字 (_) の組み合わせだけは、このプロパティの有効な値です。 スペースまたはその他の無効な文字を含む ASP.NET ページ パーサー エラーになります。  
  
   
  
## Examples  
 [!code-csharp[Control_Sample#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control_Sample#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
        <altmember cref="T:System.Web.UI.INamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IdSeparator As Char" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property char IdSeparator { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール ID を区別するために使用する文字を取得します。</summary>
        <value>区切り記号。 既定値は "$" です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含まれる文字、<xref:System.Web.UI.Control.IdSeparator%2A>子コントロールのコントロール id を区別するプロパティを使用します。 識別子の区切り文字を追加、<xref:System.Web.UI.Control.ID%2A>プロパティです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Init As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Init;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールが初期化されると発生します。これは、サーバー コントロールの有効期間における最初の手順です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバー コントロールには、インスタンスを作成および設定するために必要な初期化の手順を実行する必要があります。 このイベント内のビュー状態情報を使用することはできません。値を返さないまだです。 別のサーバー コントロールは、このコントロールを親または子に関係なく、このイベント中にアクセスしないでください。 その他のサーバー コントロールの作成、アクセスの準備が整ってするではありません。 サーバー コントロールのイベントの詳細については、次を参照してください。 [ASP.NET Web フォーム サーバー コントロールのイベント モデル](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3)です。  
  
   
  
## Examples  
 次の例では、カスタム イベント ハンドラー、`Calendar_Init`を`Init`のイベント、<xref:System.Web.UI.WebControls.Calendar>コントロール。  
  
 [!code-aspx-csharp[Control_Sample#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-aspx-vb[Control_Sample#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected internal bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsChildControlStateCleared As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsChildControlStateCleared { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに含まれているコントロールに、コントロールの状態が設定されているかどうかを示す値を取得します。</summary>
        <value>
          このコントロールの子がコントロールの状態を使用していない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsLiteralContent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsLiteralContent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールがリテラルな内容だけを保持しているかどうかを決定します。</summary>
        <returns>
          サーバー コントロールがリテラルな内容だけを含む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが戻る`true`、サーバー コントロールのコレクションを単一のリテラル コントロールを保持します。  
  
   
  
## Examples  
 次の例では、サーバー コントロールを含むページがポストバックされたかどうかを確認します。 呼び出す場合に、<xref:System.Web.UI.Control.IsLiteralContent%2A>かを確認するかどうか、コントロールだけリテラル コンテンツが含まれる他のサーバー コントロールに親コントロールのメソッドです。 リテラルの内容だけが含まれている場合、<xref:System.Web.UI.Control.UniqueID%2A>のプロパティ、<xref:System.Web.UI.LiteralControl>を応答に書き込まれたコンテンツを表すです。  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.HasControls" />
        <altmember cref="T:System.Web.UI.LiteralControl" />
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsTrackingViewState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsTrackingViewState { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがビューステートの変更を保存しているかどうかを示す値を取得します。</summary>
        <value>
          コントロールがその状態を保存するようにマークされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用するサンプル カスタム サーバー コントロールは、次を参照してください[テンプレート化されたサーバー コントロールの例。](http://msdn.microsoft.com/library/986f63b8-6b50-42b9-a62d-a2f13cafa88b)  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.DataBind%2A>カスタム ASP.NET サーバー コントロールのメソッドです。 基数を呼び出すことによって開始<xref:System.Web.UI.Control.OnDataBinding%2A>メソッドおよび、使用、`ControlCollection`オブジェクト。 <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> メソッドはすべての子コントロールを削除して、<xref:System.Web.UI.Control.ClearChildViewState%2A>削除するためのメソッドが、それらの子コントロールのビュー状態の設定を保存します。 最後に、<xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティに設定されている`true`です。 コントロールを使用し、<xref:System.Web.UI.Control.IsTrackingViewState%2A>コントロールのビュー ステートの変更の追跡が有効になっているかどうかを決定するプロパティです。 有効でない場合、<xref:System.Web.UI.Control.TrackViewState%2A>メソッドが呼び出されます。  
  
 [!code-csharp[Control_StateManagement#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control_StateManagement#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected internal bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property IsViewStateEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsViewStateEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールでビューステートが有効かどうかを示す値を取得します。</summary>
        <value>
          このコントロールでビューステートが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビュー ステートは、ページ、コンテナー、または制御レベルで有効にすることができます。 ページまたはコンテナー レベルでは、ビュー ステートが無効である場合は、ページまたはコンテナーに含まれるすべてのコントロール ビュー ステートが無効になります。 <xref:System.Web.UI.Control.IsViewStateEnabled%2A>プロパティは、ページ、コンテナー、またはコントロール ビュー ステートが有効になっているかどうかを示します。  
  
 できます、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティおよび<xref:System.Web.UI.Control.IsViewStateEnabled%2A>別にするプロパティです。 たとえば場合、<xref:System.Web.UI.Page>無効にすると、ビュー状態を持つコントロールを含む、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティを指定できます`true`中に、<xref:System.Web.UI.Control.IsViewStateEnabled%2A>プロパティは`false`します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>ページの開発者は設定、<see cref="P:System.Web.UI.Control.EnableViewState" />プロパティおよび<see cref="P:System.Web.UI.Control.ViewStateMode" />ビュー ステートが、コントロールを使用しているかどうかを示すプロパティです。 使用して、<see cref="P:System.Web.UI.Control.IsViewStateEnabled" />プロパティおよび<see cref="P:System.Web.UI.Control.ViewStateMode" />プロパティ、コントロールおよびすべてのコンテナーのビュー ステートが有効になっているかどうかを決定するコードにします。</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewStateMode" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールが <see cref="T:System.Web.UI.Page" /> オブジェクトに読み込まれると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各ページ要求に発生する可能性に設定されているすべての処理手順を実行するサーバー コントロールに通知します。 状態情報を表示し、Web フォームの POST データは、このイベントからアクセスできます。 ページのコントロールの階層内の他のサーバー コントロールにアクセスすることもできます。  
  
> [!NOTE]
>  時にコントロールのカスタム テンプレートを設定するかどうか、`Page_Load`イベント、カスタム テンプレート内の子コントロールのテキスト値は失われます。 これは、フォームの値が既に読み込まれているために発生します。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Load#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control_Load#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadControlState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">復元するコントロールの状態を表す <see cref="T:System.Object" />。</param>
        <summary>
          <see cref="M:System.Web.UI.Control.SaveControlState" /> メソッドによって保存された前回のページ要求からコントロールの状態情報を復元します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタム サーバー コントロールがコントロールの状態を復元する方法を指定する必要がある場合は、このメソッドをオーバーライドします。 詳細については、次を参照してください。 [ASP.NET 状態管理の概要](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce)です。  
  
   
  
## Examples  
 次のコード例の上書き、 <xref:System.Web.UI.Control.LoadControlState%2A> ASP.NET カスタム コントロール内のメソッドです。 このメソッドが呼び出されるかどうが決定コントロールの状態コントロールの以前に保存した場合は、内部プロパティを設定`currentIndex`保存されている値にします。  
  
 <xref:System.Web.UI.Control.OnInit%2A>メソッドをオーバーライドして、呼び出し、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッドを<xref:System.Web.UI.Control.Page%2A>にカスタム コントロールがコントロールの状態を使用するように指定します。  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadViewState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadViewState(System::Object ^ savedState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">復元するコントロールの状態を表す <see cref="T:System.Object" />。</param>
        <summary>
          <see cref="M:System.Web.UI.Control.SaveViewState" /> メソッドによって保存された前回のページ要求からビューステート情報を復元します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、主に、.NET Framework インフラストラクチャによって使用され、コードから直接使用するものではありません。 ただし、コントロールの開発者は、カスタム サーバー コントロールがそのビューステートを復元する方法を指定するには、このメソッドをオーバーライドすることができます。 詳細については、次を参照してください。 [ASP.NET 状態管理の概要](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce)です。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.LoadViewState%2A>カスタム ASP.NET サーバー コントロールのメソッドです。 作成、<xref:System.Object>に渡されたビュー状態情報を格納する配列、`savedState`パラメーターの基本実装を呼び出すと、<xref:System.Web.UI.Control.LoadViewState%2A>メソッドの最初の配列のインデックス位置。 という名前の変数に次の 2 つのインデックス位置に格納されている値を割り当てます`UserText`と`PasswordText`、それぞれします。  
  
 [!code-csharp[Control_StateManagement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control_StateManagement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property LoadViewStateByID As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool LoadViewStateByID { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがインデックスではなく <see cref="P:System.Web.UI.Control.ID" /> によりビューステートの読み込みを行うかどうかを示す値を取得します。</summary>
        <value>
          コントロールが <see cref="P:System.Web.UI.Control.ID" /> によりビューステートを読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、親コントロールが作成される子コントロールにビュー ステートを読み込むときにこれは、親コントロールの各子コントロールの位置によって<xref:System.Web.UI.Control.Controls%2A>コレクション。 ビュー ステートが最初に適用されると、すべての子コントロールがありますが作成されていません。 この場合、作成されていないコントロールのビュー ステートが保存され、後で子コントロールを作成するときに適用されます。  
  
 親コントロール ビュー ステートをコントロールの子コントロールに適用するには、2 つの条件を満たす必要があります。  
  
-   ポストバックで、親コントロールする必要があります、子コントロールを作成、前回の要求とまったく同じ順序で、コントロールの順序が変わらないようにします。  
  
-   ポストバックの後に、親コントロールの末尾に作成された任意の子コントロールを追加<xref:System.Web.UI.Control.Controls%2A>コレクション。  
  
 使用して、親コントロールがビュー状態を読み込むことができる場合は、子コントロールの作成が遅れる場合と、これら 2 つの条件を満たすことができない、<xref:System.Web.UI.Control.ID%2A>です。 設定する、<xref:System.Web.UI.Control.LoadViewStateByID%2A>プロパティを`true`を使用して、<xref:System.Web.UI.ViewStateModeByIdAttribute>親コントロールのメタデータの属性です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.ViewStateModeByIdAttribute" />
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected internal string MapPathSecure (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function MapPathSecure (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::String ^ MapPathSecure(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">相対 URL、またはルートに対して相対的な URL。</param>
        <summary>仮想パス (絶対パスまたは相対パス) の割り当て先の物理パスを取得します。</summary>
        <returns>要求されたファイルへの物理パス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ファイルを読み取る権限があることと、完全に信頼された .dll ファイル、System.Web.dll などの一部は、サーバー コントロールでのみ使用できます。 これにより、セキュリティ侵害を防止できます。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.UI.Control.MapPathSecure%2A>メソッドを含むの仮想ディレクトリの物理パスを取得する<xref:System.Web.UI.Page>または<xref:System.Web.UI.UserControl>オブジェクト。  
  
 [!code-csharp[Control_MapPathSecure#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control_MapPathSecure#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="virtualPath" /> は <see langword="null" /> または空の文字列 ("") です。</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NamingContainer As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ NamingContainer { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同じ <see cref="P:System.Web.UI.Control.ID" /> プロパティ値を持つ複数のサーバー コントロールを区別するための一意の名前空間を作成する、サーバー コントロールの名前付けコンテナーへの参照を取得します。</summary>
        <value>サーバー コントロールの名前付けコンテナー。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web アプリケーション内の各ページには、コントロールの階層が含まれています。 この階層では、コントロールがユーザーに表示される UI を生成するかどうかに依存しません。 指定されたコントロールの名前付けコンテナーは、親コントロールを実装する階層で、<xref:System.Web.UI.INamingContainer>インターフェイスです。 このインターフェイスを実装するサーバー コントロールの一意の名前空間の作成、<xref:System.Web.UI.Control.ID%2A>子サーバー コントロールのプロパティ値。 使用することができます、<xref:System.Web.UI.Control.NamingContainer%2A>名前付けコンテナーの子コントロールを親コンテナーへの参照を取得します。  
  
 など、データへの Web サーバー コントロールをバインドするときにサーバー コントロールの一意の名前空間の作成は、特に重要、<xref:System.Web.UI.WebControls.Repeater>と<xref:System.Web.UI.WebControls.DataList>サーバー コントロールです。 データ ソースの複数のエントリは、コントロールの子であるサーバー コントロールの複数のインスタンスを作成するときに、名前付けコンテナーにより、これらの子コントロールの各インスタンス<xref:System.Web.UI.Control.UniqueID%2A>競合しないプロパティ値。 ページの既定の名前付けコンテナーは、インスタンスの<xref:System.Web.UI.Page>そのページが要求されたときに生成されるクラスです。  
  
 <xref:System.Web.UI.Control.ClientID%2A>プロパティには、要素のとして表示される値が含まれています。 `id` HTML マークアップ内の属性です。 割り当てられる値に応じて、<xref:System.Web.UI.Control.ClientIDMode%2A>プロパティ、に対して生成される値、<xref:System.Web.UI.Control.ClientID%2A>プロパティの ID を含めることがあります、<xref:System.Web.UI.Control.NamingContainer%2A>オブジェクト。 設定すると<xref:System.Web.UI.Control.ClientIDMode%2A>に<xref:System.Web.UI.ClientIDMode.Static>、<xref:System.Web.UI.Control.ClientID%2A>値の ID が含まれていない、<xref:System.Web.UI.Control.NamingContainer%2A>オブジェクト。 設定すると<xref:System.Web.UI.Control.ClientIDMode%2A>いずれかに<xref:System.Web.UI.ClientIDMode.AutoID>または<xref:System.Web.UI.ClientIDMode.Predictable>、<xref:System.Web.UI.Control.ClientID%2A>値がから ID を含める、<xref:System.Web.UI.Control.NamingContainer%2A>オブジェクト。 詳細については、[ASP.NET Web サーバー コントロールの識別](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7)に関する記事をご覧ください。  
  
   
  
## Examples  
 次の例では、使用方法を示します、<xref:System.Web.UI.Control.NamingContainer%2A>プロパティです。  
  
 [!code-aspx-csharp[Control_NamingContainer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-aspx-vb[Control_NamingContainer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.INamingContainer" />
        <altmember cref="P:System.Web.UI.Control.UniqueID" />
        <altmember cref="P:System.Web.UI.Control.ID" />
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnBubbleEvent (source As Object, args As EventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">イベントのソース。</param>
        <param name="args">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>サーバー コントロールのイベントをページの UI サーバー コントロールの階層構造に渡すかどうかを決定します。</summary>
        <returns>
          イベントがキャンセルされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET サーバー コントロールなど、 <xref:System.Web.UI.WebControls.Repeater>、<xref:System.Web.UI.WebControls.DataList>と<xref:System.Web.UI.WebControls.GridView>Web コントロールがイベントを発生させる子コントロールを含めることができます。 たとえば、内の行ごと、<xref:System.Web.UI.WebControls.GridView>コントロールは、テンプレートで動的に作成された 1 つまたは複数のボタンを含めることができます。 個別にイベントを発生させる各ボタンではなく、入れ子になったコントロールからのイベントは「バブル イベント」-は、名前付けコンテナーに送信されます。 名前付けコンテナーでイベントを発生させますジェネリックと呼ばれる<xref:System.Web.UI.WebControls.GridView.RowCommand>パラメーター値を使用します。 これらの値を使用すると、元のイベントを発生させたコントロールを判断できます。 この単一のイベントに応答して、子コントロールの個々 のイベント処理メソッドを記述することを回避できます。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.OnBubbleEvent%2A>カスタム ASP.NET サーバー コントロール、`ParentControl`です。 子コントロールにある場合、このメソッドが呼び出される`ParentControl`呼び出し、<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>メソッドです。 この場合、`ParentControl`クラスは、最初のことを示すを含む ASP.NET ページに 2 つの文字列を書き込みますをその<xref:System.Web.UI.Control.OnBubbleEvent%2A>メソッドが呼び出されて、2 番目の特定のソース管理、<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>メソッドです。  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataBinding (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataBinding(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.DataBinding" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、それに関連付けられているデータをバインドするためのロジックを実行するサーバー コントロールに通知します。  
  
 処理する場合、<xref:System.Web.UI.Control.DataBinding>イベント、このイベント処理メソッドをオーバーライドする必要があります。 これにより、すべてのデリゲートに接続されている、<xref:System.Web.UI.Control.DataBinding>イベントが呼び出されます。  
  
   
  
## Examples  
 次の例では、オーバーライドする方法、<xref:System.Web.UI.Control.OnDataBinding%2A>データ ソースから、親コントロールに子コントロールを追加するメソッド。  
  
 [!code-csharp[TemplatedDataBoundControl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.DataBinding" />
        <altmember cref="M:System.Web.UI.Control.DataBind" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.Init" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET を発生させるには、このメソッドを呼び出し、<xref:System.Web.UI.Control.Init>イベント。 カスタム コントロールを開発している場合は、追加の処理を提供するためにこのメソッドをオーバーライドすることができます。 このメソッドをオーバーライドする場合は、基本コントロールを呼び出す<xref:System.Web.UI.Control.OnInit%2A>イベントにサブスクライバーに通知するメソッド。  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.Load" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET を発生させるには、このメソッドを呼び出し、<xref:System.Web.UI.Control.Load>イベント。 カスタム コントロールを開発している場合は、追加の処理を提供するためにこのメソッドをオーバーライドすることができます。 このメソッドをオーバーライドする場合は、基本コントロールを呼び出す<xref:System.Web.UI.Control.OnLoad%2A>イベントにサブスクライバーに通知するメソッド。  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control_OnUnload#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="P:System.Web.UI.Page.IsPostBack" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.PreRender" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET を発生させるには、このメソッドを呼び出し、<xref:System.Web.UI.Control.PreRender>イベント。 カスタム コントロールを開発している場合は、追加の処理を提供するためにこのメソッドをオーバーライドすることができます。 このメソッドをオーバーライドする場合は、基本コントロールを呼び出す<xref:System.Web.UI.Control.OnPreRender%2A>イベントにサブスクライバーに通知するメソッド。  
  
   
  
## Examples  
 [!code-csharp[Control_Sample_1_snipper#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control_Sample_1_snipper#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>
          <see cref="E:System.Web.UI.Control.Unload" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET を発生させるには、このメソッドを呼び出し、<xref:System.Web.UI.Control.Unload>イベント。 カスタム コントロールを開発している場合は、追加の処理を提供するためにこのメソッドをオーバーライドすることができます。 このメソッドをオーバーライドする場合は、基本コントロールを呼び出す<xref:System.Web.UI.Control.OnUnload%2A>イベントにサブスクライバーに通知するメソッド。  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control_OnUnload#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.Unload" />
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected internal System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function OpenFile (path As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::IO::Stream ^ OpenFile(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">目的のファイルへのパス。</param>
        <summary>ファイルの読み込みで使用される <see cref="T:System.IO.Stream" /> を取得します。</summary>
        <returns>目的のファイルを参照する <see cref="T:System.IO.Stream" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.OpenFile%2A>メソッドを返します、<xref:System.IO.Stream>で指定されたファイルの内容を読み取るために使用できるオブジェクト、`path`パラメーター。 Path パラメーターか相対したりせず、プロトコルのルート URL (など、"~/mySite/myFile.txt)、または物理パスをローカル ("c:\mySite\myFile.txt") または UNC のいずれか ("\\\myServer\myFile.txt") です。  
  
 <xref:System.Web.UI.Control.OpenFile%2A>メソッドでは、ファイル アクセスのセキュリティを使用して、指定したファイルへのアクセスを制御します。 現在の ASP.NET ユーザー、ファイルへのアクセスがありません。 ファイルが開かれていないと、<xref:System.Web.HttpException>アクセスが拒否されたことを示すために例外がスローされます。 場合、`path`パラメーターは、相対パスを指定すると、例外では、要求されたファイルへの物理パスに関する情報は含まれません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">指定したファイルへのアクセスは拒否されました。</exception>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); void set(System::Web::UI::Page ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールを含んでいる <see cref="T:System.Web.UI.Page" /> インスタンスへの参照を取得します。</summary>
        <value>サーバー コントロールを含んでいる <see cref="T:System.Web.UI.Page" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値には、サーバー コントロールを含む .aspx ファイルの名前が反映されます。  
  
   
  
## Examples  
 <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> メソッドをオーバーライドする例を次に示します。 使用して、<xref:System.Web.UI.Page>プロパティへのアクセスを<xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=nameWithType>プロパティしこのコントロールを含むページがだけが読み込まれたため、初めてまたはポストバックの結果であるかどうかを決定します。  
  
 [!code-csharp[Control_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="T:System.Web.UI.Page" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::Control ^ Parent { System::Web::UI::Control ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ページ コントロールの階層構造における、サーバー コントロールの親コントロールへの参照を取得します。</summary>
        <value>サーバー コントロールの親コントロールへの参照。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ページが要求されるたびに、そのページ上のサーバー コントロールの階層が作成されています。 このプロパティでは、その階層では、それに対してプログラムは、現在のサーバー コントロールの親コントロールを決定することができます。  
  
   
  
## Examples  
 次の例は、新しい設定<xref:System.Web.UI.Control>ページでは、オブジェクト`myControl1`で指定したコントロールを<xref:System.Web.UI.Control.FindControl%2A>メソッドの呼び出しです。 コードを使用して、呼び出しが、コントロールを返す場合、<xref:System.Web.UI.Control.Parent%2A>を含むコントロールを使用するには`myControl1`します。 親コントロールが存在する場合、文字列「のテキスト ボックスの親が」と連結され、<xref:System.Web.UI.Control.ID%2A>親コントロールのプロパティに書き込まれると、<xref:System.Web.UI.Control.Page%2A>です。 親コントロールが見つからない場合、文字列「コントロール見つかりません」が出力されます。  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreRender As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PreRender;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.Control" /> オブジェクトの読み込み後、表示を開始する前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを使用すると、サーバー コントロールがページに表示される前に、更新プログラムを実行できます。 このイベント中に、サーバー コントロールのビュー ステートの変更を保存できます。 レンダリングのフェーズで行われた変更は保存されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseBubbleEvent (source As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseBubbleEvent(System::Object ^ source, EventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">イベントのソース。</param>
        <param name="args">イベント データを格納している <see cref="T:System.EventArgs" /> オブジェクト。</param>
        <summary>イベントのソースおよびその情報をコントロールの親に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET サーバー コントロールなど、 <xref:System.Web.UI.WebControls.Repeater>、<xref:System.Web.UI.WebControls.DataList>と<xref:System.Web.UI.WebControls.GridView>Web コントロールがイベントを発生させる子コントロールを含めることができます。 たとえば、内の行ごと、<xref:System.Web.UI.WebControls.GridView>コントロールは、テンプレートで動的に作成された 1 つまたは複数のボタンを含めることができます。 個別にイベントを発生させる各ボタンではなく、入れ子になったコントロールからのイベントは「バブル イベント」-は、コントロールの親に送信します。 親がさらと呼ばれるジェネリック イベントを発生させます<xref:System.Web.UI.WebControls.GridView.RowCommand>パラメーター値を使用します。 これらの値を使用すると、元のイベントを発生させたコントロールを判断できます。 この単一のイベントに応答して、子コントロールの個々 のイベント処理メソッドを記述することを回避できます。  
  
 このメソッドをオーバーライドすることはできません、ときにコントロールを作成する処理したり、オーバーライドすることでバブルのイベントを発生させる、<xref:System.Web.UI.Control.OnBubbleEvent%2A>メソッドです。  
  
   
  
## Examples  
 次のコード例は、カスタム クラスを作成する方法をデモンストレーション`ChildControl`、オーバーライド、<xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=nameWithType>メソッドを呼び出す、<xref:System.Web.UI.Control.RaiseBubbleEvent%2A>を送信するメソッド、<xref:System.Web.UI.WebControls.Button.Click?displayProperty=nameWithType>親 ASP.NET サーバー コントロールのイベントです。 インスタンスを含む ASP.NET ページ内のボタンをクリックすると`ChildControl`を生成、<xref:System.Web.UI.Control.OnBubbleEvent%2A>メソッドのインスタンスを含む親コントロールを`ChildControl`"ChildControl クラス OnClick メソッドは、文字列を書き込みますページに"を呼び出します。  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected internal virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RemovedControl(System::Web::UI::Control ^ control);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">既に削除済みの <see cref="T:System.Web.UI.Control" />。</param>
        <summary>
          <see cref="T:System.Web.UI.Control" /> オブジェクトの <see cref="P:System.Web.UI.Control.Controls" /> コレクションから子コントロールが削除された後に呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.RemovedControl%2A>メソッドは、コントロールがから削除された直後後に呼び出されますが、<xref:System.Web.UI.Control.Controls%2A>コレクション。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="P:System.Web.UI.Control.Controls" />
        <altmember cref="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">サーバー コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクト。</param>
        <summary>提供されたクライアントに表示される内容を書き込む <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトに、サーバー コントロールの内容を送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタム サーバー コントロールを開発する場合は、ASP.NET ページのコンテンツを生成するには、このメソッドをオーバーライドすることができます。  
  
   
  
## Examples  
 次のコード例では、オーバーライドを示しています、<xref:System.Web.UI.Control.Render%2A>メソッドです。 <xref:System.Web.UI.Control.HasControls%2A>メソッドを使用して、サーバー コントロールに格納されている子コントロールがあるかどうかを判断、<xref:System.Web.UI.ControlCollection>オブジェクト経由でアクセスできるは、<xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType>プロパティです。 場合<xref:System.Web.UI.Control.HasControls%2A>返します true とコレクションの最初のサーバー コントロールは、リテラル テキスト、リテラル テキストは、HTML 文字列に追加されます。  
  
 [!code-csharp[Classic Control.Render Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected internal virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">表示された内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクト。</param>
        <summary>クライアントに表示される内容の書き込みを行う、指定された <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトに、サーバー コントロールの子を出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ページ上の任意の Active Server Pages (ASP) コードを表示するために ASP.NET を通知します。 ページ上の ASP コードが存在しない、このメソッドはサーバー コントロールのコントロールすべての子を表示します。 このメソッドは、<xref:System.Web.UI.Control.Render%2A>メソッドです。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.RenderChildren%2A>カスタム サーバー コントロールのメソッドです。 現在のコントロール子コントロールがあるかどうかを判定その<xref:System.Web.UI.ControlCollection>オブジェクト。 場合は、これを使用して、<xref:System.Web.UI.ControlCollection.Count%2A>プロパティ コレクションを反復処理をします。 各子コントロールを検出すると、それを使用して、<xref:System.Web.UI.Control.RenderControl%2A>コントロール、およびすべての子コントロールを含むページに、親を表示するメソッド。  
  
 オーバーライドされた<xref:System.Web.UI.Control.Render%2A>メソッドを呼び出します、オーバーライドされた<xref:System.Web.UI.Control.RenderChildren%2A>メソッドです。  
  
 [!code-csharp[Control_Sample_1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control_Sample_1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RenderControl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>サーバー コントロールの内容を出力し、トレースが有効である場合はコントロールに関するトレース情報を格納します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RenderControl (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RenderControl(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクト。</param>
        <summary>指定の <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトにサーバー コントロールの内容を出力し、トレースが有効である場合はコントロールに関するトレース情報を保存します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバー コントロールの場合、<xref:System.Web.UI.Control.Visible%2A>プロパティに設定されている`true`、このメソッドは、ページのトレースが有効になっているかどうかを判断します。 場合は、コントロールに関連付けられているトレース情報を格納し、ページにサーバー コントロールの内容を表示します。  
  
 このメソッドは、表示中にページが自動的に呼び出されますが、カスタム コントロールの開発者によってオーバーライドされることができます。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.RenderChildren%2A>カスタム サーバー コントロールのメソッドです。 現在のコントロール子コントロールがあるかどうかを判定その<xref:System.Web.UI.ControlCollection>オブジェクト。 場合は、これを使用して、<xref:System.Web.UI.ControlCollection.Count%2A>プロパティ コレクションを反復処理をします。 各子コントロールを検出すると、それを使用して、<xref:System.Web.UI.Control.RenderControl%2A>コントロール、およびすべての子コントロールを含むページに、子を表示するメソッド。 <xref:System.Web.UI.XhtmlTextWriter>がこのメソッドに渡されるオブジェクトをインスタンス化、<xref:System.Web.UI.Page.Render%2A>メソッドです。  
  
 [!code-csharp[Control_Sample_1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control_Sample_1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RenderControl (writer As HtmlTextWriter, adapter As ControlAdapter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RenderControl(System::Web::UI::HtmlTextWriter ^ writer, System::Web::UI::Adapters::ControlAdapter ^ adapter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" />
      </Parameters>
      <Docs>
        <param name="writer">コントロールの内容を受け取る <see cref="T:System.Web.UI.HtmlTextWriter" />。</param>
        <param name="adapter">表示を定義する <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</param>
        <summary>指定した <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> オブジェクトを使用して、指定した <see cref="T:System.Web.UI.HtmlTextWriter" /> オブジェクトにサーバー コントロールの内容を出力します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web ページは、さまざまなデバイスや Web サイトから情報を要求できるブラウザーの間で使用可能です。 <xref:System.Web.UI.Control.Adapter%2A>プロパティから返される、<xref:System.Web.UI.Adapters.ControlAdapter>要求元のデバイスまたはブラウザーの画面でコントロールを描画するオブジェクト。  
  
 アダプターの詳細については、次を参照してください。[アーキテクチャの概要のアダプティブ動作を制御](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff)です。  
  
 サーバー コントロールの場合、<xref:System.Web.UI.Control.Visible%2A>プロパティに設定されている`true`ページのトレースを有効にし、コントロールに関連付けられているトレース情報をキャプチャします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>オーバーライドする場合、<see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />メソッドにカスタム コントロールは、メソッドを呼び出して基底クラスをトレース情報が正常にキャプチャされることを確認します。</para>
        </block>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.UI.Adapters.ControlAdapter" />
        <altmember cref="P:System.Web.HttpContext.Trace" />
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RenderingCompatibility As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Version ^ RenderingCompatibility { Version ^ get(); void set(Version ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レンダリングされる HTML と互換性がある ASP.NET のバージョンを表す値を取得します。</summary>
        <value>レンダリングされる HTML と互換性がある ASP.NET のバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値に設定して ASP.NET、`controlRenderingCompatibilityVersion`の属性、 `pages` Web.config ファイル内の要素。 場合、`controlRenderingCompatibilityVersion`属性は、Web.config ファイルで設定されていない、既定値は、ASP.NET の現在のバージョン。  
  
> [!CAUTION]
>  このプロパティのパブリック set アクセサーがプロパティの set アクセサーを .NET Framework インフラストラクチャをサポートします。 コードから直接使用するものではありません。 コードでこの値を設定する場合、効果は予測できません。  
  
 ASP.NET の各リリースでは、以前のリリースから、HTML を異なる方法で表示可能性があります。 ASP.NET 3.5 では、たとえばで場合、<xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A>のプロパティ、<xref:System.Web.UI.WebControls.Label>コントロールが`false`、既定では、ASP.NET の表示、`span`要素が`disabled`属性が「無効」に設定します。 既定では、ASP.NET 4 で、`span`カスケード スタイル シート (CSS) を含む要素が表示される`class`属性の代わりに、`disabled`属性。 これにより、無効になっているコントロールの外観を指定することができますを無効な HTML 表示を回避できます。 (HTML 4.0 および XHTML 1.1 では、`span`要素はサポートしていません、`disabled`属性です)。  
  
 Web アプリケーションでは、HTML 表示を変更した場合、正常に機能しないようされるコードを含む可能性があります。 この問題を避けるためには、設定することができます、`controlRenderingCompatibilityVersion`の属性、`pages`との互換性を維持する旧バージョンを示すために Web.config ファイル内の要素。 例では、設定した場合の<xref:System.Web.UI.Control.RenderingCompatibility%2A>プロパティを`3.5`、無効な<xref:System.Web.UI.WebControls.Label>コントロールを表示、`disabled`属性および CSS クラスではありません。  
  
> [!NOTE]
>  最も古いバージョンをこのプロパティを設定することができますを`3.5`です。  
  
 Visual Studio を使用して、以前のバージョンの ASP.NET 4 Web プロジェクトをアップグレードする場合は、旧バージョンとの互換性を維持、Visual Studio が自動的に設定、`controlRenderingCompatibilityVersion`に Web.config ファイルで属性`3.5`です。 ASP.NET 4 で導入されたアルゴリズムを使用して HTML を表示するために、アップグレード済みの Web サイトを設定する場合は、変更または削除、`controlRenderingCompatibilityVersion`属性。  
  
 ほとんどの場合、このプロパティによって制御される動作が自動でとを確認する必要はありません、<xref:System.Web.UI.Control.RenderingCompatibility%2A>コード内のプロパティです。 ただし、カスタム コントロールをプログラミングしている場合は、このプロパティの設定に基づいて、コントロールの動作を変更するコードを含める必要があります。 たとえば、ASP.NET 4 用のカスタム コントロールがありますで構成されている<xref:System.Web.UI.WebControls.Label>コントロール、およびカスタム コントロールを指定できます、無効になっているコントロールの外観を変更する JavaScript コードを生成することによって、`aspNetDisabled`クラスです。 これは、必要な場合として動作<xref:System.Web.UI.Control.RenderingCompatibility%2A>は`4.0`またはそれ以降。 されるときに有効ですが、同じを取得する<xref:System.Web.UI.Control.RenderingCompatibility%2A>は`3.5`、カスタム コントロールのコードは、コントロールを設定する必要があります`CssClass`プロパティを"aspNetDisabled"ときに、<xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A>プロパティは`false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.Configuration.PagesSection.ControlRenderingCompatibilityVersion" />
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ResolveAdapter () As ControlAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::Adapters::ControlAdapter ^ ResolveAdapter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指定したコントロールを表示するコントロール アダプターを取得します。</summary>
        <returns>コントロールを表示する <see cref="T:System.Web.UI.Adapters.ControlAdapter" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET Web pages は Web からページが要求の対応するデバイスの幅広い表示できます。 <xref:System.Web.UI.Control.ResolveAdapter%2A>メソッド コントロール アダプター責任を返します、ASP.NET ページを要求する、特定のブラウザーまたはデバイス上のコントロールを表示します。  
  
 返される特定のアダプター型の子孫の種類によって異なります、<xref:System.Web.UI.Control>レンダリングされているクラスです。  
  
 アダプターの詳細については、次を参照してください。[アーキテクチャの概要のアダプティブ動作を制御](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.Adapter" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveClientUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveClientUrl(System::String ^ relativeUrl);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IUrlResolutionService.ResolveClientUrl(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">現在のページに相対的な URL。</param>
        <summary>ブラウザーで使用できる URL を取得します。</summary>
        <returns>ブラウザーで使用できる、指定したリソースへの完全修飾 URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Control.ResolveClientUrl%2A>を返す URL 文字列の使用に適したクライアントがリソースにアクセスする画像ファイルなど、Web サーバー上のメソッドを他のページにリンクします。  
  
> [!NOTE]
>  このメソッドによって返される URL は、コントロールがインスタンス化されたソース ファイルを含むフォルダーの相対パスです。 など、このプロパティを継承コントロール<xref:System.Web.UI.UserControl>と<xref:System.Web.UI.MasterPage>のコントロールに対する相対的な完全修飾 URL を返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relativeUrl" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveUrl (relativeUrl As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ResolveUrl(System::String ^ relativeUrl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">
          <see cref="P:System.Web.UI.Control.TemplateSourceDirectory" /> プロパティに関連付けられた URL。</param>
        <summary>要求側クライアントで使用できる URL に変換します。</summary>
        <returns>変換後の URL。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、`relativeUrl`パラメーターには、絶対 URL が含まれています、URL はそのまま返されます。 場合、`relativeUrl`パラメーターには、相対 URL が含まれています、ブラウザーが URL を解決できるように、現在の要求パスに適した相対 URL への URL を変更することです。  
  
 たとえば、次の場合を考えてください。  
  
-   クライアントはユーザー コントロールが関連付けられているイメージを含む ASP.NET ページを要求しました。  
  
-   ASP.NET ページは、/Store/page1.aspx に配置されます。  
  
-   ユーザー コントロールは/Store/UserControls/UC1.ascx にあります。  
  
-   イメージ ファイルは/UserControls/Images/Image1.jpg にあります。  
  
 ユーザー コントロールにイメージ (つまり、/Store/UserControls/Images/Image1.jpg) への相対パスに合格した場合、<xref:System.Web.UI.Control.ResolveUrl%2A>メソッド、メソッドは値を返します/Images/Image1.jpg です。  
  
 このメソッドを使用して、<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>絶対 URL を解決するのにはプロパティです。 返された URL はクライアント使用されます。  
  
 Web サイトのリソース パスの詳細については、次を参照してください。 [ASP.NET Web プロジェクト パス](http://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd)です。  
  
> [!NOTE]
>  モバイル Web ページに対してのみ、アプリケーションが cookie なしのセッションに依存や cookie なしのセッションを必要とするモバイル ブラウザーから要求を受信する可能性がある場合、チルダを使用 ("~") で新しいセッションが誤って作成され、セッション データを失う可能性が生じることが、パス。 など、パスを持つプロパティを設定する"~/*パス"*、呼び出すことによって、パスを解決するには、<xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A>ように引数を持つ"~/*パス"* プロパティに割り当てる前にします。  
  
   
  
## Examples  
 次の例を作成、 <xref:System.Web.UI.WebControls.Image> Web サーバー コントロールのオブジェクトと使用、<xref:System.Web.UI.Control.ResolveUrl%2A>で格納されているイメージへのパスを設定するメソッドを<xref:System.Web.UI.WebControls.Image.ImageUrl%2A>プロパティです。  
  
 [!code-csharp[Control_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relativeUrl" /> パラメーターが <see langword="null" /> を格納している場合に発生します。</exception>
        <altmember cref="P:System.Web.UI.Control.TemplateSourceDirectory" />
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveControlState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページがサーバーにポスト バックされた時間以降に発生したすべてのサーバー コントロール状態の変化を保存します。</summary>
        <returns>サーバー コントロールの現在の状態を返します。 このコントロールに関連付けられている状態がない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Web.UI.Control.SaveControlState%2A>メソッドを特定のコントロールの操作に必要な状態情報を保存します。 このコントロールの状態データは、コントロールのビュー状態のデータから個別に保存されます。  
  
 コントロールの状態を使用してカスタム コントロールを呼び出す必要があります、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッドを<xref:System.Web.UI.Control.Page%2A>コントロールの状態を保存する前にします。  
  
   
  
## Examples  
 次のコード例の上書き、 <xref:System.Web.UI.Control.SaveControlState%2A> ASP.NET カスタム コントロール内のメソッドです。 このメソッドが呼び出され、時に決定するかどうか、内部プロパティ`currentIndex`と、既定以外の値に設定されている場合は、コントロールの状態に値を保存します。  
  
 <xref:System.Web.UI.Control.OnInit%2A>メソッドをオーバーライドして、呼び出し、<xref:System.Web.UI.Page.RegisterRequiresControlState%2A>メソッドを<xref:System.Web.UI.Control.Page%2A>にカスタム コントロールがコントロールの状態を使用するように指定します。  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>文字列オブジェクトが、HTML に格納されている変数として、クライアントに返されるコントロールの状態が保存されると、<see langword="HIDDEN" />要素。 コントロールで使用する状態情報を抽出するには、このメソッドをオーバーライドします。  
  
 コントロールの状態は、ページのインデックス、またはキーワードなどの重要なデータ量が少ないものです。 大量のデータの制御状態を使用すると、ページのパフォーマンスが低下することができます。 詳細については、次を参照してください。 [ASP.NET 状態管理の概要](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce)です。</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SaveViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ SaveViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ページがサーバーにポスト バックされた時間以降に発生した、サーバー コントロールのビューステートの変更を保存します。</summary>
        <returns>サーバー コントロールの現在のビューステートを返します。 コントロールに関連付けられているビューステートがない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ビュー ステートが、サーバー コントロールのプロパティの値の累積します。 これらの値は自動的に、サーバー コントロールの配置<xref:System.Web.UI.Control.ViewState%2A>インスタンスであるプロパティの<xref:System.Web.UI.StateBag>クラスです。 保存状態の段階のサーバー コントロールのライフ サイクルの後に、このプロパティの値が文字列オブジェクトを永続化します。 詳細については、次を参照してください。 [ASP.NET ページ ライフ サイクルの概要](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991)です。  
  
 ビューステートを保存すると、この文字列として返されるオブジェクトをクライアントに HTML に格納されている変数`HIDDEN`要素。 カスタム ビュー状態を持つカスタム サーバー コントロールを作成するときにビュー ステートを明示的に管理できる、<xref:System.Web.UI.Control.SaveViewState%2A>と<xref:System.Web.UI.Control.LoadViewState%2A>メソッドです。 詳細については、次を参照してください。 [ASP.NET 状態管理の概要](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce)です。 カスタム セッション状態プロバイダーを実装する方法については、次を参照してください。[セッション状態ストア プロバイダーを実装する](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66)です。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.SaveViewState%2A>カスタム ASP.NET サーバー コントロールのメソッドです。 このメソッドが呼び出されるかどうが決定コントロールで子コントロールがあるかどうかを含む、<xref:System.Web.UI.Page>ポストバックの結果であるオブジェクト。 両方に当てはまる場合に変更、<xref:System.Web.UI.WebControls.Label.Text%2A>のプロパティ、 <xref:System.Web.UI.WebControls.Label> Web サーバー コントロールを読み取る`Custom Control Has Saved State`です。 という名前のオブジェクトの配列として、コントロールのビューステートを保存`allStates`です。  
  
 [!code-csharp[Control_StateManagement#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control_StateManagement#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="T:System.Web.UI.StateBag" />
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetDesignModeState (data As IDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetDesignModeState(System::Collections::IDictionary ^ data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">コントロールのデザイン時データを格納する <see cref="T:System.Collections.IDictionary" />。</param>
        <summary>コントロールのデザイン時データを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.SetDesignModeState%2A>メソッドは、コントロールのデザイン時データを保存します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>コントロールに必要なデザイン時データを保存するには、このメソッドをオーバーライドする必要があります。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRenderMethodDelegate(System::Web::UI::RenderMethod ^ renderMethod);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">サーバー コントロールを表示するためにデリゲートに渡す必要がある情報。</param>
        <summary>サーバー コントロールとその内容を親コントロールに表示するイベント ハンドラー デリゲートを割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが実装用としてのみです。 指定されました。直接呼び出す必要があることはありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetTraceData">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>レンダリング データのデザイン時トレースのトレース データを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">トレース データ キー。</param>
        <param name="traceDataValue">トレース データの値。</param>
        <summary>トレース データ キーとトレース データ値を使用して、レンダリング データのデザイン時トレースのトレース データを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetTraceData (tracedObject As Object, traceDataKey As Object, traceDataValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetTraceData(System::Object ^ tracedObject, System::Object ^ traceDataKey, System::Object ^ traceDataValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" />
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tracedObject">トレースされたオブジェクト。</param>
        <param name="traceDataKey">トレース データ キー。</param>
        <param name="traceDataValue">トレース データの値。</param>
        <summary>トレースされたオブジェクト、トレース データ キー、およびトレース データ値を使用して、レンダリング データのデザイン時トレースのトレース データを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デザイン サーフェイスに現在のコントロールを表示するときに、このコントロールをホストするコンテナーに関する情報を取得します。</summary>
        <value>コントロールをホストしているコンテナーに関する情報が格納されている <see cref="T:System.ComponentModel.ISite" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サイトのバインド、<xref:System.ComponentModel.Component>オブジェクトを<xref:System.ComponentModel.Container>オブジェクトし、2 つの間の通信を有効にします。 コンテナーのコンポーネントを管理するための手段も提供します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">コントロールが <see cref="T:System.Web.UI.WebControls.Substitution" /> コントロールです。</exception>
        <altmember cref="T:System.ComponentModel.ISite" />
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに適用するスキンを取得または設定します。</summary>
        <value>コントロールに適用するスキンの名前。 既定値は、<see cref="F:System.String.Empty" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールで使用できるスキンは、テーマ ディレクトリ内の 1 つまたは複数のスキン ファイルに格納されます。 <xref:System.Web.UI.Control.SkinID%2A>プロパティでは、これらのコントロールに適用するスキンのどれを指定します。 スキンは、特定のコントロールに固有異なる種類のコントロール間のスキンの設定を共有することはできません。  
  
 設定しない場合、<xref:System.Web.UI.Control.SkinID%2A>プロパティ、コントロールを使用して既定のスキンが定義されている場合。 たとえば場合、スキンなし ID の定義、<xref:System.Web.UI.WebControls.Image>制御、そのスキンはすべてに適用されます<xref:System.Web.UI.WebControls.Image>コントロールを明示的に参照しない ID によって、スキンとテーマを無効にするには設定されていません。 ID を使用して、スキンが定義されている場合、<xref:System.Web.UI.WebControls.Image>制御、そのスキンにのみ適用されます<xref:System.Web.UI.WebControls.Image>が制御<xref:System.Web.UI.Control.SkinID%2A>プロパティがその ID に設定  
  
 テーマのディレクトリにスキン ファイルに指定した、スキンが含まれていない場合<xref:System.Web.UI.Control.SkinID%2A>、プロパティ、<xref:System.ArgumentException>実行時に例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">スタイル シートが既に適用されています。  
  
 \- または  
  
 <see langword="Page_PreInit" /> イベントが既に発生しています。  
  
 \- または  
  
 コントロールが既に <see langword="Controls" /> コレクションに追加されました。</exception>
        <altmember cref="P:System.Web.UI.Control.EnableTheming" />
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ControlBuilder As ControlBuilder Implements IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ControlBuilder ^ System.Web.UI.IControlBuilderAccessor.ControlBuilder { System::Web::UI::ControlBuilder ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlBuilderAccessor.ControlBuilder</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" />」をご覧ください。</summary>
        <value>コントロールを作成した <see cref="T:System.Web.UI.ControlBuilder" />。ビルダーが使用されなかった場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlBuilderAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberSignature Language="VB.NET" Value="Function GetDesignModeState () As IDictionary Implements IControlDesignerAccessor.GetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionary ^ System.Web.UI.IControlDesignerAccessor.GetDesignModeState() = System::Web::UI::IControlDesignerAccessor::GetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />」をご覧ください。</summary>
        <returns>コントロールの状態の <see cref="T:System.Collections.IDictionary" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub SetDesignModeState (data As IDictionary) Implements IControlDesignerAccessor.SetDesignModeState" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System::Collections::IDictionary ^ data) = System::Web::UI::IControlDesignerAccessor::SetDesignModeState;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">コントロールのデザイン時データを格納する <see cref="T:System.Collections.IDictionary" />。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberSignature Language="VB.NET" Value="Sub SetOwnerControl (owner As Control) Implements IControlDesignerAccessor.SetOwnerControl" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System::Web::UI::Control ^ owner) = System::Web::UI::IControlDesignerAccessor::SetOwnerControl;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="owner">コントロールの所有者。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 <xref:System.Web.UI.IControlDesignerAccessor>インターフェイスは、コントロールのデザイン時のアクションを実行するコントロールのデザイナーで使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="owner" /> が現在のコントロールに対して設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property UserData As IDictionary Implements IControlDesignerAccessor.UserData" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::IDictionary ^ System.Web.UI.IControlDesignerAccessor.UserData { System::Collections::IDictionary ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IControlDesignerAccessor.UserData</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />」をご覧ください。</summary>
        <value>コントロールに関する情報が格納されている <see cref="T:System.Collections.IDictionary" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IControlDesignerAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property DataBindings As DataBindingCollection Implements IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::DataBindingCollection ^ System.Web.UI.IDataBindingsAccessor.DataBindings { System::Web::UI::DataBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" />」をご覧ください。</summary>
        <value>データ連結のコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IDataBindingsAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasDataBindings As Boolean Implements IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IDataBindingsAccessor.HasDataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />」をご覧ください。</summary>
        <value>
          コントロールにデータ バインディング ロジックが含まれる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IDataBindingsAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Expressions As ExpressionBindingCollection Implements IExpressionsAccessor.Expressions" />
      <MemberSignature Language="C++ CLI" Value="property System::Web::UI::ExpressionBindingCollection ^ System.Web.UI.IExpressionsAccessor.Expressions { System::Web::UI::ExpressionBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.Expressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />」をご覧ください。</summary>
        <value>コントロールのプロパティと式を表す <see cref="T:System.Web.UI.ExpressionBindingCollection" /> オブジェクトが格納された <see cref="T:System.Web.UI.ExpressionBinding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IExpressionsAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property HasExpressions As Boolean Implements IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Web.UI.IExpressionsAccessor.HasExpressions { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.IExpressionsAccessor.HasExpressions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメンバーの詳細については、「<see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />」をご覧ください。</summary>
        <value>
          コントロールに、式によって設定されるプロパティがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IExpressionsAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddParsedSubObject (obj As Object) Implements IParserAccessor.AddParsedSubObject" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.IParserAccessor.AddParsedSubObject(System::Object ^ obj) = System::Web::UI::IParserAccessor::AddParsedSubObject;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">追加するオブジェクト。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Web.UI.Control> のインスタンスが <xref:System.Web.UI.IParserAccessor> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberSignature Language="VB.NET" Value="Public Property TemplateControl As TemplateControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::TemplateControl ^ TemplateControl { System::Web::UI::TemplateControl ^ get(); void set(System::Web::UI::TemplateControl ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールを格納しているテンプレートへの参照を取得または設定します。</summary>
        <value>このコントロールを格納している <see cref="T:System.Web.UI.TemplateControl" /> インスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Web.UI.Control>インスタンスが、コントロール テンプレートの一部で、<xref:System.Web.UI.Control.TemplateControl%2A>プロパティに含まれるコントロールへの参照が含まれています。 詳細については、次を参照してください。、<xref:System.Web.UI.TemplateControl?displayProperty=nameWithType>ドキュメント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TemplateSourceDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ TemplateSourceDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のサーバー コントロールを格納している <see cref="T:System.Web.UI.Page" /> または <see cref="T:System.Web.UI.UserControl" /> の仮想ディレクトリを取得します。</summary>
        <value>サーバー コントロールを格納しているページまたはユーザー コントロールの仮想ディレクトリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.Control.TemplateSourceDirectory%2A>プロパティは、現在のコントロールを含むページやユーザー コントロールへのパスを指定します。 Web ページが存在する場合など、 http://www.contoso.com/application/subdirectory、<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>プロパティが「アプリケーション/サブディレクトリ」を返します。  
  
 アプリケーションの相対仮想パスを返します ("~/サブディレクトリ")、使用して、<xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A>プロパティです。  
  
   
  
## Examples  
 次の例では、<xref:System.Web.UI.Control.TemplateSourceDirectory%2A>プロパティを 2 回クリックします。 使用されている最初の時間、<xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=nameWithType>メソッドの呼び出しをコントロールが存在するディレクトリへのパスを取得します。 2 回目では、<xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType>メソッドの呼び出しをそのディレクトリ内に含まれるすべてのファイルの一覧を取得します。  
  
 [!code-csharp[Control_TemplateSourceDirectory#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control_TemplateSourceDirectory#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.UserControl" />
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void TrackViewState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>サーバー コントロールにビューステートの変更を追跡させ、サーバー コントロールの <see cref="T:System.Web.UI.StateBag" /> オブジェクトに変更を格納できるようにします。 このオブジェクトは、<see cref="P:System.Web.UI.Control.ViewState" /> プロパティによってアクセスできます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、の最後に自動的に呼び出されます、<xref:System.Web.UI.Control.Init>サーバー コントロールのライフ サイクルのイベントです。  
  
 テンプレート宣言されたデータ バインド コントロールを開発する場合は、このメソッドを呼び出します。 このメソッドをオーバーライドするときに必要なサーバー コントロールのビュー ステートの変更を監視する ASP.NET のアラート、<xref:System.Web.UI.Control.DataBind%2A?displayProperty=nameWithType>メソッドです。  
  
   
  
## Examples  
 次の例よりも優先、<xref:System.Web.UI.Control.DataBind%2A>カスタム ASP.NET サーバー コントロールのメソッドです。 基数を呼び出すことによって開始<xref:System.Web.UI.Control.OnDataBinding%2A>メソッドおよび、使用、<xref:System.Web.UI.ControlCollection.Clear%2A>メソッドはすべての子コントロールを削除して、<xref:System.Web.UI.Control.ClearChildViewState%2A>削除するためのメソッドが、それらの子コントロールのビュー状態の設定を保存します。 最後に、<xref:System.Web.UI.Control.ChildControlsCreated%2A>プロパティに設定されている`true`です。 コントロールを使用し、<xref:System.Web.UI.Control.IsTrackingViewState%2A>コントロールのビュー ステートの変更の追跡が有効になっているかどうかを決定するプロパティです。 有効でない場合、<xref:System.Web.UI.Control.TrackViewState%2A>メソッドが呼び出されます。  
  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.IStateManager" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property UniqueID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ UniqueID { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>階層構造で修飾されたサーバー コントロールの一意の ID を取得します。</summary>
        <value>サーバー コントロールの完全修飾 ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティとは異なります、<xref:System.Web.UI.Control.ID%2A>ことで、プロパティ、<xref:System.Web.UI.Control.UniqueID%2A>サーバー コントロールの名前付けコンテナーのプロパティには識別子が含まれます。 この識別子が、ページ要求が処理されるときに自動的に生成されます。  
  
 このプロパティは、繰り返されるデータ バインディング サーバー コントロールに含まれるサーバー コントロールを区別する場合に特に重要です。 繰り返しコントロール<xref:System.Web.UI.WebControls.Repeater>、 <xref:System.Web.UI.WebControls.DataList>、 <xref:System.Web.UI.WebControls.DetailsView>、<xref:System.Web.UI.WebControls.FormView>と<xref:System.Web.UI.WebControls.GridView>Web サーバー コントロール (または作成したカスタム サーバーのコントロールで、データ バインドされている場合は、機能を繰り返しを含む) の子コントロールの名前付けコンテナーとして機能します。 つまり、それが作成される一意の名前空間の子のコントロールできるように、<xref:System.Web.UI.Control.ID%2A>プロパティの値が競合しません。  
  
 たとえば、ASP.NET を含める場合<xref:System.Web.UI.WebControls.Label>Web サーバー コントロールで、<xref:System.Web.UI.WebControls.Repeater>サーバー コントロール、および割り当て、<xref:System.Web.UI.WebControls.Label>コントロール、<xref:System.Web.UI.Control.ID%2A>のプロパティの値`MyLabel`、および<xref:System.Web.UI.WebControls.Repeater>、<xref:System.Web.UI.Control.ID%2A>の`MyRepeater`します。 データをバインドする場合、<xref:System.Web.UI.WebControls.Repeater>を<xref:System.Collections.ArrayList>、その結果、3 つのエントリを持つオブジェクト<xref:System.Web.UI.Control.UniqueID%2A>の各インスタンスのプロパティ、<xref:System.Web.UI.WebControls.Label>サーバー コントロールは、 `MyRepeater$ctl00$MyLabel`、 `MyRepeater$ctl01$MyLabel`、および`MyRepeater$ctl02$MyLabel`です。  
  
   
  
## Examples  
 次の例を作成、<xref:System.Collections.ArrayList>オブジェクト、3 つのテキスト文字列に設定し、バインド、 <xref:System.Web.UI.WebControls.Repeater> Web サーバー コントロール内のデータに、<xref:System.Collections.ArrayList>ページが読み込まれるときにします。 コードを取得、<xref:System.Web.UI.Control.UniqueID%2A>データ バインド中に生成された各子コントロールのプロパティです。 コードは 3 つのバージョンを生成、<xref:System.Web.UI.WebControls.Label>コントロールと書き込みの`UniqueID`ページにプロパティの値。  
  
 [!code-aspx-csharp[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-aspx-vb[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Control.ID" />
        <altmember cref="P:System.Web.UI.Control.NamingContainer" />
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unload;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがメモリからアンロードされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバー コントロールには、最終的なクリーンアップ、ファイル、データベース接続を閉じると、インスタンスが読み込まれる前に、コントロールのライフ サイクルのこの段階で、オブジェクトの破棄などを実行する必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ValidateRequestMode As ValidateRequestMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ValidateRequestMode ValidateRequestMode { System::Web::UI::ValidateRequestMode get(); void set(System::Web::UI::ValidateRequestMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブラウザーからのクライアント入力の安全性をコントロールで調べるかどうかを示す値を取得または設定します。</summary>
        <value>コントロールがクライアントの入力をチェックするかどうかを決定する値。 使用できる値には <see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />、<see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />、および <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" /> があります。 既定値は <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" /> で、コントロールが親から値を取得することを意味します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要求の検証の詳細については、次を参照してください。<xref:System.Web.UnvalidatedRequestValues>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewState As StateBag" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Web::UI::StateBag ^ ViewState { System::Web::UI::StateBag ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同一のページに対する複数の要求にわたって、サーバー コントロールのビューステートを保存し、復元できるようにする状態情報のディクショナリを取得します。</summary>
        <value>サーバー コントロールのビューステートの情報を格納している <see cref="T:System.Web.UI.StateBag" /> クラスのインスタンス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サーバー コントロールのビューステートは、すべてのプロパティ値の累積です。 HTTP 要求間でこれらの値を保持するために、ASP.NET サーバー コントロールがインスタンスでは、このプロパティを使用しての<xref:System.Web.UI.StateBag>クラス、プロパティ値を格納します。 値は、後続の要求が処理されるときに、変数として HTML 非表示の input 要素を渡されます。 サーバー コントロールのビューステートの保存に関する詳細については、次を参照してください。 [ASP.NET 状態管理の概要](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce)です。  
  
 既定では、すべてのサーバー コントロールのビューステートが有効な場合がありますを無効にするされます。 詳細については、次を参照してください。 [ASP.NET パフォーマンス概要](http://msdn.microsoft.com/library/f882bf1b-a009-4312-ac06-74370ffabc0b)です。  
  
 ディクショナリとその使用方法については、次を参照してください。[コレクションとデータ構造体](http://msdn.microsoft.com/library/60cc581f-1db5-445b-ba04-a173396bf872)です。  
  
   
  
## Examples  
 次の例では、実装することを示しています、`Text`を格納し、そのコントロールからその値を取得するプロパティ<xref:System.Web.UI.Control.ViewState%2A>プロパティです。  
  
 [!code-csharp[SysWebUIControlViewState#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ViewStateIgnoresCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ViewStateIgnoresCase { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Web.UI.StateBag" /> オブジェクトが大文字小文字を区別しないかどうかを示す値を取得します。</summary>
        <value>
          <see cref="T:System.Web.UI.StateBag" /> インスタンスが大文字小文字を区別しない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ケースを考慮せず、ビュー状態を保存するカスタムのサーバー コントロールを作成する場合は、このメソッドをオーバーライドします。 格納できる、同じキーではなく、大文字小文字が異なるので、複数のオブジェクトの操作を実行すると、<xref:System.Web.UI.StateBag>に関連付けられている、<xref:System.Web.UI.Control.ViewState%2A>プロパティです。  
  
   
  
## Examples  
 次の例では、オーバーライドする方法、<xref:System.Web.UI.Control.ViewStateIgnoresCase%2A>を返すプロパティ`true`です。  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.StateBag" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ViewStateMode As ViewStateMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ViewStateMode ViewStateMode { System::Web::UI::ViewStateMode get(); void set(System::Web::UI::ViewStateMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールのビューステート モードを取得または設定します。</summary>
        <value>このコントロールのビューステート モード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することができます、<xref:System.Web.UI.Control.ViewStateMode%2A>プロパティ ページのビュー ステートが無効になっている場合でも、個々 のコントロールのビュー ステートを有効にします。 ビュー ステートとコントロールの状態の詳細については、次を参照してください。、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティです。  
  
 ページのビュー ステートを無効にし、ページ上の特定のコントロールに対して有効にするには、設定、<xref:System.Web.UI.Control.EnableViewState%2A>ページおよびコントロールのプロパティ`true`、設定、<xref:System.Web.UI.Control.ViewStateMode%2A>をページのプロパティ<xref:System.Web.UI.ViewStateMode.Disabled>、設定と、<xref:System.Web.UI.Control.ViewStateMode%2A>するコントロールのプロパティ<xref:System.Web.UI.ViewStateMode.Enabled>です。  
  
 既定値、<xref:System.Web.UI.Control.ViewStateMode%2A>ページのプロパティは<xref:System.Web.UI.ViewStateMode.Enabled>します。 既定値、<xref:System.Web.UI.Control.ViewStateMode%2A>ページ内の Web サーバー コントロールのプロパティは<xref:System.Web.UI.ViewStateMode.Inherit>します。 その結果、ページまたはコントロール レベルの値のいずれかでこのプロパティを設定しない場合、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティの表示状態の動作を決定します。  
  
 <xref:System.Web.UI.Control.ViewStateMode%2A>ページまたはコントロールのプロパティがの場合のみ有効、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティに設定されている`true`です。 場合、<xref:System.Web.UI.Control.EnableViewState%2A>プロパティに設定されている`false`、ビュー ステートがあってもオフになります、<xref:System.Web.UI.Control.ViewStateMode%2A>プロパティに設定されている<xref:System.Web.UI.ViewStateMode.Enabled>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">このプロパティを <see cref="T:System.Web.UI.ViewStateMode" /> 列挙値にない値に設定しようとしました。</exception>
        <altmember cref="P:System.Web.UI.Control.EnableViewState" />
        <altmember cref="P:System.Web.UI.Control.IsViewStateEnabled" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サーバー コントロールがページ上の UI としてレンダリングされているかどうかを示す値を取得または設定します。</summary>
        <value>
          コントロールをページに表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティが場合`false`、サーバー コントロールは表示されません。 ページのレイアウトを整理するときのアカウントに注意する必要があります。  
  
> [!NOTE]
>  設定した場合でもそれに含まれる任意のコントロールが表示されない場合は、コンテナー コントロールが表示されません、<xref:System.Web.UI.Control.Visible%2A>に個々 のコントロールのプロパティ`true`です。 その場合は、個々 のコントロールを返します`false`の<xref:System.Web.UI.Control.Visible%2A>プロパティ明示的に設定した場合でも`true`です。 (されている場合、`Visible`親コントロールのプロパティに設定されて`false`子コントロールはその設定が継承、および設定がローカル設定より優先されます)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>