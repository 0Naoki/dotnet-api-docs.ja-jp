<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="TypeBuilder.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac50a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0a3d455de9bd4fc2bafe3221ec13aeb7bd4ade87</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines and creates new instances of classes during run time.</source>
          <target state="translated">実行時のクラスの新しいインスタンスを定義し、作成します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is the root class used to control the creation of dynamic classes in the runtime.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> ランタイム内の動的クラスの作成を制御するために使用するルート クラスです。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module.</source>
          <target state="translated">クラスを定義、メソッドおよびフィールドを追加し、モジュール内のクラスを作成するために使用するルーチンのセットを提供します。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>A new <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be created from a dynamic module by calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType&gt;</ph> method, which returns a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">新しい<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>呼び出すことによって、動的モジュールから作成できる、<ph id="ph2">&lt;xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType&gt;</ph>を返すメソッド、<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Reflection emit provides the following options for defining types:</source>
          <target state="translated">リフレクション出力の種類を定義するため、次のオプションを提供します。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class or interface with the given name.</source>
          <target state="translated">クラスまたは指定した名前のインターフェイスを定義します。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class or interface with the given name and attributes.</source>
          <target state="translated">クラスまたは指定された名前および属性を持つインターフェイスを定義します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, and base class.</source>
          <target state="translated">指定された名前、属性、および基本クラスを持つクラスを定義します。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and the set of interfaces that the class implements.</source>
          <target state="translated">指定された名前、属性、基本クラスおよびクラスが実装するインターフェイスのセットを持つクラスを定義します。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and packing size.</source>
          <target state="translated">指定された名前、属性、基底クラス、およびパッキング サイズを持つクラスを定義します。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, and the class size as a whole.</source>
          <target state="translated">全体として指定された名前、属性、基本クラスおよびクラスのサイズを持つクラスを定義します。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Define a class with the given name, attributes, base class, packing size, and the class size as a whole.</source>
          <target state="translated">全体として指定された名前、属性、基底クラス、パッキング サイズ、およびクラスのサイズを持つクラスを定義します。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>To create an array type, pointer type, or byref type for an incomplete type that is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method, <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method, respectively.</source>
          <target state="translated">配列型、ポインター型、または不完全な型で表されるの byref 型を作成する、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクトを使用して、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph>メソッド、<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph>メソッド、または<ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph>メソッド、それぞれします。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Before a type is used, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph> method must be called.</source>
          <target state="translated">型を使用すると、前に、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType&gt;</ph>メソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> completes the creation of the type.</source>
          <target state="translated"><bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>型の作成を完了します。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Following the call to <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>, the caller can instantiate the type by using the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and invoke members of the type by using the <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">呼び出しに続く<bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>、呼び出し元は、型をインスタンス化を使用して、<ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph>メソッドを使用して、型のメンバーを呼び出すと、<ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>It is an error to invoke methods that change the implementation of a type after <bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept> has been called.</source>
          <target state="translated">エラー後の型の実装を変更するメソッドを呼び出す<bpt id="p1">**</bpt>CreateType<ept id="p1">**</ept>が呼び出されています。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>For example, the common language runtime throws an exception if the caller tries to add new members to a type.</source>
          <target state="translated">たとえば、呼び出し元を型に新しいメンバーを追加しようとした場合、共通言語ランタイムは例外をスローします。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>A class initializer is created by using the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">クラス初期化子を使用して作成された、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept> returns a <ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>DefineTypeInitializer<ept id="p1">**</ept>を返します、<ph id="ph1">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Nested types are defined by calling one of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">入れ子にされた型がのいずれかを呼び出すことによって定義されている、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Attributes</source>
          <target state="translated">属性</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class uses the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration to further specify the characteristics of the type to be created:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>クラスの使用、<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes&gt;</ph>さらに作成する型の特性を指定する列挙体。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Interfaces are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType&gt;</ph> attributes.</source>
          <target state="translated">インターフェイスを指定、<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Interface?displayProperty=nameWithType&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Abstract?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Concrete classes (classes that cannot be extended) are specified using the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">具象クラス (クラスは拡張できません) を指定する、<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.Sealed?displayProperty=nameWithType&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Several attributes determine type visibility.</source>
          <target state="translated">いくつかの属性は、型の可視性を決定します。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>See the description of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration.</source>
          <target state="translated">説明を参照して、<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph>列挙します。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>If <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> is specified, the class loader lays out fields in the order they are read from metadata.</source>
          <target state="translated">場合<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph>が指定されているクラス ローダーがメタデータから読み取られた順序でフィールドをレイアウトします。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The class loader considers the specified packing size but ignores any specified field offsets.</source>
          <target state="translated">クラス ローダーは、指定したパッキング サイズを考慮が、指定したフィールドのオフセットは無視されます。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The metadata preserves the order in which the field definitions are emitted.</source>
          <target state="translated">メタデータには、フィールドの定義が出力される順序が保持されます。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Even across a merge, the metadata will not reorder the field definitions.</source>
          <target state="translated">マージが異なる場合でも、メタデータにフィールドの定義は並べ替えられません。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The loader will honor the specified field offsets only if <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> is specified.</source>
          <target state="translated">ローダーでは、指定したフィールド オフセット場合にのみが許可<ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>を指定します。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Known Issues</source>
          <target state="translated">既知の問題</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Reflection emit does not verify whether a non-abstract class that implements an interface has implemented all the methods declared in the interface.</source>
          <target state="translated">リフレクション出力は、インターフェイスを実装する非抽象クラスがインターフェイスで宣言されているすべてのメソッドを実装するかどうかは検証されません。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>However, if the class does not implement all the methods declared in an interface, the runtime does not load the class.</source>
          <target state="translated">ただし、クラスがインターフェイスで宣言されているすべてのメソッドを実装していない場合、ランタイムは読み込みませんクラス。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Although <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> is derived from <ph id="ph2">&lt;xref:System.Type&gt;</ph>, some of the abstract methods defined in the <ph id="ph3">&lt;xref:System.Type&gt;</ph> class are not fully implemented in the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>から派生した<ph id="ph2">&lt;xref:System.Type&gt;</ph>、一部の抽象メソッドで定義されている、<ph id="ph3">&lt;xref:System.Type&gt;</ph>クラスが完全に実装されていません、<ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Calls to these <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> methods throw a <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> exception.</source>
          <target state="translated">これらの呼び出し<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>メソッドをスロー、<ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The desired functionality can be obtained by retrieving the created type using the <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and reflecting on the retrieved type.</source>
          <target state="translated">必要な機能を使用して作成されている型を取得することによって取得できます、<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型へのリフレクションとします。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>This section contains two code examples.</source>
          <target state="translated">このセクションには、2 つのコード例が含まれています。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The first example shows how to create a dynamic type with a field, constructor, property, and method.</source>
          <target state="translated">最初の例では、フィールド、コンス トラクター、プロパティ、およびメソッドを使用する動的な型を作成する方法を示します。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The second example builds a method dynamically from user input.</source>
          <target state="translated">2 番目の例では、ユーザー入力から動的にメソッドを構築します。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>Example one<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>1 つの例<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The following code example shows how to define a dynamic assembly with one module.</source>
          <target state="translated">次のコード例では、1 つのモジュールを持つ動的アセンブリを定義する方法を示します。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The module in the example assembly contains one type, <ph id="ph1">`MyDynamicType`</ph>, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.</source>
          <target state="translated">アセンブリのモジュールには、1 つの型が含まれています<ph id="ph1">`MyDynamicType`</ph>、プライベート フィールド、プロパティを取得して、プライベート フィールドの設定を、プライベート フィールドを初期化するコンス トラクターとプライベート フィールドでユーザーが指定した数を乗算するメソッドを持つ。値し、結果を返します。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph> field is specified when the assembly is created.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave?displayProperty=nameWithType&gt;</ph>アセンブリの作成時にフィールドを指定します。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> or used in another program.</source>
          <target state="translated">アセンブリ コードが、すぐに使用され、アセンブリが保存もで調べることができるようにディスクに<bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>または別のプログラムで使用します。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source><bpt id="p1">**</bpt>Example two<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>2 つの例<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>The following code sample demonstrates how to build a dynamic type by using <ph id="ph1">`TypeBuilder`</ph>.</source>
          <target state="translated">次のコード サンプルを使用して動的な型を作成する方法を示しています<ph id="ph1">`TypeBuilder`</ph>です。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The security action to be taken such as Demand, Assert, and so on.</source>
          <target state="translated">Demand、Assert などの実行されるセキュリティ アクション。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The set of permissions the action applies to.</source>
          <target state="translated">アクションが適用されるアクセス許可のセット。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>Adds declarative security to this type.</source>
          <target state="translated">この型に宣言セキュリティを追加します。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">`AddDeclarativeSecurity`</ph> may be called several times with each call specifying a security action (such as Demand, Assert, or Deny) and a set of permissions that apply to the action.</source>
          <target state="translated"><ph id="ph1">`AddDeclarativeSecurity`</ph> 数回が (必要に応じて、Assert、Deny など) のセキュリティ アクションおよびアクションに適用される権限のセットを指定する呼び出しごとに呼び出すには、ができます。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a type by using this method are stored in the old XML metadata format.</source>
          <target state="translated">.NET Framework バージョン 1.0、1.1、および 2.0 では、このメソッドを使用して、型に適用される宣言セキュリティ属性は、XML メタデータの古い形式に格納されます。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The following example demonstrates the use of the <ph id="ph1">`AddDeclarativeSecurity`</ph> method to add a security demand for <ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph> flag to a dynamic type named <ph id="ph4">`MyDynamicClass`</ph>, in an assembly named EmittedExample.dll.</source>
          <target state="translated">次の例での使用、<ph id="ph1">`AddDeclarativeSecurity`</ph>のセキュリティ確認要求を追加するメソッドを<ph id="ph2">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph>で、<ph id="ph3">&lt;xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType&gt;</ph>フラグという名前の動的な型を<ph id="ph4">`MyDynamicClass`</ph>EmittedExample.dll をという名前のアセンブリにします。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The example produces no console output; after you run it, you can use <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine EmittedExample.dll.</source>
          <target state="translated">例では、出力されませんコンソールです。使用することができますを実行した後<bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> EmittedExample.dll を確認します。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>In <ph id="ph1">`MyDynamicClass`</ph>, open the <ph id="ph2">`.class public auto ansi`</ph> statement to see the declarative permission.</source>
          <target state="translated"><ph id="ph1">`MyDynamicClass`</ph>を開き、<ph id="ph2">`.class public auto ansi`</ph>ステートメントを宣言型のアクセス許可を参照してください。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The <ph id="ph1">&lt;paramref name="action" /&gt;</ph> is invalid (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>, <ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph>, and <ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> are invalid).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="action" /&gt;</ph> が正しくありません (<ph id="ph2">&lt;see langword="RequestMinimum" /&gt;</ph>、<ph id="ph3">&lt;see langword="RequestOptional" /&gt;</ph>、<ph id="ph4">&lt;see langword="RequestRefuse" /&gt;</ph> が正しくない)。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The containing type has been created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">含んでいる型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して作成されています。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source>The permission set <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> contains an action that was added earlier by <ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph>.</source>
          <target state="translated">アクセス許可のセット <ph id="ph1">&lt;paramref name="pset" /&gt;</ph> に、<ph id="ph2">&lt;see langword="AddDeclarativeSecurity" /&gt;</ph> によって以前に追加されたアクションが含まれています。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)">
          <source><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="pset" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The interface that this type implements.</source>
          <target state="translated">この型が実装するインターフェイス。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>Adds an interface that this type implements.</source>
          <target state="translated">この型が実装するインターフェイスを追加します。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The following code sample demonstrates the implementation of an interface on a dynamically created type using <ph id="ph1">`AddInterfaceImplementation`</ph>.</source>
          <target state="translated">次のコード サンプルでは動的に作成された型を使用して、上のインターフェイスの実装<ph id="ph1">`AddInterfaceImplementation`</ph>です。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
          <target state="translated">この型の定義を含む動的アセンブリを取得します。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Assembly">
          <source>Retrieves the dynamic assembly that contains this type definition.</source>
          <target state="translated">この型の定義を含む動的アセンブリを取得します。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Returns the full name of this type qualified by the display name of the assembly.</source>
          <target state="translated">アセンブリの表示名で修飾されたこの型の完全名を返します。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Read-only.</source>
          <target state="translated">読み取り専用。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>The full name of this type qualified by the display name of the assembly.</source>
          <target state="translated">アセンブリの表示名で修飾されたこの型の完全名。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>The format of the returned string is the concatenation of the full name of the type (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) and the display name of the assembly (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType&gt;</ph>), separated by a comma and a space.</source>
          <target state="translated">返される文字列の形式は、型の完全名を連結したもの (<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.FullName%2A&gt;</ph>) と、アセンブリの表示名 (<ph id="ph2">&lt;xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType&gt;</ph>)、コンマとスペースで区切って、します。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> for a description of the format of the display name of an assembly.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph>アセンブリの表示名の形式の詳細についてはします。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>Version Information</source>
          <target state="translated">バージョン情報</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName">
          <source>In the .NET Framework versions 1.0 and 1.1, the value of this property does not include the culture or public key.</source>
          <target state="translated">.NET Framework バージョン 1.0 および 1.1 では、このプロパティの値はカルチャまたは公開キーには含まれません。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Retrieves the base type of this type.</source>
          <target state="translated">この型の基本データ型を取得します。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.BaseType">
          <source>Retrieves the base type of this type.</source>
          <target state="translated">この型の基本データ型を取得します。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for the class.</source>
          <target state="translated">クラスの <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを作成します。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>After defining fields and methods on the class, <ph id="ph1">&lt;see langword="CreateType" /&gt;</ph> is called in order to load its <ph id="ph2">&lt;see langword="Type" /&gt;</ph> object.</source>
          <target state="translated">フィールドおよびメソッドをクラスで定義した後、<ph id="ph2">&lt;see langword="Type" /&gt;</ph> オブジェクトを読みこむために <ph id="ph1">&lt;see langword="CreateType" /&gt;</ph> が呼び出されます。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>Returns the new <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object for this class.</source>
          <target state="translated">このクラスの新しい <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If this type is a nested type, the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method must be called on the enclosing type before it is called on the nested type.</source>
          <target state="translated">この型が入れ子になった型である場合、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>入れ子にされた型で呼び出される前に、それを囲む型でメソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If the current type derives from an incomplete type or implements incomplete interfaces, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the parent type and the interface types before calling it on the current type.</source>
          <target state="translated">現在の型は、不完全な型から派生または不完全なインターフェイスを実装する、呼び出し、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>現在の型を呼び出す前に、親の型およびインターフェイスのメソッドです。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>If the enclosing type contains a field that is a value type defined as a nested type (for example, a field that is an enumeration defined as a nested type), calling the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on the enclosing type will generate a <ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">それを囲む型が入れ子にされた型 (たとえば、フィールド、入れ子にされた型として定義されている列挙型である)、として定義されている値型であるフィールドが含まれるかどうかの呼び出し、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>外側の型でメソッドが生成されます、<ph id="ph2">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph>イベント。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This is because the loader cannot determine the size of the enclosing type until the nested type has been completed.</source>
          <target state="translated">これは、入れ子にされた型が完了するまで、ローダーはそれを囲む型のサイズを判断できないためです。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The caller should define a handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph> event to complete the definition of the nested type by calling <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the nested type.</source>
          <target state="translated">呼び出し元のハンドラーを定義する必要があります、<ph id="ph1">&lt;xref:System.AppDomain.TypeResolve&gt;</ph>イベントを呼び出すことによって、入れ子にされた型の定義を完了<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>上、<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>を入れ子にされた型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The code example for this topic shows how to define such an event handler.</source>
          <target state="translated">このトピックのコード例では、このようなイベント ハンドラーを定義する方法を示します。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>A type is created only once, no matter how many times the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">型が作成される 1 回だけ方法に関係なく何度も、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>All calls return the same <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">すべての呼び出しを返す同じ<ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The following code example shows how to define an event handler for the <ph id="ph1">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph> event, in order to call the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method on a nested type during a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> call on the enclosing type.</source>
          <target state="translated">次のコード例は、イベント ハンドラーを定義する方法を示します、<ph id="ph1">&lt;xref:System.AppDomain.TypeResolve?displayProperty=nameWithType&gt;</ph>呼び出すために、イベント、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>中に入れ子にされた型のメソッドに、<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>外側の型で呼び出します。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The enclosing type has not been created.</source>
          <target state="translated">囲む型が作成されていません。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This type is non-abstract and contains an abstract method.</source>
          <target state="translated">この型は非抽象であり、抽象メソッドを含んでいます。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>This type is not an abstract class or an interface and has a method without a method body.</source>
          <target state="translated">この型は抽象クラスまたはインターフェイスではなく、メソッド本体のないメソッドを持ちます。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The type contains invalid Microsoft intermediate language (MSIL) code.</source>
          <target state="translated">この型は正しくない MSIL (Microsoft Intermediate Language) コードを含んでいます。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The branch target is specified using a 1-byte offset, but the target is at a distance greater than 127 bytes from the branch.</source>
          <target state="translated">分岐ターゲットは 1 バイト オフセットを使用して指定されますが、ターゲットは分岐点から 127 バイトを超える距離にあります。 </target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>The type cannot be loaded.</source>
          <target state="translated">型を読み込めません。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateType">
          <source>For example, it contains a <ph id="ph1">&lt;see langword="static" /&gt;</ph> method that has the calling convention <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph>.</source>
          <target state="translated">たとえば、呼び出し規則 <ph id="ph2">&lt;see cref="F:System.Reflection.CallingConventions.HasThis" /&gt;</ph> を持つ <ph id="ph1">&lt;see langword="static" /&gt;</ph> メソッドを含んでいます。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object that represents this type.</source>
          <target state="translated">この型を表す <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> オブジェクトを取得します。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo">
          <source>An object that represents this type.</source>
          <target state="translated">この型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>Gets the method that declared the current generic type parameter.</source>
          <target state="translated">現在のジェネリック型パラメーターを宣言したメソッドを取得します。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">現在の型がジェネリック型パラメーターである場合は、現在の型を宣言したメソッドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>、それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">ジェネリック型パラメーターがによって表されるコードを生成するときに、<ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph>オブジェクトではなく、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>Returns the type that declared this type.</source>
          <target state="translated">この型を宣言した型を返します。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.DeclaringType">
          <source>The type that declared this type.</source>
          <target state="translated">この型を宣言した型。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new constructor to the dynamic type.</source>
          <target state="translated">動的な型に新しいコンストラクターを追加します。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The attributes of the constructor.</source>
          <target state="translated">コンストラクターの属性。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The calling convention of the constructor.</source>
          <target state="translated">コンストラクターの呼び出し規約。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The parameter types of the constructor.</source>
          <target state="translated">コンストラクターのパラメーター型。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>Adds a new constructor to the type, with the given attributes and signature.</source>
          <target state="translated">型に、指定した属性およびシグネチャの新しいコンストラクターを追加します。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The defined constructor.</source>
          <target state="translated">定義済みのコンス トラクター。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</source>
          <target state="translated">動的な型のコンス トラクターを定義しない場合は、既定のコンス トラクターが自動的に提供され、基底クラスの既定のコンス トラクターを呼び出します。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you define a constructor for your dynamic type, a default constructor is not provided.</source>
          <target state="translated">場合は、動的な型のコンス トラクターを定義すると、既定のコンス トラクターが指定されていません。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>You have the following options for providing a default constructor in addition to the constructor you defined:</source>
          <target state="translated">コンス トラクターが定義しただけでなく、既定のコンス トラクターを提供するため、次のオプションがあります。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you want a default constructor that simply calls the default constructor of the base class, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph> method to create one (and optionally restrict access to it).</source>
          <target state="translated">既定のコンス トラクターを単に、基本クラスの既定のコンス トラクターを呼び出す場合は、行うこともできます、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A&gt;</ph>メソッドを 1 つを作成する (必要に応じてアクセスを制限すること)。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>Do not provide an implementation for this default constructor.</source>
          <target state="translated">この既定のコンス トラクターの実装を提供しません。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you do, an exception is thrown when you try to use the constructor.</source>
          <target state="translated">指定する場合は、コンス トラクターを使用しようとすると、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>No exception is thrown when the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">例外がスローされない場合に、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> method to create one, and provide your own implementation.</source>
          <target state="translated">基本クラス、または何か他完全、使用する必要がある場合は、基本クラスの既定のコンス トラクターを呼び出すだけで複数の何かを実行するかの別のコンス トラクターを呼び出す既定のコンス トラクター、 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType&gt;</ph> 、1 つを作成し、独自の実装を提供します。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineConstructor`</ph> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">使用を次のコード サンプルに示します<ph id="ph1">`DefineConstructor`</ph>動的な型のコンス トラクターの特定の署名と属性を設定し、対応するを返す<ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>MSIL 設定のためです。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the constructor.</source>
          <target state="translated">コンストラクターの属性。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the constructor.</source>
          <target state="translated">コンストラクターの呼び出し規約。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The parameter types of the constructor.</source>
          <target state="translated">コンストラクターのパラメーター型。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">型の配列の配列。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">型の各配列は、<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、対応するパラメーターの必須のカスタム修飾子を表します。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">特定のパラメーターに必須のカスタム修飾子がない場合は、型の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">どのパラメーターにも必須のカスタム修飾子がない場合は、配列の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">型の配列の配列。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">型の各配列は、<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、対応するパラメーターの省略可能なカスタム修飾子を表します。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">特定のパラメーターに省略可能なカスタム修飾子がない場合は、型の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">どのパラメーターにも省略可能カスタム修飾子がない場合は、配列の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</source>
          <target state="translated">指定された属性、署名、およびカスタム修飾子で、型に新しいコンストラクターを追加します。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The defined constructor.</source>
          <target state="translated">定義済みのコンス トラクター。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">このオーバー ロードでは、マネージ コンパイラのデザイナーが指定されます。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">カスタム修飾子の詳細については、ECMA Partition II メタデータ ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">ドキュメントはオンラインで入手できます。MSDN の「<bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「<bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The size of <ph id="ph1">&lt;paramref name="requiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="optionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="requiredCustomModifiers" /&gt;</ph> または <ph id="ph2">&lt;paramref name="optionalCustomModifiers" /&gt;</ph> のサイズは <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph> のサイズと同じではありません。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型では、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティは <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>A <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> object representing the attributes to be applied to the constructor.</source>
          <target state="translated">コンストラクターに適用される属性を表す <ph id="ph1">&lt;see langword="MethodAttributes" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Defines the default constructor.</source>
          <target state="translated">既定のコンストラクターを定義します。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The constructor defined here will simply call the default constructor of the parent.</source>
          <target state="translated">ここで定義されたコンストラクターは、単に親の既定のコンストラクターを呼び出します。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Returns the constructor.</source>
          <target state="translated">コンストラクターを返します。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</source>
          <target state="translated">既定のコンス トラクターが自動的に定義されているために、次の状況でのみこのメソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</source>
          <target state="translated">別のコンス トラクターを定義し、単に、基本クラス コンス トラクターを呼び出す既定のコンス トラクターをします。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>You want to set the attributes on the default constructor to something other than <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>, and <ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>.</source>
          <target state="translated">以外のものに既定のコンス トラクターに属性を設定する<ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.PrivateScope&gt;</ph>、 <ph id="ph2">&lt;xref:System.Reflection.MethodAttributes.Public&gt;</ph>、 <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.HideBySig&gt;</ph>、 <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph>、および<ph id="ph5">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineConstructor`</ph> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">使用を次のコード サンプルに示します<ph id="ph1">`DefineConstructor`</ph>動的な型のコンス トラクターの特定の署名と属性を設定し、対応するを返す<ph id="ph2">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>MSIL 設定のためです。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The parent type (base type) does not have a default constructor.</source>
          <target state="translated">親の型 (基本型) には、既定のコンストラクターがありません。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されています。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型では、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティは <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The name of the event.</source>
          <target state="translated">イベントの名前です。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The attributes of the event.</source>
          <target state="translated">イベントの属性。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The type of the event.</source>
          <target state="translated">イベントの型。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>Adds a new event to the type, with the given name, attributes and event type.</source>
          <target state="translated">指定した名前、属性、イベント型の新しいイベントを型に追加します。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The defined event.</source>
          <target state="translated">定義済みのイベント。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="eventtype" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="eventtype" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new field to the dynamic type.</source>
          <target state="translated">動的な型に新しいフィールドを追加します。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The name of the field.</source>
          <target state="translated">フィールドの名前。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The type of the field</source>
          <target state="translated">フィールドの種類。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The attributes of the field.</source>
          <target state="translated">フィールドの属性。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>Adds a new field to the type, with the given name, attributes, and field type.</source>
          <target state="translated">指定した名前、属性、フィールド型の新しいフィールドを型に追加します。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The defined field.</source>
          <target state="translated">定義済みのフィールド。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is System.Void.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> が System.Void です。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>A total size was specified for the parent class of this field.</source>
          <target state="translated">このフィールドの親クラスの合計サイズが指定されました。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The name of the field.</source>
          <target state="translated">フィールドの名前。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>fieldName<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The type of the field</source>
          <target state="translated">フィールドの種類。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>An array of types representing the required custom modifiers for the field, such as <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph> など、フィールドの必須のカスタム修飾子を表す型の配列。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>An array of types representing the optional custom modifiers for the field, such as <ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:Microsoft.VisualC.IsConstModifier" /&gt;</ph> など、フィールドのオプションのカスタム修飾子を表す型の配列。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The attributes of the field.</source>
          <target state="translated">フィールドの属性。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</source>
          <target state="translated">指定された名前、属性、フィールドの種類、およびカスタム修飾子を持つ新しいフィールドを型に追加します。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The defined field.</source>
          <target state="translated">定義済みのフィールド。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">このオーバー ロードでは、マネージ コンパイラのデザイナーが指定されます。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is System.Void.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> が System.Void です。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>A total size was specified for the parent class of this field.</source>
          <target state="translated">このフィールドの親クラスの合計サイズが指定されました。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="fieldName" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An array of names for the generic type parameters.</source>
          <target state="translated">ジェネリック型パラメーターの名前の配列。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to set their constraints.</source>
          <target state="translated">現在の型のジェネリック型パラメーターを定義してその数と名前を指定し、それらの制約の設定に使用できる <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> objects that can be used to define the constraints of the generic type parameters for the current type.</source>
          <target state="translated">現在の型のジェネリック型パラメーターの制約を定義するために使用できる <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Calling this method makes the current type a generic type.</source>
          <target state="translated">このメソッドを呼び出すと、現在の型がジェネリック型にします。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>If the method is called again on the same type, an <ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">メソッドは、同じ型に再び呼び出された場合、<ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll.</source>
          <target state="translated">次のコード例では、次の 2 つの型パラメーターを持つジェネリック型を作成し、アセンブリ GenericEmitExample1.dll に保存します。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to view the generated types.</source>
          <target state="translated">使用することができます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>を生成された型を表示します。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>For a more detailed explanation of the steps involved in defining a dynamic generic type, see <bpt id="p1">[</bpt>How to: Define a Generic Type with Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept>.</source>
          <target state="translated">動的、ジェネリック型定義に必要な手順の詳細については、次を参照してください。<bpt id="p1">[</bpt>する方法: リフレクション出力を持つジェネリック型定義<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>Generic type parameters have already been defined for this type.</source>
          <target state="translated">この型のジェネリック型パラメーターは既に定義されています。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source>An element of <ph id="ph1">&lt;paramref name="names" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> の要素は <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])">
          <source><ph id="ph1">&lt;paramref name="names" /&gt;</ph> is an empty array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="names" /&gt;</ph> は空の配列です。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">データを参照するために使用する名前。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The blob of data.</source>
          <target state="translated">データの blob。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">フィールドの属性。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Defines initialized data field in the .sdata section of the portable executable (PE) file.</source>
          <target state="translated">ポータブル実行可能 (PE) ファイルの .sdata セクションの初期化済みデータ フィールドを定義します。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">データを参照するフィールド。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
          <target state="translated">このメソッドを使用して作成したフィールドになります<ph id="ph1">`static`</ph>含めないようにする場合でも、<ph id="ph2">`FieldAttributes.Static`</ph>で、<ph id="ph3">`attributes`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source>The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000.</source>
          <target state="translated">データのサイズが、0 以下か、0x3f0000 以上です。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="data" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> または <ph id="ph2">&lt;paramref name="data" /&gt;</ph> が <ph id="ph3">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> has been previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> は以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a method to the type.</source>
          <target state="translated">型にメソッドを追加します。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The name of the method.</source>
          <target state="translated">メソッドの名前。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The attributes of the method.</source>
          <target state="translated">メソッドの属性。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>Adds a new method to the type, with the specified name and method attributes.</source>
          <target state="translated">新しいメソッドを、指定された名前とメソッドの属性を持つ型に追加します。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">新しく定義したメソッドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
          <target state="translated">メソッドを定義する時のメソッドのシグネチャがわからない場合は、このメソッドのオーバー ロードを使用します。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
          <target state="translated">たとえば、メソッドは、型に追加した後に定義する必要がありますメソッドのジェネリック型パラメーターでパラメーターの型とジェネリック メソッドの戻り値の型を指定する可能性があります。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">以降を使用して、パラメーターとメソッドの戻り値の型を設定できる、<ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>This method overload defines a method with <ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">このメソッドのオーバー ロードを持つメソッドを定義する<ph id="ph1">&lt;xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>If you need to define a method without a signature, with a different calling convention, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overload.</source>
          <target state="translated">別の呼び出し規約と、署名のないメソッドを定義する必要がある場合、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The following code example defines a generic method named <ph id="ph1">`DemoMethod`</ph> whose parameter type and return type are specified by its generic type parameters.</source>
          <target state="translated">次のコード例は、という名前のジェネリック メソッドを定義<ph id="ph1">`DemoMethod`</ph>がパラメーターの型と戻り値の型のジェネリック型パラメーターによって指定されます。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The method is defined without a signature, using the standard calling convention.</source>
          <target state="translated">メソッドは、標準呼び出し規約を使用して、署名のない定義されます。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method is used to make <ph id="ph2">`DemoMethod`</ph> a generic method, and the newly defined type parameters are then used for the signature and return type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph>を行うメソッドが使用<ph id="ph2">`DemoMethod`</ph>署名のために使用され、型を返すジェネリック メソッド、および新しく定義した型のパラメーターです。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph> method.</source>
          <target state="translated">このコード例に示されている例の一部である、<ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドの親の型がインターフェイスであり、このメソッドは仮想 (Visual Basic では <ph id="ph1">&lt;see langword="Overridable" /&gt;</ph>) ではありません。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型では、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティは <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The name of the method.</source>
          <target state="translated">メソッドの名前。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The attributes of the method.</source>
          <target state="translated">メソッドの属性。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The calling convention of the method.</source>
          <target state="translated">メソッドの呼び出し規約。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>Adds a new method to the type, with the specified name, method attributes, and calling convention.</source>
          <target state="translated">新しいメソッドを、指定された名前、メソッドの属性、および呼び出し規約を持つ型に追加します。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">新しく定義したメソッドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>Use this method overload when you do not know the method signature at the time you define the method.</source>
          <target state="translated">メソッドを定義する時のメソッドのシグネチャがわからない場合は、このメソッドのオーバー ロードを使用します。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type.</source>
          <target state="translated">たとえば、メソッドは、型に追加した後に定義する必要がありますメソッドのジェネリック型パラメーターでパラメーターの型とジェネリック メソッドの戻り値の型を指定する可能性があります。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The parameters and return type of the method can be set later using the <ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">以降を使用して、パラメーターとメソッドの戻り値の型を設定できる、<ph id="ph1">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The type of the parent of this method is an interface and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドの親の型がインターフェイスであり、このメソッドは仮想ではありません (Visual Basic では <ph id="ph1">&lt;see langword="Overridable" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型では、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティは <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">メソッドの名前。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">メソッドの属性。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">メソッドの戻り値の型。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">メソッドのパラメーターの型。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>Adds a new method to the type, with the specified name, method attributes, and method signature.</source>
          <target state="translated">新しいメソッドを、指定された名前、メソッドの属性、およびメソッドのシグニチャを持つ型に追加します。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The defined method.</source>
          <target state="translated">定義されたメソッド。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineMethod`</ph> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">使用を次のコード サンプルに示します<ph id="ph1">`DefineMethod`</ph>動的な型にコンス トラクターの特定の署名と属性を設定して、対応するを返す<ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>MSIL 設定のためです。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドの親の型がインターフェイスであり、このメソッドは仮想 (Visual Basic では <ph id="ph1">&lt;see langword="Overridable" /&gt;</ph>) ではありません。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型では、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティは <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the method.</source>
          <target state="translated">メソッドの名前。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the method.</source>
          <target state="translated">メソッドの属性。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention of the method.</source>
          <target state="translated">メソッドの呼び出し規約。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the method.</source>
          <target state="translated">メソッドの戻り値の型。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">メソッドのパラメーターの型。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</source>
          <target state="translated">指定された名前、メソッドの属性、呼び出し規則、およびメソッドのシグネチャを持つ新しいメソッドを型に追加します。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the newly defined method.</source>
          <target state="translated">新しく定義したメソッドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineMethod`</ph> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> for MSIL population.</source>
          <target state="translated">使用を次のコード サンプルに示します<ph id="ph1">`DefineMethod`</ph>動的な型にコンス トラクターの特定の署名と属性を設定して、対応するを返す<ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>MSIL 設定のためです。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドの親の型がインターフェイスであり、このメソッドは仮想 (Visual Basic では <ph id="ph1">&lt;see langword="Overridable" /&gt;</ph>) ではありません。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型では、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティは <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the method.</source>
          <target state="translated">メソッドの名前。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the method.</source>
          <target state="translated">メソッドの属性。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the method.</source>
          <target state="translated">メソッドの呼び出し規約。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the method.</source>
          <target state="translated">メソッドの戻り値の型</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">メソッドの戻り値の型の <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> など、必須のカスタム修飾子を表す型の配列。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">戻り値の型が必須のカスタム修飾子を持たない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">メソッドの戻り値の型の <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、省略可能なカスタム修飾子を表す型の配列。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">戻り値の型が省略可能なカスタム修飾子を持たない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the method.</source>
          <target state="translated">メソッドのパラメーターの型。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">型の配列の配列。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">型の各配列は、<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、対応するパラメーターの必須のカスタム修飾子を表します。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">特定のパラメーターに必須のカスタム修飾子がない場合は、型の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">どのパラメーターにも必須のカスタム修飾子がない場合は、配列の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">型の配列の配列。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">型の各配列は、<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、対応するパラメーターの省略可能なカスタム修飾子を表します。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">特定のパラメーターに省略可能なカスタム修飾子がない場合は、型の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">どのパラメーターにも省略可能カスタム修飾子がない場合は、配列の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</source>
          <target state="translated">新しいメソッドを、指定された名前、メソッドの属性、呼び出し規約、メソッドのシグニチャ、およびカスタム修飾子を持つ型に追加します。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> object representing the newly added method.</source>
          <target state="translated">新しく追加されたメソッドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Use this overload if you need to specify custom modifiers.</source>
          <target state="translated">カスタム修飾子を指定する必要がある場合は、このオーバー ロードを使用します。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph> method overloads to define the method and then use the <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method to define the parameter and return types with custom modifiers.</source>
          <target state="translated">同様、メソッドを作成すると後に、カスタム修飾子を指定する必要がある場合など、パラメーター型を持つが、そのジェネリック型パラメーターで指定されたジェネリック メソッドを使用して行うこともできます、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29&gt;</ph>メソッドのオーバー ロード メソッドを定義し、使用して、<ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph>パラメーターを定義して返すメソッドのカスタム修飾子を持つ型します。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">カスタム修飾子の詳細については、ECMA Partition II メタデータ ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">ドキュメントはオンラインで入手できます。MSDN の「<bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「<bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type of the parent of this method is an interface, and this method is not virtual (<ph id="ph1">&lt;see langword="Overridable" /&gt;</ph> in Visual Basic).</source>
          <target state="translated">このメソッドの親の型がインターフェイスであり、このメソッドは仮想ではありません (Visual Basic では <ph id="ph1">&lt;see langword="Overridable" /&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The size of <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> または <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> のサイズは <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph> のサイズと同じではありません。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型では、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティは <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The method body to be used.</source>
          <target state="translated">使用するメソッド本体。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>This should be a <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> object.</source>
          <target state="translated">これは <ph id="ph1">&lt;see langword="MethodBuilder" /&gt;</ph> オブジェクトである必要があります。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The method whose declaration is to be used.</source>
          <target state="translated">宣言が使用されるメソッド。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Specifies a given method body that implements a given method declaration, potentially with a different name.</source>
          <target state="translated">特定のメソッド宣言 (名前が異なる可能性があります) を実装する特定のメソッド本体を指定します。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Do not use this method to emit method overrides or interface implementations.</source>
          <target state="translated">メソッドのオーバーライドまたはインターフェイスの実装を出力するのには、このメソッドを使用しないでください。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</source>
          <target state="translated">基底クラスのメソッドをオーバーライドまたはインターフェイスのメソッドを実装するは、コード例で示すよう、オーバーライドまたは実装するメソッドとして同じ名前およびシグネチャを持つメソッドを生成するだけです。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is used when a method body and a method declaration have different names.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph>メソッドは、メソッドの本体とメソッドの宣言は、異なる名前を付けるときに使用します。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example.</source>
          <target state="translated">たとえば、クラスは、基本クラス メソッドをオーバーライドしのコード例に示すように、同じ名前のインターフェイス メンバーの別々 の実装も提供することがします。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">`DefineMethodOverride`</ph> defines a <ph id="ph2">`methodimpl`</ph>, which consists of a pair of metadata tokens.</source>
          <target state="translated"><ph id="ph1">`DefineMethodOverride`</ph> 定義、 <ph id="ph2">`methodimpl`</ph>、メタデータ トークンのペアから構成されます。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>One token points to an implementation, and the other token points to a declaration that the body implements.</source>
          <target state="translated">1 つのトークンは、実装、および本文を実装するための宣言に他のトークンのポイントを指します。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The body must be defined on the type the method impl is defined on, and the body must be virtual (<ph id="ph1">`Overridable`</ph> in Visual Basic).</source>
          <target state="translated">本文は、メソッドの実装が定義されている型で定義する必要があり、本文は仮想である必要があります (<ph id="ph1">`Overridable`</ph> Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type.</source>
          <target state="translated">宣言は、型、派生クラスのメソッドまたは型で定義されているメソッドによって実装されるインターフェイスで定義されたメソッドを作成できます。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the declaration is on an interface only, the slot defined for the interface is altered.</source>
          <target state="translated">宣言は、インターフェイスだけでは、インターフェイスに対して定義されているスロットが変更されます。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced.</source>
          <target state="translated">基本型のメソッドを宣言が行われた場合は、メソッドのスロットがオーバーライドされていて、オーバーライド対象メソッドの重複が置き換えられるもします。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The overridden method cannot be the actual method that is declared.</source>
          <target state="translated">オーバーライドされたメソッドは、宣言されている実際のメソッドにすることはできません。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</source>
          <target state="translated">メソッドは、同じ型には、スロットが置き換えられ、置き換えられたメソッドの重複がオーバーライドされます。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For more information about method impls, see <ph id="ph1">`MethodImpl`</ph> in the ECMA Partition II Metadata documentation.</source>
          <target state="translated">メソッドの impls の詳細については、次を参照してください。 <ph id="ph1">`MethodImpl`</ph> ECMA Partition II メタデータ ドキュメントにします。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">ドキュメントはオンラインで入手できます。MSDN の「<bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「<bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method is called, some features of <ph id="ph2">`methodInfoBody`</ph> cannot be changed.</source>
          <target state="translated">後に、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph>メソッドは、一部の機能の<ph id="ph2">`methodInfoBody`</ph>は変更できません。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>For example, you cannot apply an attribute to a generic type parameter of <ph id="ph1">`methodInfoBody`</ph> by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph> method.</source>
          <target state="translated">たとえば、ジェネリック型パラメーターに属性を適用することはできません<ph id="ph1">`methodInfoBody`</ph>を使用して、<ph id="ph2">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>If you must use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method, do so after all characteristics of <ph id="ph2">`methodInfoBody`</ph> have been defined.</source>
          <target state="translated">使用する場合、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph>メソッド、後のすべての特性<ph id="ph2">`methodInfoBody`</ph>が定義されています。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The following code example contains an interface <ph id="ph1">`I`</ph> with a method <ph id="ph2">`M()`</ph>, a base class <ph id="ph3">`A`</ph> that implements the interface, and a derived class <ph id="ph4">`C`</ph> that overrides the base class implementation of <ph id="ph5">`M()`</ph> and also provides a separate explicit implementation of <ph id="ph6">`I.M()`</ph>.</source>
          <target state="translated">次のコード例には、インターフェイスが含まれています<ph id="ph1">`I`</ph>メソッドを使用して<ph id="ph2">`M()`</ph>、基本クラス<ph id="ph3">`A`</ph>インターフェイス、および派生クラスを実装する<ph id="ph4">`C`</ph>の基本クラス実装をオーバーライドする<ph id="ph5">`M()`</ph>、さらに。別の明示的な実装を提供<ph id="ph6">`I.M()`</ph>です。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">`main()`</ph> method of the code example shows how to emit the derived class <ph id="ph2">`C`</ph>.</source>
          <target state="translated"><ph id="ph1">`main()`</ph>コード例のメソッドは、派生クラスを生成する方法を示しています。<ph id="ph2">`C`</ph>です。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The override of <ph id="ph1">`A.M()`</ph> is accomplished simply by emitting a method <ph id="ph2">`M()`</ph> with the same signature.</source>
          <target state="translated">オーバーライド<ph id="ph1">`A.M()`</ph>メソッドを生成するだけで完了<ph id="ph2">`M()`</ph>同じシグネチャを使用します。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>However, to provide a separate implementation of <ph id="ph1">`I.M()`</ph>, you must define a method body and then use the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph> method to associate that method body with a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representing <ph id="ph4">`I.M()`</ph>.</source>
          <target state="translated">ただしの別々 の実装を提供する<ph id="ph1">`I.M()`</ph>、メソッド本体を定義し、使用する必要があります、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A&gt;</ph>メソッドにそのメソッドの本体とを関連付けるには、<ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>を表す<ph id="ph4">`I.M()`</ph>です。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The name of the method body does not matter.</source>
          <target state="translated">メソッドの本体の名前は関係ありません。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The code example creates an instance of the emitted class.</source>
          <target state="translated">このコード例では、生成されたクラスのインスタンスを作成します。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>It obtains a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for <ph id="ph2">`I.M()`</ph>, and uses it to invoke the emitted class's explicit interface implementation.</source>
          <target state="translated">取得、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>オブジェクトに対する<ph id="ph2">`I.M()`</ph>、使用して、生成されたクラスを呼び出すための明示的なインターフェイスの実装とします。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>It then obtains a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for <ph id="ph2">`A.M()`</ph>, and uses it to invoke the emitted class's override of that method.</source>
          <target state="translated">取得し、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>オブジェクトに対する<ph id="ph2">`A.M()`</ph>、し、生成されたクラスのメソッドのオーバーライドを呼び出すために使用します。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> does not belong to this class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> はこのクラスに属していません。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> or <ph id="ph2">&lt;paramref name="methodInfoDeclaration" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> または <ph id="ph2">&lt;paramref name="methodInfoDeclaration" /&gt;</ph> が <ph id="ph3">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> is not the type represented by this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="methodInfoBody" /&gt;</ph> の宣言型は、この <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> によって表される型ではありません。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines a nested type.</source>
          <target state="translated">入れ子にされた型を定義します。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The short name of the type.</source>
          <target state="translated">型の短い名前。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>Defines a nested type, given its name.</source>
          <target state="translated">名前を指定された、入れ子にされた型を定義します。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The defined nested type.</source>
          <target state="translated">定義済みの入れ子にされた型。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">このメソッドは、入れ子になったを作成するために使用できます、型、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>外側の型でメソッドが呼び出されました。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">入れ子にされた型を使用してそれに反映できる前に完了する必要があります<ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>、または<ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">説明を参照して<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">重複する名前は必ずしも作成されません<ph id="ph1">`name`</ph>以前に定義された型または入れ子にされた型の名前と同じです。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 または 1023 を超えています。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">この操作では、現在のアセンブリ内に <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> が重複する型が作成されます。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The short name of the type.</source>
          <target state="translated">型の短い名前。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The attributes of the type.</source>
          <target state="translated">型の属性。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>Defines a nested type, given its name and attributes.</source>
          <target state="translated">指定した名前と属性を持つ入れ子にされた型を定義します。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The defined nested type.</source>
          <target state="translated">定義済みの入れ子にされた型。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">このメソッドは、入れ子になったを作成するために使用できます、型、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>外側の型でメソッドが呼び出されました。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">入れ子にされた型を使用してそれに反映できる前に完了する必要があります<ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>、または<ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">説明を参照して<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">重複する名前は必ずしも作成されません<ph id="ph1">`name`</ph>以前に定義された型または入れ子にされた型の名前と同じです。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">入れ子にされた属性が指定されていません。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is sealed.</source>
          <target state="translated">この型は封印されています。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is an array.</source>
          <target state="translated">この型は配列です。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">この型はインターフェイスですが、入れ子にされた型がインターフェイスではありません。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 であるか、1023 を超えています。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">この操作では、現在のアセンブリ内に <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> が重複する型が作成されます。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The short name of the type.</source>
          <target state="translated">型の短い名前。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The attributes of the type.</source>
          <target state="translated">型の属性。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The type that the nested type extends.</source>
          <target state="translated">入れ子にされた型を拡張する型。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>Defines a nested type, given its name, attributes, and the type that it extends.</source>
          <target state="translated">入れ子にされた型、指定された名前、属性、および拡張する型を定義します。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The defined nested type.</source>
          <target state="translated">定義済みの入れ子にされた型。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">このメソッドは、入れ子になったを作成するために使用できます、型、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>外側の型でメソッドが呼び出されました。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">入れ子にされた型を使用してそれに反映できる前に完了する必要があります<ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>、または<ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">説明を参照して<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">重複する名前は必ずしも作成されません<ph id="ph1">`name`</ph>以前に定義された型または入れ子にされた型の名前と同じです。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">入れ子にされた属性が指定されていません。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is sealed.</source>
          <target state="translated">この型は封印されています。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is an array.</source>
          <target state="translated">この型は配列です。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">この型はインターフェイスですが、入れ子にされた型がインターフェイスではありません。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 であるか、1023 を超えています。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">この操作では、現在のアセンブリ内に <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> が重複する型が作成されます。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The short name of the type.</source>
          <target state="translated">型の短い名前。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The attributes of the type.</source>
          <target state="translated">型の属性。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The type that the nested type extends.</source>
          <target state="translated">入れ子にされた型を拡張する型。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">型の合計サイズ。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</source>
          <target state="translated">入れ子にされた型、指定された名前、属性、型の合計サイズ、および拡張する型を定義します。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The defined nested type.</source>
          <target state="translated">定義済みの入れ子にされた型。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">このメソッドは、入れ子になったを作成するために使用できます、型、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>外側の型でメソッドが呼び出されました。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">入れ子にされた型を使用してそれに反映できる前に完了する必要があります<ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>、または<ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">説明を参照して<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">重複する名前は必ずしも作成されません<ph id="ph1">`name`</ph>以前に定義された型または入れ子にされた型の名前と同じです。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">入れ子にされた属性が指定されていません。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is sealed.</source>
          <target state="translated">この型は封印されています。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is an array.</source>
          <target state="translated">この型は配列です。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">この型はインターフェイスですが、入れ子にされた型がインターフェイスではありません。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 であるか、1023 を超えています。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">この操作では、現在のアセンブリ内に <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> が重複する型が作成されます。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The short name of the type.</source>
          <target state="translated">型の短い名前。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The attributes of the type.</source>
          <target state="translated">型の属性。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The type that the nested type extends.</source>
          <target state="translated">入れ子にされた型を拡張する型。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The packing size of the type.</source>
          <target state="translated">型のパッキング サイズ。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</source>
          <target state="translated">入れ子にされた型、指定された名前、属性、拡張する型、およびパッキング サイズを定義します。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The defined nested type.</source>
          <target state="translated">定義済みの入れ子にされた型。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">このメソッドは、入れ子になったを作成するために使用できます、型、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>外側の型でメソッドが呼び出されました。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">入れ子にされた型を使用してそれに反映できる前に完了する必要があります<ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>、または<ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">説明を参照して<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">重複する名前は必ずしも作成されません<ph id="ph1">`name`</ph>以前に定義された型または入れ子にされた型の名前と同じです。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The nested attribute is not specified.</source>
          <target state="translated">入れ子にされた属性が指定されていません。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is sealed.</source>
          <target state="translated">この型は封印されています。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is an array.</source>
          <target state="translated">この型は配列です。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">この型はインターフェイスですが、入れ子にされた型がインターフェイスではありません。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 であるか、1023 を超えています。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">この操作では、現在のアセンブリ内に <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> が重複する型が作成されます。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The short name of the type.</source>
          <target state="translated">型の短い名前。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The attributes of the type.</source>
          <target state="translated">型の属性。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The type that the nested type extends.</source>
          <target state="translated">入れ子にされた型が拡張する型。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The interfaces that the nested type implements.</source>
          <target state="translated">入れ子型で実装されるインターフェイス。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</source>
          <target state="translated">指定された名前、属性、拡張する基本型、および実装するインターフェイスを指定して、ネスト型を定義します。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The defined nested type.</source>
          <target state="translated">定義済みの入れ子にされた型。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This method can be used to create nested types even after the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called on the enclosing type.</source>
          <target state="translated">このメソッドは、入れ子になったを作成するために使用できます、型、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>外側の型でメソッドが呼び出されました。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The nested type needs to be complete before you can reflect on it using <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>.</source>
          <target state="translated">入れ子にされた型を使用してそれに反映できる前に完了する必要があります<ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph>、または<ph id="ph3">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>See the description of <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> for the order in which nested types and nesting types should be completed.</source>
          <target state="translated">説明を参照して<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>の入れ子にされた型と入れ子の型を完了する必要がありますを注文します。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>A duplicate name is not necessarily created if <ph id="ph1">`name`</ph> is identical to the name of a previously defined type or nested type.</source>
          <target state="translated">重複する名前は必ずしも作成されません<ph id="ph1">`name`</ph>以前に定義された型または入れ子にされた型の名前と同じです。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>To be duplicates, the full names must be the same, including the namespace and all nesting types.</source>
          <target state="translated">重複する場合は、完全名は同じで、名前空間と入れ子になったすべての型を含むをする必要があります。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The nested attribute is not specified.</source>
          <target state="translated">入れ子にされた属性が指定されていません。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is sealed.</source>
          <target state="translated">この型は封印されています。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is an array.</source>
          <target state="translated">この型は配列です。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This type is an interface, but the nested type is not an interface.</source>
          <target state="translated">この型はインターフェイスですが、入れ子にされた型がインターフェイスではありません。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero or greater than 1023.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 であるか、1023 を超えています。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>This operation would create a type with a duplicate <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> in the current assembly.</source>
          <target state="translated">この操作では、現在のアセンブリ内に <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /&gt;</ph> が重複する型が作成されます。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])">
          <source>An element of the <ph id="ph1">&lt;paramref name="interfaces" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaces" /&gt;</ph> 配列の要素が <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The short name of the type.</source>
          <target state="translated">型の短い名前。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded null values.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The attributes of the type.</source>
          <target state="translated">型の属性。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The type that the nested type extends.</source>
          <target state="translated">入れ子にされた型を拡張する型。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The packing size of the type.</source>
          <target state="translated">型のパッキング サイズ。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The total size of the type.</source>
          <target state="translated">型の合計サイズ。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>Defines a nested type, given its name, attributes, size, and the type that it extends.</source>
          <target state="translated">入れ子にされた型、指定された名前、属性、サイズ、および拡張する型を定義します。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)">
          <source>The defined nested type.</source>
          <target state="translated">定義済みの入れ子にされた型。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッドを定義します。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッドの名前。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッドが定義されている DLL の名前。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">メソッドの属性。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">メソッドの呼び出し規則。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">メソッドの戻り値の型。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">メソッドのパラメーターの型。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">ネイティブ呼び出し規則。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">メソッドのネイティブ文字セット。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッドに名前を指定して、メソッドが定義されている DLL の名前、メソッドの属性、メソッドの呼び出し規則、メソッドの戻り値の型、メソッドのパラメーター型、および <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> フラグを定義します。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">定義された <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッド。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">属性のいくつかの DLL インポート (の説明を参照して<ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) このメソッドに引数として指定することはできません。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">たとえば、DLL インポート属性<ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph>後に追加する必要があります、<ph id="ph2">`PInvoke`</ph>メソッドは値を返す場合に、メソッドが作成されます。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">この例では、これを行う方法を示します。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> method to create a <ph id="ph2">`PInvoke`</ph> method, and how to add the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">次の例で使用する方法、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph>メソッドを作成、<ph id="ph2">`PInvoke`</ph>メソッド、および追加する方法、<ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph>フラグ メソッド実装フラグを作成した後に、<ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>を使用して、<ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">0 以外の戻り値を取得する必要がありますを追加する、<ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph>フラグ。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">例では、1 つの動的モジュールと 1 つの型、動的アセンブリを作成する<ph id="ph1">`MyType`</ph>を格納している、<ph id="ph2">`PInvoke`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated"><ph id="ph1">`PInvoke`</ph>メソッドを表す、Win32<ph id="ph2">`GetTickCount`</ph>関数。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">この例を実行すると、実行、<ph id="ph1">`PInvoke`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">また、PInvokeTest.dll として動的アセンブリを保存します。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">使用することができます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>を調べる、<ph id="ph1">`MyType`</ph>クラスおよび<ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> Visual Basic で)<ph id="ph4">`PInvoke`</ph>メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Visual Basic または C# の場合、静的なを使用するプログラムをコンパイルする<ph id="ph1">`MyType.GetTickCount`</ph>csc.exe または vbc.exe; を実行するときに DLL への参照を含めることによってメソッドなど、<ph id="ph2">`/r:PInvokeTest.dll`</ph>です。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">メソッドは静的ではありません。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">親の型がインターフェイスです。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">抽象メソッドです。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">メソッドは以前に定義されています。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> または <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> or <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> または <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph> が <ph id="ph3">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">含んでいる型が <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して以前に作成されています。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッドの名前。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッドが定義されている DLL の名前。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">DLL 内のエントリ ポイントの名前。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">メソッドの属性。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">メソッドの呼び出し規則。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">メソッドの戻り値の型。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">メソッドのパラメーターの型。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">ネイティブ呼び出し規則。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">メソッドのネイティブ文字セット。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, and the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッドに名前を指定して、メソッドが定義されている DLL の名前、エントリ ポイント名、メソッドの属性、メソッドの呼び出し規約、メソッドの戻り値の型、メソッドのパラメーター型、および <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> フラグを定義します。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The defined <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">定義された <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッド。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">属性のいくつかの DLL インポート (の説明を参照して<ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) このメソッドに引数として指定することはできません。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">たとえば、DLL インポート属性<ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph>後に追加する必要があります、<ph id="ph2">`PInvoke`</ph>メソッドは値を返す場合に、メソッドが作成されます。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">この例では、これを行う方法を示します。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph> method to create a <ph id="ph2">`PInvoke`</ph> method, and how to add the <ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">次のコード例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt;</ph>メソッドを作成、<ph id="ph2">`PInvoke`</ph>メソッド、および追加する方法、<ph id="ph3">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph>フラグ メソッド実装フラグを作成した後に、<ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>を使用して、<ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph6">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">0 以外の戻り値を取得する必要がありますを追加する、<ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph>フラグ。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">例では、1 つの動的モジュールと 1 つの型、動的アセンブリを作成する<ph id="ph1">`MyType`</ph>を格納している、<ph id="ph2">`PInvoke`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated"><ph id="ph1">`PInvoke`</ph>メソッドを表す、Win32<ph id="ph2">`GetTickCount`</ph>関数。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">この例を実行すると、実行、<ph id="ph1">`PInvoke`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">また、PInvokeTest.dll として動的アセンブリを保存します。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">使用することができます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>を調べる、<ph id="ph1">`MyType`</ph>クラスおよび<ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> Visual Basic で)<ph id="ph4">`PInvoke`</ph>メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Visual Basic または C# の場合、静的なを使用するプログラムをコンパイルする<ph id="ph1">`MyType.GetTickCount`</ph>csc.exe または vbc.exe; を実行するときに DLL への参照を含めることによってメソッドなど、<ph id="ph2">`/r:PInvokeTest.dll`</ph>です。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">メソッドは静的ではありません。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">親の型がインターフェイスです。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">抽象メソッドです。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">メソッドは以前に定義されています。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>、<ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>、または <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>、<ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>、または <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> が <ph id="ph4">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">含んでいる型が <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して以前に作成されています。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッドの名前。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the DLL in which the <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method is defined.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッドが定義されている DLL の名前。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The name of the entry point in the DLL.</source>
          <target state="translated">DLL 内のエントリ ポイントの名前。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The attributes of the method.</source>
          <target state="translated">メソッドの属性。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's calling convention.</source>
          <target state="translated">メソッドの呼び出し規則。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's return type.</source>
          <target state="translated">メソッドの戻り値の型。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">メソッドの戻り値の型の <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> など、必須のカスタム修飾子を表す型の配列。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">戻り値の型が必須のカスタム修飾子を持たない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the method.</source>
          <target state="translated">メソッドの戻り値の型の <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、省略可能なカスタム修飾子を表す型の配列。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">戻り値の型に省略可能のカスタム修飾子がない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The types of the method's parameters.</source>
          <target state="translated">メソッドのパラメーター型。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of arrays of types.</source>
          <target state="translated">型の配列の配列。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">型の各配列は、<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、対応するパラメーターの必須のカスタム修飾子を表します。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">特定のパラメーターに必須のカスタム修飾子がない場合は、型の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">どのパラメーターにも必須のカスタム修飾子がない場合は、配列の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>An array of arrays of types.</source>
          <target state="translated">型の配列の配列。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">型の各配列は、<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、対応するパラメーターの省略可能なカスタム修飾子を表します。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">特定のパラメーターに省略可能なカスタム修飾子がない場合は、型の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">どのパラメーターにも省略可能カスタム修飾子がない場合は、配列の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The native calling convention.</source>
          <target state="translated">ネイティブ呼び出し規則。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method's native character set.</source>
          <target state="translated">メソッドのネイティブ文字セット。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Defines a <ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> method given its name, the name of the DLL in which the method is defined, the name of the entry point, the attributes of the method, the calling convention of the method, the return type of the method, the types of the parameters of the method, the <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> flags, and custom modifiers for the parameters and return type.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="PInvoke" /&gt;</ph> メソッドを定義します。名前、メソッドが定義されている DLL の名前、エントリ ポイント名、メソッドの属性、メソッドの呼び出し規則、メソッドの戻り値の型、メソッドのパラメーター型、<ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> フラグ、およびパラメーターと戻り値の型のカスタム修飾子を指定します。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph> representing the defined <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> method.</source>
          <target state="translated">定義された <ph id="ph2">&lt;see langword="PInvoke" /&gt;</ph> メソッドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>Some DLL import attributes (see the description of <ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) cannot be specified as arguments to this method.</source>
          <target state="translated">属性のいくつかの DLL インポート (の説明を参照して<ph id="ph1">&lt;xref:System.Runtime.InteropServices.DllImportAttribute&gt;</ph>) このメソッドに引数として指定することはできません。</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For example, the DLL import attribute <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> must be added after the <ph id="ph2">`PInvoke`</ph> method is created, if the method returns a value.</source>
          <target state="translated">たとえば、DLL インポート属性<ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph>後に追加する必要があります、<ph id="ph2">`PInvoke`</ph>メソッドは値を返す場合に、メソッドが作成されます。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example shows how to do this.</source>
          <target state="translated">この例では、これを行う方法を示します。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">カスタム修飾子の詳細については、ECMA Partition II メタデータ ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">ドキュメントはオンラインで入手できます。MSDN の「<bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「<bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The following code example demonstrates how to use the [<ph id="ph1">\]</ph>, Type<ph id="ph2">\[</ph><ph id="ph3">\]</ph>, Type<ph id="ph4">\[</ph><ph id="ph5">\]</ph>, Type<ph id="ph6">\[</ph><ph id="ph7">\]</ph><ph id="ph8">\[</ph><ph id="ph9">\]</ph>, Type<ph id="ph10">\[</ph><ph id="ph11">\]</ph><ph id="ph12">\&lt;</ph>xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A&gt; method to create a <ph id="ph13">`PInvoke`</ph> method, and how to add the <ph id="ph14">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag to the method implementation flags after you create the <ph id="ph15">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, by using the <ph id="ph16">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph17">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">次のコード例を使用して、[<ph id="ph1">\]</ph>、型<ph id="ph2">\[</ph><ph id="ph3">\]</ph>、型<ph id="ph4">\[</ph><ph id="ph5">\]</ph>、型<ph id="ph6">\[</ph><ph id="ph7">\]</ph><ph id="ph8">\[</ph><ph id="ph9">\]</ph>、型<ph id="ph10">\[</ph><ph id="ph11">\]</ph> <ph id="ph12">\&lt;</ph>xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A &gt; を作成する方法、<ph id="ph13">`PInvoke`</ph>メソッド、および追加する方法、<ph id="ph14">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph>フラグ メソッド実装フラグを作成した後に、<ph id="ph15">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>を使用して、<ph id="ph16">&lt;xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph17">&lt;xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example creates a dynamic assembly with one dynamic module and a single type, <ph id="ph1">`MyType`</ph>, that contains the <ph id="ph2">`PInvoke`</ph> method.</source>
          <target state="translated">例では、1 つの動的モジュールと 1 つの型、動的アセンブリを作成する<ph id="ph1">`MyType`</ph>を格納している、<ph id="ph2">`PInvoke`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The <ph id="ph1">`PInvoke`</ph> method represents the Win32 <ph id="ph2">`GetTickCount`</ph> function.</source>
          <target state="translated"><ph id="ph1">`PInvoke`</ph>メソッドを表す、Win32<ph id="ph2">`GetTickCount`</ph>関数。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To get a non-zero return value, you must add the <ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">0 以外の戻り値を取得する必要がありますを追加する、<ph id="ph1">&lt;xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType&gt;</ph>フラグ。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The example uses an overload that does not specify custom modifiers.</source>
          <target state="translated">この例では、カスタム修飾子を指定しないオーバー ロードを使用します。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>To specify custom modifiers, change the example code to use this method overload instead.</source>
          <target state="translated">カスタム修飾子を指定するには、代わりにこのメソッドのオーバー ロードを使用するコード例を変更します。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>When the example is run, it executes the <ph id="ph1">`PInvoke`</ph> method.</source>
          <target state="translated">この例を実行すると、実行、<ph id="ph1">`PInvoke`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>It also saves the dynamic assembly as PInvokeTest.dll.</source>
          <target state="translated">また、PInvokeTest.dll として動的アセンブリを保存します。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine the <ph id="ph1">`MyType`</ph> class and the <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic) <ph id="ph4">`PInvoke`</ph> method it contains.</source>
          <target state="translated">使用することができます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>を調べる、<ph id="ph1">`MyType`</ph>クラスおよび<ph id="ph2">`static`</ph>(<ph id="ph3">`Shared`</ph> Visual Basic で)<ph id="ph4">`PInvoke`</ph>メソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>You can compile a Visual Basic or C# program that uses the static <ph id="ph1">`MyType.GetTickCount`</ph> method by including a reference to the DLL when you run csc.exe or vbc.exe; for example, <ph id="ph2">`/r:PInvokeTest.dll`</ph>.</source>
          <target state="translated">Visual Basic または C# の場合、静的なを使用するプログラムをコンパイルする<ph id="ph1">`MyType.GetTickCount`</ph>csc.exe または vbc.exe; を実行するときに DLL への参照を含めることによってメソッドなど、<ph id="ph2">`/r:PInvokeTest.dll`</ph>です。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is not static.</source>
          <target state="translated">メソッドは静的ではありません。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The parent type is an interface.</source>
          <target state="translated">親の型がインターフェイスです。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method is abstract.</source>
          <target state="translated">抽象メソッドです。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The method was previously defined.</source>
          <target state="translated">メソッドは以前に定義されています。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>、<ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>、または <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The size of <ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> or <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> does not equal the size of <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypeRequiredCustomModifiers" /&gt;</ph> または <ph id="ph2">&lt;paramref name="parameterTypeOptionalCustomModifiers" /&gt;</ph> のサイズは <ph id="ph3">&lt;paramref name="parameterTypes" /&gt;</ph> のサイズと同じではありません。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph>, <ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph>、<ph id="ph2">&lt;paramref name="dllName" /&gt;</ph>、または <ph id="ph3">&lt;paramref name="entryName" /&gt;</ph> が <ph id="ph4">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型では、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティは <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Adds a new property to the type.</source>
          <target state="translated">型に新しいプロパティを追加します。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The name of the property.</source>
          <target state="translated">プロパティの名前。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The attributes of the property.</source>
          <target state="translated">プロパティの属性。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">プロパティの戻り値の型。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">プロパティのパラメーターの型。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Adds a new property to the type, with the given name and property signature.</source>
          <target state="translated">指定された名前とプロパティのシグネチャにより、新しいプロパティを型に追加します。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The defined property.</source>
          <target state="translated">定義されたプロパティ。</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The following code sample demonstrates how to define a dynamic property and obtain a <ph id="ph1">&lt;xref:System.Reflection.Emit.PropertyBuilder&gt;</ph> for specification.</source>
          <target state="translated">次のコード サンプルを取得および動的なプロパティを定義する方法を示しています、<ph id="ph1">&lt;xref:System.Reflection.Emit.PropertyBuilder&gt;</ph>仕様です。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Note that a <ph id="ph1">`PropertyBuilder`</ph> must also have a corresponding <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>, which will house the IL logic for the property.</source>
          <target state="translated">なお、 <ph id="ph1">`PropertyBuilder`</ph> 、対応する必要があります<ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>プロパティの IL ロジックを格納します。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> 配列の要素のいずれかが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The name of the property.</source>
          <target state="translated">プロパティの名前。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The attributes of the property.</source>
          <target state="translated">プロパティの属性。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The calling convention of the property accessors.</source>
          <target state="translated">プロパティ アクセサーの呼び出し規約。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">プロパティの戻り値の型。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">プロパティのパラメーターの型。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</source>
          <target state="translated">新しいプロパティを、指定された名前、属性、呼び出し規約、およびプロパティの署名を持つ型に追加します。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The defined property.</source>
          <target state="translated">定義されたプロパティ。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> 配列の要素のいずれかが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the property.</source>
          <target state="translated">プロパティの名前。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the property.</source>
          <target state="translated">プロパティの属性。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the property.</source>
          <target state="translated">プロパティの戻り値の型。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">プロパティの戻り値の型の <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> など、必須のカスタム修飾子を表す型の配列。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">戻り値の型に必須のカスタム修飾子がない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">プロパティの戻り値の型の <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、省略可能なカスタム修飾子を表す型の配列。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">戻り値の型に省略可能なカスタム修飾子がない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">プロパティのパラメーターの型。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">型の配列の配列です。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">型の各配列は、<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、対応するパラメーターの必須のカスタム修飾子を表します。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">特定のパラメーターに必須のカスタム修飾子がない場合は、型の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">どのパラメーターにも必須のカスタム修飾子がない場合は、配列の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">型の配列の配列。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">型の各配列は、<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、対応するパラメーターの省略可能なカスタム修飾子を表します。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">特定のパラメーターに省略可能なカスタム修飾子がない場合は、型の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">どのパラメーターにも省略可能カスタム修飾子がない場合は、配列の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new property to the type, with the given name, property signature, and custom modifiers.</source>
          <target state="translated">指定された名前、プロパティのシグネチャ、およびカスタム修飾子により、新しいプロパティを型に追加します。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined property.</source>
          <target state="translated">定義されたプロパティ。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">このオーバー ロードでは、マネージ コンパイラのデザイナーが指定されます。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">カスタム修飾子の詳細については、ECMA Partition II メタデータ ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">ドキュメントはオンラインで入手できます。MSDN の「<bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「<bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph> です</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> 配列の要素のいずれかが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The name of the property.</source>
          <target state="translated">プロパティの名前。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The attributes of the property.</source>
          <target state="translated">プロパティの属性。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The calling convention of the property accessors.</source>
          <target state="translated">プロパティ アクセサーの呼び出し規約。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The return type of the property.</source>
          <target state="translated">プロパティの戻り値の型。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the required custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">プロパティの戻り値の型の <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> など、必須のカスタム修飾子を表す型の配列。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">戻り値の型に必須のカスタム修飾子がない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of types representing the optional custom modifiers, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>, for the return type of the property.</source>
          <target state="translated">プロパティの戻り値の型の <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、省略可能なカスタム修飾子を表す型の配列。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If the return type has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">戻り値の型に省略可能なカスタム修飾子がない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The types of the parameters of the property.</source>
          <target state="translated">プロパティのパラメーターの型。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">型の配列の配列です。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the required custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">型の各配列は、<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、対応するパラメーターの必須のカスタム修飾子を表します。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">特定のパラメーターに必須のカスタム修飾子がない場合は、型の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have required custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">どのパラメーターにも必須のカスタム修飾子がない場合は、配列の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>An array of arrays of types.</source>
          <target state="translated">型の配列の配列。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Each array of types represents the optional custom modifiers for the corresponding parameter, such as <ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph>.</source>
          <target state="translated">型の各配列は、<ph id="ph1">&lt;see cref="T:System.Runtime.CompilerServices.IsConst" /&gt;</ph> のような、対応するパラメーターの省略可能なカスタム修飾子を表します。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If a particular parameter has no optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of types.</source>
          <target state="translated">特定のパラメーターに省略可能なカスタム修飾子がない場合は、型の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>If none of the parameters have optional custom modifiers, specify <ph id="ph1">&lt;see langword="null" /&gt;</ph> instead of an array of arrays.</source>
          <target state="translated">どのパラメーターにも省略可能カスタム修飾子がない場合は、配列の配列の代わりに <ph id="ph1">&lt;see langword="null" /&gt;</ph> を指定します。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</source>
          <target state="translated">指定された名前、呼び出し規約、プロパティの署名、およびカスタム修飾子を使用して、新しいプロパティを型に追加します。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The defined property.</source>
          <target state="translated">定義されたプロパティ。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This overload is provided for designers of managed compilers.</source>
          <target state="translated">このオーバー ロードでは、マネージ コンパイラのデザイナーが指定されます。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>For more information on custom modifiers, see the ECMA Partition II Metadata documentation.</source>
          <target state="translated">カスタム修飾子の詳細については、ECMA Partition II メタデータ ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">ドキュメントはオンラインで入手できます。MSDN の「<bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「<bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>This method overload is introduced in the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">このメソッドのオーバー ロードがで導入された、<ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph>またはそれ以降。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>Any of the elements of the <ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> array is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parameterTypes" /&gt;</ph> 配列の要素のいずれかが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>Defines the initializer for this type.</source>
          <target state="translated">この型の初期化子を定義します。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>Returns a type initializer.</source>
          <target state="translated">型の初期化子を返します。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The initializer created is always public.</source>
          <target state="translated">作成、初期化子がパブリックでは常にします。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The following code sample demonstrates how to create an initialization constructor using <ph id="ph1">`DefineTypeInitializer`</ph>.</source>
          <target state="translated">次のコード サンプルを使用して初期化コンス トラクターを作成する方法を示します<ph id="ph1">`DefineTypeInitializer`</ph>です。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer">
          <source>The containing type has been previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">含んでいる型が <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して以前に作成されています。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The name used to refer to the data.</source>
          <target state="translated">データを参照するために使用する名前。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> cannot contain embedded nulls.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> に埋め込み null 値を含めることはできません。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The size of the data field.</source>
          <target state="translated">データ フィールドのサイズ。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The attributes for the field.</source>
          <target state="translated">フィールドの属性。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Defines an uninitialized data field in the <ph id="ph1">&lt;see langword=".sdata" /&gt;</ph> section of the portable executable (PE) file.</source>
          <target state="translated">ポータブル実行可能 (PE) ファイルの <ph id="ph1">&lt;see langword=".sdata" /&gt;</ph> セクションの初期化されていないデータ フィールドを定義します。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>A field to reference the data.</source>
          <target state="translated">データを参照するフィールド。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The field that you create with this method will be <ph id="ph1">`static`</ph>, even if you do not include <ph id="ph2">`FieldAttributes.Static`</ph> in the <ph id="ph3">`attributes`</ph> parameter.</source>
          <target state="translated">このメソッドを使用して作成したフィールドになります<ph id="ph1">`static`</ph>含めないようにする場合でも、<ph id="ph2">`FieldAttributes.Static`</ph>で、<ph id="ph3">`attributes`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The following code sample demonstrates the use of <ph id="ph1">`DefineUninitializedData`</ph> to create an uninitialized data field in a dynamic type:</source>
          <target state="translated">使用を次のコード サンプルに示します<ph id="ph1">`DefineUninitializedData`</ph>動的な型に初期化されていないデータ フィールドを作成します。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>Length of <ph id="ph1">&lt;paramref name="name" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than or equal to zero, or greater than or equal to 0x003f0000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 以下か、0x003f0000 以上です。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Retrieves the full path of this type.</source>
          <target state="translated">この型の完全なパスを取得します。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>Retrieves the full path of this type.</source>
          <target state="translated">この型の完全なパスを取得します。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.FullName">
          <source>The returned format is "enclosingTypeFullName+nestedTypeName" for nested types and "typeName" for non-nested types.</source>
          <target state="translated">返される形式では、「enclosingTypeFullName + nestedTypeName」を入れ子にされた型と"typeName"の種類の入れ子になっていません。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>Gets a value that indicates the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">現在のジェネリック型パラメーターの共変性および特殊な制約を示す値を取得します。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">現在のジェネリック型パラメーターの共変性と特殊な制約を表す <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">ジェネリック型パラメーターがによって表されるコードを生成するときに、<ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph>オブジェクトではなく、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</source>
          <target state="translated">パラメーターを宣言するジェネリック型の型パラメーター リスト内の型パラメーターの位置を取得します。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> オブジェクトがジェネリック型パラメーターを表す場合、パラメーターを宣言したジェネリック型の型パラメーター リスト内の型パラメーターの位置。それ以外の場合は、定義されません。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">ジェネリック型パラメーターがによって表されるコードを生成するときに、<ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph>オブジェクトではなく、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent a generic type parameter, the value of this property is undefined.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>がジェネリック型パラメーターを表していませんこのプロパティの値が定義されていません。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents a generic type parameter.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph>を決定するプロパティかどうか、現在<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>ジェネリック型パラメーターを表します。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The constructed generic type whose constructor is returned.</source>
          <target state="translated">コンストラクターが返される構築されたジェネリック型。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A constructor on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which constructor of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">返される <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> のコンストラクターを指定する <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept> のジェネリック型の定義のコンストラクター。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition.</source>
          <target state="translated">ジェネリック型定義の指定されたコンストラクターに対応する、指定の構築されたジェネリック型のコンストラクターを返します。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object that represents the constructor of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="constructor" /&gt;</ph>, which specifies a constructor belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph4">&lt;paramref name="type" /&gt;</ph> のジェネリック型定義に属するコンストラクターを指定する、<ph id="ph3">&lt;paramref name="constructor" /&gt;</ph> に対応する <ph id="ph2">&lt;paramref name="type" /&gt;</ph> のコンストラクターを表す <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph>メソッドを取得する方法を提供する、<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>を持つジェネリック型定義がによって表される構築されたジェネリック型のコンス トラクターを表すオブジェクト、<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents a constructor of <ph id="ph6">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば、ある、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>型を表すオブジェクト<ph id="ph2">`G&lt;T&gt;`</ph>c# 構文では (<ph id="ph3">`G(Of T)`</ph> Visual basic で<ph id="ph4">`generic &lt;T&gt; ref class G`</ph>C++ で) および<ph id="ph5">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>のコンス トラクターを表すオブジェクト<ph id="ph6">`G&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph>.</source>
          <target state="translated">仮定します<ph id="ph1">`G&lt;T&gt;`</ph>型パラメーターを持つジェネリック メソッドを持つ<ph id="ph2">`U`</ph>構築された型のインスタンスを作成する<ph id="ph3">`G&lt;U&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>In order to emit the code to create an instance of the constructed type, you need a <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that represents the constructor of this constructed type — in other words, that creates an instance of <ph id="ph2">`G&lt;U&gt;`</ph>.</source>
          <target state="translated">構築された型のインスタンスを作成するコードを生成するためにする必要があります、<ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>をこのコンス トラクターを表すオブジェクトの構築型 — のインスタンスを作成する、つまり<ph id="ph2">`G&lt;U&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">これを行うには、まず、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph>メソッドを<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクトを指定する、<ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph>を表すオブジェクト<ph id="ph4">`U`</ph>型引数として。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object that represents the constructor of <ph id="ph5">`G&lt;U&gt;`</ph> as parameter <ph id="ph6">`constructor`</ph>.</source>
          <target state="translated">まず、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph>メソッドの戻り値を<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph>メソッド パラメーターとして<ph id="ph3">`type`</ph>と<ph id="ph4">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph>のコンス トラクターを表すオブジェクト<ph id="ph5">`G&lt;U&gt;`</ph>パラメーターとして<ph id="ph6">`constructor`</ph>です。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">戻り値は、<ph id="ph1">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>オブジェクト、関数呼び出しを生成する必要があります。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The code example demonstrates this scenario.</source>
          <target state="translated">このコード例では、このシナリオを示します。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The following code example contains source code for a generic class named <ph id="ph1">`Sample`</ph> that has a type parameter named <ph id="ph2">`T`</ph>.</source>
          <target state="translated">次のコード例には、という名前のジェネリック クラスのソース コードが含まれています。<ph id="ph1">`Sample`</ph>という名前の型パラメーターを持つ<ph id="ph2">`T`</ph>します。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">クラスは、という名前のフィールドを持つ<ph id="ph1">`Field`</ph>、型の<ph id="ph2">`T`</ph>とジェネリック メソッドの名前付き<ph id="ph3">`GM`</ph>独自の型パラメーターでは、名前付き<ph id="ph4">`U`</ph>します。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">メソッド<ph id="ph1">`GM`</ph>のインスタンスを作成<ph id="ph2">`Sample`</ph>、独自の型パラメーターに置き換えること<ph id="ph3">`U`</ph>の型パラメーターに対して<ph id="ph4">`Sample`</ph>でその入力パラメーターを格納および<ph id="ph5">`Field`</ph>です。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">このソース コードがコンパイルされますが、使用されません。表示できます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>クラスによって出力されるコードを比較し、<ph id="ph1">`Example`</ph>です。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">クラスのコード<ph id="ph1">`Example`</ph>の使用例を示します、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph>ジェネリック コードを出力するメソッド。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph> and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Main`</ph>クラスのメソッド<ph id="ph2">`Example`</ph>という名前のクラスを含む動的アセンブリを作成<ph id="ph3">`Sample`</ph>を使用して、<ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph>メソッドという名前の型パラメーターを追加することで汎用的なものを<ph id="ph5">`T`</ph>です。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">既定のコンス トラクターとという名前のフィールド<ph id="ph1">`Field`</ph>、型の<ph id="ph2">`T`</ph>、クラスに追加されます<ph id="ph3">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">メソッド<ph id="ph1">`GM`</ph>が追加されを使用して、ジェネリック メソッドに変わるは、<ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">型パラメーター<ph id="ph1">`GM`</ph>という<ph id="ph2">`U`</ph>です。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">型パラメーターを定義すると後のシグネチャ<ph id="ph1">`GM`</ph>を使用して追加された、<ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">戻り値の型がないと いいえ必要があるか、カスタム修飾子は、このメソッドのすべてのパラメーターは<ph id="ph1">`null`</ph>を除く<ph id="ph2">`parameterTypes`</ph>です。<ph id="ph3">`parameterTypes`</ph>をメソッドの唯一のパラメーターの型を設定<ph id="ph4">`U`</ph>メソッドのジェネリック型のパラメーターです。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">メソッドの本体の構築型のインスタンスを作成する<ph id="ph1">`Sample&lt;U&gt;`</ph>(<ph id="ph2">`Sample(Of U)`</ph> Visual Basic で)、メソッドのパラメーターに割り当てます<ph id="ph3">`Field`</ph>、しの値を出力<ph id="ph4">`Field`</ph>です。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents the default constructor of the constructed generic type <ph id="ph3">`Sample&lt;U&gt;`</ph> in the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType&gt;</ph> instruction that creates the instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A&gt;</ph>メソッドの使用を作成、<ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>構築ジェネリック型の既定のコンス トラクターを表す<ph id="ph3">`Sample&lt;U&gt;`</ph>で、<ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType&gt;</ph>命令が、インスタンスを作成します。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">エントリ ポイント メソッドを保持するためにダミーの型が定義されている<ph id="ph1">`Main`</ph>です。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">本体で<ph id="ph1">`Main`</ph>、静的な<ph id="ph2">`GM`</ph>構築されたジェネリック型でメソッドが呼び出される<ph id="ph3">`Sample&lt;int&gt;`</ph>(<ph id="ph4">`Sample(Of Integer)`</ph> Visual Basic で)、型と<ph id="ph5">&lt;xref:System.String&gt;</ph>の代わりに使用<ph id="ph6">`U`</ph>です。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">このコード例を実行すると、TypeBuilderGetFieldExample.exe として出力されたアセンブリが保存されます。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">TypeBuilderGetFieldExample.exe を実行して、使用することができます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> 、出力コードのコードを比較する、<ph id="ph1">`Sample`</ph>自体のコード例にコンパイルされるクラスです。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> がジェネリック型を表していません。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> が <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> 型ではありません。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> の宣言する型がジェネリック型定義ではありません。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="constructor" /&gt;</ph> の宣言する型が <ph id="ph2">&lt;paramref name="type" /&gt;</ph> のジェネリック型定義ではありません。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">これは <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> や <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> などにある、<ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> からのビット フラグでなければなりません。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing the public and non-public constructors defined for this class, as specified.</source>
          <target state="translated">指定に従って、このクラスに定義されているパブリック コンストラクターおよび非パブリック コンストラクターを表す <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing the specified constructors defined for this class.</source>
          <target state="translated">このクラスに定義されている指定したコンストラクターを表す <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>If no constructors are defined, an empty array is returned.</source>
          <target state="translated">コンストラクターが定義されていない場合は、空の配列が返されます。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns the custom attributes defined for this type.</source>
          <target state="translated">この型の定義済みのカスタム属性を返します。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">このメンバーの継承チェーンを検索して属性を見つけるかどうかを指定します。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns all the custom attributes defined for this type.</source>
          <target state="translated">この型の定義済みのカスタム属性をすべて返します。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Returns an array of objects representing all the custom attributes of this type.</source>
          <target state="translated">この型のすべてのカスタム属性を表す、オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは現在サポートされていません。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> を使用して型を取得し、返された <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> で <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> を呼び出します。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">検索する属性の種類。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">この型に代入可能な属性だけが返されます。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">このメンバーの継承チェーンを検索して属性を見つけるかどうかを指定します。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Returns all the custom attributes of the current type that are assignable to a specified type.</source>
          <target state="translated">現在の型のカスタム属性のうち、指定された型に代入可能なものすべてを返します。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>An array of custom attributes defined on the current type.</source>
          <target state="translated">現在の型について定義されているカスタム属性の配列。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは現在サポートされていません。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> を使用して型を取得し、返された <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> で <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> を呼び出します。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)">
          <source>The type must be a type provided by the underlying runtime system.</source>
          <target state="translated">型は、基になるランタイム システムで提供されている型でなければなりません。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>Calling this method always throws <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph>.</source>
          <target state="translated">このメソッドを呼び出すと、必ず <ph id="ph1">&lt;see cref="T:System.NotSupportedException" /&gt;</ph> がスローされます。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>This method is not supported.</source>
          <target state="translated">このメソッドはサポートされていません。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>No value is returned.</source>
          <target state="translated">値は返されません。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetElementType">
          <source>This method is not supported.</source>
          <target state="translated">このメソッドはサポートされていません。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The name of the event to search for.</source>
          <target state="translated">検索対象のイベントの名前。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limits the search.</source>
          <target state="translated">検索を制限する <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Returns the event with the specified name.</source>
          <target state="translated">指定した名前のイベントを返します。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the event declared or inherited by this type with the specified name, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if there are no matches.</source>
          <target state="translated">この型によって宣言または継承されている、指定した名前のイベントを表す <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> オブジェクト。または、一致するものがない場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns the events defined by the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> で定義されているイベントを返します。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Returns the public events declared or inherited by this type.</source>
          <target state="translated">この型で宣言または継承されているパブリック イベントを返します。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing the public events declared or inherited by this type.</source>
          <target state="translated">この型で宣言または継承されているパブリック イベントを表す <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>An empty array is returned if there are no public events.</source>
          <target state="translated">パブリック イベントがない場合は、空の配列が返されます。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> values that limits the search.</source>
          <target state="translated">検索を制限する <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public events that are declared by this type.</source>
          <target state="translated">この型で宣言されているパブリック イベントとパブリックでないイベントを返します。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing the events declared or inherited by this type that match the specified binding flags.</source>
          <target state="translated">この型で宣言または継承されているイベントのうち、指定したバインディング フラグに一致するイベントを表す <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matching events.</source>
          <target state="translated">一致するイベントがない場合は、空の配列が返されます。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns a field defined by the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> で定義されているフィールドを返します。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The name of the field to get.</source>
          <target state="translated">取得するフィールドの名前。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">これは <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> や <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> などにある、<ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> からのビット フラグでなければなりません。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns the field specified by the given name.</source>
          <target state="translated">指定した名前で指定されたフィールドを返します。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object representing the field declared or inherited by this type with the specified name and public or non-public modifier.</source>
          <target state="translated">指定した名前と公開または非公開の修飾子を持つ、この型によって宣言または継承されているフィールドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If there are no matches then <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">一致するものがない場合は、<ph id="ph1">&lt;see langword="null" /&gt;</ph> が返されます。</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The constructed generic type whose field is returned.</source>
          <target state="translated">フィールドが返される構築されたジェネリック型。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A field on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which field of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">返される <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> のフィールドを指定する、<bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept> のジェネリック型定義のフィールド。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition.</source>
          <target state="translated">ジェネリック型定義の指定されたフィールドに対応する、指定の構築されたジェネリック型のフィールドを返します。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> object that represents the field of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="field" /&gt;</ph>, which specifies a field belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph4">&lt;paramref name="type" /&gt;</ph> のジェネリック型定義に属するフィールドを指定する、<ph id="ph3">&lt;paramref name="field" /&gt;</ph> に対応する <ph id="ph2">&lt;paramref name="type" /&gt;</ph> のフィールドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents a field of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph>メソッドを取得する方法を提供する、<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>を持つジェネリック型定義がによって表される構築されたジェネリック型のフィールドを表すオブジェクト、<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents a field <ph id="ph6">`public T F`</ph> in C# syntax (<ph id="ph7">`Public F As T`</ph> in Visual Basic, <ph id="ph8">`public: T F`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば、ある、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>型を表すオブジェクト<ph id="ph2">`G&lt;T&gt;`</ph>c# 構文では (<ph id="ph3">`G(Of T)`</ph> Visual basic で<ph id="ph4">`generic &lt;T&gt; ref class G`</ph>C++ で) と<ph id="ph5">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph>フィールドを表すオブジェクト<ph id="ph6">`public T F`</ph>c# 構文では (<ph id="ph7">`Public F As T`</ph> Visual basic で<ph id="ph8">`public: T F`</ph>C++ では) によって定義されている<ph id="ph9">`G&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls field <ph id="ph4">`F`</ph> on that instance.</source>
          <target state="translated">仮定します<ph id="ph1">`G&lt;T&gt;`</ph>型パラメーターを持つジェネリック メソッドがあります<ph id="ph2">`U`</ph>構築された型のインスタンスを作成する<ph id="ph3">`G&lt;U&gt;`</ph>と呼び出しフィールド<ph id="ph4">`F`</ph>そのインスタンスにします。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object that represents <ph id="ph2">`F`</ph> on the constructed type — in other words, that is of type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">関数呼び出しを生成するためにする必要があります、<ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>を表すオブジェクト<ph id="ph2">`F`</ph>構築された型で、型である言い換えれば、<ph id="ph3">`U`</ph>型ではなく<ph id="ph4">`T`</ph>です。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">これを行うには、まず、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph>メソッドを<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクトを指定する、<ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph>を表すオブジェクト<ph id="ph4">`U`</ph>型引数として。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph> object that represents <ph id="ph5">`F`</ph> as parameter <ph id="ph6">`field`</ph>.</source>
          <target state="translated">まず、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph>メソッドの戻り値を<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph>メソッド パラメーターとして<ph id="ph3">`type`</ph>と<ph id="ph4">&lt;xref:System.Reflection.Emit.FieldBuilder&gt;</ph>を表すオブジェクト<ph id="ph5">`F`</ph>パラメーターとして<ph id="ph6">`field`</ph>です。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">戻り値は、<ph id="ph1">&lt;xref:System.Reflection.FieldInfo&gt;</ph>オブジェクト、関数呼び出しを生成する必要があります。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The code example demonstrates this scenario.</source>
          <target state="translated">このコード例では、このシナリオを示します。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The following code example contains source code for a generic class named Sample that has a type parameter named <ph id="ph1">`T`</ph>.</source>
          <target state="translated">次のコード例には、という名前の型パラメーターを持つ Sample という名前のジェネリック クラスのソース コードが含まれています。<ph id="ph1">`T`</ph>です。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">クラスは、という名前のフィールドを持つ<ph id="ph1">`Field`</ph>、型の<ph id="ph2">`T`</ph>とジェネリック メソッドの名前付き<ph id="ph3">`GM`</ph>独自の型パラメーターでは、名前付き<ph id="ph4">`U`</ph>します。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">メソッド<ph id="ph1">`GM`</ph>のインスタンスを作成<ph id="ph2">`Sample`</ph>、独自の型パラメーターに置き換えること<ph id="ph3">`U`</ph>の型パラメーターに対して<ph id="ph4">`Sample`</ph>でその入力パラメーターを格納および<ph id="ph5">`Field`</ph>です。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">このソース コードがコンパイルされますが、使用されません。表示できます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>クラスによって出力されるコードを比較し、<ph id="ph1">`Example`</ph>です。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">クラスのコード<ph id="ph1">`Example`</ph>の使用例を示します、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph>ジェネリック コードを出力するメソッド。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph>, and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Main`</ph>クラスのメソッド<ph id="ph2">`Example`</ph>という名前のクラスを含む動的アセンブリを作成<ph id="ph3">`Sample`</ph>を使用して、<ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph>メソッドという名前の型パラメーターを追加することで汎用的なものを<ph id="ph5">`T`</ph>です。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">既定のコンス トラクターとという名前のフィールド<ph id="ph1">`Field`</ph>、型の<ph id="ph2">`T`</ph>、クラスに追加されます<ph id="ph3">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">メソッド<ph id="ph1">`GM`</ph>が追加されを使用して、ジェネリック メソッドに変わるは、<ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">型パラメーター<ph id="ph1">`GM`</ph>という<ph id="ph2">`U`</ph>です。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">型パラメーターを定義すると後のシグネチャ<ph id="ph1">`GM`</ph>を使用して追加された、<ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">戻り値の型がないと いいえ必要があるか、カスタム修飾子は、このメソッドのすべてのパラメーターは<ph id="ph1">`null`</ph>を除く<ph id="ph2">`parameterTypes`</ph>です。<ph id="ph3">`parameterTypes`</ph>をメソッドの唯一のパラメーターの型を設定<ph id="ph4">`U`</ph>メソッドのジェネリック型のパラメーターです。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">メソッドの本体の構築型のインスタンスを作成する<ph id="ph1">`Sample&lt;U&gt;`</ph>(<ph id="ph2">`Sample(Of U)`</ph> Visual Basic で)、メソッドのパラメーターに割り当てます<ph id="ph3">`Field`</ph>、しの値を出力<ph id="ph4">`Field`</ph>です。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> that represents the field of the constructed generic type <ph id="ph3">`Sample&lt;U&gt;`</ph> in the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType&gt;</ph> and <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType&gt;</ph> instructions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%2A&gt;</ph>メソッドの使用を作成、<ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph>構築ジェネリック型のフィールドを表す<ph id="ph3">`Sample&lt;U&gt;`</ph>で、<ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType&gt;</ph>と<ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType&gt;</ph>指示します。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">エントリ ポイント メソッドを保持するためにダミーの型が定義されている<ph id="ph1">`Main`</ph>です。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">本体で<ph id="ph1">`Main`</ph>、静的な<ph id="ph2">`GM`</ph>構築されたジェネリック型でメソッドが呼び出される<ph id="ph3">`Sample&lt;int&gt;`</ph>(<ph id="ph4">`Sample(Of Integer)`</ph> Visual Basic で)、型と<ph id="ph5">&lt;xref:System.String&gt;</ph>の代わりに使用<ph id="ph6">`U`</ph>です。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">このコード例を実行すると、TypeBuilderGetFieldExample.exe として出力されたアセンブリが保存されます。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">TypeBuilderGetFieldExample.exe を実行して、使用することができます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> 、出力コードのコードを比較する、<ph id="ph1">`Sample`</ph>自体のコード例にコンパイルされるクラスです。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> がジェネリック型を表していません。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> が <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> 型ではありません。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="field" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="field" /&gt;</ph> の宣言する型がジェネリック型定義ではありません。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="field" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="field" /&gt;</ph> の宣言する型が <ph id="ph2">&lt;paramref name="type" /&gt;</ph> のジェネリック型定義ではありません。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">これは <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> や <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> など、<ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> からのビット フラグでなければなりません。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public fields that are declared by this type.</source>
          <target state="translated">この型で宣言されているパブリック フィールドとパブリックでないフィールドを返します。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing the public and non-public fields declared or inherited by this type.</source>
          <target state="translated">この型で宣言または継承されているパブリック フィールドと非パブリック フィールドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no fields, as specified.</source>
          <target state="translated">指定どおりに、フィールドがない場合は空の配列が返されます。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetFields%2A&gt;</ph>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order can vary.</source>
          <target state="translated">その順序が異なるので、コードは、フィールドが返される順序に依存しない必要があります。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the type arguments of a generic type or the type parameters of a generic type definition.</source>
          <target state="translated">ジェネリック型の型引数またはジェネリック型定義の型パラメーターを表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>The elements of the array represent the type arguments of a generic type or the type parameters of a generic type definition.</source>
          <target state="translated">ジェネリック型の型引数またはジェネリック型定義の型パラメーターを表す配列の要素。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic type definition.</source>
          <target state="translated">返される配列の要素は、ジェネリック型定義の型パラメーターの一覧に表示される順序では。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>場合、オブジェクトがジェネリック型定義を表す、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph>メソッドはジェネリック型パラメーターに使用されています。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>This method retrieves the <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> objects that represent the generic type parameters.</source>
          <target state="translated">このメソッドは、取得、<ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph>をジェネリック型パラメーターを表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">ジェネリック型のリフレクションとジェネリック リフレクションで使用される用語に対するインバリアント条件の一覧の詳細については、次を参照してください。、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a generic type definition from which the current type can be obtained.</source>
          <target state="translated">現在の型を取得する元になるジェネリック型定義を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a generic type definition from which the current type can be obtained.</source>
          <target state="translated">現在の型を取得する元になる型定義を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>If you call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object for which the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph> property returns the current instance.</source>
          <target state="translated">呼び出す場合は、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph>メソッドを<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>対象のオブジェクト、<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A&gt;</ph>プロパティから返される<ph id="ph4">`true`</ph>、<ph id="ph5">&lt;xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A&gt;</ph>プロパティは、現在のインスタンスを返します。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type is always a generic type definition.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>常にジェネリック型定義では、ジェネリック型を表します。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>If you used the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method to construct a generic type from a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents a generic type definition, using the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType&gt;</ph> method on the constructed type gets back the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the generic type definition.</source>
          <target state="translated">使用した場合、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph>からジェネリック型を構築するメソッド、 <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> 、ジェネリック型定義を表すオブジェクトを使用して、 <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType&gt;</ph> 、構築された型にメソッドが返される、<ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>をジェネリック型定義を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>The current type is not generic.</source>
          <target state="translated">現在の型はジェネリックではありません。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> は <ph id="ph2">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>The name of the interface.</source>
          <target state="translated">インターフェイスの名前。</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="true" /&gt;</ph>, the search is case-insensitive.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> の場合、検索では、大文字と小文字を区別しません。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>If <ph id="ph1">&lt;see langword="false" /&gt;</ph>, the search is case-sensitive.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> の場合、検索では、大文字と小文字が区別されます。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns the interface implemented (directly or indirectly) by this class with the fully qualified name matching the given interface name.</source>
          <target state="translated">指定されたインターフェイス名に一致する完全修飾名を名前とする、このクラスによって (直接的または間接的に) 実装されるインターフェイスを返します。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the implemented interface.</source>
          <target state="translated">実装されているインターフェイスを表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Returns null if no interface matching name is found.</source>
          <target state="translated">インターフェイスの一致する名前が見つからない場合、null を返します。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the interface for which the mapping is to be retrieved.</source>
          <target state="translated">マッピングの取得対象のインターフェイスの <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the requested interface.</source>
          <target state="translated">要求されたインターフェイスに対するインターフェイス マップを返します。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Returns the requested interface mapping.</source>
          <target state="translated">要求されたインターフェイス マップを返します。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>Returns an array of all the interfaces implemented on this type and its base types.</source>
          <target state="translated">この型とその基本型に実装されているすべてのインターフェイスの配列を返します。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the implemented interfaces.</source>
          <target state="translated">実装されているインターフェイスを表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetInterfaces">
          <source>If none are defined, an empty array is returned.</source>
          <target state="translated">何も定義されていない場合は、空の配列が返されます。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The name of the member.</source>
          <target state="translated">メンバーの名前。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The type of the member to return.</source>
          <target state="translated">返すメンバーの型。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">これは <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> や <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> などにある、<ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> からのビット フラグでなければなりません。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public members declared or inherited by this type, as specified.</source>
          <target state="translated">指定のとおりに、この型によって宣言または継承されたパブリック メンバーと非パブリック メンバーをすべて返します。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public and non-public members defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public members are returned.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> が使用されている場合、この型で定義されているパブリック メンバーと非パブリック メンバーを表す <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> オブジェクトの配列を返します。それ以外の場合、パブリック メンバーのみが返されます。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, such as <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">これは <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> や <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> などの、<ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> からのビット フラグでなければなりません。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns the members for the public and non-public members declared or inherited by this type.</source>
          <target state="translated">この型によって宣言または継承されたパブリック メンバーと非パブリック メンバーをすべて返します。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public and non-public members declared or inherited by this type.</source>
          <target state="translated">この型で宣言または継承されているパブリック メンバーと非パブリック メンバーを表す <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> オブジェクトの配列を返します。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>An empty array is returned if there are no matching members.</source>
          <target state="translated">一致するメンバーがない場合は、空の配列が返されます。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The constructed generic type whose method is returned.</source>
          <target state="translated">メソッドが返される構築されたジェネリック型。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A method on the generic type definition of <bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept>, which specifies which method of <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> to return.</source>
          <target state="translated">返される <bpt id="p2">&lt;c&gt;</bpt>type<ept id="p2">&lt;/c&gt;</ept> のメソッドを指定する、<bpt id="p1">&lt;c&gt;</bpt>type<ept id="p1">&lt;/c&gt;</ept> のジェネリック型定義のメソッド。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition.</source>
          <target state="translated">ジェネリック型定義の指定されたメソッドに対応する、指定の構築されたジェネリック型のメソッドを返します。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents the method of <ph id="ph2">&lt;paramref name="type" /&gt;</ph> corresponding to <ph id="ph3">&lt;paramref name="method" /&gt;</ph>, which specifies a method belonging to the generic type definition of <ph id="ph4">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph4">&lt;paramref name="type" /&gt;</ph> のジェネリック型定義に属するメソッドを指定する、<ph id="ph3">&lt;paramref name="method" /&gt;</ph> に対応する <ph id="ph2">&lt;paramref name="type" /&gt;</ph> のメソッドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method provides a way to get a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a method of a constructed generic type whose generic type definition is represented by a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph>メソッドを取得する方法を提供する、<ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>オブジェクトがジェネリック型定義で表される構築されたジェネリック型のメソッドを表す、<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>For example, suppose you have a <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object that represents the type <ph id="ph2">`G&lt;T&gt;`</ph> in C# syntax (<ph id="ph3">`G(Of T)`</ph> in Visual Basic, <ph id="ph4">`generic &lt;T&gt; ref class G`</ph> in C++) and a <ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents a method <ph id="ph6">`T M()`</ph> in C# syntax (<ph id="ph7">`Function M() As T`</ph> in Visual Basic, <ph id="ph8">`T M()`</ph> in C++) that is defined by <ph id="ph9">`G&lt;T&gt;`</ph>.</source>
          <target state="translated">たとえば、ある、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>型を表すオブジェクト<ph id="ph2">`G&lt;T&gt;`</ph>c# 構文では (<ph id="ph3">`G(Of T)`</ph> Visual basic で<ph id="ph4">`generic &lt;T&gt; ref class G`</ph>C++ で) と<ph id="ph5">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>メソッドを表すオブジェクト<ph id="ph6">`T M()`</ph>c# 構文では (<ph id="ph7">`Function M() As T`</ph> Visual basic で<ph id="ph8">`T M()`</ph>C++ では) によって定義されている<ph id="ph9">`G&lt;T&gt;`</ph>です。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Suppose that <ph id="ph1">`G&lt;T&gt;`</ph> has a generic method with type parameter <ph id="ph2">`U`</ph> that creates an instance of the constructed type <ph id="ph3">`G&lt;U&gt;`</ph> and calls method <ph id="ph4">`M`</ph> on that instance.</source>
          <target state="translated">仮定します<ph id="ph1">`G&lt;T&gt;`</ph>型パラメーターを持つジェネリック メソッドがあります<ph id="ph2">`U`</ph>構築された型のインスタンスを作成する<ph id="ph3">`G&lt;U&gt;`</ph>メソッドを呼び出すと<ph id="ph4">`M`</ph>そのインスタンスにします。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>In order to emit the function call, you need a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph2">`M`</ph> on the constructed type — in other words, that returns type <ph id="ph3">`U`</ph> rather than type <ph id="ph4">`T`</ph>.</source>
          <target state="translated">関数呼び出しを生成するためにする必要があります、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>を表すオブジェクト<ph id="ph2">`M`</ph>構築された型で、つまり、型を返す<ph id="ph3">`U`</ph>型ではなく<ph id="ph4">`T`</ph>です。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>To do this, first call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object, specifying the <ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object that represents <ph id="ph4">`U`</ph> as the type argument.</source>
          <target state="translated">これを行うには、まず、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph>メソッドを<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクトを指定する、<ph id="ph3">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph>を表すオブジェクト<ph id="ph4">`U`</ph>型引数として。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Then call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method with the return value of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method as parameter <ph id="ph3">`type`</ph> and the <ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph> object that represents <ph id="ph5">`T M()`</ph> as parameter <ph id="ph6">`method`</ph>.</source>
          <target state="translated">まず、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph>メソッドの戻り値を<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph>メソッド パラメーターとして<ph id="ph3">`type`</ph>と<ph id="ph4">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>を表すオブジェクト<ph id="ph5">`T M()`</ph>パラメーターとして<ph id="ph6">`method`</ph>です。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The return value is the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object you need to emit the function call.</source>
          <target state="translated">戻り値は、<ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>オブジェクト、関数呼び出しを生成する必要があります。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The code example demonstrates a scenario similar to this.</source>
          <target state="translated">コード例では、次のようなシナリオを示します。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The following code example contains source code for a generic class named <ph id="ph1">`Sample`</ph> that has a type parameter named <ph id="ph2">`T`</ph>.</source>
          <target state="translated">次のコード例には、という名前のジェネリック クラスのソース コードが含まれています。<ph id="ph1">`Sample`</ph>という名前の型パラメーターを持つ<ph id="ph2">`T`</ph>します。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The class has a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, and a generic method named <ph id="ph3">`GM`</ph> with its own type parameter, named <ph id="ph4">`U`</ph>.</source>
          <target state="translated">クラスは、という名前のフィールドを持つ<ph id="ph1">`Field`</ph>、型の<ph id="ph2">`T`</ph>とジェネリック メソッドの名前付き<ph id="ph3">`GM`</ph>独自の型パラメーターでは、名前付き<ph id="ph4">`U`</ph>します。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>Method <ph id="ph1">`GM`</ph> creates an instance of <ph id="ph2">`Sample`</ph>, substituting its own type parameter <ph id="ph3">`U`</ph> for the type parameter of <ph id="ph4">`Sample`</ph>, and stores its input parameter in <ph id="ph5">`Field`</ph>.</source>
          <target state="translated">メソッド<ph id="ph1">`GM`</ph>のインスタンスを作成<ph id="ph2">`Sample`</ph>、独自の型パラメーターに置き換えること<ph id="ph3">`U`</ph>の型パラメーターに対して<ph id="ph4">`Sample`</ph>でその入力パラメーターを格納および<ph id="ph5">`Field`</ph>です。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>This source code is compiled but not used; you can view it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> and compare it to the code emitted by class <ph id="ph1">`Example`</ph>.</source>
          <target state="translated">このソース コードがコンパイルされますが、使用されません。表示できます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>クラスによって出力されるコードを比較し、<ph id="ph1">`Example`</ph>です。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The code in class <ph id="ph1">`Example`</ph> demonstrates the use of the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method to emit generic code.</source>
          <target state="translated">クラスのコード<ph id="ph1">`Example`</ph>の使用例を示します、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph>ジェネリック コードを出力するメソッド。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">`Main`</ph> method of class <ph id="ph2">`Example`</ph> creates a dynamic assembly containing a class named <ph id="ph3">`Sample`</ph> and uses the <ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method to make it generic by adding a type parameter named <ph id="ph5">`T`</ph>.</source>
          <target state="translated"><ph id="ph1">`Main`</ph>クラスのメソッド<ph id="ph2">`Example`</ph>という名前のクラスを含む動的アセンブリを作成<ph id="ph3">`Sample`</ph>を使用して、<ph id="ph4">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph>メソッドという名前の型パラメーターを追加することで汎用的なものを<ph id="ph5">`T`</ph>です。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A default constructor and a field named <ph id="ph1">`Field`</ph>, of type <ph id="ph2">`T`</ph>, are added to class <ph id="ph3">`Sample`</ph>.</source>
          <target state="translated">既定のコンス トラクターとという名前のフィールド<ph id="ph1">`Field`</ph>、型の<ph id="ph2">`T`</ph>、クラスに追加されます<ph id="ph3">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A method <ph id="ph1">`GM`</ph> is added and turned into a generic method by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">メソッド<ph id="ph1">`GM`</ph>が追加されを使用して、ジェネリック メソッドに変わるは、<ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The type parameter of <ph id="ph1">`GM`</ph> is named <ph id="ph2">`U`</ph>.</source>
          <target state="translated">型パラメーター<ph id="ph1">`GM`</ph>という<ph id="ph2">`U`</ph>です。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>After the type parameter is defined, the signature of <ph id="ph1">`GM`</ph> is added by using the <ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">型パラメーターを定義すると後のシグネチャ<ph id="ph1">`GM`</ph>を使用して追加された、<ph id="ph2">&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>There is no return type and no required or custom modifiers, so all the parameters of this method are <ph id="ph1">`null`</ph> except <ph id="ph2">`parameterTypes`</ph>; <ph id="ph3">`parameterTypes`</ph> sets the type of the method's only parameter to <ph id="ph4">`U`</ph>, the method's generic type parameter.</source>
          <target state="translated">戻り値の型がないと いいえ必要があるか、カスタム修飾子は、このメソッドのすべてのパラメーターは<ph id="ph1">`null`</ph>を除く<ph id="ph2">`parameterTypes`</ph>です。<ph id="ph3">`parameterTypes`</ph>をメソッドの唯一のパラメーターの型を設定<ph id="ph4">`U`</ph>メソッドのジェネリック型のパラメーターです。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The body of the method creates an instance of the constructed type <ph id="ph1">`Sample&lt;U&gt;`</ph> (<ph id="ph2">`Sample(Of U)`</ph> in Visual Basic), assigns the method's parameter to <ph id="ph3">`Field`</ph>, and then prints the value of <ph id="ph4">`Field`</ph>.</source>
          <target state="translated">メソッドの本体の構築型のインスタンスを作成する<ph id="ph1">`Sample&lt;U&gt;`</ph>(<ph id="ph2">`Sample(Of U)`</ph> Visual Basic で)、メソッドのパラメーターに割り当てます<ph id="ph3">`Field`</ph>、しの値を出力<ph id="ph4">`Field`</ph>です。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>A dummy type is defined to hold the entry-point method <ph id="ph1">`Main`</ph>.</source>
          <target state="translated">エントリ ポイント メソッドを保持するためにダミーの型が定義されている<ph id="ph1">`Main`</ph>です。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>In the body of <ph id="ph1">`Main`</ph>, the static <ph id="ph2">`GM`</ph> method is invoked on the constructed generic type <ph id="ph3">`Sample&lt;int&gt;`</ph> (<ph id="ph4">`Sample(Of Integer)`</ph> in Visual Basic), with type <ph id="ph5">&lt;xref:System.String&gt;</ph> substituted for <ph id="ph6">`U`</ph>.</source>
          <target state="translated">本体で<ph id="ph1">`Main`</ph>、静的な<ph id="ph2">`GM`</ph>構築されたジェネリック型でメソッドが呼び出される<ph id="ph3">`Sample&lt;int&gt;`</ph>(<ph id="ph4">`Sample(Of Integer)`</ph> Visual Basic で)、型と<ph id="ph5">&lt;xref:System.String&gt;</ph>の代わりに使用<ph id="ph6">`U`</ph>です。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph> method is used to create a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the static <ph id="ph3">`GM`</ph> method of the constructed generic type <ph id="ph4">`Sample&lt;U&gt;`</ph>, and the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method is then used to create a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can emitted in a method call.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A&gt;</ph>メソッドの使用を作成、 <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> 、静的<ph id="ph3">`GM`</ph>構築ジェネリック型のメソッド<ph id="ph4">`Sample&lt;U&gt;`</ph>、および<ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph>を作成するメソッドを使用して、<ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph>メソッドの呼び出しで出力することができます。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe.</source>
          <target state="translated">このコード例を実行すると、TypeBuilderGetFieldExample.exe として出力されたアセンブリが保存されます。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>You can run TypeBuilderGetFieldExample.exe, and you can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to compare the emitted code with the code for the <ph id="ph1">`Sample`</ph> class that is compiled into the code example itself.</source>
          <target state="translated">TypeBuilderGetFieldExample.exe を実行して、使用することができます、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> 、出力コードのコードを比較する、<ph id="ph1">`Sample`</ph>自体のコード例にコンパイルされるクラスです。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="method" /&gt;</ph> is a generic method that is not a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> はジェネリック メソッド定義ではないジェネリック メソッドです。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> does not represent a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> がジェネリック型を表していません。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is not of type <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="type" /&gt;</ph> が <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> 型ではありません。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not a generic type definition.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> の宣言する型がジェネリック型定義ではありません。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)">
          <source>The declaring type of <ph id="ph1">&lt;paramref name="method" /&gt;</ph> is not the generic type definition of <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="method" /&gt;</ph> の宣言する型が <ph id="ph2">&lt;paramref name="type" /&gt;</ph> のジェネリック型定義ではありません。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">これは <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> や <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> などにある、<ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> からのビット フラグでなければなりません。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public methods declared or inherited by this type, as specified.</source>
          <target state="translated">指定のとおりに、この型によって宣言または継承されたパブリック メソッドと非パブリック メソッドをすべて返します。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing the public and non-public methods defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public methods are returned.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> が使用されている場合、この型で定義されているパブリック メソッドと非パブリック メソッドを表す <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> オブジェクトの配列を返します。それ以外の場合、パブリック メソッドのみが返されます。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the name of the nested type to get.</source>
          <target state="translated">取得対象の入れ子にされた型の名前を格納している <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">検索の実行方法を指定する 1 つ以上の <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> から成るビットマスク。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to conduct a case-sensitive search for public methods.</source>
          <target state="translated">大文字小文字を区別してパブリック メソッドの検索を行う場合は 0。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Returns the public and non-public nested types that are declared by this type.</source>
          <target state="translated">この型によって宣言されている、入れ子にされたパブリック型とパブリックでない型を返します。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">指定した要件と一致し、入れ子にされた型が存在する場合は、その型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。それ以外の場合は <ph id="ph2">&lt;see langword="null" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
          <target state="translated">この型が完了すると、たとえば場合、<ph id="ph1">`CreateType`</ph>は、この型で呼び出されましたが完了すると、入れ子にされた型が<ph id="ph2">`GetNestedTypes`</ph>のみ戻るがその入れ子にされた型を<ph id="ph3">`CreateType`</ph>が呼び出されました。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, as in <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">これは <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> や <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> などにある、<ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> からのビット フラグでなければなりません。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Returns the public and non-public nested types that are declared or inherited by this type.</source>
          <target state="translated">この型で宣言または継承されている入れ子にされたパブリック型とパブリックでない型を返します。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the types nested within the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">現在の <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 内で入れ子にされた型のうち、指定したバインディング制約に一致するすべての型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトの配列。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if no types are nested within the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the nested types match the binding constraints.</source>
          <target state="translated">現在の <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> 内で型が入れ子にされていないか、または入れ子にされた型の中にバインディング制約に一致するものが存在しない場合は、<ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> 型の空の配列。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If this type is complete, for example, if <ph id="ph1">`CreateType`</ph> has been called on this type, but there are nested types that are not complete, then <ph id="ph2">`GetNestedTypes`</ph> will only return those nested types for which <ph id="ph3">`CreateType`</ph> has been called.</source>
          <target state="translated">この型が完了すると、たとえば場合、<ph id="ph1">`CreateType`</ph>は、この型で呼び出されましたが完了すると、入れ子にされた型が<ph id="ph2">`GetNestedTypes`</ph>のみ戻るがその入れ子にされた型を<ph id="ph3">`CreateType`</ph>が呼び出されました。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This invocation attribute.</source>
          <target state="translated">この呼び出しの属性。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This must be a bit flag from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> : <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, and so on.</source>
          <target state="translated">これは <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> や <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph> など、<ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> からのビット フラグでなければなりません。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns all the public and non-public properties declared or inherited by this type, as specified.</source>
          <target state="translated">指定のとおりに、この型によって宣言または継承されたパブリック プロパティと非パブリック プロパティをすべて返します。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Returns an array of <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> objects representing the public and non-public properties defined on this type if <ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> is used; otherwise, only the public properties are returned.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="nonPublic" /&gt;</ph> が使用されている場合、この型で定義されているパブリック プロパティと非パブリック プロパティを表す <ph id="ph1">&lt;see langword="PropertyInfo" /&gt;</ph> オブジェクトの配列を返します。 それ以外の場合、パブリック プロパティのみが返されます。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)">
          <source>This method is not implemented for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは実装されません。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieves the GUID of this type.</source>
          <target state="translated">この型の GUID を取得します。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieves the GUID of this type</source>
          <target state="translated">この型の GUID を取得します。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.GUID">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは現在サポートされていません。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The name of the member to invoke.</source>
          <target state="translated">呼び出すメンバーの名前。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This can be a constructor, method, property, or field.</source>
          <target state="translated">コンストラクター、メソッド、プロパティ、またはフィールドを指定できます。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A suitable invocation attribute must be specified.</source>
          <target state="translated">適切な呼び出し属性を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member.</source>
          <target state="translated">メンバーの名前として空の文字列を渡すことによって、クラスの既定のメンバーを呼び出せることにご注意ください。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The invocation attribute.</source>
          <target state="translated">呼び出し属性。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This must be a bit flag from <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>.</source>
          <target state="translated">これは <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> からのビット フラグでなければなりません。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects using reflection.</source>
          <target state="translated">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> オブジェクトの取得を有効にするオブジェクト。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If binder is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">バインダーが <ph id="ph1">&lt;see langword="null" /&gt;</ph> の場合は、既定のバインダーが使用されます。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</source>
          <target state="translated">「<ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">指定したメンバーを呼び出す対象となるオブジェクト。</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the member is static, this parameter is ignored.</source>
          <target state="translated">メンバーが静的な場合、このパラメーターは無視されます。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An argument list.</source>
          <target state="translated">引数リスト。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked.</source>
          <target state="translated">これは、呼び出されるメンバーのパラメーターの数、順序、および型を含むオブジェクトの配列です。</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If there are no parameters this should be null.</source>
          <target state="translated">パラメーターがない場合は、これは null である必要があります。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of the same length as <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> with elements that represent the attributes associated with the arguments of the member to be invoked.</source>
          <target state="translated">呼び出されるメンバーの引数に関連付けられた属性を表す要素を持つ、<bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> と同じ長さの配列。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter has attributes associated with it in the metadata.</source>
          <target state="translated">メタデータの中でパラメーターには属性が関連付けられています。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>They are used by various interoperability services.</source>
          <target state="translated">これらは、さまざまな相互運用サービスで使用されます。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See the metadata specs for more details.</source>
          <target state="translated">詳細については、メタデータの仕様を参照してください。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">型の強制変換を制御するために使用する <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> のインスタンス。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If this is null, the <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">null の場合は、現在のスレッドの <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> が使用されます。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>(Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">(これは、たとえば、1000 を表す String を Double 値に変換する場合に必要であることに注意ください。これは、カルチャによって 1000 の表記が異なるためです。)</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Each parameter in the <bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept> array gets the value in the corresponding element in the <bpt id="p2">&lt;c&gt;</bpt>args<ept id="p2">&lt;/c&gt;</ept> array.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>namedParameters<ept id="p1">&lt;/c&gt;</ept> 配列の各パラメーターは、<bpt id="p2">&lt;c&gt;</bpt>args<ept id="p2">&lt;/c&gt;</ept> 配列内の対応する要素の値を取得します。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the length of <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> is greater than the length of <bpt id="p2">&lt;c&gt;</bpt>namedParameters<ept id="p2">&lt;/c&gt;</ept>, the remaining argument values are passed in order.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> の長さが <bpt id="p2">&lt;c&gt;</bpt>namedParameters<ept id="p2">&lt;/c&gt;</ept> の長さを超える場合は、残った引数の値が順に渡されます。</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invokes the specified member.</source>
          <target state="translated">指定したメンバーを呼び出します。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method that is to be invoked must be accessible and provide the most specific match with the specified argument list, under the constraints of the specified binder and invocation attributes.</source>
          <target state="translated">呼び出すメソッドはアクセス可能でなければならず、指定したバインダーと呼び出し属性の制約の下で、指定された引数リストに対する一致の特定性が最高のものでなければなりません。</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Returns the return value of the invoked member.</source>
          <target state="translated">呼び出されたメンバーの戻り値を返します。</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if the number of parameters in the method declaration equals the number of arguments in the specified argument list, and the type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">指定した引数リスト内の引数の数に等しければ、メソッドの宣言のパラメーターの数と各引数の型は、バインダーによってパラメーターの型に変換できる場合、メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">バインダーは、すべての一致するメソッドに紹介します。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based on the type of binding requested (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.).</source>
          <target state="translated">これらのメソッドは、要求された (BindingFlags.InvokeMethod、BindingFlags.GetProperties、しなど) のバインディングの種類に基づくにあります。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">メソッドのセットは、名前、引数の数と、バインダーで定義されている検索修飾子のセットによってフィルターされています。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it will be invoked.</source>
          <target state="translated">メソッドを選択した後に呼び出されます。</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">ユーザー補助機能がその時点でチェックされます。</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search can control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">検索では、メソッドに関連付けられているユーザー補助属性に基づいて、メソッドのセットを検索するかを制御できます。</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`IBinder.BindToMethod`</ph> method is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">`IBinder.BindToMethod`</ph>メソッドが呼び出されるメソッドを選択します。</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">既定のバインダーは、最も具体的な一致を選択します。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">アクセスの制限には、完全に信頼されたコードは無視されます。</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully trusted.</source>
          <target state="translated">つまり、private のコンス トラクター、メソッド、フィールド、およびプロパティにアクセスできるし、コードが完全に信頼できる場合は、リフレクションを使用して呼び出されます。</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is not currently supported.</source>
          <target state="translated">このメソッドは現在サポートされていません。</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">使用して型を取得する<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは現在サポートされていません。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Determines whether a specified type can be assigned to this object.</source>
          <target state="translated">指定された型をこのオブジェクトに割り当てることができるかどうかを判定します。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>The object to test.</source>
          <target state="translated">テストするオブジェクト。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> object can be assigned to this object.</source>
          <target state="translated">指定された <ph id="ph1">&lt;see cref="T:System.Reflection.TypeInfo" /&gt;</ph> オブジェクトをこのオブジェクトに割り当てることができるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="typeInfo" /&gt;</ph> can be assigned to this object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="typeInfo" /&gt;</ph> をこのオブジェクトに割り当てることができる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source>The object to test.</source>
          <target state="translated">テストするオブジェクト。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source>Gets a value that indicates whether a specified <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be assigned to this object.</source>
          <target state="translated">指定された <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> をこのオブジェクトに割り当てることができるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="c" /&gt;</ph> parameter and the current type represent the same type, or if the current type is in the inheritance hierarchy of <ph id="ph3">&lt;paramref name="c" /&gt;</ph>, or if the current type is an interface that <ph id="ph4">&lt;paramref name="c" /&gt;</ph> supports.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="c" /&gt;</ph> パラメーターと現在の型が同じ型を表す場合、現在の型が <ph id="ph3">&lt;paramref name="c" /&gt;</ph> の継承階層内にある場合、または現在の型が <ph id="ph4">&lt;paramref name="c" /&gt;</ph> によってサポートされるインターフェイスである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if none of these conditions are valid, or if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">これらの条件がいずれも当てはまらない場合、または <ph id="ph2">&lt;paramref name="c" /&gt;</ph> が <ph id="ph3">&lt;see langword="null" /&gt;</ph> である場合は <ph id="ph1">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">このオブジェクトが構築ジェネリック型かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">このオブジェクトが構築ジェネリック型を表している場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>Returns a value that indicates whether the current dynamic type has been created.</source>
          <target state="translated">現在の動的な型が作成されたかどうかを示す値を返します。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method has been called; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> メソッドが呼び出された場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>After the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method has been called, the type represented by the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object is complete.</source>
          <target state="translated">後に、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>メソッドが呼び出されて、によって表される型、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクトが完了しました。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsCreated">
          <source>Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</source>
          <target state="translated">さらにしようとしたメンバーを追加または型の他の特性を変更するのには、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>The type of attribute to search for.</source>
          <target state="translated">検索する属性の種類。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Only attributes that are assignable to this type are returned.</source>
          <target state="translated">この型に代入可能な属性だけが返されます。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Specifies whether to search this member's inheritance chain to find the attributes.</source>
          <target state="translated">このメンバーの継承チェーンを検索して属性を見つけるかどうかを指定します。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Determines whether a custom attribute is applied to the current type.</source>
          <target state="translated">カスタム属性が現在の型に適用されるかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if one or more instances of <ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph>, or an attribute derived from <ph id="ph3">&lt;paramref name="attributeType" /&gt;</ph>, is defined on this type; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="attributeType" /&gt;</ph> の 1 つ以上のインスタンス、または <ph id="ph3">&lt;paramref name="attributeType" /&gt;</ph> から派生する属性がこの型で定義されている場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not supported for incomplete generic type parameters.</source>
          <target state="translated">このメソッドは、不完全なジェネリック型パラメーターはサポートされません。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>This method is not currently supported for incomplete types.</source>
          <target state="translated">不完全な型では、このメソッドは現在サポートされていません。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source>Retrieve the type using <ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> and call <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> on the returned <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetType" /&gt;</ph> を使用して型を取得し、返された <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> で <ph id="ph2">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph> を呼び出します。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is not defined.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> が定義されていません。</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="attributeType" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source>Gets a value indicating whether the current type is a generic type parameter.</source>
          <target state="translated">現在の型がジェネリック型パラメーターかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type parameter; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> オブジェクトがジェネリック型パラメーターを表している場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter">
          <source>When emitting code, a generic type parameter is represented by a <ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph> object rather than by a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object.</source>
          <target state="translated">ジェネリック型パラメーターがによって表されるコードを生成するときに、<ph id="ph1">&lt;xref:System.Reflection.Emit.GenericTypeParameterBuilder&gt;</ph>オブジェクトではなく、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>Gets a value indicating whether the current type is a generic type.</source>
          <target state="translated">現在の型がジェネリック型かどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type represented by the current <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object is generic; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> オブジェクトによって表される型がジェネリックの場合、<ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合、<ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>場合、オブジェクトがジェネリック型定義を表す、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph>メソッドはジェネリック型パラメーターに使用されています。</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
          <target state="translated">インスタンス、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>がジェネリック クラスは、ジェネリック型定義では常にします。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericType">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">ジェネリック型のリフレクションとジェネリック リフレクションで使用される用語に対するインバリアント条件の一覧の詳細については、次を参照してください。、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> represents a generic type definition from which other generic types can be constructed.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> が、他のジェネリック型を構築できるジェネリック型の定義を表しているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">この <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> オブジェクトがジェネリック型定義を表している場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> object represents a generic type definition if the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph> method has been used to give it generic type parameters.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>場合、オブジェクトがジェネリック型定義を表す、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A&gt;</ph>メソッドはジェネリック型パラメーターに使用されています。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> class that is generic is always a generic type definition.</source>
          <target state="translated">インスタンス、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>がジェネリック クラスは、ジェネリック型定義では常にします。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> can be used to build generic type definitions, but not constructed generic types.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>ジェネリック型定義、ビルドに使用できますが、ジェネリック型を構築されていません。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>To get a constructed generic type, call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
          <target state="translated">構築されたジェネリック型を取得する、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph>メソッドを<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>ジェネリック型定義を表すです。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition">
          <source>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">ジェネリック型のリフレクションとジェネリック リフレクションで使用される用語に対するインバリアント条件の一覧の詳細については、次を参照してください。、<ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical, and therefore can perform critical operations.</source>
          <target state="translated">現在の型がセキュリティ クリティカルまたはセキュリティ セーフ クリティカルであり、重要な操作を実行できるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-critical or security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated">現在の型がセキュリティ クリティカルまたはセキュリティ セーフ クリティカルである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。現在の動的メソッドが透過的な場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph>プロパティは、共通言語ランタイム (CLR) によって決定される型の透過度を報告します。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">これらのプロパティの組み合わせは、次の表に示します。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">セキュリティ レベル</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">重大</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Safe-critical</source>
          <target state="translated">セーフ クリティカル</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">ランタイムは、アセンブリに透過性レベルの評価を開始します。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">など、動的アセンブリがセキュリティ クリティカルである場合は、型の注釈は無視され、すべての型がセキュリティ クリティカル。</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">既定では、動的アセンブリは、それを出力するアセンブリの透過性を継承します。</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">使用してこの既定の動作をオーバーライドすることができます、 <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>、 <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>、または<ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバー ロードとセキュリティ属性を指定します。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">これを行ってセキュリティ レベルを引き上げることができません。つまり、透過的なコードは、セキュリティ クリティカルまたはセキュリティ セーフ クリティカルなコードを生成することはできません。</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">動的アセンブリを作成すると、または、有効になりませんアセンブリをディスクに保存され、再読み込みされるまでときに、属性を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">既定の継承は、透過性のランタイムの評価に制限されます。</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">動的アセンブリには、属性は適用されません。</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">セキュリティ属性を追加する場合を自分でに適用する必要があります。</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">詳細については、リフレクション出力と透明度を参照してください<bpt id="p1">[</bpt>リフレクション出力のセキュリティ関連事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透過性の詳細については、次を参照してください。<bpt id="p1">[</bpt>セキュリティの変更点<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">現在の動的な型は、<ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> メソッドを呼び出して作成された型ではありません。</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current type is security-safe-critical; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">現在の型がセキュリティ セーフ クリティカルであり、重要な操作を実行でき、透過的なコードからアクセスできるかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-safe-critical; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated">現在の型がセキュリティ セーフ クリティカルである場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。現在の型がセキュリティ クリティカルまたは透過的な場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph>プロパティは、共通言語ランタイム (CLR) によって決定される型の透過度を報告します。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">これらのプロパティの組み合わせは、次の表に示します。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">セキュリティ レベル</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">重大</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Safe-critical</source>
          <target state="translated">セーフ クリティカル</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">ランタイムは、アセンブリに透過性レベルの評価を開始します。</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">など、動的アセンブリがセキュリティ クリティカルである場合は、型の注釈は無視され、すべての型がセキュリティ クリティカル。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">既定では、動的アセンブリは、それを出力するアセンブリの透過性を継承します。</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">使用してこの既定の動作をオーバーライドすることができます、 <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>、 <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>、または<ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバー ロードとセキュリティ属性を指定します。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">これを行ってセキュリティ レベルを引き上げることができません。つまり、透過的なコードは、セキュリティ クリティカルまたはセキュリティ セーフ クリティカルなコードを生成することはできません。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">動的アセンブリを作成すると、または、有効になりませんアセンブリをディスクに保存され、再読み込みされるまでときに、属性を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">既定の継承は、透過性のランタイムの評価に制限されます。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">動的アセンブリには、属性は適用されません。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">セキュリティ属性を追加する場合を自分でに適用する必要があります。</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">詳細については、リフレクション出力と透明度を参照してください<bpt id="p1">[</bpt>リフレクション出力のセキュリティ関連事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透過性の詳細については、次を参照してください。<bpt id="p1">[</bpt>セキュリティの変更点<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">現在の動的な型は、<ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> メソッドを呼び出して作成された型ではありません。</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current type is transparent, and therefore cannot perform critical operations.</source>
          <target state="translated">現在の型が透過的であり、重要な操作を実行できないかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is security-transparent; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">型が透過的セキュリティの場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A&gt;</ph>プロパティは、共通言語ランタイム (CLR) によって決定される型の透過度を報告します。</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">これらのプロパティの組み合わせは、次の表に示します。</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Security level</source>
          <target state="translated">セキュリティ レベル</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Critical</source>
          <target state="translated">重大</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Safe-critical</source>
          <target state="translated">セーフ クリティカル</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Transparent</source>
          <target state="translated">透明</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">これらのプロパティを使用する方が、アセンブリとその型のセキュリティの注釈を調べたり、現在の信頼レベルを確認したり、ランタイムの規則を複製したりするより、はるかに簡単です。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The runtime begins evaluating transparency levels at the assembly.</source>
          <target state="translated">ランタイムは、アセンブリに透過性レベルの評価を開始します。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For example, if the dynamic assembly is security-critical, annotations on types are ignored, and all types are security-critical.</source>
          <target state="translated">など、動的アセンブリがセキュリティ クリティカルである場合は、型の注釈は無視され、すべての型がセキュリティ クリティカル。</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>By default, a dynamic assembly inherits the transparency of the assembly that emits it.</source>
          <target state="translated">既定では、動的アセンブリは、それを出力するアセンブリの透過性を継承します。</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>You can override this default by using the <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph> method overload and specifying security attributes.</source>
          <target state="translated">使用してこの既定の動作をオーバーライドすることができます、 <ph id="ph1">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>、 <ph id="ph2">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>、または<ph id="ph3">&lt;xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバー ロードとセキュリティ属性を指定します。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>You cannot elevate security levels by doing this; that is, transparent code cannot emit security-critical or security-safe-critical code.</source>
          <target state="translated">これを行ってセキュリティ レベルを引き上げることができません。つまり、透過的なコードは、セキュリティ クリティカルまたはセキュリティ セーフ クリティカルなコードを生成することはできません。</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Attributes must be specified when the dynamic assembly is created, or they do not take effect until the assembly has been saved to disk and reloaded.</source>
          <target state="translated">動的アセンブリを作成すると、または、有効になりませんアセンブリをディスクに保存され、再読み込みされるまでときに、属性を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>Default inheritance is limited to the runtime's evaluation of transparency.</source>
          <target state="translated">既定の継承は、透過性のランタイムの評価に制限されます。</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>No attributes are applied to the dynamic assembly.</source>
          <target state="translated">動的アセンブリには、属性は適用されません。</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>If you want to add security attributes, you must apply them yourself.</source>
          <target state="translated">セキュリティ属性を追加する場合を自分でに適用する必要があります。</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For more information about reflection emit and transparency, see <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.</source>
          <target state="translated">詳細については、リフレクション出力と透明度を参照してください<bpt id="p1">[</bpt>リフレクション出力のセキュリティ関連事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">透過性の詳細については、次を参照してください。<bpt id="p1">[</bpt>セキュリティの変更点<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent">
          <source>The current dynamic type has not been created by calling the <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method.</source>
          <target state="translated">現在の動的な型は、<ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> メソッドを呼び出して作成された型ではありません。</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> that is to be checked.</source>
          <target state="translated">チェックする <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Determines whether this type is derived from a specified type.</source>
          <target state="translated">この型が指定した型から派生したものかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if this type is the same as the type <ph id="ph2">&lt;paramref name="c" /&gt;</ph>, or is a subtype of type <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">この型が型 <ph id="ph2">&lt;paramref name="c" /&gt;</ph> と同じ場合、または型 <ph id="ph3">&lt;paramref name="c" /&gt;</ph> のサブタイプである場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type.</source>
          <target state="translated">現在の型の配列を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">下限を 0 に設定して現在の型の 1 次元配列を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</source>
          <target state="translated">下限を 0 に設定して要素型が現在の型である 1 次元配列を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph>メソッドがジェネリック型など、任意の要素型の配列型を生成する方法を提供します。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">次のコード例は、動的モジュールの場合、名前付き抽象型を作成<ph id="ph1">`Sample`</ph>、という名前の抽象メソッドと<ph id="ph2">`TestMethod`</ph>です。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> <ph id="ph2">`ref`</ph>パラメーター (<ph id="ph3">`ByRef`</ph> Visual Basic で) 型の<ph id="ph4">`Sample`</ph>、型へのポインター <ph id="ph5">`Sample`</ph>、型の配列と<ph id="ph6">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">型の 2 次元の配列を返します<ph id="ph1">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">コード例をディスクに保存、動的モジュールで調査できるように、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The number of dimensions for the array.</source>
          <target state="translated">配列の次元数。</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">次元数を指定して現在の型の配列を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a one-dimensional array of the current type.</source>
          <target state="translated">現在の型の 1 次元配列を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph> method provides a way to generate an array type with any possible element type, including generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A&gt;</ph>メソッドがジェネリック型など、任意の要素型の配列型を生成する方法を提供します。</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">次のコード例は、動的モジュールの場合、名前付き抽象型を作成<ph id="ph1">`Sample`</ph>、という名前の抽象メソッドと<ph id="ph2">`TestMethod`</ph>です。</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> <ph id="ph2">`ref`</ph>パラメーター (<ph id="ph3">`ByRef`</ph> Visual Basic で) 型の<ph id="ph4">`Sample`</ph>、型へのポインター <ph id="ph5">`Sample`</ph>、型の配列と<ph id="ph6">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">型の 2 次元の配列を返します<ph id="ph1">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">コード例をディスクに保存、動的モジュールで調査できるように、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is not a valid array dimension.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> は有効な配列の次元ではありません。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph2">&lt;see langword="ref" /&gt;</ph> パラメーター (Visual Basic の場合は <ph id="ph3">&lt;see langword="ByRef" /&gt;</ph>) として渡されるときに現在の型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph2">&lt;see langword="ref" /&gt;</ph> パラメーター (Visual Basic の場合は <ph id="ph3">&lt;see langword="ByRef" /&gt;</ph>) として渡されるときに現在の型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A&gt;</ph>メソッドを生成する方法を提供する<ph id="ph2">`ref`</ph>型 (<ph id="ph3">`ByRef`</ph> Visual Basic で) パラメーター リストが表示されます。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType&amp;`</ph>.</source>
          <target state="translated">場合は、Microsoft intermediate language (MSIL) の構文を使用して、現在<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>を表す<ph id="ph2">`MyType`</ph>、このメソッドによって返される型になりますし、<ph id="ph3">`MyType&amp;`</ph>です。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">次のコード例は、動的モジュールの場合、名前付き抽象型を作成<ph id="ph1">`Sample`</ph>、という名前の抽象メソッドと<ph id="ph2">`TestMethod`</ph>です。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> <ph id="ph2">`ref`</ph>パラメーター (<ph id="ph3">`ByRef`</ph> Visual Basic で) 型の<ph id="ph4">`Sample`</ph>、型へのポインター <ph id="ph5">`Sample`</ph>、型の配列と<ph id="ph6">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">型の 2 次元の配列を返します<ph id="ph1">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeByRefType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">コード例をディスクに保存、動的モジュールで調査できるように、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic type definition.</source>
          <target state="translated">現在のジェネリック型定義の型パラメーターに置き換えられる型の配列。</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</source>
          <target state="translated">型の配列の要素を現在のジェネリック型定義の型パラメーターで置き換え、結果の構築型を返します。</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the constructed type formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic type.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> の要素を現在のジェネリック型の型パラメーターで置き換えることによって作られる構築型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Use this method when your emitted code requires a type constructed from the current generic type definition.</source>
          <target state="translated">生成されたコードは、現在のジェネリック型定義から構築された型を必要とする場合は、このメソッドを使用します。</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>It is not necessary to call the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method before calling the <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph> method on a <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> that represents a generic type definition.</source>
          <target state="translated">呼び出す必要はありません、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>メソッドを呼び出す前に、<ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A&gt;</ph>メソッドを<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>ジェネリック型定義を表すです。</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> does not represent the definition of a generic type, an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">場合、現在<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>がジェネリック型の定義を表していません、<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The object returned by this method functions as a placeholder for a constructed generic type in your emitted code.</source>
          <target state="translated">生成されたコードで構築されたジェネリック型のプレース ホルダーとしてこのメソッドによって返されるオブジェクト。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>It is an instance of a class derived from <ph id="ph1">&lt;xref:System.Type&gt;</ph> that has limited capabilities.</source>
          <target state="translated">派生したクラスのインスタンスでは<ph id="ph1">&lt;xref:System.Type&gt;</ph>機能が制限されます。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>In particular:</source>
          <target state="translated">特に次の点に注意してください。</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>To get methods, fields, and constructors for these constructed generic types, use the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph> method overloads.</source>
          <target state="translated">これらの構築ジェネリック型のメソッド、フィールド、およびコンス トラクターを取得する、 <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29&gt;</ph>、 <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29&gt;</ph>、および<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Two instances that represent the same constructed type do not compare as equal.</source>
          <target state="translated">同じの構築型を表す 2 つのインスタンスには等しいとを比較できません。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>For example, in the following code <ph id="ph1">`t1.Equals(t2)`</ph> returns <ph id="ph2">`false`</ph>:</source>
          <target state="translated">たとえば、次のコードで<ph id="ph1">`t1.Equals(t2)`</ph>返します<ph id="ph2">`false`</ph>:</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The current type does not represent the definition of a generic type.</source>
          <target state="translated">現在の型はジェネリック型の定義を表していません。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> は <ph id="ph2">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> のどの要素も <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Type.Module" /&gt;</ph> property of any element of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> のどの要素の <ph id="ph1">&lt;see cref="P:System.Type.Module" /&gt;</ph> プロパティも <ph id="ph3">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;see cref="P:System.Reflection.Module.Assembly" /&gt;</ph> property of the module of any element of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> のどの要素のモジュールの <ph id="ph1">&lt;see cref="P:System.Reflection.Module.Assembly" /&gt;</ph> プロパティも <ph id="ph3">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
          <target state="translated">現在の型を指すアンマネージ ポインターの型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the type of an unmanaged pointer to the current type.</source>
          <target state="translated">現在の型を指すアンマネージ ポインターの型を表す <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A&gt;</ph>メソッドはパラメーター リストのポインター型を生成する方法を提供します。</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>Using Microsoft intermediate language (MSIL) syntax, if the current <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph> represents <ph id="ph2">`MyType`</ph>, then the type returned by this method would be <ph id="ph3">`MyType*`</ph>.</source>
          <target state="translated">場合は、Microsoft intermediate language (MSIL) の構文を使用して、現在<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>を表す<ph id="ph2">`MyType`</ph>、このメソッドによって返される型になりますし、<ph id="ph3">`MyType*`</ph>です。</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The following code example creates a dynamic module, an abstract type named <ph id="ph1">`Sample`</ph>, and an abstract method named <ph id="ph2">`TestMethod`</ph>.</source>
          <target state="translated">次のコード例は、動的モジュールの場合、名前付き抽象型を作成<ph id="ph1">`Sample`</ph>、という名前の抽象メソッドと<ph id="ph2">`TestMethod`</ph>です。</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source><ph id="ph1">`TestMethod`</ph> takes a <ph id="ph2">`ref`</ph> parameter (<ph id="ph3">`ByRef`</ph> in Visual Basic) of type <ph id="ph4">`Sample`</ph>, a pointer to type <ph id="ph5">`Sample`</ph>, and an array of type <ph id="ph6">`Sample`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestMethod`</ph> <ph id="ph2">`ref`</ph>パラメーター (<ph id="ph3">`ByRef`</ph> Visual Basic で) 型の<ph id="ph4">`Sample`</ph>、型へのポインター <ph id="ph5">`Sample`</ph>、型の配列と<ph id="ph6">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>It returns a two-dimensional array of type <ph id="ph1">`Sample`</ph>.</source>
          <target state="translated">型の 2 次元の配列を返します<ph id="ph1">`Sample`</ph>です。</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.MakePointerType">
          <source>The code example saves the dynamic module to disk, so you can examine it with the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>.</source>
          <target state="translated">コード例をディスクに保存、動的モジュールで調査できるように、 <bpt id="p1">[</bpt>Ildasm.exe (IL 逆アセンブラー)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Retrieves the dynamic module that contains this type definition.</source>
          <target state="translated">この型定義を含む動的モジュールを取得します。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Module">
          <source>Retrieves the dynamic module that contains this type definition.</source>
          <target state="translated">この型定義を含む動的モジュールを取得します。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Retrieves the name of this type.</source>
          <target state="translated">この型の名前を取得します。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Name">
          <source>Retrieves the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> name of this type.</source>
          <target state="translated">この型の <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> 名を取得します。</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Retrieves the namespace where this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> is defined.</source>
          <target state="translated">この <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> が定義されている名前空間を取得します。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Namespace">
          <source>Retrieves the namespace where this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> is defined.</source>
          <target state="translated">この <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> が定義されている名前空間を取得します。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Retrieves the packing size of this type.</source>
          <target state="translated">この型のパッキング サイズを取得します。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.PackingSize">
          <source>Retrieves the packing size of this type.</source>
          <target state="translated">この型のパッキング サイズを取得します。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>Returns the type that was used to obtain this type.</source>
          <target state="translated">この型を取得するために使用された型を返します。</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.ReflectedType">
          <source>The type that was used to obtain this type.</source>
          <target state="translated">この型を取得するために使用された型。</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.TypeBuilder">
          <source>Sets a custom attribute.</source>
          <target state="translated">カスタム属性を設定します。</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>An instance of a helper class to define the custom attribute.</source>
          <target state="translated">カスタム属性を定義するヘルパー クラスのインスタンス。</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Set a custom attribute using a custom attribute builder.</source>
          <target state="translated">カスタム属性ビルダーを使用して、カスタム属性を設定します。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">以降で、 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>、このメンバーは不要<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>で、<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph>フラグ。</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(を参照してください<bpt id="p1">[</bpt>出力リフレクションのセキュリティ関連事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>)。この機能を使用するには、アプリケーションで <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 以降を対象とする必要があります。</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="customBuilder" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型では、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティは <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The constructor for the custom attribute.</source>
          <target state="translated">カスタム属性のコンストラクター。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>A byte blob representing the attributes.</source>
          <target state="translated">属性を表すバイト blob。</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Sets a custom attribute using a specified custom attribute blob.</source>
          <target state="translated">指定されたカスタム属性の blob を使用して、カスタム属性を設定します。</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For more information on how to format <ph id="ph1">`binaryAttribute`</ph>, see the Common Language Infrastructure (CLI) documentation, especially "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">書式設定する方法の詳細についての<ph id="ph1">`binaryAttribute`</ph>、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」を参照してください。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">ドキュメントはオンラインで入手できます。MSDN の「<bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「<bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this member no longer requires <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph> flag.</source>
          <target state="translated">以降で、 <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>、このメンバーは不要<ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>で、<ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType&gt;</ph>フラグ。</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>(See <bpt id="p1">[</bpt>Security Issues in Reflection Emit<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>.) To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">(を参照してください<bpt id="p1">[</bpt>出力リフレクションのセキュリティ関連事項<ept id="p1">](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)</ept>)。この機能を使用するには、アプリケーションで <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> 以降を対象とする必要があります。</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="con" /&gt;</ph> or <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="con" /&gt;</ph> または <ph id="ph2">&lt;paramref name="binaryAttribute" /&gt;</ph> が <ph id="ph3">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型では、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティは <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The new base type.</source>
          <target state="translated">新しい基本型。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>Sets the base type of the type currently under construction.</source>
          <target state="translated">現在作成中の型の基本型を設定します。</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>If <ph id="ph1">`parent`</ph> is <ph id="ph2">`null`</ph>, <ph id="ph3">&lt;xref:System.Object&gt;</ph> is used as the base type.</source>
          <target state="translated">場合<ph id="ph1">`parent`</ph>は<ph id="ph2">`null`</ph>、<ph id="ph3">&lt;xref:System.Object&gt;</ph>は基本型として使用します。</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>In the .NET Framework versions 1.0 and 1.1, no exception is thrown if <ph id="ph1">`parent`</ph> is an interface type, but a <ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph> is thrown when the <ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method is called.</source>
          <target state="translated">.NET Framework バージョン 1.0 および 1.1 では、例外がスローされない場合<ph id="ph1">`parent`</ph>はインターフェイス型が、<ph id="ph2">&lt;xref:System.TypeLoadException&gt;</ph>場合にスローされる、<ph id="ph3">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph> method does not check for most invalid parent types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.SetParent%2A&gt;</ph>メソッドは、ほとんどの無効な親の型をチェックしません。</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> type.</source>
          <target state="translated">たとえば、親の型を持たない既定のコンス トラクターと現在の型が既定のコンス トラクターを持つ、sealed 型を破棄しません破棄しません拒否されなければ、<ph id="ph1">&lt;xref:System.Delegate&gt;</ph>型です。</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>In all these cases, exceptions are thrown by the <ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph> method.</source>
          <target state="translated">これらすべてのケースがスローした例外、<ph id="ph1">&lt;xref:System.Reflection.Emit.TypeBuilder.CreateType%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, and the current instance represents an interface whose attributes do not include <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.Abstract" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> が <ph id="ph2">&lt;see langword="null" /&gt;</ph> で、現在のインスタンスが <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.Abstract" /&gt;</ph> を含まない属性のインターフェイスを表します。</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>For the current dynamic type, the <ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> property is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, but the <ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> property is <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の動的な型の場合、<ph id="ph1">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /&gt;</ph> プロパティが <ph id="ph2">&lt;see langword="true" /&gt;</ph> ですが、<ph id="ph3">&lt;see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /&gt;</ph> プロパティは <ph id="ph4">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> is an interface.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="parent" /&gt;</ph> がインターフェイスです。</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)">
          <source>This exception condition is new in the .NET Framework version 2.0.</source>
          <target state="translated">この例外条件は、.NET Framework Version 2.0 で新しく追加されたものです。</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Retrieves the total size of a type.</source>
          <target state="translated">型の合計サイズを取得します。</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.Size">
          <source>Retrieves this type’s total size.</source>
          <target state="translated">この型の合計サイズを取得します。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">将来使用するために予約されています。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">IID_NULL にする必要があります。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">マッピング対象として渡される名前の配列。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">マッピングされる名前のカウント。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">名前を解釈するロケール コンテキスト。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">一連の名前を対応する一連のディスパッチ識別子に割り当てます。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::GetIDsOfNames`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">返される型情報。</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">型情報のロケール ID。</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">要求された型情報オブジェクトへのポインターを取得します。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::GetTypeInfo`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">メンバーを識別します。</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">将来使用するために予約されています。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">IID_NULL にする必要があります。</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">引数を解釈する対象のロケール コンテキスト。</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">呼び出しのコンテキストを記述するフラグ。</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">結果が格納される場所へのポインター。</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">例外情報を格納する構造体へのポインター。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">エラーが存在する最初の引数のインデックス。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">詳細については<ph id="ph1">`IDispatch::Invoke`</ph>、MSDN ライブラリを参照してください。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>Returns the name of the type excluding the namespace.</source>
          <target state="translated">名前空間を含まない型の名前を返します。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.TypeBuilder.ToString">
          <source>The name of the type excluding the namespace.</source>
          <target state="translated">名前空間を含まない型の名前。</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Not supported in dynamic modules.</source>
          <target state="translated">動的モジュールではサポートされていません。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Retrieve the type using <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> and use reflection on the retrieved type.</source>
          <target state="translated">型を使用して、取得<ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>取得した型のリフレクションを使用します。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeHandle">
          <source>Not supported in dynamic modules.</source>
          <target state="translated">動的モジュールではサポートされていません。</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Returns the type token of this type.</source>
          <target state="translated">この型の型トークンを返します。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>Returns the <ph id="ph1">&lt;see langword="TypeToken" /&gt;</ph> of this type.</source>
          <target state="translated">この型の <ph id="ph1">&lt;see langword="TypeToken" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.TypeToken">
          <source>The type was previously created using <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>.</source>
          <target state="translated">型は <ph id="ph1">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> を使用して既に作成されました。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Returns the underlying system type for this <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph>.</source>
          <target state="translated">この <ph id="ph1">&lt;see langword="TypeBuilder" /&gt;</ph> の基になるシステム型を返します。</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Read-only.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>Returns the underlying system type.</source>
          <target state="translated">基になるシステム型を返します。</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType">
          <source>This type is an enumeration, but there is no underlying system type.</source>
          <target state="translated">この型は列挙型ですが、基になるシステム型はありません。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize">
          <source>Represents that total size for the type is not specified.</source>
          <target state="translated">この型の合計サイズが指定されていないことを表します。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>