<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aea33b9e902b909e4adf9f543fadb5190ce68f9b" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70437548" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="45410-101"><see cref="T:System.Reflection.Emit.ILGenerator" /> クラス メンバー (<see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> など) による出力に対する MSIL (Microsoft Intermediate Language) 命令のフィールド表現を提供します。</span><span class="sxs-lookup"><span data-stu-id="45410-101">Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <see cref="T:System.Reflection.Emit.ILGenerator" /> class members (such as <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-102">メンバーオペコードの詳細については、共通言語基盤 (CLI) のドキュメント、特に「パーティション III: CIL 命令セット」と「パーティション II: メタデータの定義とセマンティクス」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-102">For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="45410-103">ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-103">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45410-104">次の例は、を使用して<xref:System.Reflection.Emit.ILGenerator>に出力`OpCodes` <xref:System.Reflection.Emit.MethodBuilder>する動的メソッドを構築する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-104">The following example demonstrates the construction of a dynamic method using <xref:System.Reflection.Emit.ILGenerator> to emit `OpCodes` into a <xref:System.Reflection.Emit.MethodBuilder>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-105">2 つの値を加算し、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-105">Adds two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-106">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-106">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-107">形式</span><span class="sxs-lookup"><span data-stu-id="45410-107">Format</span></span>|<span data-ttu-id="45410-108">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-108">Assembly Format</span></span>|<span data-ttu-id="45410-109">説明</span><span class="sxs-lookup"><span data-stu-id="45410-109">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-110">58</span><span class="sxs-lookup"><span data-stu-id="45410-110">58</span></span>|<span data-ttu-id="45410-111">add</span><span class="sxs-lookup"><span data-stu-id="45410-111">add</span></span>|<span data-ttu-id="45410-112">2つの数値を加算して、新しい数値を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-112">Adds two numeric values, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="45410-113">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-113">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-114">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-114">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-115">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-115">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-116">`value2`と`value1`はスタックからポップされます。`value1`がに `value2` 追加されます。</span><span class="sxs-lookup"><span data-stu-id="45410-116">`value2` and `value1` are popped from the stack; `value1` is added to `value2`.</span></span>  
  
4.  <span data-ttu-id="45410-117">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-117">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-118">整数演算のオーバーフローは検出されません (適切なオーバーフロー <xref:System.Reflection.Emit.OpCodes.Add_Ovf>処理の場合は、「」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="45410-118">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).</span></span>  
  
 <span data-ttu-id="45410-119">整数の加算は、飽和度ではなく、ラップします。</span><span class="sxs-lookup"><span data-stu-id="45410-119">Integer addition wraps, rather than saturates.</span></span> <span data-ttu-id="45410-120">たとえば、が255に設定され、 `value1`が1に設定さ`value2`れている8ビット整数と想定した場合、ラップされた結果は256ではなく0になります。</span><span class="sxs-lookup"><span data-stu-id="45410-120">For example, assuming 8-bit integers where `value1` is set to 255 and `value2` is set to 1, the wrapped result is 0 rather than 256.</span></span>  
  
 <span data-ttu-id="45410-121">浮動小数点オーバーフローは`+inf` 、`PositiveInfinity`() `-inf`また`NegativeInfinity`は () を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-121">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="45410-122">許容されるオペランドの型とそれに対応する結果のデータ型を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="45410-122">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="45410-123">特定の型の組み合わせ (や`int32` `float`など) のエントリがない場合は。`int32` また `int64` 、無効な Microsoft 中間言語 (MSIL) であり、エラーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-123">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</span></span>  
  
|<span data-ttu-id="45410-124">オペランド</span><span class="sxs-lookup"><span data-stu-id="45410-124">operand</span></span>|<span data-ttu-id="45410-125">value1 型</span><span class="sxs-lookup"><span data-stu-id="45410-125">value1 type</span></span>|<span data-ttu-id="45410-126">value2 型</span><span class="sxs-lookup"><span data-stu-id="45410-126">value2 type</span></span>|<span data-ttu-id="45410-127">結果の種類</span><span class="sxs-lookup"><span data-stu-id="45410-127">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="45410-128">add</span><span class="sxs-lookup"><span data-stu-id="45410-128">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="45410-129">追加</span><span class="sxs-lookup"><span data-stu-id="45410-129">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="45410-130">追加</span><span class="sxs-lookup"><span data-stu-id="45410-130">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="45410-131">追加</span><span class="sxs-lookup"><span data-stu-id="45410-131">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="45410-132">追加</span><span class="sxs-lookup"><span data-stu-id="45410-132">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="45410-133">追加</span><span class="sxs-lookup"><span data-stu-id="45410-133">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="45410-134">追加</span><span class="sxs-lookup"><span data-stu-id="45410-134">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="45410-135">追加</span><span class="sxs-lookup"><span data-stu-id="45410-135">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="45410-136">追加</span><span class="sxs-lookup"><span data-stu-id="45410-136">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="45410-137">追加</span><span class="sxs-lookup"><span data-stu-id="45410-137">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="45410-138">追加</span><span class="sxs-lookup"><span data-stu-id="45410-138">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="45410-139">追加</span><span class="sxs-lookup"><span data-stu-id="45410-139">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="45410-140">追加</span><span class="sxs-lookup"><span data-stu-id="45410-140">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="45410-141">add</span><span class="sxs-lookup"><span data-stu-id="45410-141">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="45410-142">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `add`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-142">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add` opcode:</span></span>  
  
-   <span data-ttu-id="45410-143">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-143">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-144">2 つの整数を加算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-144">Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-145">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-145">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-146">形式</span><span class="sxs-lookup"><span data-stu-id="45410-146">Format</span></span>|<span data-ttu-id="45410-147">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-147">Assembly Format</span></span>|<span data-ttu-id="45410-148">説明</span><span class="sxs-lookup"><span data-stu-id="45410-148">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-149">D6</span><span class="sxs-lookup"><span data-stu-id="45410-149">D6</span></span>|<span data-ttu-id="45410-150">ovf を追加します。</span><span class="sxs-lookup"><span data-stu-id="45410-150">add.ovf</span></span>|<span data-ttu-id="45410-151">オーバーフローチェック付きの2つの符号付き整数値を追加します。</span><span class="sxs-lookup"><span data-stu-id="45410-151">Adds two signed integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="45410-152">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-152">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-153">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-153">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-154">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-154">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-155">`value2`と`value1`はスタックからポップされます。は、オーバーフロー `value2`のチェックを使用してに追加されます。 `value1`</span><span class="sxs-lookup"><span data-stu-id="45410-155">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="45410-156">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-156">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-157"><xref:System.OverflowException>結果が結果型に表示されない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-157"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-158">この操作は、符号付き整数に対して実行できます。</span><span class="sxs-lookup"><span data-stu-id="45410-158">You can perform this operation on signed integers.</span></span> <span data-ttu-id="45410-159">浮動小数点値の場合は<xref:System.Reflection.Emit.OpCodes.Add>、を使用します。</span><span class="sxs-lookup"><span data-stu-id="45410-159">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="45410-160">許容されるオペランドの型とそれに対応する結果のデータ型を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="45410-160">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="45410-161">特定の型の組み合わせ (や`int32` `float`など) のエントリがない場合は。`int32` また `int64` 、これは無効な MSIL (Microsoft 中間言語) 命令であり、エラーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-161">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="45410-162">オペランド</span><span class="sxs-lookup"><span data-stu-id="45410-162">operand</span></span>|<span data-ttu-id="45410-163">value1 型</span><span class="sxs-lookup"><span data-stu-id="45410-163">value1 type</span></span>|<span data-ttu-id="45410-164">value2 型</span><span class="sxs-lookup"><span data-stu-id="45410-164">value2 type</span></span>|<span data-ttu-id="45410-165">結果の種類</span><span class="sxs-lookup"><span data-stu-id="45410-165">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="45410-166">add</span><span class="sxs-lookup"><span data-stu-id="45410-166">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="45410-167">追加</span><span class="sxs-lookup"><span data-stu-id="45410-167">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="45410-168">追加</span><span class="sxs-lookup"><span data-stu-id="45410-168">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="45410-169">追加</span><span class="sxs-lookup"><span data-stu-id="45410-169">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="45410-170">追加</span><span class="sxs-lookup"><span data-stu-id="45410-170">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="45410-171">追加</span><span class="sxs-lookup"><span data-stu-id="45410-171">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="45410-172">追加</span><span class="sxs-lookup"><span data-stu-id="45410-172">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="45410-173">追加</span><span class="sxs-lookup"><span data-stu-id="45410-173">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="45410-174">追加</span><span class="sxs-lookup"><span data-stu-id="45410-174">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="45410-175">追加</span><span class="sxs-lookup"><span data-stu-id="45410-175">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="45410-176">追加</span><span class="sxs-lookup"><span data-stu-id="45410-176">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="45410-177">追加</span><span class="sxs-lookup"><span data-stu-id="45410-177">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="45410-178">追加</span><span class="sxs-lookup"><span data-stu-id="45410-178">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="45410-179">add</span><span class="sxs-lookup"><span data-stu-id="45410-179">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="45410-180">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `add.ovf`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-180">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="45410-181">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-181">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-182">2 つの符号なし整数値を加算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-182">Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-183">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-183">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-184">形式</span><span class="sxs-lookup"><span data-stu-id="45410-184">Format</span></span>|<span data-ttu-id="45410-185">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-185">Assembly Format</span></span>|<span data-ttu-id="45410-186">説明</span><span class="sxs-lookup"><span data-stu-id="45410-186">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-187">D7</span><span class="sxs-lookup"><span data-stu-id="45410-187">D7</span></span>|<span data-ttu-id="45410-188">ovf を追加します。</span><span class="sxs-lookup"><span data-stu-id="45410-188">add.ovf.un</span></span>|<span data-ttu-id="45410-189">オーバーフローチェック付きの2つの符号なし整数値を追加します。</span><span class="sxs-lookup"><span data-stu-id="45410-189">Adds two unsigned integer values with an overflow check.</span></span>|  
  
 <span data-ttu-id="45410-190">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-190">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-191">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-191">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-192">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-192">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-193">`value2`と`value1`はスタックからポップされます。は、オーバーフロー `value2`のチェックを使用してに追加されます。 `value1`</span><span class="sxs-lookup"><span data-stu-id="45410-193">`value2` and `value1` are popped from the stack; `value1` is added to `value2` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="45410-194">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-194">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-195"><xref:System.OverflowException>結果が結果型に表示されない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-195"><xref:System.OverflowException> is thrown if the result is not represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-196">この操作は、符号付き整数に対して実行できます。</span><span class="sxs-lookup"><span data-stu-id="45410-196">You can perform this operation on signed integers.</span></span> <span data-ttu-id="45410-197">浮動小数点値の場合は<xref:System.Reflection.Emit.OpCodes.Add>、を使用します。</span><span class="sxs-lookup"><span data-stu-id="45410-197">For floating-point values, use <xref:System.Reflection.Emit.OpCodes.Add>.</span></span>  
  
 <span data-ttu-id="45410-198">許容されるオペランドの型とそれに対応する結果のデータ型を次の表に示します。</span><span class="sxs-lookup"><span data-stu-id="45410-198">The acceptable operand types and their corresponding result data type are listed in the table below.</span></span> <span data-ttu-id="45410-199">特定の型の組み合わせ (や`int32` `float`など) のエントリがない場合は。`int32` また `int64` 、これは無効な MSIL (Microsoft 中間言語) 命令であり、エラーが生成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-199">If there is no entry for a particular type combination (for example, `int32` and `float`; `int32` and `int64`), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</span></span>  
  
|<span data-ttu-id="45410-200">オペランド</span><span class="sxs-lookup"><span data-stu-id="45410-200">operand</span></span>|<span data-ttu-id="45410-201">value1 型</span><span class="sxs-lookup"><span data-stu-id="45410-201">value1 type</span></span>|<span data-ttu-id="45410-202">value2 型</span><span class="sxs-lookup"><span data-stu-id="45410-202">value2 type</span></span>|<span data-ttu-id="45410-203">結果の種類</span><span class="sxs-lookup"><span data-stu-id="45410-203">result type</span></span>|  
|-------------|-----------------|-----------------|-----------------|  
|<span data-ttu-id="45410-204">add</span><span class="sxs-lookup"><span data-stu-id="45410-204">add</span></span>|`int32`|`int32`|`int32`|  
|<span data-ttu-id="45410-205">追加</span><span class="sxs-lookup"><span data-stu-id="45410-205">add</span></span>|`int32`|`native int`|`native int`|  
|<span data-ttu-id="45410-206">追加</span><span class="sxs-lookup"><span data-stu-id="45410-206">add</span></span>|`int32`|`&`|`&`|  
|<span data-ttu-id="45410-207">追加</span><span class="sxs-lookup"><span data-stu-id="45410-207">add</span></span>|`int32`|`*`|`*`|  
|<span data-ttu-id="45410-208">追加</span><span class="sxs-lookup"><span data-stu-id="45410-208">add</span></span>|`int64`|`int64`|`int64`|  
|<span data-ttu-id="45410-209">追加</span><span class="sxs-lookup"><span data-stu-id="45410-209">add</span></span>|`native int`|`int32`|`native int`|  
|<span data-ttu-id="45410-210">追加</span><span class="sxs-lookup"><span data-stu-id="45410-210">add</span></span>|`native int`|`native int`|`native int`|  
|<span data-ttu-id="45410-211">追加</span><span class="sxs-lookup"><span data-stu-id="45410-211">add</span></span>|`native int`|`&`|`&`|  
|<span data-ttu-id="45410-212">追加</span><span class="sxs-lookup"><span data-stu-id="45410-212">add</span></span>|`native int`|`*`|`*`|  
|<span data-ttu-id="45410-213">追加</span><span class="sxs-lookup"><span data-stu-id="45410-213">add</span></span>|`F`|`F`|`F`|  
|<span data-ttu-id="45410-214">追加</span><span class="sxs-lookup"><span data-stu-id="45410-214">add</span></span>|`&`|`int32`|`&`|  
|<span data-ttu-id="45410-215">追加</span><span class="sxs-lookup"><span data-stu-id="45410-215">add</span></span>|`&`|`native int`|`&`|  
|<span data-ttu-id="45410-216">追加</span><span class="sxs-lookup"><span data-stu-id="45410-216">add</span></span>|`*`|`int32`|`*`|  
|<span data-ttu-id="45410-217">add</span><span class="sxs-lookup"><span data-stu-id="45410-217">add</span></span>|`*`|`native int`|`*`|  
  
 <span data-ttu-id="45410-218">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `add.ovf.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-218">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `add.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-219">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-219">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-220">2 つの値のビットごとの AND を計算し、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-220">Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-221">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-221">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-222">形式</span><span class="sxs-lookup"><span data-stu-id="45410-222">Format</span></span>|<span data-ttu-id="45410-223">命令</span><span class="sxs-lookup"><span data-stu-id="45410-223">Instruction</span></span>|<span data-ttu-id="45410-224">説明</span><span class="sxs-lookup"><span data-stu-id="45410-224">Description</span></span>|  
|------------|-----------------|-----------------|  
|<span data-ttu-id="45410-225">5F (</span><span class="sxs-lookup"><span data-stu-id="45410-225">5F</span></span>|<span data-ttu-id="45410-226">and</span><span class="sxs-lookup"><span data-stu-id="45410-226">and</span></span>|<span data-ttu-id="45410-227">2つの整数値のビットごとの AND を決定します。</span><span class="sxs-lookup"><span data-stu-id="45410-227">Determines the bitwise AND of two integer values.</span></span>|  
  
 <span data-ttu-id="45410-228">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-228">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-229">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-229">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-230">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-230">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-231">`value1`と`value2`はスタックからポップされ、2つの値のビットごとの and が計算されます。</span><span class="sxs-lookup"><span data-stu-id="45410-231">`value1` and `value2` are popped from the stack; the bitwise AND of the two values is computed.</span></span>  
  
4.  <span data-ttu-id="45410-232">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-232">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-233">命令`and`は、スタックの上位2つの値のビットごとの and を計算し、結果をスタックに残します。</span><span class="sxs-lookup"><span data-stu-id="45410-233">The `and` instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="45410-234">`And`は整数固有の演算です。</span><span class="sxs-lookup"><span data-stu-id="45410-234">`And` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="45410-235">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `and`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-235">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `and` opcode:</span></span>  
  
-   <span data-ttu-id="45410-236">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-236">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-237">現在のメソッドの引数リストへのアンマネージ ポインターを返します。</span><span class="sxs-lookup"><span data-stu-id="45410-237">Returns an unmanaged pointer to the argument list of the current method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-238">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-238">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-239">形式</span><span class="sxs-lookup"><span data-stu-id="45410-239">Format</span></span>|<span data-ttu-id="45410-240">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-240">Assembly Format</span></span>|<span data-ttu-id="45410-241">説明</span><span class="sxs-lookup"><span data-stu-id="45410-241">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-242">FE 00</span><span class="sxs-lookup"><span data-stu-id="45410-242">FE 00</span></span>|<span data-ttu-id="45410-243">arglist</span><span class="sxs-lookup"><span data-stu-id="45410-243">arglist</span></span>|<span data-ttu-id="45410-244">現在のメソッドの引数リストハンドルを返します。</span><span class="sxs-lookup"><span data-stu-id="45410-244">Returns an argument list handle for the current method.</span></span>|  
  
 <span data-ttu-id="45410-245">この操作では、評価スタックの動作は実行されません。</span><span class="sxs-lookup"><span data-stu-id="45410-245">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="45410-246">命令`arglist`は、現在のメソッドの引数リストを表す不透明な`native int`ハンドル (型のアンマネージポインター) を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-246">The `arglist` instruction returns an opaque handle (an unmanaged pointer, of type `native int`) that represents the argument list of the current method.</span></span> <span data-ttu-id="45410-247">このハンドルは、現在のメソッドの有効期間中にのみ有効です。</span><span class="sxs-lookup"><span data-stu-id="45410-247">This handle is valid only during the lifetime of the current method.</span></span> <span data-ttu-id="45410-248">ただし、現在のメソッドがコントロールのスレッド上にある限り、ハンドルを他のメソッドに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-248">You can, however, pass the handle to other methods as long as the current method is on the thread of control.</span></span> <span data-ttu-id="45410-249">この命令は`arglist` 、可変個の引数を受け取るメソッド内でのみ実行できます。</span><span class="sxs-lookup"><span data-stu-id="45410-249">You can only execute the `arglist` instruction within a method that takes a variable number of arguments.</span></span>  
  
 <span data-ttu-id="45410-250">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `arglist`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-250">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `arglist` opcode:</span></span>  
  
-   <span data-ttu-id="45410-251">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-251">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-252">2 つの値が等しい場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-252">Transfers control to a target instruction if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-253">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-253">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-254">形式</span><span class="sxs-lookup"><span data-stu-id="45410-254">Format</span></span>|<span data-ttu-id="45410-255">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-255">Assembly Format</span></span>|<span data-ttu-id="45410-256">説明</span><span class="sxs-lookup"><span data-stu-id="45410-256">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-257">3B <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-257">3B < `int32` ></span></span>|<span data-ttu-id="45410-258">beq`target`</span><span class="sxs-lookup"><span data-stu-id="45410-258">beq `target`</span></span>|<span data-ttu-id="45410-259">2つの値が等しい場合`target`は、オフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-259">Branch to the target instruction at offset `target` if the two values are equal.</span></span>|  
  
 <span data-ttu-id="45410-260">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-260">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-261">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-261">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-262">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-262">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-263">`value2`と`value1`はスタックからポップされます`value1` 。がに`value2`等しい場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-263">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-264">が`beq`と等しい `value1` 場合、命令は、指定されたターゲット命令に制御を転送します。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-264">The `beq` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="45410-265">効果は、命令の`ceq`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-265">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-266">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-266">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-267">許容されるオペランドの型は、次のようにカプセル化されます。</span><span class="sxs-lookup"><span data-stu-id="45410-267">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="45410-268">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-268">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="45410-269">`try` 、 `catch` 、 、および<xref:System.Reflection.Emit.OpCodes.Leave>ブロックとの間の制御転送は、この命令では実行できません (このような転送は厳しく制限されており、代わりに命令を使用する必要があります)。 `finally` `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-269">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="45410-270">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `beq`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-270">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq` opcode:</span></span>  
  
-   <span data-ttu-id="45410-271">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-271">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-272">2 つの値が等しい場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-272">Transfers control to a target instruction (short form) if two values are equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-273">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-273">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-274">形式</span><span class="sxs-lookup"><span data-stu-id="45410-274">Format</span></span>|<span data-ttu-id="45410-275">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-275">Assembly Format</span></span>|<span data-ttu-id="45410-276">説明</span><span class="sxs-lookup"><span data-stu-id="45410-276">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-277">2E <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-277">2E < `int8` ></span></span>|<span data-ttu-id="45410-278">beq. s`target`</span><span class="sxs-lookup"><span data-stu-id="45410-278">beq.s `target`</span></span>|<span data-ttu-id="45410-279">同じ、短い形式の場合は`target` 、オフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-279">Branch to the target instruction at offset `target` if equal, short form</span></span>|  
  
 <span data-ttu-id="45410-280">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-280">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-281">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-281">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-282">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-282">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-283">`value2`と`value1`はスタックからポップされます`value1` 。がに`value2`等しい場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-283">`value2` and `value1` are popped from the stack; if `value1` is equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-284">が`beq.s`と等しい `value1` 場合、命令は、指定されたターゲット命令に制御を転送します。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-284">The `beq.s` instruction transfers control to the specified target instruction if `value1` is equal to `value2`.</span></span> <span data-ttu-id="45410-285">効果は、命令の`ceq`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-285">The effect is the same as performing a `ceq` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-286">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-286">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-287">許容されるオペランドの型は、次のようにカプセル化されます。</span><span class="sxs-lookup"><span data-stu-id="45410-287">The acceptable operand types are encapsulated below:</span></span>  
  
 <span data-ttu-id="45410-288">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-288">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="45410-289">`try` 、 `catch` 、 、および<xref:System.Reflection.Emit.OpCodes.Leave>ブロックとの間の制御転送は、この命令では実行できません (このような転送は厳しく制限されており、代わりに命令を使用する必要があります)。 `finally` `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-289">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction instead).</span></span>  
  
 <span data-ttu-id="45410-290">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `beq.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-290">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `beq.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-291">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-291">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-292">最初の値が 2 番目の値以上の場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-292">Transfers control to a target instruction if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-293">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-293">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-294">形式</span><span class="sxs-lookup"><span data-stu-id="45410-294">Format</span></span>|<span data-ttu-id="45410-295">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-295">Assembly Format</span></span>|<span data-ttu-id="45410-296">説明</span><span class="sxs-lookup"><span data-stu-id="45410-296">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-297">3C`<int32>`</span><span class="sxs-lookup"><span data-stu-id="45410-297">3C `<int32>`</span></span>|<span data-ttu-id="45410-298">bge`target`</span><span class="sxs-lookup"><span data-stu-id="45410-298">bge `target`</span></span>|<span data-ttu-id="45410-299">最初の値が2番目の値以上の場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-299">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="45410-300">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-300">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-301">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-301">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-302">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-302">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-303">`value2`と`value1`はスタックからポップされます`value1` 。が`value2`以上の場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-303">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-304">命令`bge`は、が以上の `value1` 場合に、指定されたターゲット命令に制御を転送します。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-304">The `bge` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="45410-305">効果は、命令の`clt.un`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-305">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-306">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-306">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-307">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-307">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-308">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-308">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-309">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bge`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-309">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge` opcode:</span></span>  
  
-   <span data-ttu-id="45410-310">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-310">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-311">最初の値が 2 番目の値以上の場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-311">Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-312">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-312">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-313">形式</span><span class="sxs-lookup"><span data-stu-id="45410-313">Format</span></span>|<span data-ttu-id="45410-314">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-314">Assembly Format</span></span>|<span data-ttu-id="45410-315">説明</span><span class="sxs-lookup"><span data-stu-id="45410-315">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-316">.2F`<int8>`</span><span class="sxs-lookup"><span data-stu-id="45410-316">2F `<int8>`</span></span>|<span data-ttu-id="45410-317">bge`target`</span><span class="sxs-lookup"><span data-stu-id="45410-317">bge.s `target`</span></span>|<span data-ttu-id="45410-318">最初の値が2番目の値 (短い形式) 以上の場合、指定したオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-318">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="45410-319">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-319">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-320">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-320">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-321">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-321">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-322">`value2`と`value1`はスタックからポップされます`value1` 。が`value2`以上の場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-322">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-323">命令`bge.s`は、が以上の `value1` 場合に、指定されたターゲット命令に制御を転送します。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-323">The `bge.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`.</span></span> <span data-ttu-id="45410-324">効果は、命令の`clt.un`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-324">The effect is identical to performing a `clt.un` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-325">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-325">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-326">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-326">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-327">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-327">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-328">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bge.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-328">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-329">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-329">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-330">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-330">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-331">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-331">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-332">形式</span><span class="sxs-lookup"><span data-stu-id="45410-332">Format</span></span>|<span data-ttu-id="45410-333">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-333">Assembly Format</span></span>|<span data-ttu-id="45410-334">説明</span><span class="sxs-lookup"><span data-stu-id="45410-334">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-335">41 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="45410-335">41 `<int32>`</span></span>|<span data-ttu-id="45410-336">bge`target`</span><span class="sxs-lookup"><span data-stu-id="45410-336">bge.un `target`</span></span>|<span data-ttu-id="45410-337">最初の値が2番目の値 (符号なしの値) 以上の場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-337">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="45410-338">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-338">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-339">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-339">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-340">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-340">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-341">`value2`と`value1`はスタックからポップされます`value1` 。が`value2`以上の場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-341">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-342">命令`bge.un`は、符号なし整数または順序なし`value1` float 値を使用して`value2`比較した場合、が以上の場合に、指定されたターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-342">The `bge.un` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45410-343">効果は、命令の`clt`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-343">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-344">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-344">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-345">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-345">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-346">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-346">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-347">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bge.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-348">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-348">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-349">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-349">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-350">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-351">形式</span><span class="sxs-lookup"><span data-stu-id="45410-351">Format</span></span>|<span data-ttu-id="45410-352">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-352">Assembly Format</span></span>|<span data-ttu-id="45410-353">説明</span><span class="sxs-lookup"><span data-stu-id="45410-353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-354">34 <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-354">34 < `int8` ></span></span>|<span data-ttu-id="45410-355">bge`target`</span><span class="sxs-lookup"><span data-stu-id="45410-355">bge.un.s `target`</span></span>|<span data-ttu-id="45410-356">最初の値が2番目の値 (符号なしの値)、短い形式の場合、指定したオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-356">Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="45410-357">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-358">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-358">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-359">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-359">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-360">`value2`と`value1`はスタックからポップされます`value1` 。が`value2`以上の場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-360">`value2` and `value1` are popped from the stack; if `value1` is greater than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-361">命令`bge.un.s`は、符号なし整数または順序なし`value1` float 値を使用して`value2`比較した場合、が以上の場合に、指定されたターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-361">The `bge.un.s` instruction transfers control to the specified target instruction if `value1` is greater than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45410-362">効果は、命令の`clt`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-362">The effect is identical to performing a `clt` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-363">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-363">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-364">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-364">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-365">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-365">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-366">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bge.un.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-366">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bge.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-367">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-367">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-368">最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-368">Transfers control to a target instruction if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-369">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-370">形式</span><span class="sxs-lookup"><span data-stu-id="45410-370">Format</span></span>|<span data-ttu-id="45410-371">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-371">Assembly Format</span></span>|<span data-ttu-id="45410-372">説明</span><span class="sxs-lookup"><span data-stu-id="45410-372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-373">3D <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-373">3D < `int32` ></span></span>|<span data-ttu-id="45410-374">bgt`target`</span><span class="sxs-lookup"><span data-stu-id="45410-374">bgt `target`</span></span>|<span data-ttu-id="45410-375">最初の値が2番目の値よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-375">Branch to the target instruction at the specified offset if the first value is greater than the second value.</span></span>|  
  
 <span data-ttu-id="45410-376">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-376">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-377">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-377">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-378">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-378">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-379">`value2`と`value1`はスタックからポップされます`value1` 。がより`value2`大きい場合は、分岐操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-379">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-380">が`bgt` `value1`より大きい `value2` 場合、命令は、指定されたターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-380">The `bgt` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="45410-381">効果は、命令の`cgt`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-381">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-382">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-382">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-383">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-383">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-384">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-384">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-385">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bgt`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-385">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt` opcode:</span></span>  
  
-   <span data-ttu-id="45410-386">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-386">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-387">最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-387">Transfers control to a target instruction (short form) if the first value is greater than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-388">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-388">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-389">形式</span><span class="sxs-lookup"><span data-stu-id="45410-389">Format</span></span>|<span data-ttu-id="45410-390">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-390">Assembly Format</span></span>|<span data-ttu-id="45410-391">説明</span><span class="sxs-lookup"><span data-stu-id="45410-391">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-392">30 <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-392">30 < `int8` ></span></span>|<span data-ttu-id="45410-393">bgt`target`</span><span class="sxs-lookup"><span data-stu-id="45410-393">bgt.s `target`</span></span>|<span data-ttu-id="45410-394">最初の値が2番目の値 (短い形式) よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-394">Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</span></span>|  
  
 <span data-ttu-id="45410-395">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-395">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-396">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-396">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-397">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-397">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-398">`value2`と`value1`はスタックからポップされます`value1` 。がより`value2`大きい場合は、分岐操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-398">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-399">が`bgt.s` `value1`より大きい `value2` 場合、命令は、指定されたターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-399">The `bgt.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`.</span></span> <span data-ttu-id="45410-400">効果は、命令の`cgt`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-400">The effect is identical to performing a `cgt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-401">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-401">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-402">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-402">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-403">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-403">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-404">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bgt.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-404">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-405">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-405">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-406">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-406">Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-407">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-407">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-408">形式</span><span class="sxs-lookup"><span data-stu-id="45410-408">Format</span></span>|<span data-ttu-id="45410-409">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-409">Assembly Format</span></span>|<span data-ttu-id="45410-410">説明</span><span class="sxs-lookup"><span data-stu-id="45410-410">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-411">42 <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-411">42 < `int32` ></span></span>|<span data-ttu-id="45410-412">bgt`target`</span><span class="sxs-lookup"><span data-stu-id="45410-412">bgt.un `target`</span></span>|<span data-ttu-id="45410-413">最初の値が2番目の値 (符号なしの値) よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-413">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="45410-414">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-414">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-415">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-415">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-416">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-416">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-417">`value2`と`value1`はスタックからポップされます`value1` 。がより`value2`大きい場合は、分岐操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-417">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-418">命令は、符号なし整数または順序なし`value1` float 値を`value2`使用して比較した場合、がより大きい場合は、指定されたターゲット命令に制御を転送します。 `bgt.un`</span><span class="sxs-lookup"><span data-stu-id="45410-418">The `bgt.un` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45410-419">効果は、命令の`cgt.un`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-419">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-420">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-420">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-421">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-421">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-422">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-422">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-423">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bgt.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-423">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-424">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-424">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-425">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-425">Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-426">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-426">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-427">形式</span><span class="sxs-lookup"><span data-stu-id="45410-427">Format</span></span>|<span data-ttu-id="45410-428">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-428">Assembly Format</span></span>|<span data-ttu-id="45410-429">説明</span><span class="sxs-lookup"><span data-stu-id="45410-429">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-430">35 <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-430">35 < `int8` ></span></span>|<span data-ttu-id="45410-431">bgt`target`</span><span class="sxs-lookup"><span data-stu-id="45410-431">bgt.un.s `target`</span></span>|<span data-ttu-id="45410-432">最初の値が2番目の値 (符号なしの値) (短い形式) よりも大きい場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-432">Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="45410-433">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-433">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-434">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-434">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-435">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-435">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-436">`value2`と`value1`はスタックからポップされます`value1` 。がより`value2`大きい場合は、分岐操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-436">`value2` and `value1` are popped from the stack; if `value1` is greater than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-437">命令は、符号なし整数または順序なし`value1` float 値を`value2`使用して比較した場合、がより大きい場合は、指定されたターゲット命令に制御を転送します。 `bgt.un.s`</span><span class="sxs-lookup"><span data-stu-id="45410-437">The `bgt.un.s` instruction transfers control to the specified target instruction if `value1` is greater than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45410-438">効果は、命令の`cgt.un`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-438">The effect is identical to performing a `cgt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-439">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-439">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-440">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-440">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-441">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-441">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-442">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bgt.un.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-442">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bgt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-443">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-443">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-444">最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-444">Transfers control to a target instruction if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-445">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-445">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-446">形式</span><span class="sxs-lookup"><span data-stu-id="45410-446">Format</span></span>|<span data-ttu-id="45410-447">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-447">Assembly Format</span></span>|<span data-ttu-id="45410-448">説明</span><span class="sxs-lookup"><span data-stu-id="45410-448">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-449">3E`<int32>`</span><span class="sxs-lookup"><span data-stu-id="45410-449">3E `<int32>`</span></span>|<span data-ttu-id="45410-450">ble`target`</span><span class="sxs-lookup"><span data-stu-id="45410-450">ble `target`</span></span>|<span data-ttu-id="45410-451">最初の値が2番目の値以下の場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-451">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</span></span>|  
  
 <span data-ttu-id="45410-452">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-452">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-453">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-453">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-454">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-454">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-455">`value2`と`value1`はスタックからポップされます`value1` 。が`value2`以下の場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-455">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-456">が`ble` 以下の `value1` 場合、命令は、指定されたターゲット命令に制御を転送します。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-456">The `ble` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="45410-457">効果は、 `cgt`命令 (`cgt.un` `brfalse` float) を実行した後、特定のターゲット命令への分岐を実行した場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-457">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-458">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-458">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-459">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-459">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-460">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-460">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-461">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ble`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-461">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble` opcode:</span></span>  
  
-   <span data-ttu-id="45410-462">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-462">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-463">最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-463">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-464">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-464">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-465">形式</span><span class="sxs-lookup"><span data-stu-id="45410-465">Format</span></span>|<span data-ttu-id="45410-466">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-466">Assembly Format</span></span>|<span data-ttu-id="45410-467">説明</span><span class="sxs-lookup"><span data-stu-id="45410-467">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-468">31 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="45410-468">31 `<int8>`</span></span>|<span data-ttu-id="45410-469">. s`target`</span><span class="sxs-lookup"><span data-stu-id="45410-469">ble.s `target`</span></span>|<span data-ttu-id="45410-470">最初の値が2番目の値 (短い形式) 以下の場合は、指定したオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-470">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</span></span>|  
  
 <span data-ttu-id="45410-471">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-471">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-472">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-472">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-473">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-473">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-474">`value2`と`value1`はスタックからポップされます`value1` 。が`value2`以下の場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-474">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-475">が`ble.s` 以下の `value1` 場合、命令は、指定されたターゲット命令に制御を転送します。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-475">The `ble.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="45410-476">効果は、 `cgt`命令 (`cgt.un` float`brfalse` ) 命令を実行した後、特定のターゲット命令への分岐を実行した場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-476">The effect is identical to performing a `cgt` instruction (`cgt.un` for floats) instruction followed by a`brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-477">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-477">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-478">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-478">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-479">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-479">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-480">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ble.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-481">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-481">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-482">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-482">Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-483">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-484">形式</span><span class="sxs-lookup"><span data-stu-id="45410-484">Format</span></span>|<span data-ttu-id="45410-485">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-485">Assembly Format</span></span>|<span data-ttu-id="45410-486">説明</span><span class="sxs-lookup"><span data-stu-id="45410-486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-487">43 `<int32>`</span><span class="sxs-lookup"><span data-stu-id="45410-487">43 `<int32>`</span></span>|<span data-ttu-id="45410-488">un`target`</span><span class="sxs-lookup"><span data-stu-id="45410-488">ble.un `target`</span></span>|<span data-ttu-id="45410-489">最初の値が2番目の値 (符号なしの値) 以下の場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-489">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="45410-490">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-491">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-491">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-492">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-492">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-493">`value2`と`value1`はスタックからポップされます`value1` 。が`value2`以下の場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-493">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-494">命令は、 `value1`が符号なし整数または順序なし float 値を使用し`value2`て比較した場合に、指定されたターゲット命令に制御を転送します。 `ble.un`</span><span class="sxs-lookup"><span data-stu-id="45410-494">The `ble.un` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45410-495">効果は、 `cgt.un`命令 (`cgt` `brfalse` float) を実行した後、特定のターゲット命令への分岐を実行した場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-495">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-496">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-496">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-497">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-497">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-498">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-498">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-499">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ble.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-499">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-500">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-500">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-501">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-501">Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-502">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-502">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-503">形式</span><span class="sxs-lookup"><span data-stu-id="45410-503">Format</span></span>|<span data-ttu-id="45410-504">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-504">Assembly Format</span></span>|<span data-ttu-id="45410-505">説明</span><span class="sxs-lookup"><span data-stu-id="45410-505">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-506">36 `<int8>`</span><span class="sxs-lookup"><span data-stu-id="45410-506">36 `<int8>`</span></span>|<span data-ttu-id="45410-507">un. s`target`</span><span class="sxs-lookup"><span data-stu-id="45410-507">ble.un.s `target`</span></span>|<span data-ttu-id="45410-508">最初の値が2番目の値 (符号なしの値)、短い形式の場合、指定したオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-508">Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="45410-509">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-509">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-510">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-510">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-511">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-511">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-512">`value2`と`value1`はスタックからポップされます`value1` 。が`value2`以下の場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-512">`value2` and `value1` are popped from the stack; if `value1` is less than or equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-513">命令は、 `value1`が符号なし整数または順序なし float 値を使用し`value2`て比較した場合に、指定されたターゲット命令に制御を転送します。 `ble.un.s`</span><span class="sxs-lookup"><span data-stu-id="45410-513">The `ble.un.s` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45410-514">効果は、 `cgt.un`命令 (`cgt` `brfalse` float) を実行した後、特定のターゲット命令への分岐を実行した場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-514">The effect is identical to performing a `cgt.un` instruction (`cgt` for floats) followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-515">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-515">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-516">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-516">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-517">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-517">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-518">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ble.un.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-518">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ble.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-519">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-519">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-520">最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-520">Transfers control to a target instruction if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-521">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-521">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-522">形式</span><span class="sxs-lookup"><span data-stu-id="45410-522">Format</span></span>|<span data-ttu-id="45410-523">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-523">Assembly Format</span></span>|<span data-ttu-id="45410-524">説明</span><span class="sxs-lookup"><span data-stu-id="45410-524">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-525">3F <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-525">3F < `int32` ></span></span>|<span data-ttu-id="45410-526">blt`target`</span><span class="sxs-lookup"><span data-stu-id="45410-526">blt `target`</span></span>|<span data-ttu-id="45410-527">最初の値が2番目の値より小さい場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-527">Branch to the target instruction at the specified offset if the first value is less than the second value.</span></span>|  
  
 <span data-ttu-id="45410-528">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-528">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-529">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-529">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-530">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-530">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-531">`value2`と`value1`はスタックからポップされます`value1` 。がより`value2`小さい場合は、分岐操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-531">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-532">が`blt` 以下の `value1` 場合、命令は、指定されたターゲット命令に制御を転送します。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-532">The `blt` instruction transfers control to the specified target instruction if `value1` is less than or equal to `value2`.</span></span> <span data-ttu-id="45410-533">効果は、命令の`clt`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-533">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-534">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-534">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-535">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-535">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-536">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-536">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-537">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `blt`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-537">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt` opcode:</span></span>  
  
-   <span data-ttu-id="45410-538">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-538">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-539">最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-539">Transfers control to a target instruction (short form) if the first value is less than the second value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-540">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-540">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-541">形式</span><span class="sxs-lookup"><span data-stu-id="45410-541">Format</span></span>|<span data-ttu-id="45410-542">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-542">Assembly Format</span></span>|<span data-ttu-id="45410-543">説明</span><span class="sxs-lookup"><span data-stu-id="45410-543">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-544">32 <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-544">32 < `int8` ></span></span>|<span data-ttu-id="45410-545">blt`target`</span><span class="sxs-lookup"><span data-stu-id="45410-545">blt.s `target`</span></span>|<span data-ttu-id="45410-546">最初の値が2番目の値 (短い形式) より小さい場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-546">Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</span></span>|  
  
 <span data-ttu-id="45410-547">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-547">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-548">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-548">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-549">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-549">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-550">`value2`と`value1`はスタックからポップされます`value1` 。がより`value2`小さい場合は、分岐操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-550">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-551">が`blt.s` `value1`より小さい `value2` 場合、命令は、指定されたターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-551">The `blt.s` instruction transfers control to the specified target instruction if `value1` is less than `value2`.</span></span> <span data-ttu-id="45410-552">効果は、命令の`clt`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-552">The effect is identical to performing a `clt` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-553">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-553">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-554">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-554">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-555">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-555">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-556">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `blt.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-556">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-557">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-557">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-558">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-558">Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-559">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-559">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-560">形式</span><span class="sxs-lookup"><span data-stu-id="45410-560">Format</span></span>|<span data-ttu-id="45410-561">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-561">Assembly Format</span></span>|<span data-ttu-id="45410-562">説明</span><span class="sxs-lookup"><span data-stu-id="45410-562">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-563">44 <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-563">44 < `int32` ></span></span>|<span data-ttu-id="45410-564">blt`target`</span><span class="sxs-lookup"><span data-stu-id="45410-564">blt.un `target`</span></span>|<span data-ttu-id="45410-565">最初の値が2番目の値 (符号なしの値) より小さい場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-565">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</span></span>|  
  
 <span data-ttu-id="45410-566">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-566">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-567">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-567">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-568">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-568">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-569">`value2`と`value1`はスタックからポップされます`value1` 。がより`value2`小さい場合は、分岐操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-569">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-570">命令`blt.un`は、符号なし整数または順序なし float 値を`value2`使用して比較した場合、がより小さい場合`value1`は、指定されたターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-570">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45410-571">効果は、命令の`clt.un`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-571">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-572">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-572">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-573">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-573">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-574">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-574">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-575">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `blt.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-575">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-576">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-576">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-577">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-577">Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-578">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-578">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-579">形式</span><span class="sxs-lookup"><span data-stu-id="45410-579">Format</span></span>|<span data-ttu-id="45410-580">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-580">Assembly Format</span></span>|<span data-ttu-id="45410-581">説明</span><span class="sxs-lookup"><span data-stu-id="45410-581">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-582">37 <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-582">37 < `int8` ></span></span>|<span data-ttu-id="45410-583">blt. s`target`</span><span class="sxs-lookup"><span data-stu-id="45410-583">blt.un.s `target`</span></span>|<span data-ttu-id="45410-584">最初の値が2番目の値 (符号なしの値) (短い形式) よりも小さい場合は、指定したオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-584">Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="45410-585">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-585">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-586">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-586">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-587">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-587">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-588">`value2`と`value1`はスタックからポップされます`value1` 。がより`value2`小さい場合は、分岐操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-588">`value2` and `value1` are popped from the stack; if `value1` is less than `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-589">命令`blt.un`は、符号なし整数または順序なし float 値を`value2`使用して比較した場合、がより小さい場合`value1`は、指定されたターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-589">The `blt.un` instruction transfers control to the specified target instruction if `value1` is less than `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45410-590">効果は、命令の`clt.un`後に特定のターゲット命令への`brtrue`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-590">The effect is identical to performing a `clt.un` instruction followed by a `brtrue` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-591">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-591">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-592">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-592">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-593">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-593">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-594">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `blt.un.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-594">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `blt.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-595">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-595">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-596">2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-596">Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-597">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-597">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-598">形式</span><span class="sxs-lookup"><span data-stu-id="45410-598">Format</span></span>|<span data-ttu-id="45410-599">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-599">Assembly Format</span></span>|<span data-ttu-id="45410-600">説明</span><span class="sxs-lookup"><span data-stu-id="45410-600">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-601">40 <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-601">40 < `int32` ></span></span>|<span data-ttu-id="45410-602">bne`target`</span><span class="sxs-lookup"><span data-stu-id="45410-602">bne.un `target`</span></span>|<span data-ttu-id="45410-603">2つの符号なし整数値が等しくない場合 (符号なしの値)、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-603">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</span></span>|  
  
 <span data-ttu-id="45410-604">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-604">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-605">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-605">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-606">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-606">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-607">`value2`と`value1`はスタックからポップされます`value1` 。がと等しく`value2`ない場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-607">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-608">命令は、符号なし整数または順序なし`value1` float 値を使用`value2`して比較した場合、がと等しくない場合は、指定されたターゲット命令に制御を転送します。 `bne.un`</span><span class="sxs-lookup"><span data-stu-id="45410-608">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45410-609">効果は、命令の`ceq`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-609">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-610">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-610">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-611">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-611">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-612">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-612">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-613">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bne.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-613">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-614">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-614">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-615">2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-615">Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-616">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-616">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-617">形式</span><span class="sxs-lookup"><span data-stu-id="45410-617">Format</span></span>|<span data-ttu-id="45410-618">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-618">Assembly Format</span></span>|<span data-ttu-id="45410-619">説明</span><span class="sxs-lookup"><span data-stu-id="45410-619">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-620">33 <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-620">33 < `int8` ></span></span>|<span data-ttu-id="45410-621">bne`target`</span><span class="sxs-lookup"><span data-stu-id="45410-621">bne.un.s `target`</span></span>|<span data-ttu-id="45410-622">2つの符号なし整数値が等しくない場合 (符号なしの値)、短い形式の場合、指定したオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-622">Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</span></span>|  
  
 <span data-ttu-id="45410-623">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-623">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-624">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-624">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-625">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-625">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-626">`value2`と`value1`はスタックからポップされます`value1` 。がと等しく`value2`ない場合は、分岐演算が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-626">`value2` and `value1` are popped from the stack; if `value1` is not equal to `value2`, the branch operation is performed.</span></span>  
  
 <span data-ttu-id="45410-627">命令は、符号なし整数または順序なし`value1` float 値を使用`value2`して比較した場合、がと等しくない場合は、指定されたターゲット命令に制御を転送します。 `bne.un`</span><span class="sxs-lookup"><span data-stu-id="45410-627">The `bne.un` instruction transfers control to the specified target instruction if `value1` is not equal to `value2`, when compared using unsigned integer or unordered float values.</span></span> <span data-ttu-id="45410-628">効果は、命令の`ceq`後に特定のターゲット命令への`brfalse`分岐を実行することと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-628">The effect is identical to performing a `ceq` instruction followed by a `brfalse` branch to the specific target instruction.</span></span> <span data-ttu-id="45410-629">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-629">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-630">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-630">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-631">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-631">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-632">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `bne.un.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-632">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `bne.un.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-633">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-633">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-634">値型をオブジェクト参照 (<see langword="O" /> 型) に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-634">Converts a value type to an object reference (type <see langword="O" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-635">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-635">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-636">形式</span><span class="sxs-lookup"><span data-stu-id="45410-636">Format</span></span>|<span data-ttu-id="45410-637">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-637">Assembly Format</span></span>|<span data-ttu-id="45410-638">説明</span><span class="sxs-lookup"><span data-stu-id="45410-638">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-639">8C <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-639">8C < `T` ></span></span>|<span data-ttu-id="45410-640">箱`valTypeToken`</span><span class="sxs-lookup"><span data-stu-id="45410-640">box `valTypeToken`</span></span>|<span data-ttu-id="45410-641">(で`valTypeToken`指定された型の) 値型を true オブジェクト参照に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-641">Convert a value type (of the type specified in `valTypeToken`) to a true object reference.</span></span>|  
  
 <span data-ttu-id="45410-642">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-642">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-643">値型がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-643">A value type is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-644">値の型がスタックからポップされます。`box`操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-644">The value type is popped from the stack; the `box` operation is performed.</span></span>  
  
3.  <span data-ttu-id="45410-645">結果の "ボックス化された" 値型へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-645">An object reference to the resulting "boxed" value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-646">値型には、共通言語基盤 (CLI) 内の2つの異なる表現があります。</span><span class="sxs-lookup"><span data-stu-id="45410-646">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="45410-647">値型が別のオブジェクトまたはスタックに埋め込まれている場合に使用される ' 未加工 ' フォーム。</span><span class="sxs-lookup"><span data-stu-id="45410-647">A 'raw' form used when a value type is embedded within another object or on the stack.</span></span>  
  
-   <span data-ttu-id="45410-648">' ボックス化された ' フォーム。値型のデータは、独立したエンティティとして存在できるように、オブジェクトにラップ (ボックス化) されます。</span><span class="sxs-lookup"><span data-stu-id="45410-648">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="45410-649">命令`box`は、' raw ' (ボックス化が解除された) 値型を`O`オブジェクト参照 (型) に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-649">The `box` instruction converts the 'raw' (unboxed) value type into an object reference (type `O`).</span></span> <span data-ttu-id="45410-650">これは、新しいオブジェクトを作成し、値型から新しく割り当てられたオブジェクトにデータをコピーすることで実現されます。</span><span class="sxs-lookup"><span data-stu-id="45410-650">This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</span></span> <span data-ttu-id="45410-651">`valTypeToken`スタック上の値型の型を示すメタデータトークンです。</span><span class="sxs-lookup"><span data-stu-id="45410-651">`valTypeToken` is a metadata token indicating the type of the value type on the stack.</span></span>  
  
 <span data-ttu-id="45410-652"><xref:System.OutOfMemoryException>要求を満たすのに十分なメモリがない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-652"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="45410-653"><xref:System.TypeLoadException>クラスが見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-653"><xref:System.TypeLoadException> is thrown if the class cannot be found.</span></span> <span data-ttu-id="45410-654">これは通常、Microsoft 中間言語 (MSIL) が実行時ではなくネイティブコードに変換された場合に検出されます。</span><span class="sxs-lookup"><span data-stu-id="45410-654">This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="45410-655">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `box`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-655">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `box` opcode:</span></span>  
  
-   <span data-ttu-id="45410-656">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-656">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-657">無条件でターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-657">Unconditionally transfers control to a target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-658">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-658">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-659">形式</span><span class="sxs-lookup"><span data-stu-id="45410-659">Format</span></span>|<span data-ttu-id="45410-660">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-660">Assembly Format</span></span>|<span data-ttu-id="45410-661">説明</span><span class="sxs-lookup"><span data-stu-id="45410-661">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-662">38 <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-662">38 < `int32` ></span></span>|<span data-ttu-id="45410-663">br`target`</span><span class="sxs-lookup"><span data-stu-id="45410-663">br `target`</span></span>|<span data-ttu-id="45410-664">指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-664">Branches to a target instruction at the specified offset.</span></span>|  
  
 <span data-ttu-id="45410-665">この操作では、評価スタックの動作は実行されません。</span><span class="sxs-lookup"><span data-stu-id="45410-665">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="45410-666">命令`br`は無条件でターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-666">The `br` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="45410-667">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-667">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-668">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-668">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-669">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-669">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-670">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `br`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-670">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br` opcode:</span></span>  
  
-   <span data-ttu-id="45410-671">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-671">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-672">無条件でターゲット命令に制御を転送します (短い形式)。</span><span class="sxs-lookup"><span data-stu-id="45410-672">Unconditionally transfers control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-673">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-673">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-674">形式</span><span class="sxs-lookup"><span data-stu-id="45410-674">Format</span></span>|<span data-ttu-id="45410-675">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-675">Assembly Format</span></span>|<span data-ttu-id="45410-676">説明</span><span class="sxs-lookup"><span data-stu-id="45410-676">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-677">2B <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-677">2B < `int8` ></span></span>|<span data-ttu-id="45410-678">br. s`target`</span><span class="sxs-lookup"><span data-stu-id="45410-678">br.s `target`</span></span>|<span data-ttu-id="45410-679">指定されたオフセット (短い形式) でターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-679">Branches to a target instruction at the specified offset, short form.</span></span>|  
  
 <span data-ttu-id="45410-680">この操作では、評価スタックの動作は実行されません。</span><span class="sxs-lookup"><span data-stu-id="45410-680">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="45410-681">命令`br.s`は無条件でターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-681">The `br.s` instruction unconditionally transfers control to a target instruction.</span></span> <span data-ttu-id="45410-682">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-682">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-683">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-683">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-684">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-684">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-685">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `br.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-685">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `br.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-686">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-686">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-687">ブレークポイントがトリップしたことをデバッガーに通知するように、共通言語基盤 (CLI) に通知します。</span><span class="sxs-lookup"><span data-stu-id="45410-687">Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-688">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-688">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-689">形式</span><span class="sxs-lookup"><span data-stu-id="45410-689">Format</span></span>|<span data-ttu-id="45410-690">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-690">Assembly Format</span></span>|<span data-ttu-id="45410-691">説明</span><span class="sxs-lookup"><span data-stu-id="45410-691">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-692">01</span><span class="sxs-lookup"><span data-stu-id="45410-692">01</span></span>|<span data-ttu-id="45410-693">break</span><span class="sxs-lookup"><span data-stu-id="45410-693">break</span></span>|<span data-ttu-id="45410-694">ブレークポイントに達したことをデバッガーに通知します。</span><span class="sxs-lookup"><span data-stu-id="45410-694">inform a debugger that a breakpoint has been reached.</span></span>|  
  
 <span data-ttu-id="45410-695">この操作では、評価スタックの動作は実行されません。</span><span class="sxs-lookup"><span data-stu-id="45410-695">No evaluation stack behaviors are performed by this operation.</span></span>  
  
 <span data-ttu-id="45410-696">この`break`命令は、デバッグをサポートするためのものです。</span><span class="sxs-lookup"><span data-stu-id="45410-696">The `break` instruction is for debugging support.</span></span> <span data-ttu-id="45410-697">これは、ブレークポイントがトリップしたことをデバッガーに通知するよう CLI に通知します。</span><span class="sxs-lookup"><span data-stu-id="45410-697">It signals the CLI to inform the debugger that a break point has been tripped.</span></span> <span data-ttu-id="45410-698">インタープリターの状態に他の影響はありません。</span><span class="sxs-lookup"><span data-stu-id="45410-698">It has no other effect on the interpreter state.</span></span>  
  
 <span data-ttu-id="45410-699">`break`命令には、ブレークポイントを使用してコードを修正し、周囲のコードへの影響を最小限に抑えることができる、最小限の命令サイズがあります。</span><span class="sxs-lookup"><span data-stu-id="45410-699">The `break` instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</span></span>  
  
 <span data-ttu-id="45410-700">命令`break`は、デバッガーへのトラップ、何も行わない、またはセキュリティ例外の発生を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-700">The `break` instruction can trap to a debugger, do nothing, or raise a security exception.</span></span> <span data-ttu-id="45410-701">実際の動作は実装定義です。</span><span class="sxs-lookup"><span data-stu-id="45410-701">The exact behavior is implementation-defined.</span></span>  
  
 <span data-ttu-id="45410-702">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `break`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-702">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `break` opcode:</span></span>  
  
-   <span data-ttu-id="45410-703">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-703">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-704"><paramref name="value" /> が <see langword="false" />、null 参照 (Visual Basic の場合は <see langword="Nothing" />)、または 0 の場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-704">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference (<see langword="Nothing" /> in Visual Basic), or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-705">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-705">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-706">形式</span><span class="sxs-lookup"><span data-stu-id="45410-706">Format</span></span>|<span data-ttu-id="45410-707">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-707">Assembly Format</span></span>|<span data-ttu-id="45410-708">説明</span><span class="sxs-lookup"><span data-stu-id="45410-708">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-709">39 <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-709">39 < `int32` ></span></span>|<span data-ttu-id="45410-710">brfalse`target`</span><span class="sxs-lookup"><span data-stu-id="45410-710">brfalse `target`</span></span><br /><br /> <span data-ttu-id="45410-711">brnull`target`</span><span class="sxs-lookup"><span data-stu-id="45410-711">brnull `target`</span></span><br /><br /> <span data-ttu-id="45410-712">brzero`target`</span><span class="sxs-lookup"><span data-stu-id="45410-712">brzero `target`</span></span>|<span data-ttu-id="45410-713">の場合`false`、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-713">Branches to a target instruction at the specified offset if `false`.</span></span>|  
  
 <span data-ttu-id="45410-714">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-714">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-715">`value`は、前の操作によってスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-715">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="45410-716">`value`スタックからポップされます。`target`が`value` の場合 `false` は、をに分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-716">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="45410-717">命令`brfalse` (およびそのエイリアス`brnull`および`brzero`) は、(型`int32`、 `int64`、オブジェクト参照`O`、 `value`マネージポインター) の場合、指定されたターゲット命令に制御を転送します。、transient `*`ポインター) が 0 (`false`) です。 `native int` `&`</span><span class="sxs-lookup"><span data-stu-id="45410-717">The `brfalse` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="45410-718">が`value` 0 以外の場合 (`true`)、次の命令で実行が続行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-718">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="45410-719">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-719">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-720">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-720">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-721">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-721">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-722">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `brfalse`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse` opcode:</span></span>  
  
-   <span data-ttu-id="45410-723">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-723">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-724"><paramref name="value" /> が <see langword="false" />、null 参照または 0 の場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-724">Transfers control to a target instruction if <paramref name="value" /> is <see langword="false" />, a null reference, or zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-725">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-726">形式</span><span class="sxs-lookup"><span data-stu-id="45410-726">Format</span></span>|<span data-ttu-id="45410-727">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-727">Assembly Format</span></span>|<span data-ttu-id="45410-728">説明</span><span class="sxs-lookup"><span data-stu-id="45410-728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-729">2C <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-729">2C <`int8` ></span></span>|<span data-ttu-id="45410-730">brfalse`target`</span><span class="sxs-lookup"><span data-stu-id="45410-730">brfalse.s `target`</span></span><br /><br /> <span data-ttu-id="45410-731">brnull. s`target`</span><span class="sxs-lookup"><span data-stu-id="45410-731">brnull.s `target`</span></span><br /><br /> <span data-ttu-id="45410-732">brzero s`target`</span><span class="sxs-lookup"><span data-stu-id="45410-732">brzero.s `target`</span></span>|<span data-ttu-id="45410-733">、短い形式の場合は`false`、指定したオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-733">Branches to a target instruction at the specified offset if `false`, short form.</span></span>|  
  
 <span data-ttu-id="45410-734">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-734">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-735">`value`は、前の操作によってスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-735">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="45410-736">`value`スタックからポップされます。`target`が`value` の場合 `false` は、をに分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-736">`value` is popped from the stack; if `value` is `false`, branch to `target`.</span></span>  
  
 <span data-ttu-id="45410-737">命令`brfalse.s` (およびそのエイリアス`brnull`および`brzero`) は、(型`int32`、 `int64`、オブジェクト参照`O`、 `value`マネージポインター) の場合、指定されたターゲット命令に制御を転送します。、transient `*`ポインター) が 0 (`false`) です。 `native int` `&`</span><span class="sxs-lookup"><span data-stu-id="45410-737">The `brfalse.s` instruction (and its aliases `brnull` and `brzero`) transfers control to the specified target instruction if `value` (of type `int32`, `int64`, object reference `O`, managed pointer `&`, transient pointer `*`, `native int`) is zero (`false`).</span></span> <span data-ttu-id="45410-738">が`value` 0 以外の場合 (`true`)、次の命令で実行が続行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-738">If `value` is non-zero (`true`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="45410-739">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-739">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-740">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-740">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-741">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-741">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-742">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `brfalse.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-742">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brfalse.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-743">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-743">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-744"><paramref name="value" /> が <see langword="true" />、null 以外、または 0 以外の場合は、ターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-744">Transfers control to a target instruction if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-745">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-745">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-746">形式</span><span class="sxs-lookup"><span data-stu-id="45410-746">Format</span></span>|<span data-ttu-id="45410-747">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-747">Assembly Format</span></span>|<span data-ttu-id="45410-748">説明</span><span class="sxs-lookup"><span data-stu-id="45410-748">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-749">3A <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-749">3A < `int32` ></span></span>|<span data-ttu-id="45410-750">brtrue`target`</span><span class="sxs-lookup"><span data-stu-id="45410-750">brtrue `target`</span></span><br /><br /> <span data-ttu-id="45410-751">brinst`target`</span><span class="sxs-lookup"><span data-stu-id="45410-751">brinst `target`</span></span>|<span data-ttu-id="45410-752">0`true`以外の場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-752">Branch to a target instruction at the specified offset if non-zero (`true`).</span></span>|  
  
 <span data-ttu-id="45410-753">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-753">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-754">`value`は、前の操作によってスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-754">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="45410-755">`value`スタックからポップされます。`target`が`value` の場合 `true` は、をに分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-755">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="45410-756">命令`brtrue`は、(type `native int`) が0以外 ( `value` `true`) の場合に、指定されたターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-756">The `brtrue` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="45410-757">が`value` 0 (`false`) の場合、次の命令で実行が続行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-757">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="45410-758">が`value`オブジェクト参照 (型`O`) `brinst`である場合、(の`brtrue`別名) は、オブジェクトのインスタンスを表す場合に制御を転送します (たとえば、null オブジェクト参照でない場合は<xref:System.Reflection.Emit.OpCodes.Ldnull>、「」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="45410-758">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="45410-759">ターゲット命令は、現在の命令に続く命令の先頭からの4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-759">The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-760">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-760">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-761">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-761">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-762">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `brtrue`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-762">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue` opcode:</span></span>  
  
-   <span data-ttu-id="45410-763">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-763">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-764"><paramref name="value" /> が <see langword="true" />、null 以外、または 0 以外の場合は、ターゲット命令 (短い形式) に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-764">Transfers control to a target instruction (short form) if <paramref name="value" /> is <see langword="true" />, not null, or non-zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-765">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-765">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-766">形式</span><span class="sxs-lookup"><span data-stu-id="45410-766">Format</span></span>|<span data-ttu-id="45410-767">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-767">Assembly Format</span></span>|<span data-ttu-id="45410-768">説明</span><span class="sxs-lookup"><span data-stu-id="45410-768">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-769">2D <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-769">2D < `int8` ></span></span>|<span data-ttu-id="45410-770">brtrue`target`</span><span class="sxs-lookup"><span data-stu-id="45410-770">brtrue.s `target`</span></span><br /><br /> <span data-ttu-id="45410-771">brinst. s`target`</span><span class="sxs-lookup"><span data-stu-id="45410-771">brinst.s `target`</span></span>|<span data-ttu-id="45410-772">0以外 (`true`)、短い形式の場合は、指定されたオフセットでターゲット命令に分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-772">Branch to a target instruction at the specified offset if non-zero (`true`), short form.</span></span>|  
  
 <span data-ttu-id="45410-773">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-773">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-774">`value`は、前の操作によってスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-774">`value` is pushed onto the stack by a previous operation.</span></span>  
  
2.  <span data-ttu-id="45410-775">`value`スタックからポップされます。`target`が`value` の場合 `true` は、をに分岐します。</span><span class="sxs-lookup"><span data-stu-id="45410-775">`value` is popped from the stack; if `value` is `true`, branch to `target`.</span></span>  
  
 <span data-ttu-id="45410-776">命令`brtrue.s`は、(type `native int`) が0以外 ( `value` `true`) の場合に、指定されたターゲット命令に制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-776">The `brtrue.s` instruction transfers control to the specified target instruction if `value` (type `native int`) is nonzero (`true`).</span></span> <span data-ttu-id="45410-777">が`value` 0 (`false`) の場合、次の命令で実行が続行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-777">If `value` is zero (`false`) execution continues at the next instruction.</span></span>  
  
 <span data-ttu-id="45410-778">が`value`オブジェクト参照 (型`O`) `brinst`である場合、(の`brtrue`別名) は、オブジェクトのインスタンスを表す場合に制御を転送します (たとえば、null オブジェクト参照でない場合は<xref:System.Reflection.Emit.OpCodes.Ldnull>、「」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="45410-778">If `value` is an object reference (type `O`) then `brinst` (an alias for `brtrue`) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref:System.Reflection.Emit.OpCodes.Ldnull>).</span></span>  
  
 <span data-ttu-id="45410-779">ターゲット命令は、現在の命令に続く命令の先頭からの1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-779">The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-780">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-780">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span> <span data-ttu-id="45410-781">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-781">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span>  
  
 <span data-ttu-id="45410-782">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `brtrue.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-782">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `brtrue.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-783">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-783">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-784">渡されたメソッド記述子によって示されているメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-784">Calls the method indicated by the passed method descriptor.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-785">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-785">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-786">形式</span><span class="sxs-lookup"><span data-stu-id="45410-786">Format</span></span>|<span data-ttu-id="45410-787">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-787">Assembly Format</span></span>|<span data-ttu-id="45410-788">説明</span><span class="sxs-lookup"><span data-stu-id="45410-788">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-789">28 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-789">28 < `T` ></span></span>|<span data-ttu-id="45410-790">発信`methodDesc`</span><span class="sxs-lookup"><span data-stu-id="45410-790">call `methodDesc`</span></span>|<span data-ttu-id="45410-791">「」で説明さ`methodDesc`れているメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-791">Call the method described by `methodDesc`.</span></span>|  
  
 <span data-ttu-id="45410-792">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-792">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-793">`arg1` から `argN` のメソッド引数はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-793">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-794">を介し`arg1` `argN`たメソッド引数はスタックからポップされます。メソッドの呼び出しはこれらの引数を使用して実行され、制御はメソッド記述子によって参照されるメソッドに転送されます。</span><span class="sxs-lookup"><span data-stu-id="45410-794">Method arguments `arg1` through `argN` are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</span></span> <span data-ttu-id="45410-795">完了すると、呼び出し先メソッドによって戻り値が生成され、呼び出し元に送信されます。</span><span class="sxs-lookup"><span data-stu-id="45410-795">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
3.  <span data-ttu-id="45410-796">戻り値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-796">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-797">命令`call`は、命令で渡されたメソッド記述子によって示されるメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-797">The `call` instruction calls the method indicated by the method descriptor passed with the instruction.</span></span> <span data-ttu-id="45410-798">メソッド記述子は、呼び出すメソッドと、そのメソッドに渡されるスタックに配置された引数の数、型、および順序、および使用される呼び出し規約を示すメタデータトークンであり、</span><span class="sxs-lookup"><span data-stu-id="45410-798">The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</span></span> <span data-ttu-id="45410-799">命令`call`の前には、 `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) プレフィックス命令を指定して、現在のメソッドの状態を解放してから制御を転送するように指定できます。</span><span class="sxs-lookup"><span data-stu-id="45410-799">The `call` instruction can be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix instruction to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="45410-800">呼び出しが、元のメソッドよりも高い信頼のメソッドに制御を転送する場合、スタックフレームは解放されません。</span><span class="sxs-lookup"><span data-stu-id="45410-800">If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</span></span> <span data-ttu-id="45410-801">代わりに、が`tail`指定されていないかのように実行が自動的に続行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-801">Instead, the execution continues silently as if the `tail` had not been supplied.</span></span> <span data-ttu-id="45410-802">メタデータトークンは、呼び出しが静的メソッド、インスタンスメソッド、仮想メソッド、またはグローバル関数のいずれであるかを判断するために十分な情報を保持します。</span><span class="sxs-lookup"><span data-stu-id="45410-802">The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</span></span> <span data-ttu-id="45410-803">これらのすべてのケースでは、宛先アドレスはメソッド記述子から完全に決定されます<xref:System.Reflection.Emit.OpCodes.Callvirt> (これは仮想メソッドを呼び出すための命令と比較します。宛先アドレスもインスタンスのランタイム型に依存します。参照がの前<xref:System.Reflection.Emit.OpCodes.Callvirt>にプッシュされました。</span><span class="sxs-lookup"><span data-stu-id="45410-803">In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref:System.Reflection.Emit.OpCodes.Callvirt>).</span></span>  
  
 <span data-ttu-id="45410-804">引数は、左から右の順序でスタックに配置されます。</span><span class="sxs-lookup"><span data-stu-id="45410-804">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="45410-805">つまり、最初の引数が計算され、スタックに配置されます。次に、2番目の引数が、必要なすべての引数がスタックの一番上になるまで、3番目の引数が降順になります。</span><span class="sxs-lookup"><span data-stu-id="45410-805">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="45410-806">次の3つの重要な特殊なケースがあります。</span><span class="sxs-lookup"><span data-stu-id="45410-806">There are three important special cases:</span></span>  
  
 1. <span data-ttu-id="45410-807">インスタンス (または仮想) メソッドの呼び出しでは、ユーザーに表示される引数の前に、そのインスタンス参照をプッシュする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-807">Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</span></span> <span data-ttu-id="45410-808">インスタンス参照を null 参照にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-808">The instance reference must not be a null reference.</span></span> <span data-ttu-id="45410-809">メタデータに格納されているシグネチャには、 `this`ポインターのパラメーターリストにエントリが含まれていません。代わりに、ビットを使用して、メソッドが`this`ポインターを渡す必要があるかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="45410-809">The signature carried in the metadata does not contain an entry in the parameter list for the `this` pointer; instead, it uses a bit to indicate whether the method requires passing the `this` pointer.</span></span>  
  
 2. <span data-ttu-id="45410-810">`call` ( `callvirt` ではなく) を使用して仮想メソッドを呼び出すことができます。これは、メソッドが、呼び出されるオブジェクトから動的に指定されるのではなく、メソッドによって指定されたクラスを使用して解決されることを示します。</span><span class="sxs-lookup"><span data-stu-id="45410-810">It is valid to call a virtual method using `call` (rather than `callvirt`); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</span></span>  
  
 3. <span data-ttu-id="45410-811">デリゲートの`Invoke`メソッドは、 `call`命令または`callvirt`命令を使用して呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-811">Note that a delegate's `Invoke` method can be called with either the `call` or `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="45410-812"><xref:System.Security.SecurityException>呼び出されたメソッドへのアクセスがシステムセキュリティによって付与されていない場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-812"><xref:System.Security.SecurityException> may be thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="45410-813">セキュリティチェックは、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-813">The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45410-814">値型に対して system.object のメソッドを呼び出す場合は、 `constrained`命令を`call`出力`callvirt`する代わりに、命令と共にプレフィックスを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="45410-814">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction instead of emitting a `call` instruction.</span></span> <span data-ttu-id="45410-815">これにより、値型がメソッドをオーバーライドするかどうかによって異なる IL を生成する必要がなくなり、バージョン管理の問題が発生する可能性がなくなります。</span><span class="sxs-lookup"><span data-stu-id="45410-815">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="45410-816">インターフェイスメソッドを`constrained`実装する値型のメソッドはを`MethodImpl`使用して変更できるため、値型に対してインターフェイスメソッドを呼び出すときは、プレフィックスを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="45410-816">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="45410-817">これらの問題の詳細については<xref:System.Reflection.Emit.OpCodes.Constrained> 、「オペコード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-817">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="45410-818">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `call`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `call` opcode:</span></span>  
  
-   <span data-ttu-id="45410-819">ILGenerator (オペコード, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-819">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="45410-820">ILGenerator EmitCall (オペコード、MethodInfo、型 [])</span><span class="sxs-lookup"><span data-stu-id="45410-820">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45410-821">メソッド<xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>は、呼び出し用`varargs`に用意されています。</span><span class="sxs-lookup"><span data-stu-id="45410-821">The <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> method is provided for `varargs` calls.</span></span> <span data-ttu-id="45410-822">通常の<xref:System.Reflection.Emit.ILGenerator.Emit%2A>呼び出しにはメソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="45410-822">Use the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method for normal calls.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-823">呼び出し規約によって記述されている引数を使用して、評価スタックで (エントリ ポイントへのポインターとして) 指定されているメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-823">Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-824">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-824">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-825">形式</span><span class="sxs-lookup"><span data-stu-id="45410-825">Format</span></span>|<span data-ttu-id="45410-826">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-826">Assembly Format</span></span>|<span data-ttu-id="45410-827">説明</span><span class="sxs-lookup"><span data-stu-id="45410-827">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-828">29 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-828">29 < `T` ></span></span>|<span data-ttu-id="45410-829">呼び出し`callSiteDescr`</span><span class="sxs-lookup"><span data-stu-id="45410-829">calli `callSiteDescr`</span></span>|<span data-ttu-id="45410-830">呼び出し規約によって記述された引数を使用して、が指すメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-830">Calls the method pointed to with arguments described by the calling convention.</span></span>|  
  
 <span data-ttu-id="45410-831">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-831">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-832">`arg1` から `argN` のメソッド引数はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-832">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-833">メソッドのエントリポインターがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-833">The method entry pointer is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-834">メソッドの`arg1`引数`argN`とメソッドのエントリポインターはスタックからポップされ、メソッドの呼び出しが実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-834">Method arguments `arg1` through `argN` and the method entry pointer are popped from the stack; the call to the method is performed.</span></span> <span data-ttu-id="45410-835">完了すると、呼び出し先メソッドによって戻り値が生成され、呼び出し元に送信されます。</span><span class="sxs-lookup"><span data-stu-id="45410-835">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="45410-836">戻り値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-836">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-837">命令`calli`は、を通じて`argN`引数`arg1`を指定してメソッドのエントリポインターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-837">The `calli` instruction calls the method entry pointer with the arguments `arg1` through `argN`.</span></span> <span data-ttu-id="45410-838">これらの引数の型は、特定の呼び出し規則 (`callSiteDesc`) によって記述されます。</span><span class="sxs-lookup"><span data-stu-id="45410-838">The types of these arguments are described by the specific calling convention (`callSiteDesc`).</span></span> <span data-ttu-id="45410-839">命令`calli`の前`tail`にプレフィックス (<xref:System.Reflection.Emit.OpCodes.Tailcall>) を付けると、コントロールを転送する前に現在のメソッドの状態を解放するように指定できます。</span><span class="sxs-lookup"><span data-stu-id="45410-839">The `calli` instruction may be immediately preceded by a `tail` prefix (<xref:System.Reflection.Emit.OpCodes.Tailcall>) to specify that the current method state should be released before transferring control.</span></span> <span data-ttu-id="45410-840">呼び出しによって、元のメソッドより高い信頼のメソッドに制御が転送される場合、スタックフレームは解放されません。代わりに、が`tail`指定されていないかのように、実行は暗黙的に続行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-840">If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the `tail` had not been supplied.</span></span>  
  
 <span data-ttu-id="45410-841">メソッドのエントリポインターは、(ターゲットコンピューターの) ネイティブコードへの特定のポインターと見なされます。このポインターは、呼び出し規約 (スタンドアロン署名の場合はメタデータトークン) で記述された引数を使用して、正規的に呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-841">The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</span></span> <span data-ttu-id="45410-842">このようなポインターは、 <xref:System.Reflection.Emit.OpCodes.Ldftn>命令また<xref:System.Reflection.Emit.OpCodes.Ldvirtftn>は命令を使用して作成することも、ネイティブコードから渡すこともできます。</span><span class="sxs-lookup"><span data-stu-id="45410-842">Such a pointer can be created using the <xref:System.Reflection.Emit.OpCodes.Ldftn> or <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instructions, or passed in from native code.</span></span>  
  
 <span data-ttu-id="45410-843">呼び出し規約は動的にチェックされないため、指定さ`calli`れた呼び出し規約を変換先が実際に使用していない場合、命令を使用するコードは正常に機能しません。</span><span class="sxs-lookup"><span data-stu-id="45410-843">The calling convention is not checked dynamically, so code that uses a `calli` instruction does not work correctly if the destination does not actually use the specified calling convention.</span></span>  
  
 <span data-ttu-id="45410-844">引数は、左から右の順序でスタックに配置されます。</span><span class="sxs-lookup"><span data-stu-id="45410-844">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="45410-845">つまり、最初の引数が計算され、スタックに配置されます。次に、2番目の引数が、必要なすべての引数がスタックの一番上になるまで、3番目の引数が降順になります。</span><span class="sxs-lookup"><span data-stu-id="45410-845">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="45410-846">インスタンスまたは仮想メソッドの引数作成コードシーケンスは、ユーザーに表示される引数の前に、そのインスタンス参照 (null 参照ではない必要があります) をプッシュする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-846">The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</span></span>  
  
 <span data-ttu-id="45410-847"><xref:System.Security.SecurityException>呼び出されたメソッドへの呼び出し元アクセスがシステムセキュリティによって付与されていない場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-847"><xref:System.Security.SecurityException> may be thrown if the system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="45410-848">セキュリティチェックは、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-848">The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="45410-849">次<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>のメソッドを使用して、スタック`calli`で命令を実行できます。</span><span class="sxs-lookup"><span data-stu-id="45410-849">The following <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> methods can be used to perform a `calli` instruction on the stack.</span></span> <span data-ttu-id="45410-850">は、 <xref:System.Reflection.Emit.ILGenerator.Emit%2A>クラスを使用して命令を直接スタックに配置するのではなく、以下のメソッドを通じて呼び出す必要があります。 `calli`</span><span class="sxs-lookup"><span data-stu-id="45410-850">Note that `calli` should be called through the below methods rather than using the <xref:System.Reflection.Emit.ILGenerator.Emit%2A> class to place the instruction directly on the stack.</span></span>  
  
-   <span data-ttu-id="45410-851">マネージ呼び出し規約を使用した呼び出しの場合は、ILGenerator EmitCalli (オペコード、CallingConventions、Type、Type []、Type [])。</span><span class="sxs-lookup"><span data-stu-id="45410-851">ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</span></span>  
  
-   <span data-ttu-id="45410-852">アンマネージ呼び出し規約を使用した呼び出しの場合は、ILGenerator EmitCalli (オペコード、CallingConvention、Type、Type [])。</span><span class="sxs-lookup"><span data-stu-id="45410-852">ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-853">オブジェクト上で遅延バインディング メソッドを呼び出し、戻り値を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-853">Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-854">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-855">形式</span><span class="sxs-lookup"><span data-stu-id="45410-855">Format</span></span>|<span data-ttu-id="45410-856">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-856">Assembly Format</span></span>|<span data-ttu-id="45410-857">説明</span><span class="sxs-lookup"><span data-stu-id="45410-857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-858">6F <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-858">6F < `T` ></span></span>|<span data-ttu-id="45410-859">callvirt`method`</span><span class="sxs-lookup"><span data-stu-id="45410-859">callvirt `method`</span></span>|<span data-ttu-id="45410-860">に`obj`関連付けられた特定のメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-860">Calls a specific method associated with `obj`.</span></span>|  
  
 <span data-ttu-id="45410-861">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-862">オブジェクト参照`obj`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-862">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-863">`arg1` から `argN` のメソッド引数はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-863">Method arguments `arg1` through `argN` are pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-864">とオブジェクト`arg1`参照 `argN` を介したメソッド引数はスタックからポップされます。メソッド呼び出しはこれらの引数を使用`obj`して実行され、メソッドによって参照されるメソッドに制御が移ります。 `obj`メタデータトークン。</span><span class="sxs-lookup"><span data-stu-id="45410-864">Method arguments `arg1` through `argN` and the object reference `obj` are popped from the stack; the method call is performed with these arguments and control is transferred to the method in `obj` referred to by the method metadata token.</span></span> <span data-ttu-id="45410-865">完了すると、呼び出し先メソッドによって戻り値が生成され、呼び出し元に送信されます。</span><span class="sxs-lookup"><span data-stu-id="45410-865">When complete, a return value is generated by the callee method and sent to the caller.</span></span>  
  
4.  <span data-ttu-id="45410-866">戻り値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-866">The return value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-867">この`callvirt`命令は、オブジェクトに対して遅延バインディングメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-867">The `callvirt` instruction calls a late-bound method on an object.</span></span> <span data-ttu-id="45410-868">つまり、メソッドは、メソッドポインターで参照できるコンパイル時クラス`obj`ではなく、のランタイム型に基づいて選択されます。</span><span class="sxs-lookup"><span data-stu-id="45410-868">That is, the method is chosen based on the runtime type of `obj` rather than the compile-time class visible in the method pointer.</span></span> <span data-ttu-id="45410-869">`Callvirt`を使用すると、仮想メソッドとインスタンスメソッドの両方を呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-869">`Callvirt` can be used to call both virtual and instance methods.</span></span> <span data-ttu-id="45410-870">命令`callvirt`の直前に`tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) プレフィックスを付けて、コントロールを転送する前に現在のスタックフレームを解放するように指定することができます。</span><span class="sxs-lookup"><span data-stu-id="45410-870">The `callvirt` instruction may be immediately preceded by a `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefix to specify that the current stack frame should be released before transferring control.</span></span> <span data-ttu-id="45410-871">呼び出しによって、元のメソッドよりも高い信頼のメソッドに制御が転送される場合、スタックフレームは解放されません。</span><span class="sxs-lookup"><span data-stu-id="45410-871">If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</span></span>  
  
 <span data-ttu-id="45410-872">メソッドメタデータトークンは、呼び出すメソッドの名前、クラス、および署名を提供します。</span><span class="sxs-lookup"><span data-stu-id="45410-872">The method metadata token provides the name, class and signature of the method to call.</span></span> <span data-ttu-id="45410-873">に`obj`関連付けられているクラスは、それがインスタンスであるクラスです。</span><span class="sxs-lookup"><span data-stu-id="45410-873">The class associated with `obj` is the class of which it is an instance.</span></span> <span data-ttu-id="45410-874">クラスが、指定されたメソッド名とシグネチャに一致する非静的メソッドを定義している場合、このメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="45410-874">If the class defines a non-static method that matches the indicated method name and signature, this method is called.</span></span> <span data-ttu-id="45410-875">それ以外の場合は、このクラスの基底クラスチェーンにあるすべてのクラスが順番にチェックインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-875">Otherwise all classes in the base class chain of this class are checked in order.</span></span> <span data-ttu-id="45410-876">メソッドが見つからない場合、エラーになります。</span><span class="sxs-lookup"><span data-stu-id="45410-876">It is an error if no method is found.</span></span>  
  
 <span data-ttu-id="45410-877">`Callvirt`メソッドを呼び出す前に、オブジェクトと関連する引数を評価スタックからポップします。</span><span class="sxs-lookup"><span data-stu-id="45410-877">`Callvirt` pops the object and the associated arguments off the evaluation stack before calling the method.</span></span> <span data-ttu-id="45410-878">メソッドに戻り値がある場合、メソッドの完了時にスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-878">If the method has a return value, it is pushed on the stack upon method completion.</span></span> <span data-ttu-id="45410-879">呼び出し先側`obj`では、パラメーターは引数0として`arg1` 、引数1などとしてアクセスされます。</span><span class="sxs-lookup"><span data-stu-id="45410-879">On the callee side, the `obj` parameter is accessed as argument 0, `arg1` as argument 1, and so on.</span></span>  
  
 <span data-ttu-id="45410-880">引数は、左から右の順序でスタックに配置されます。</span><span class="sxs-lookup"><span data-stu-id="45410-880">The arguments are placed on the stack in left-to-right order.</span></span> <span data-ttu-id="45410-881">つまり、最初の引数が計算され、スタックに配置されます。次に、2番目の引数が、必要なすべての引数がスタックの一番上になるまで、3番目の引数が降順になります。</span><span class="sxs-lookup"><span data-stu-id="45410-881">That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</span></span> <span data-ttu-id="45410-882">インスタンス参照`obj` (では`callvirt`常に必須) は、ユーザーが参照できる引数のいずれかの前にプッシュする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-882">The instance reference `obj` (always required for `callvirt`) must be pushed before any of the user-visible arguments.</span></span> <span data-ttu-id="45410-883">(メタデータトークンに含まれる) シグネチャには、このポインターのパラメーターリストにエントリが含まれていてはなりません。</span><span class="sxs-lookup"><span data-stu-id="45410-883">The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</span></span>  
  
 <span data-ttu-id="45410-884">仮想メソッドは、 <xref:System.Reflection.Emit.OpCodes.Call>命令を使用して呼び出すこともできます。</span><span class="sxs-lookup"><span data-stu-id="45410-884">Note that a virtual method can also be called using the <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span>  
  
 <span data-ttu-id="45410-885"><xref:System.MissingMethodException>は、指定された名前およびシグネチャを持つ非静的メソッドが、 `obj`またはその基底クラスに関連付けられているクラスで見つからなかった場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-885"><xref:System.MissingMethodException> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with `obj` or any of its base classes.</span></span> <span data-ttu-id="45410-886">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。</span><span class="sxs-lookup"><span data-stu-id="45410-886">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="45410-887"><xref:System.NullReferenceException>obj が null の場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-887"><xref:System.NullReferenceException> is thrown if obj is null.</span></span>  
  
 <span data-ttu-id="45410-888"><xref:System.Security.SecurityException>呼び出されたメソッドへのアクセスがシステムセキュリティによって付与されていない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-888"><xref:System.Security.SecurityException> is thrown if system security does not grant the caller access to the called method.</span></span> <span data-ttu-id="45410-889">セキュリティチェックは、CIL が実行時ではなくネイティブコードに変換されたときに発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-889">The security check may occur when the CIL is converted to native code rather than at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="45410-890">値型に対して system.object のメソッドを呼び出すときは、と`constrained`いう`callvirt`命令でプレフィックスを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="45410-890">When calling methods of System.Object on value types, consider using the `constrained` prefix with the `callvirt` instruction.</span></span> <span data-ttu-id="45410-891">これにより、値型がメソッドをオーバーライドするかどうかによって異なる IL を生成する必要がなくなり、バージョン管理の問題が発生する可能性がなくなります。</span><span class="sxs-lookup"><span data-stu-id="45410-891">This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</span></span> <span data-ttu-id="45410-892">インターフェイスメソッドを`constrained`実装する値型のメソッドはを`MethodImpl`使用して変更できるため、値型に対してインターフェイスメソッドを呼び出すときは、プレフィックスを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="45410-892">Consider using the `constrained` prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="45410-893">これらの問題の詳細については<xref:System.Reflection.Emit.OpCodes.Constrained> 、「オペコード」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-893">These issues are described in more detail in the <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.</span></span>  
  
 <span data-ttu-id="45410-894">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `callvirt`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-894">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `callvirt` opcode:</span></span>  
  
-   <span data-ttu-id="45410-895">ILGenerator (オペコード, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-895">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="45410-896">ILGenerator EmitCall (オペコード、MethodInfo、型 [])</span><span class="sxs-lookup"><span data-stu-id="45410-896">ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-897">指定したクラスへの参照により渡されたオブジェクトをキャストしようとします。</span><span class="sxs-lookup"><span data-stu-id="45410-897">Attempts to cast an object passed by reference to the specified class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-898">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-899">形式</span><span class="sxs-lookup"><span data-stu-id="45410-899">Format</span></span>|<span data-ttu-id="45410-900">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-900">Assembly Format</span></span>|<span data-ttu-id="45410-901">説明</span><span class="sxs-lookup"><span data-stu-id="45410-901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-902">74 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-902">74 < `T` ></span></span>|<span data-ttu-id="45410-903">castclass`class`</span><span class="sxs-lookup"><span data-stu-id="45410-903">castclass `class`</span></span>|<span data-ttu-id="45410-904">オブジェクトを型`class`の新しいオブジェクトにキャストします。</span><span class="sxs-lookup"><span data-stu-id="45410-904">Casts an object to a new object of type `class`.</span></span>|  
  
 <span data-ttu-id="45410-905">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-906">オブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-906">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-907">オブジェクト参照がスタックからポップされます。参照先のオブジェクトは、指定さ`class`れたとしてキャストされます。</span><span class="sxs-lookup"><span data-stu-id="45410-907">The object reference is popped from the stack; the referenced object is cast as the specified `class`.</span></span>  
  
3.  <span data-ttu-id="45410-908">成功すると、新しいオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-908">If successful, a new object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-909">命令`castclass`は、スタックの一番上にあるオブジェクト`O`参照 (型) を指定されたクラスにキャストしようとします。</span><span class="sxs-lookup"><span data-stu-id="45410-909">The `castclass` instruction attempts to cast the object reference (type `O`) atop the stack to a specified class.</span></span> <span data-ttu-id="45410-910">新しいクラスは、必要なクラスを示すメタデータトークンによって指定されます。</span><span class="sxs-lookup"><span data-stu-id="45410-910">The new class is specified by a metadata token indicating the desired class.</span></span> <span data-ttu-id="45410-911">スタックの一番上にあるオブジェクトのクラスが新しいクラスを実装していない (新しいクラスがインターフェイスであると仮定している) 場合、が新しいクラスの派生クラス<xref:System.InvalidCastException>ではない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-911">If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref:System.InvalidCastException> is thrown.</span></span> <span data-ttu-id="45410-912">オブジェクト参照が null 参照の場合、 `castclass`は成功し、新しいオブジェクトを null 参照として返します。</span><span class="sxs-lookup"><span data-stu-id="45410-912">If the object reference is a null reference, `castclass` succeeds and returns the new object as a null reference.</span></span>  
  
 <span data-ttu-id="45410-913"><xref:System.InvalidCastException>obj をクラスにキャストできない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-913"><xref:System.InvalidCastException> is thrown if obj cannot be cast to class.</span></span>  
  
 <span data-ttu-id="45410-914"><xref:System.TypeLoadException>クラスが見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-914"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="45410-915">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。</span><span class="sxs-lookup"><span data-stu-id="45410-915">This is typically detected when a Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="45410-916">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `castclass`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-916">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `castclass` opcode:</span></span>  
  
-   <span data-ttu-id="45410-917">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-917">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-918">2 つの値を比較します。</span><span class="sxs-lookup"><span data-stu-id="45410-918">Compares two values.</span></span> <span data-ttu-id="45410-919">2 つの値が等しい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-919">If they are equal, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-920">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-920">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-921">形式</span><span class="sxs-lookup"><span data-stu-id="45410-921">Format</span></span>|<span data-ttu-id="45410-922">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-922">Assembly Format</span></span>|<span data-ttu-id="45410-923">説明</span><span class="sxs-lookup"><span data-stu-id="45410-923">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-924">FE 01</span><span class="sxs-lookup"><span data-stu-id="45410-924">FE 01</span></span>|<span data-ttu-id="45410-925">ceq</span><span class="sxs-lookup"><span data-stu-id="45410-925">ceq</span></span>|<span data-ttu-id="45410-926">がに等しい`value1` `value2`場合は1をプッシュします。それ以外の場合は0をプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-926">Pushes 1 if `value1` equals `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="45410-927">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-927">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-928">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-928">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-929">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-929">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-930">`value2`と`value1`はスタックからポップされます。はと比較されます。 `value1`  `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-930">`value2` and `value1` are popped from the stack; `value1` is compared to `value2`.</span></span>  
  
4.  <span data-ttu-id="45410-931">が`value1` に `value2` 等しい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-931">If `value1` is equal to `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-932">命令`ceq`はと`value1` を `value2` 比較します。</span><span class="sxs-lookup"><span data-stu-id="45410-932">The `ceq` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="45410-933">が`value1`に`value2`等しい場合、1 (型`int32`) がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-933">If `value1` is equal to `value2`, then 1 (of type `int32`) is pushed on the stack.</span></span> <span data-ttu-id="45410-934">それ以外の場合は`int32`、0 (型) がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-934">Otherwise 0 (of type `int32`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="45410-935">浮動小数点数の場合、 `ceq`は、数値が順序付けられていない場合は0を返します (または両方が NaN)。</span><span class="sxs-lookup"><span data-stu-id="45410-935">For floating-point number, `ceq` will return 0 if the numbers are unordered (either or both are NaN).</span></span> <span data-ttu-id="45410-936">無限値は、それ自体と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-936">The infinite values are equal to themselves.</span></span>  
  
 <span data-ttu-id="45410-937">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ceq`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-937">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ceq` opcode:</span></span>  
  
-   <span data-ttu-id="45410-938">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-938">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-939">2 つの値を比較します。</span><span class="sxs-lookup"><span data-stu-id="45410-939">Compares two values.</span></span> <span data-ttu-id="45410-940">最初の値が 2 番目の値を超える場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-940">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-941">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-942">形式</span><span class="sxs-lookup"><span data-stu-id="45410-942">Format</span></span>|<span data-ttu-id="45410-943">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-943">Assembly Format</span></span>|<span data-ttu-id="45410-944">説明</span><span class="sxs-lookup"><span data-stu-id="45410-944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-945">FE 02</span><span class="sxs-lookup"><span data-stu-id="45410-945">FE 02</span></span>|<span data-ttu-id="45410-946">cgt</span><span class="sxs-lookup"><span data-stu-id="45410-946">cgt</span></span>|<span data-ttu-id="45410-947">がより`value1` `value2`大きい場合は1を、それ以外の場合は0をプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-947">Pushes 1 if `value1` is greater than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="45410-948">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-949">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-949">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-950">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-950">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-951">`value2`と`value1`はスタックからポップされます。`cgt`が`value1`より大きい `value2` かどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="45410-951">`value2` and `value1` are popped from the stack; `cgt` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="45410-952">が`value1` より `value2` 大きい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-952">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-953">命令`cgt`はと`value1` を `value2` 比較します。</span><span class="sxs-lookup"><span data-stu-id="45410-953">The `cgt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="45410-954">が`value1`厳密により`value2`大きい場合、 `int32`値1がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-954">If `value1` is strictly greater than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="45410-955">それ以外の`int32`場合、値0がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-955">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="45410-956">浮動小数点数の場合、 `cgt`数値が順序付けられていない場合 (つまり、引数の一方または両方が NaN の場合) は、0を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-956">For floating-point numbers, `cgt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="45410-957">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `cgt`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-957">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt` opcode:</span></span>  
  
-   <span data-ttu-id="45410-958">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-958">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-959">2 つの符号なしの値または順序なしの値を比較します。</span><span class="sxs-lookup"><span data-stu-id="45410-959">Compares two unsigned or unordered values.</span></span> <span data-ttu-id="45410-960">最初の値が 2 番目の値を超える場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-960">If the first value is greater than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-961">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-961">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-962">形式</span><span class="sxs-lookup"><span data-stu-id="45410-962">Format</span></span>|<span data-ttu-id="45410-963">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-963">Assembly Format</span></span>|<span data-ttu-id="45410-964">説明</span><span class="sxs-lookup"><span data-stu-id="45410-964">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-965">FE 03</span><span class="sxs-lookup"><span data-stu-id="45410-965">FE 03</span></span>|<span data-ttu-id="45410-966">cgt</span><span class="sxs-lookup"><span data-stu-id="45410-966">cgt.un</span></span>|<span data-ttu-id="45410-967">がより`value1` `value2`大きい場合は1を、それ以外の場合は 0 (符号なしの値) をプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-967">Pushes 1 if `value1` is greater than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="45410-968">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-968">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-969">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-969">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-970">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-970">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-971">`value2`と`value1`はスタックからポップされます。`cgt.un`が`value1`より大きい `value2` かどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="45410-971">`value2` and `value1` are popped from the stack; `cgt.un` tests if `value1` is greater than `value2`.</span></span>  
  
4.  <span data-ttu-id="45410-972">が`value1` より `value2` 大きい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-972">If `value1` is greater than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-973">次のいずれかに該当する場合は、 `int32`値1がスタックにプッシュされます。 `true`</span><span class="sxs-lookup"><span data-stu-id="45410-973">An `int32` value of 1 is pushed on the stack if any of the following is `true` :</span></span>  
  
 <span data-ttu-id="45410-974">浮動小数点数値の場合`value1` 、はに`value2`対して順序付けられません。</span><span class="sxs-lookup"><span data-stu-id="45410-974">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
 <span data-ttu-id="45410-975">整数値の場合`value1` 、は符号なし`value2`数値として見なされる場合より厳密に大きくなります。</span><span class="sxs-lookup"><span data-stu-id="45410-975">For integer values, `value1` is strictly greater than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="45410-976">それ以外`int32`の場合、値0がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-976">Otherwise an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="45410-977">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `cgt.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-977">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cgt.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-978">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-978">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-979">値が有限数ではない場合は、<see cref="T:System.ArithmeticException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-979">Throws <see cref="T:System.ArithmeticException" /> if value is not a finite number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-980">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-980">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-981">形式</span><span class="sxs-lookup"><span data-stu-id="45410-981">Format</span></span>|<span data-ttu-id="45410-982">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-982">Assembly Format</span></span>|<span data-ttu-id="45410-983">説明</span><span class="sxs-lookup"><span data-stu-id="45410-983">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-984">C3</span><span class="sxs-lookup"><span data-stu-id="45410-984">C3</span></span>|<span data-ttu-id="45410-985">ckfinite</span><span class="sxs-lookup"><span data-stu-id="45410-985">ckfinite</span></span>|<span data-ttu-id="45410-986">値<xref:System.ArithmeticException>が有限数でない場合は、をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-986">throw <xref:System.ArithmeticException> if value is not a finite number.</span></span>|  
  
 <span data-ttu-id="45410-987">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-987">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-988">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-988">`value` is pushed onto the stack.</span></span> 
  
2.  <span data-ttu-id="45410-989">`value`がスタック`ckfinite`からポップされ、命令が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-989">`value` is popped from the stack and the `ckfinite` instruction is performed on it.</span></span>  
  
3.  <span data-ttu-id="45410-990">`value`例外がスローされない場合は、がスタックに戻されます。</span><span class="sxs-lookup"><span data-stu-id="45410-990">`value` is pushed back onto the stack if no exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-991">( `ckfinite instruction`浮動小数`value`点数) が "not no `+-` number" 値 (NaN) または無限大値の場合、はをスロー <xref:System.ArithmeticException>します。</span><span class="sxs-lookup"><span data-stu-id="45410-991">The `ckfinite instruction` throws <xref:System.ArithmeticException> if `value` (a floating-point number) is either a "not a number" value (NaN) or a `+-` infinity value.</span></span> <span data-ttu-id="45410-992">`Ckfinite`例外がスローされない場合は、スタックの値をそのままにします。</span><span class="sxs-lookup"><span data-stu-id="45410-992">`Ckfinite` leaves the value on the stack if no exception is thrown.</span></span> <span data-ttu-id="45410-993">が浮動小数点数`value`でない場合、実行は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-993">Execution is unspecified if `value` is not a floating-point number.</span></span>  
  
 <span data-ttu-id="45410-994"><xref:System.ArithmeticException>が ' normal `value` ' の数値でない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-994"><xref:System.ArithmeticException> is thrown if `value` is not a 'normal' number.</span></span>  
  
 <span data-ttu-id="45410-995">特別な例外またはの<xref:System.ArithmeticException>派生クラスがより適切である可能性があることに注意してください。例外ハンドラーに間違った値を渡します。</span><span class="sxs-lookup"><span data-stu-id="45410-995">Note that a special exception or a derived class of <xref:System.ArithmeticException> may be more appropriate, passing the incorrect value to the exception handler.</span></span>  
  
 <span data-ttu-id="45410-996">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ckfinite`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-996">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ckfinite` opcode:</span></span>  
  
-   <span data-ttu-id="45410-997">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-997">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-998">2 つの値を比較します。</span><span class="sxs-lookup"><span data-stu-id="45410-998">Compares two values.</span></span> <span data-ttu-id="45410-999">最初の値が 2 番目の値より小さい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-999">If the first value is less than the second, the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1000">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1000">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1001">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1001">Format</span></span>|<span data-ttu-id="45410-1002">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1002">Assembly Format</span></span>|<span data-ttu-id="45410-1003">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1003">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1004">FE 04</span><span class="sxs-lookup"><span data-stu-id="45410-1004">FE 04</span></span>|<span data-ttu-id="45410-1005">clt</span><span class="sxs-lookup"><span data-stu-id="45410-1005">clt</span></span>|<span data-ttu-id="45410-1006">がより`value1` `value2`小さい場合は1をプッシュします。それ以外の場合は0をプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1006">Pushes 1 if `value1` is less than `value2`; else pushes 0.</span></span>|  
  
 <span data-ttu-id="45410-1007">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1007">The stack transitional behavior, in sequential order, is:</span></span> 

1.  <span data-ttu-id="45410-1008">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1008">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1009">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1009">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-1010">`value2`と`value1`はスタックからポップされます。`clt`が`value1`より小さい `value2` かどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="45410-1010">`value2` and `value1` are popped from the stack; `clt` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="45410-1011">が`value1` より `value2` 小さい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1011">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1012">命令`clt`はと`value1` を `value2` 比較します。</span><span class="sxs-lookup"><span data-stu-id="45410-1012">The `clt` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="45410-1013">が`value1`厳密により`value2`小さい場合、 `int32`値1がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1013">If `value1` is strictly less than `value2`, then an `int32` value of 1 is pushed on the stack.</span></span> <span data-ttu-id="45410-1014">それ以外の`int32`場合、値0がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1014">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
-   <span data-ttu-id="45410-1015">浮動小数点数の場合、 `clt`数値が順序付けられていない場合 (つまり、引数の一方または両方が NaN の場合) は、0を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-1015">For floating-point numbers, `clt` returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</span></span>  
  
 <span data-ttu-id="45410-1016">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `clt`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1016">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1017">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1017">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1018">符号なしの値または順序なしの値である <paramref name="value1" /> と <paramref name="value2" /> を比較します。</span><span class="sxs-lookup"><span data-stu-id="45410-1018">Compares the unsigned or unordered values <paramref name="value1" /> and <paramref name="value2" />.</span></span> <span data-ttu-id="45410-1019"><paramref name="value1" /> が <paramref name="value2" /> より小さい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1019">If <paramref name="value1" /> is less than <paramref name="value2" />, then the integer value 1 <see langword="(int32" />) is pushed onto the evaluation stack; otherwise 0 (<see langword="int32" />) is pushed onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1020">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1020">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1021">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1021">Format</span></span>|<span data-ttu-id="45410-1022">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1022">Assembly Format</span></span>|<span data-ttu-id="45410-1023">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1023">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1024">FE 05</span><span class="sxs-lookup"><span data-stu-id="45410-1024">FE 05</span></span>|<span data-ttu-id="45410-1025">clt</span><span class="sxs-lookup"><span data-stu-id="45410-1025">clt.un</span></span>|<span data-ttu-id="45410-1026">がより`value1` `value2`小さい場合は1を、それ以外の場合は 0 (符号なしの値) をプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1026">Pushes 1 if `value1` is less than `value2`; else pushes 0 (unsigned values).</span></span>|  
  
 <span data-ttu-id="45410-1027">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1027">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1028">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1028">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1029">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1029">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-1030">`value2`と`value1`はスタックからポップされます。`clt.un`が`value1`より小さい `value2` かどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="45410-1030">`value2` and `value1` are popped from the stack; `clt.un` tests if `value1` is less than `value2`.</span></span>  
  
4.  <span data-ttu-id="45410-1031">が`value1` より `value2` 小さい場合、1がスタックにプッシュされます。それ以外の場合は、0がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1031">If `value1` is less than `value2`, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1032">命令`clt.un`はと`value1` を `value2` 比較します。</span><span class="sxs-lookup"><span data-stu-id="45410-1032">The `clt.un` instruction compares `value1` and `value2`.</span></span> <span data-ttu-id="45410-1033">次のいずれかに該当する場合は、値1がスタックにプッシュされます。 `int32`</span><span class="sxs-lookup"><span data-stu-id="45410-1033">An `int32` value of 1 is pushed on the stack if any of the following is true:</span></span>  
  
-   <span data-ttu-id="45410-1034">`value1`は (の場合`value2`と同様に`clt`) より厳密にはありません。</span><span class="sxs-lookup"><span data-stu-id="45410-1034">`value1` is strictly less than `value2` (as for `clt`).</span></span>  
  
-   <span data-ttu-id="45410-1035">浮動小数点数値の場合`value1` 、はに`value2`対して順序付けられません。</span><span class="sxs-lookup"><span data-stu-id="45410-1035">For floating-point numbers, `value1` is not ordered with respect to `value2`.</span></span>  
  
-   <span data-ttu-id="45410-1036">整数値の場合`value1` 、は符号なし`value2`数値として見なされる場合より厳密には小さくなります。</span><span class="sxs-lookup"><span data-stu-id="45410-1036">For integer values, `value1` is strictly less than `value2` when considered as unsigned numbers.</span></span>  
  
 <span data-ttu-id="45410-1037">それ以外の`int32`場合、値0がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1037">Otherwise, an `int32` value of 0 is pushed on the stack.</span></span>  
  
 <span data-ttu-id="45410-1038">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `clt.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1038">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `clt.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1039">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1039">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1040">仮想メソッド呼び出しをする対象の型を制約します。</span><span class="sxs-lookup"><span data-stu-id="45410-1040">Constrains the type on which a virtual method call is made.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1041">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1041">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1042">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1042">Format</span></span>|<span data-ttu-id="45410-1043">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1043">Assembly Format</span></span>|<span data-ttu-id="45410-1044">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1044">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1045">FE 16 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-1045">FE 16 < `T` ></span></span>|<span data-ttu-id="45410-1046">制約付き.</span><span class="sxs-lookup"><span data-stu-id="45410-1046">constrained.</span></span> `thisType`|<span data-ttu-id="45410-1047">型`T`として制約されている型に対して仮想メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-1047">Call a virtual method on a type constrained to be type `T`.</span></span>|  
  
 <span data-ttu-id="45410-1048">プレフィックスは、 `callvirt`命令でのみ許可されます。 `constrained`</span><span class="sxs-lookup"><span data-stu-id="45410-1048">The `constrained` prefix is permitted only on a `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="45410-1049">この時点での MSIL スタックの状態は、次のようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1049">The state of the MSIL stack at this point must be as follows:</span></span>  
  
1.  <span data-ttu-id="45410-1050">マネージポインター `ptr`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1050">A managed pointer, `ptr`, is pushed onto the stack.</span></span> <span data-ttu-id="45410-1051">の型は`ptr` 、のマネージポインター (`&`) `thisType`である必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1051">The type of `ptr` must be a managed pointer (`&`) to `thisType`.</span></span> <span data-ttu-id="45410-1052">これは、プレフィックス`callvirt`のない命令の場合とは異なることに注意してください。これは、の`thisType`参照を想定しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1052">Note that this is different from the case of an unprefixed `callvirt` instruction, which expects a reference of `thisType`.</span></span>  
  
2.  <span data-ttu-id="45410-1053">`callvirt`から`arg1` のメソッド `argN` 引数は、プレフィックスのない命令と同様にスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1053">Method arguments `arg1` through `argN` are pushed onto the stack, just as with an unprefixed `callvirt` instruction.</span></span>  
  
 <span data-ttu-id="45410-1054">プレフィックスは、が値型`callvirt`と参照型のどちらであるか`thisType`に関係なく、一貫した方法で命令を行うことができるように設計されています。 `constrained`</span><span class="sxs-lookup"><span data-stu-id="45410-1054">The `constrained` prefix is designed to allow `callvirt` instructions to be made in a uniform way independent of whether `thisType` is a value type or a reference type.</span></span>  
  
 <span data-ttu-id="45410-1055">命令の前にが付いている場合、命令は次のように実行されます。 `thisType`  `constrained` `callvirt` `method`</span><span class="sxs-lookup"><span data-stu-id="45410-1055">When a `callvirt` `method` instruction has been prefixed by `constrained` `thisType`, the instruction is executed as follows:</span></span>  
  
-   <span data-ttu-id="45410-1056">が`thisType`参照型 (値型ではない`ptr` ) の場合、はを逆参照し、 `callvirt`のへの`method`' this ' ポインターとして渡されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1056">If `thisType` is a reference type (as opposed to a value type) then `ptr` is dereferenced and passed as the 'this' pointer to the `callvirt` of `method`.</span></span>  
  
-   <span data-ttu-id="45410-1057">が`thisType`値`call` `ptr` `method` `method`型であり、を `method` 実装している場合、によるの実装について、は、命令への ' this ' ポインターとして未変更のまま渡されます。 `thisType`  `thisType`.</span><span class="sxs-lookup"><span data-stu-id="45410-1057">If `thisType` is a value type and `thisType` implements `method` then `ptr` is passed unmodified as the 'this' pointer to a `call` `method` instruction, for the implementation of `method` by `thisType`.</span></span>  
  
-   <span data-ttu-id="45410-1058">が`thisType`値`ptr` `method` `callvirt`型であり、を実装`method`していない場合は、を逆参照してボックス化し、命令への ' this ' ポインターとして渡します。 `thisType`</span><span class="sxs-lookup"><span data-stu-id="45410-1058">If `thisType` is a value type and `thisType` does not implement `method` then `ptr` is dereferenced, boxed, and passed as the 'this' pointer to the `callvirt` `method` instruction.</span></span>  
  
 <span data-ttu-id="45410-1059">この最後のケースは、が`method` 、 <xref:System.ValueType>、また<xref:System.Object>は<xref:System.Enum>で定義されており`thisType`、でオーバーライドされていない場合にのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="45410-1059">This last case can occur only when `method` was defined on <xref:System.Object>, <xref:System.ValueType>, or <xref:System.Enum> and not overridden by `thisType`.</span></span> <span data-ttu-id="45410-1060">この場合、ボックス化によって元のオブジェクトのコピーが作成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1060">In this case, the boxing causes a copy of the original object to be made.</span></span> <span data-ttu-id="45410-1061">ただし、、 <xref:System.Object> <xref:System.ValueType>、および<xref:System.Enum>のいずれのメソッドもオブジェクトの状態を変更しないので、このファクトを検出することはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-1061">However, because none of the methods of <xref:System.Object>, <xref:System.ValueType>, and <xref:System.Enum> modify the state of the object, this fact cannot be detected.</span></span>  
  
 <span data-ttu-id="45410-1062">この`constrained`プレフィックスは、ジェネリックコードを作成する IL ジェネレーターをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="45410-1062">The `constrained` prefix supports IL generators that create generic code.</span></span> <span data-ttu-id="45410-1063">通常、 `callvirt`命令は値型では無効です。</span><span class="sxs-lookup"><span data-stu-id="45410-1063">Normally the `callvirt` instruction is not valid on value types.</span></span> <span data-ttu-id="45410-1064">代わりに、IL コンパイラは、の`ptr`型および呼び出されるメソッドに応じて、コンパイル時に上記で説明した ' this ' 変換を効果的に実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1064">Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of `ptr` and the method being called.</span></span> <span data-ttu-id="45410-1065">ただし、が`ptr`コンパイル時に不明なジェネリック型である場合、コンパイル時にこの変換を行うことはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-1065">However, when `ptr` is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</span></span>  
  
 <span data-ttu-id="45410-1066">オペコードを使用すると、IL コンパイラは、が値型か参照型か`ptr`にかかわらず、同じ方法で仮想関数を呼び出すことができます。 `constrained`</span><span class="sxs-lookup"><span data-stu-id="45410-1066">The `constrained` opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether `ptr` is a value type or a reference type.</span></span> <span data-ttu-id="45410-1067">`thisType`はジェネリック型の変数`constrained`であることを目的としていますが、プレフィックスは非ジェネリック型に対しても機能し、値の型の区別を隠す言語での仮想呼び出しの生成の複雑さを軽減できます。参照型。</span><span class="sxs-lookup"><span data-stu-id="45410-1067">Although it is intended for the case where `thisType` is a generic type variable, the `constrained` prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</span></span>  
  
 <span data-ttu-id="45410-1068">また、 `constrained`プレフィックスを使用すると、値の型に関する潜在的なバージョン管理の問題を回避できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1068">Using the `constrained` prefix also avoids potential versioning problems with value types.</span></span> <span data-ttu-id="45410-1069">プレフィックスを`constrained`使用しない場合は、値型が system.object のメソッドをオーバーライドするかどうかに応じて、異なる IL を生成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1069">If the `constrained` prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</span></span> <span data-ttu-id="45410-1070">たとえば、値`V`型がオブジェクトの ToString () メソッド`Object.ToString()` `call` `V.ToString()`をオーバーライドする場合、命令が`box`生成されます。 `callvirt`そうでない場合は、命令と命令が生成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1070">For example, if a value type `V` overrides the Object.ToString() method, a `call` `V.ToString()` instruction is emitted; if it does not, a `box` instruction and a `callvirt` `Object.ToString()` instruction are emitted.</span></span> <span data-ttu-id="45410-1071">前のケースでは、オーバーライドが後で削除された場合は、バージョン管理の問題が発生する可能性があります。後者の場合は、オーバーライドが後で追加されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1071">A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</span></span>  
  
 <span data-ttu-id="45410-1072">インターフェイスメソッドを実装する値型のメソッドはを`MethodImpl`使用して変更できるため、プレフィックスを使用して値型のインターフェイスメソッドを呼び出すこともできます。 `constrained`</span><span class="sxs-lookup"><span data-stu-id="45410-1072">The `constrained` prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a `MethodImpl`.</span></span> <span data-ttu-id="45410-1073">`constrained`プレフィックスを使用しない場合、コンパイラはコンパイル時にバインドする値型のメソッドを強制的に選択します。</span><span class="sxs-lookup"><span data-stu-id="45410-1073">If the `constrained` prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</span></span> <span data-ttu-id="45410-1074">`constrained`プレフィックスを使用すると、コンパイル時ではなく、実行時にインターフェイスメソッドを実装するメソッドに MSIL をバインドできます。</span><span class="sxs-lookup"><span data-stu-id="45410-1074">Using the `constrained` prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</span></span>  
  
 <span data-ttu-id="45410-1075">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `constrained`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1075">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `constrained` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1076">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-1076">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1077">評価スタックの一番上の値を <see langword="native int" /> に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-1077">Converts the value on top of the evaluation stack to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1078">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1078">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1079">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1079">Format</span></span>|<span data-ttu-id="45410-1080">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1080">Assembly Format</span></span>|<span data-ttu-id="45410-1081">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1081">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1082">D3</span><span class="sxs-lookup"><span data-stu-id="45410-1082">D3</span></span>|<span data-ttu-id="45410-1083">conv. i</span><span class="sxs-lookup"><span data-stu-id="45410-1083">conv.i</span></span>|<span data-ttu-id="45410-1084">をに`native int`変換し`native int` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1084">Convert to `native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1085">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1085">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1086">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1086">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1087">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1087">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1088">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1088">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1089">オペコード`conv.i`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1089">The `conv.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1090">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1090">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1091">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1091">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1092">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1092">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1093">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1093">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1094">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1094">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1095">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1095">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1096">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1096">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1097">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1097">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1098">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1098">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45410-1099">結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1099">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45410-1100">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.i`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1100">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1101">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1101">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1102">評価スタックの一番上の値を <see langword="int8" /> に変換し、<see langword="int32" /> への拡張 (埋め込み) を行います。</span><span class="sxs-lookup"><span data-stu-id="45410-1102">Converts the value on top of the evaluation stack to <see langword="int8" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1103">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1103">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1104">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1104">Format</span></span>|<span data-ttu-id="45410-1105">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1105">Assembly Format</span></span>|<span data-ttu-id="45410-1106">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1106">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1107">67</span><span class="sxs-lookup"><span data-stu-id="45410-1107">67</span></span>|<span data-ttu-id="45410-1108">conv</span><span class="sxs-lookup"><span data-stu-id="45410-1108">conv.i1</span></span>|<span data-ttu-id="45410-1109">をに`int8`変換し`int32` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1109">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1110">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1110">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1111">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1111">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1112">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1112">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1113">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1113">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1114">オペコード`conv.i1`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1114">The `conv.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1115">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1115">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1116">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1116">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1117">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1117">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1118">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1118">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1119">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1119">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1120">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1120">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1121">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1121">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1122">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1122">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1123">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1123">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45410-1124">結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1124">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45410-1125">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.i1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1125">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1126">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1126">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1127">評価スタックの一番上の値を <see langword="int16" /> に変換し、<see langword="int32" /> への拡張 (埋め込み) を行います。</span><span class="sxs-lookup"><span data-stu-id="45410-1127">Converts the value on top of the evaluation stack to <see langword="int16" />, then extends (pads) it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1128">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1128">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1129">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1129">Format</span></span>|<span data-ttu-id="45410-1130">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1130">Assembly Format</span></span>|<span data-ttu-id="45410-1131">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1131">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1132">68</span><span class="sxs-lookup"><span data-stu-id="45410-1132">68</span></span>|<span data-ttu-id="45410-1133">i2</span><span class="sxs-lookup"><span data-stu-id="45410-1133">conv.i2</span></span>|<span data-ttu-id="45410-1134">をに`int16`変換し`int32` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1134">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1135">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1135">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1136">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1136">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1137">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1137">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1138">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1138">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1139">オペコード`conv.i2`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1139">The `conv.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1140">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1140">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1141">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1141">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1142">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1142">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1143">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1143">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1144">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1144">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1145">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1145">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1146">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1146">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1147">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1147">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1148">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1148">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45410-1149">結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1149">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45410-1150">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.i2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1150">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1151">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1151">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1152">評価スタックの一番上の値を <see langword="int32" /> に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-1152">Converts the value on top of the evaluation stack to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1153">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1153">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1154">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1154">Format</span></span>|<span data-ttu-id="45410-1155">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1155">Assembly Format</span></span>|<span data-ttu-id="45410-1156">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1156">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1157">69</span><span class="sxs-lookup"><span data-stu-id="45410-1157">69</span></span>|<span data-ttu-id="45410-1158">conv. i4</span><span class="sxs-lookup"><span data-stu-id="45410-1158">conv.i4</span></span>|<span data-ttu-id="45410-1159">をに`int32`変換し`int32` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1159">Convert to `int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1160">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1160">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1161">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1161">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1162">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1162">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1163">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1163">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1164">オペコード`conv.i4`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1164">The `conv.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1165">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1165">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1166">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1166">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1167">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1167">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1168">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1168">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1169">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1169">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1170">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1170">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1171">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1171">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1172">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1172">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1173">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1173">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45410-1174">結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1174">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45410-1175">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.i4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1175">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1176">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1176">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1177">評価スタックの一番上の値を <see langword="int64" /> に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-1177">Converts the value on top of the evaluation stack to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1178">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1178">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1179">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1179">Format</span></span>|<span data-ttu-id="45410-1180">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1180">Assembly Format</span></span>|<span data-ttu-id="45410-1181">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1181">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1182">6A</span><span class="sxs-lookup"><span data-stu-id="45410-1182">6A</span></span>|<span data-ttu-id="45410-1183">i8</span><span class="sxs-lookup"><span data-stu-id="45410-1183">conv.i8</span></span>|<span data-ttu-id="45410-1184">をに`int64`変換し`int64` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1184">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1185">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1185">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1186">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1186">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1187">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1187">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1188">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1188">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1189">オペコード`conv.i8`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1189">The `conv.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1190">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1190">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1191">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1191">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1192">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1192">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1193">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1193">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1194">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1194">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1195">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1195">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1196">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1196">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1197">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1197">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1198">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1198">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45410-1199">結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1199">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45410-1200">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.i8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1201">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1202">評価スタックの一番上にある符号付きの値を符号付き <see langword="native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1202">Converts the signed value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1203">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1204">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1204">Format</span></span>|<span data-ttu-id="45410-1205">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1205">Assembly Format</span></span>|<span data-ttu-id="45410-1206">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1207">D4</span><span class="sxs-lookup"><span data-stu-id="45410-1207">D4</span></span>|<span data-ttu-id="45410-1208">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-1208">conv.ovf.i</span></span>|<span data-ttu-id="45410-1209">を`native int` ( `native int` スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1209">Convert to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1210">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1211">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1211">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1212">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1212">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1213">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1213">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1214">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1214">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1215">オペコード`conv.ovf.i`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1215">The `conv.ovf.i` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1216">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1216">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1217">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1217">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1218">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1218">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1219"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1219"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1220">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1220">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1221">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1221">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1222">評価スタックの一番上にある符号なしの値を符号付き <see langword="native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1222">Converts the unsigned value on top of the evaluation stack to signed <see langword="native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1223">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1223">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1224">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1224">Format</span></span>|<span data-ttu-id="45410-1225">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1225">Assembly Format</span></span>|<span data-ttu-id="45410-1226">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1226">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1227">8A</span><span class="sxs-lookup"><span data-stu-id="45410-1227">8A</span></span>|<span data-ttu-id="45410-1228">ovf. i. un</span><span class="sxs-lookup"><span data-stu-id="45410-1228">conv.ovf.i.un</span></span>|<span data-ttu-id="45410-1229">符号なしの値を`native int` (として`native int`スタック上で) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1229">Converts an unsigned value to a `native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1230">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1230">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1231">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1231">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1232">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1232">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1233">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1233">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1234">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1234">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1235">オペコード`conv.ovf.i.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1235">The `conv.ovf.i.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1236">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1236">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1237">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1237">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1238">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1238">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1239"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1239"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1240">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1240">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1241">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1241">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1242">評価スタックの一番上にある符号付きの値を符号付き <see langword="int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1242">Converts the signed value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1243">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1243">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1244">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1244">Format</span></span>|<span data-ttu-id="45410-1245">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1245">Assembly Format</span></span>|<span data-ttu-id="45410-1246">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1246">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1247">B3</span><span class="sxs-lookup"><span data-stu-id="45410-1247">B3</span></span>|<span data-ttu-id="45410-1248">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-1248">conv.ovf.i1</span></span>|<span data-ttu-id="45410-1249">を`int8` ( `int32` スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1249">Convert to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1250">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1250">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1251">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1251">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1252">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1252">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1253">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1253">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1254">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1254">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1255">オペコード`conv.ovf.i1`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1255">The `conv.ovf.i1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1256">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1256">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1257">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1257">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1258">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1258">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1259"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1259"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1260">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1260">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1261">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1261">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1262">評価スタックの一番上にある符号なしの値を符号付き <see langword="int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1262">Converts the unsigned value on top of the evaluation stack to signed <see langword="int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1263">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1263">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1264">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1264">Format</span></span>|<span data-ttu-id="45410-1265">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1265">Assembly Format</span></span>|<span data-ttu-id="45410-1266">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1266">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1267">82</span><span class="sxs-lookup"><span data-stu-id="45410-1267">82</span></span>|<span data-ttu-id="45410-1268">ovf です。</span><span class="sxs-lookup"><span data-stu-id="45410-1268">conv.ovf.i1.un</span></span>|<span data-ttu-id="45410-1269">符号なしの値を`int8` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1269">Converts an unsigned value to an `int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1270">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1270">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1271">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1271">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1272">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1272">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1273">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1273">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1274">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1274">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1275">オペコード`conv.ovf.i1.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1275">The `conv.ovf.i1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1276">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1276">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1277">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1277">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1278">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1278">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1279"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1279"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1280">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i1.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1280">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i1.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1281">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1281">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1282">評価スタックの一番上にある符号付きの値を符号付き <see langword="int16" /> に変換し、変換した値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1282">Converts the signed value on top of the evaluation stack to signed <see langword="int16" /> and extending it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1283">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1283">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1284">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1284">Format</span></span>|<span data-ttu-id="45410-1285">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1285">Assembly Format</span></span>|<span data-ttu-id="45410-1286">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1286">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1287">B5</span><span class="sxs-lookup"><span data-stu-id="45410-1287">B5</span></span>|<span data-ttu-id="45410-1288">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-1288">conv.ovf.i2</span></span>|<span data-ttu-id="45410-1289">を`int16` ( `int32` スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1289">Convert to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1290">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1290">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1291">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1291">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1292">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1292">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1293">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1293">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1294">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1294">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1295">オペコード`conv.ovf.i2`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1295">The `conv.ovf.i2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1296">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1296">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1297">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1297">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1298">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1298">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1299"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1299"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1300">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1300">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1301">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1301">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1302">評価スタックの一番上にある符号なしの値を符号付き <see langword="int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1302">Converts the unsigned value on top of the evaluation stack to signed <see langword="int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1303">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1303">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1304">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1304">Format</span></span>|<span data-ttu-id="45410-1305">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1305">Assembly Format</span></span>|<span data-ttu-id="45410-1306">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1306">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1307">83</span><span class="sxs-lookup"><span data-stu-id="45410-1307">83</span></span>|<span data-ttu-id="45410-1308">ovf (un)</span><span class="sxs-lookup"><span data-stu-id="45410-1308">conv.ovf.i2.un</span></span>|<span data-ttu-id="45410-1309">符号なしの値を`int16` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1309">Converts an unsigned value to an `int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1310">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1310">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1311">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1311">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1312">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1312">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1313">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1313">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1314">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1314">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1315">オペコード`conv.ovf.i2.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1315">The `conv.ovf.i2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1316">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1316">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1317">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1317">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1318">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1318">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1319"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1319"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1320">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i2.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1320">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i2.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1321">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1321">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1322">評価スタックの一番上にある符号付きの値を符号付き <see langword="int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1322">Converts the signed value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1323">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1323">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1324">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1324">Format</span></span>|<span data-ttu-id="45410-1325">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1325">Assembly Format</span></span>|<span data-ttu-id="45410-1326">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1326">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1327">B7</span><span class="sxs-lookup"><span data-stu-id="45410-1327">B7</span></span>|<span data-ttu-id="45410-1328">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-1328">conv.ovf.i4</span></span>|<span data-ttu-id="45410-1329">を`int32` ( `int32` スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1329">Convert to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1330">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1330">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1331">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1331">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1332">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1332">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1333">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1333">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1334">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1334">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1335">オペコード`conv.ovf.i4`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1335">The `conv.ovf.i4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1336">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1336">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1337">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1337">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1338">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1338">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1339"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1339"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1340">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1340">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1341">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1341">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1342">評価スタックの一番上にある符号なしの値を符号付き <see langword="int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1342">Converts the unsigned value on top of the evaluation stack to signed <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1343">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1343">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1344">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1344">Format</span></span>|<span data-ttu-id="45410-1345">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1345">Assembly Format</span></span>|<span data-ttu-id="45410-1346">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1346">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1347">84</span><span class="sxs-lookup"><span data-stu-id="45410-1347">84</span></span>|<span data-ttu-id="45410-1348">ovf の場合</span><span class="sxs-lookup"><span data-stu-id="45410-1348">conv.ovf.i4.un</span></span>|<span data-ttu-id="45410-1349">符号なしの値を`int32` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1349">Converts an unsigned value to an `int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1350">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1350">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1351">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1351">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1352">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1352">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1353">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1353">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1354">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1354">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1355">オペコード`conv.ovf.i4.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1355">The `conv.ovf.i4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1356">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1356">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1357">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1357">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1358">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1358">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1359"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1359"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1360">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i4.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1360">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i4.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1361">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1361">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1362">評価スタックの一番上にある符号付きの値を符号付き <see langword="int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1362">Converts the signed value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1363">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1363">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1364">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1364">Format</span></span>|<span data-ttu-id="45410-1365">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1365">Assembly Format</span></span>|<span data-ttu-id="45410-1366">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1366">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1367">B9</span><span class="sxs-lookup"><span data-stu-id="45410-1367">B9</span></span>|<span data-ttu-id="45410-1368">ovf. i8</span><span class="sxs-lookup"><span data-stu-id="45410-1368">conv.ovf.i8</span></span>|<span data-ttu-id="45410-1369">を`int64` ( `int64` スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1369">Convert to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1370">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1370">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1371">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1371">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1372">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1372">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1373">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1373">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1374">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1374">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1375">オペコード`conv.ovf.i8`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1375">The `conv.ovf.i8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1376">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1376">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1377">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1377">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1378">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1378">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1379"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1379"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1380">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1380">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1381">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1381">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1382">評価スタックの一番上にある符号なしの値を符号付き <see langword="int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1382">Converts the unsigned value on top of the evaluation stack to signed <see langword="int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1383">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1383">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1384">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1384">Format</span></span>|<span data-ttu-id="45410-1385">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1385">Assembly Format</span></span>|<span data-ttu-id="45410-1386">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1386">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1387">85</span><span class="sxs-lookup"><span data-stu-id="45410-1387">85</span></span>|<span data-ttu-id="45410-1388">ovf. i8</span><span class="sxs-lookup"><span data-stu-id="45410-1388">conv.ovf.i8.un</span></span>|<span data-ttu-id="45410-1389">符号なしの値を`int64` (として`int64`スタック上で) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1389">Converts an unsigned value to an `int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1390">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1390">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1391">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1391">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1392">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1392">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1393">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1393">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1394">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1394">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1395">オペコード`conv.ovf.i8.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1395">The `conv.ovf.i8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1396">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1396">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1397">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1397">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1398">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1398">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1399"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1399"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1400">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.i8.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1400">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.i8.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1401">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1401">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1402">評価スタックの一番上にある符号付きの値を <see langword="unsigned native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1402">Converts the signed value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1403">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1403">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1404">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1404">Format</span></span>|<span data-ttu-id="45410-1405">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1405">Assembly Format</span></span>|<span data-ttu-id="45410-1406">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1406">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1407">D5</span><span class="sxs-lookup"><span data-stu-id="45410-1407">D5</span></span>|<span data-ttu-id="45410-1408">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-1408">conv.ovf.u</span></span>|<span data-ttu-id="45410-1409">を`unsigned native int` ( `native int` スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1409">Convert to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1410">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1410">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1411">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1411">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1412">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1412">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1413">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1413">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1414">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1414">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1415">オペコード`conv.ovf.u`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1415">The `conv.ovf.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1416">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1416">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1417">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1417">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1418">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1418">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1419"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1419"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1420">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1420">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1421">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1421">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1422">評価スタックの一番上にある符号なしの値を <see langword="unsigned native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1422">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned native int" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1423">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1423">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1424">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1424">Format</span></span>|<span data-ttu-id="45410-1425">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1425">Assembly Format</span></span>|<span data-ttu-id="45410-1426">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1426">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1427">8B</span><span class="sxs-lookup"><span data-stu-id="45410-1427">8B</span></span>|<span data-ttu-id="45410-1428">ovf. u. un</span><span class="sxs-lookup"><span data-stu-id="45410-1428">conv.ovf.u.un</span></span>|<span data-ttu-id="45410-1429">アン unsigned 値を`unsigned native int` ( `native int`スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1429">Converts un unsigned value to an `unsigned native int` (on the stack as `native int`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1430">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1430">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1431">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1431">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1432">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1432">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1433">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1433">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1434">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1434">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1435">オペコード`conv.ovf.u.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1435">The `conv.ovf.u.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1436">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1436">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1437">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1437">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1438">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1438">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1439"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1439"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1440">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.uvf.u.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1440">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.uvf.u.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1441">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1441">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1442">評価スタックの一番上にある符号付きの値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1442">Converts the signed value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1443">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1443">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1444">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1444">Format</span></span>|<span data-ttu-id="45410-1445">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1445">Assembly Format</span></span>|<span data-ttu-id="45410-1446">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1446">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1447">B4</span><span class="sxs-lookup"><span data-stu-id="45410-1447">B4</span></span>|<span data-ttu-id="45410-1448">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-1448">conv.ovf.u1</span></span>|<span data-ttu-id="45410-1449">を`unsigned int8` ( `int32` スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1449">Convert to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1450">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1450">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1451">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1451">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1452">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1452">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1453">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1453">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1454">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1454">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1455">オペコード`conv.ovf.u1`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1455">The `conv.ovf.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1456">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1456">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1457">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1457">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1458">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1458">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1459"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1459"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1460">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1460">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1461">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1461">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1462">評価スタックの一番上にある符号なしの値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1462">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int8" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1463">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1463">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1464">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1464">Format</span></span>|<span data-ttu-id="45410-1465">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1465">Assembly Format</span></span>|<span data-ttu-id="45410-1466">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1466">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1467">86</span><span class="sxs-lookup"><span data-stu-id="45410-1467">86</span></span>|<span data-ttu-id="45410-1468">ovf のようにします。</span><span class="sxs-lookup"><span data-stu-id="45410-1468">conv.ovf.u1.un</span></span>|<span data-ttu-id="45410-1469">符号なしの値を`unsigned int8` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1469">Converts an unsigned value to an `unsigned int8` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1470">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1470">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1471">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1471">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1472">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1472">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1473">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1473">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1474">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1474">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1475">オペコード`conv.ovf.u1.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1475">The `conv.ovf.u1.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1476">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1476">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1477">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1477">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1478">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1478">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1479"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1479"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1480">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u1.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1480">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u1.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1481">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1481">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1482">評価スタックの一番上にある符号付きの値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1482">Converts the signed value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1483">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1483">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1484">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1484">Format</span></span>|<span data-ttu-id="45410-1485">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1485">Assembly Format</span></span>|<span data-ttu-id="45410-1486">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1486">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1487">B6</span><span class="sxs-lookup"><span data-stu-id="45410-1487">B6</span></span>|<span data-ttu-id="45410-1488">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-1488">conv.ovf.u2</span></span>|<span data-ttu-id="45410-1489">を`unsigned int16` ( `int32` スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1489">Convert to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1490">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1490">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1491">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1491">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1492">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1492">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1493">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1493">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1494">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1494">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1495">オペコード`conv.ovf.u2`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1495">The `conv.ovf.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1496">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1496">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1497">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1497">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1498">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1498">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1499"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1499"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1500">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1500">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1501">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1501">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1502">評価スタックの一番上にある符号なしの値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1502">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int16" /> and extends it to <see langword="int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1503">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1503">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1504">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1504">Format</span></span>|<span data-ttu-id="45410-1505">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1505">Assembly Format</span></span>|<span data-ttu-id="45410-1506">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1506">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1507">87</span><span class="sxs-lookup"><span data-stu-id="45410-1507">87</span></span>|<span data-ttu-id="45410-1508">ovf. un</span><span class="sxs-lookup"><span data-stu-id="45410-1508">conv.ovf.u2.un</span></span>|<span data-ttu-id="45410-1509">符号なしの値を`unsigned int16` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1509">Converts an unsigned value to an `unsigned int16` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1510">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1510">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1511">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1511">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1512">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1512">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1513">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1513">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1514">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1514">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1515">オペコード`conv.ovf.u2.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1515">The `conv.ovf.u2.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1516">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1516">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1517">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1517">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1518">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1518">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1519"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1519"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1520">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u2.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1520">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u2.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1521">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1521">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1522">評価スタックの一番上にある符号付きの値を <see langword="unsigned int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1522">Converts the signed value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1523">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1523">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1524">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1524">Format</span></span>|<span data-ttu-id="45410-1525">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1525">Assembly Format</span></span>|<span data-ttu-id="45410-1526">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1526">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1527">B8</span><span class="sxs-lookup"><span data-stu-id="45410-1527">B8</span></span>|<span data-ttu-id="45410-1528">ovf. u4</span><span class="sxs-lookup"><span data-stu-id="45410-1528">conv.ovf.u4</span></span>|<span data-ttu-id="45410-1529">を`unsigned int32` ( `int32` スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1529">Convert to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1530">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1530">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1531">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1531">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1532">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1532">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1533">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1533">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1534">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1534">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1535">オペコード`conv.ovf.u4`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1535">The `conv.ovf.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1536">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1536">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1537">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1537">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1538">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1538">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1539"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1539"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1540">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1540">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1541">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1541">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1542">評価スタックの一番上にある符号なしの値を <see langword="unsigned int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1542">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int32" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1543">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1543">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1544">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1544">Format</span></span>|<span data-ttu-id="45410-1545">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1545">Assembly Format</span></span>|<span data-ttu-id="45410-1546">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1546">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1547">88</span><span class="sxs-lookup"><span data-stu-id="45410-1547">88</span></span>|<span data-ttu-id="45410-1548">ovf. u4</span><span class="sxs-lookup"><span data-stu-id="45410-1548">conv.ovf.u4.un</span></span>|<span data-ttu-id="45410-1549">符号なしの値を`unsigned int32` (として`int32`スタック上で) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1549">Converts an unsigned value to an `unsigned int32` (on the stack as `int32`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1550">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1550">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1551">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1551">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1552">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1552">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1553">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1553">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1554">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1554">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1555">オペコード`conv.ovf.u4.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1555">The `conv.ovf.u4.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1556">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1556">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1557">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1557">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1558">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1558">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1559"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1559"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1560">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u4.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1560">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u4.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1561">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1561">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1562">評価スタックの一番上にある符号付きの値を <see langword="unsigned int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1562">Converts the signed value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1563">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1563">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1564">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1564">Format</span></span>|<span data-ttu-id="45410-1565">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1565">Assembly Format</span></span>|<span data-ttu-id="45410-1566">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1566">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1567">BA</span><span class="sxs-lookup"><span data-stu-id="45410-1567">BA</span></span>|<span data-ttu-id="45410-1568">ovf. u8</span><span class="sxs-lookup"><span data-stu-id="45410-1568">conv.ovf.u8</span></span>|<span data-ttu-id="45410-1569">を`unsigned int64` ( `int64` スタック上の) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1569">Convert to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1570">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1570">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1571">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1571">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1572">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1572">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1573">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1573">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1574">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1574">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1575">オペコード`conv.ovf.u8`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1575">The `conv.ovf.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1576">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1576">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1577">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1577">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1578">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1578">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1579"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1579"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1580">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1580">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1581">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1581">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1582">評価スタックの一番上にある符号なしの値を <see langword="unsigned int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1582">Converts the unsigned value on top of the evaluation stack to <see langword="unsigned int64" />, throwing <see cref="T:System.OverflowException" /> on overflow.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1583">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1583">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1584">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1584">Format</span></span>|<span data-ttu-id="45410-1585">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1585">Assembly Format</span></span>|<span data-ttu-id="45410-1586">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1586">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1587">89</span><span class="sxs-lookup"><span data-stu-id="45410-1587">89</span></span>|<span data-ttu-id="45410-1588">ovf. u8</span><span class="sxs-lookup"><span data-stu-id="45410-1588">conv.ovf.u8.un</span></span>|<span data-ttu-id="45410-1589">符号なしの値を`unsigned int64` (として`int64`スタック上で) に変換し、オーバーフロー時に例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1589">Converts an unsigned value to an `unsigned int64` (on the stack as `int64`) and throw an exception on overflow.</span></span>|  
  
 <span data-ttu-id="45410-1590">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1590">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1591">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1591">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1592">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1592">`value` is popped from the stack and the conversion operation is attempted.</span></span> <span data-ttu-id="45410-1593">オーバーフローが発生した場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1593">If overflow occurs, an exception is thrown.</span></span>  
  
3.  <span data-ttu-id="45410-1594">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1594">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1595">オペコード`conv.ovf.u8.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-1595">The `conv.ovf.u8.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1596">値が大きすぎるか小さすぎて対象の型で表すことができない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1596">If the value is too large or too small to be represented by the target type, an exception is thrown.</span></span>  
  
 <span data-ttu-id="45410-1597">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1597">Conversions from floating-point numbers to integer values truncate the number toward zero.</span></span> <span data-ttu-id="45410-1598">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるときにに拡張されることに注意`conv.ovf.i`し`conv.ovf.u`てください (またはが使用されて`native int`いる場合は、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1598">Note that integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.ovf.i` or `conv.ovf.u` are used, in which case the result is also `native int`).</span></span>  
  
 <span data-ttu-id="45410-1599"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1599"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-1600">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.ovf.u8.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1600">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.ovf.u8.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1601">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1601">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1602">評価スタックの一番上の符号なし整数値を <see langword="float32" /> に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-1602">Converts the unsigned integer value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1603">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1603">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1604">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1604">Format</span></span>|<span data-ttu-id="45410-1605">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1605">Assembly Format</span></span>|<span data-ttu-id="45410-1606">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1606">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1607">76</span><span class="sxs-lookup"><span data-stu-id="45410-1607">76</span></span>|<span data-ttu-id="45410-1608">conv</span><span class="sxs-lookup"><span data-stu-id="45410-1608">conv.r.un</span></span>|<span data-ttu-id="45410-1609">符号なし整数を浮動小数点型に`F`変換し、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1609">Convert unsigned integer to floating-point, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1610">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1610">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1611">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1611">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1612">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1612">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1613">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1613">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1614">オペコード`conv.r.un`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1614">The `conv.r.un` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1615">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1615">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1616">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1616">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1617">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1617">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1618">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1618">When converting from a `float64` to a `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1619">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1619">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1620">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1620">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1621">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1621">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1622">浮動小数点型から整数への変換でオーバーフローが発生`result`した場合、返されるは指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1622">If overflow occurs converting a floating-point type to an integer the `result` returned is unspecified.</span></span> <span data-ttu-id="45410-1623">この`conv.r.un`操作は、スタックから整数を取得し、それを符号なしとして解釈し、整数を表す浮動小数点数に置き換えます`float32`。この値が有効桁数が大きい場合、整数を表すのに十分な幅である場合は、それ以外の場合はです。`float64`。</span><span class="sxs-lookup"><span data-stu-id="45410-1623">The `conv.r.un` operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a `float32`, if this is wide enough to represent the integer without loss of precision, or else a `float64`.</span></span>  
  
 <span data-ttu-id="45410-1624">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1624">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="45410-1625">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.r.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1626">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1627">評価スタックの一番上の値を <see langword="float32" /> に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-1627">Converts the value on top of the evaluation stack to <see langword="float32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1628">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1629">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1629">Format</span></span>|<span data-ttu-id="45410-1630">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1630">Assembly Format</span></span>|<span data-ttu-id="45410-1631">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1632">6B</span><span class="sxs-lookup"><span data-stu-id="45410-1632">6B</span></span>|<span data-ttu-id="45410-1633">conv. r4</span><span class="sxs-lookup"><span data-stu-id="45410-1633">conv.r4</span></span>|<span data-ttu-id="45410-1634">をに`float32`変換し`F` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1634">Convert to `float32`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1635">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1636">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1636">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1637">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1637">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1638">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1638">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1639">オペコード`conv.r4`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1639">The `conv.r4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1640">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1640">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1641">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1641">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1642">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1642">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1643">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1643">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1644">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1644">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1645">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1645">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1646">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1646">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1647">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1647">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1648">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1648">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="45410-1649">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.r4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1649">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1650">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1650">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1651">評価スタックの一番上の値を <see langword="float64" /> に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-1651">Converts the value on top of the evaluation stack to <see langword="float64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1652">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1652">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1653">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1653">Format</span></span>|<span data-ttu-id="45410-1654">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1654">Assembly Format</span></span>|<span data-ttu-id="45410-1655">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1655">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1656">6C</span><span class="sxs-lookup"><span data-stu-id="45410-1656">6C</span></span>|<span data-ttu-id="45410-1657">conv. r8</span><span class="sxs-lookup"><span data-stu-id="45410-1657">conv.r8</span></span>|<span data-ttu-id="45410-1658">をに`float64`変換し`F` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1658">Convert to `float64`, pushing `F` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1659">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1659">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1660">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1660">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1661">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1661">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1662">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1662">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1663">オペコード`conv.r8`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1663">The `conv.r8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1664">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1664">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1665">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1665">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1666">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1666">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1667">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1667">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1668">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1668">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1669">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1669">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1670">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1670">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1671">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1671">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1672">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1672">No exceptions are ever thrown when using this field.</span></span>  
  
 <span data-ttu-id="45410-1673">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.r8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1673">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1674">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1674">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1675">評価スタックの一番上の値を <see langword="unsigned native int" /> に変換し、その値を <see langword="native int" /> に拡張します。</span><span class="sxs-lookup"><span data-stu-id="45410-1675">Converts the value on top of the evaluation stack to <see langword="unsigned native int" />, and extends it to <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1676">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1676">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1677">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1677">Format</span></span>|<span data-ttu-id="45410-1678">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1678">Assembly Format</span></span>|<span data-ttu-id="45410-1679">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1679">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1680">E0</span><span class="sxs-lookup"><span data-stu-id="45410-1680">E0</span></span>|<span data-ttu-id="45410-1681">conv</span><span class="sxs-lookup"><span data-stu-id="45410-1681">conv.u</span></span>|<span data-ttu-id="45410-1682">をに`unsigned native int`変換し`native int` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1682">Convert to `unsigned native int`, pushing `native int` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1683">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1683">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1684">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1684">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1685">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1685">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1686">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1686">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1687">オペコード`conv.u`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1687">The `conv.u` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1688">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1688">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1689">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1689">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1690">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1690">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1691">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1691">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1692">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1692">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1693">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1693">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1694">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1694">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1695">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1695">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1696">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1696">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45410-1697">結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1697">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45410-1698">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.u`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1699">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1700">評価スタックの一番上の値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張します。</span><span class="sxs-lookup"><span data-stu-id="45410-1700">Converts the value on top of the evaluation stack to <see langword="unsigned int8" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1701">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1702">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1702">Format</span></span>|<span data-ttu-id="45410-1703">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1703">Assembly Format</span></span>|<span data-ttu-id="45410-1704">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1705">D2</span><span class="sxs-lookup"><span data-stu-id="45410-1705">D2</span></span>|<span data-ttu-id="45410-1706">conv</span><span class="sxs-lookup"><span data-stu-id="45410-1706">conv.u1</span></span>|<span data-ttu-id="45410-1707">をに`int8`変換し`int32` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1707">Convert to `int8`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1708">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1709">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1709">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1710">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1710">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1711">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1711">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1712">オペコード`conv.u1`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1712">The `conv.u1` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1713">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1713">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1714">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1714">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1715">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1715">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1716">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1716">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1717">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1717">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1718">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1718">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1719">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1719">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1720">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1720">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1721">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1721">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45410-1722">結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1722">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45410-1723">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.u1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1723">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1724">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1724">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1725">評価スタックの一番上の値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張します。</span><span class="sxs-lookup"><span data-stu-id="45410-1725">Converts the value on top of the evaluation stack to <see langword="unsigned int16" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1726">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1726">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1727">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1727">Format</span></span>|<span data-ttu-id="45410-1728">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1728">Assembly Format</span></span>|<span data-ttu-id="45410-1729">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1729">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1730">D1</span><span class="sxs-lookup"><span data-stu-id="45410-1730">D1</span></span>|<span data-ttu-id="45410-1731">conv. u2</span><span class="sxs-lookup"><span data-stu-id="45410-1731">conv.u2</span></span>|<span data-ttu-id="45410-1732">をに`int16`変換し`int32` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1732">Convert to `int16`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1733">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1733">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1734">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1734">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1735">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1735">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1736">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1736">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1737">オペコード`conv.u2`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1737">The `conv.u2` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1738">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1738">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1739">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1739">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1740">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1740">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1741">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1741">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1742">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1742">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1743">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1743">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1744">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1744">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1745">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1745">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1746">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1746">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45410-1747">結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1747">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45410-1748">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.u2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1748">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1749">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1749">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1750">評価スタックの一番上の値を <see langword="unsigned int32" /> に変換し、その値を <see langword="int32" /> に拡張します。</span><span class="sxs-lookup"><span data-stu-id="45410-1750">Converts the value on top of the evaluation stack to <see langword="unsigned int32" />, and extends it to <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1751">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1751">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1752">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1752">Format</span></span>|<span data-ttu-id="45410-1753">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1753">Assembly Format</span></span>|<span data-ttu-id="45410-1754">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1754">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1755">6D</span><span class="sxs-lookup"><span data-stu-id="45410-1755">6D</span></span>|<span data-ttu-id="45410-1756">u4</span><span class="sxs-lookup"><span data-stu-id="45410-1756">conv.u4</span></span>|<span data-ttu-id="45410-1757">をに`unsigned int32`変換し`int32` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1757">Convert to `unsigned int32`, pushing `int32` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1758">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1758">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1759">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1759">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1760">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1760">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1761">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1761">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1762">オペコード`conv.u4`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1762">The `conv.u4` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1763">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1763">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1764">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1764">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1765">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1765">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1766">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1766">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1767">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1767">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1768">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1768">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1769">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1769">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1770">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1770">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1771">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1771">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45410-1772">結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1772">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45410-1773">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.u4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1773">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1774">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1774">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1775">評価スタックの一番上の値を <see langword="unsigned int64" /> に変換し、その値を <see langword="int64" /> に拡張します。</span><span class="sxs-lookup"><span data-stu-id="45410-1775">Converts the value on top of the evaluation stack to <see langword="unsigned int64" />, and extends it to <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1776">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1776">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1777">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1777">Format</span></span>|<span data-ttu-id="45410-1778">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1778">Assembly Format</span></span>|<span data-ttu-id="45410-1779">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1779">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1780">6E</span><span class="sxs-lookup"><span data-stu-id="45410-1780">6E</span></span>|<span data-ttu-id="45410-1781">u8</span><span class="sxs-lookup"><span data-stu-id="45410-1781">conv.u8</span></span>|<span data-ttu-id="45410-1782">をに`int64`変換し`int64` 、スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1782">Convert to `int64`, pushing `int64` on stack.</span></span>|  
  
 <span data-ttu-id="45410-1783">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1783">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1784">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1784">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1785">`value`がスタックからポップされ、変換操作が試行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1785">`value` is popped from the stack and the conversion operation is attempted.</span></span>  
  
3.  <span data-ttu-id="45410-1786">変換が成功した場合、結果の値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1786">If the conversion is successful, the resulting value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1787">オペコード`conv.u8`は、スタック`value`の一番上のをオペコードに指定された型に変換し、その値をスタックの一番上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1787">The `conv.u8` opcode converts the `value` on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</span></span> <span data-ttu-id="45410-1788">4バイト未満の整数値は、評価スタック`int32`に読み込まれるときにに拡張されます`conv.i` ( `conv.u`またはが使用されている場合は`native int`、結果もになります)。</span><span class="sxs-lookup"><span data-stu-id="45410-1788">Integer values of less than 4 bytes are extended to `int32` when they are loaded onto the evaluation stack (unless `conv.i` or `conv.u` is used, in which case the result is also `native int`).</span></span> <span data-ttu-id="45410-1789">浮動小数点値は`F`型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1789">Floating-point values are converted to the `F` type.</span></span>  
  
 <span data-ttu-id="45410-1790">浮動小数点数から整数値への変換では、数値が0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1790">Conversion from floating-point numbers to integer values truncates the number toward zero.</span></span> <span data-ttu-id="45410-1791">`float64` から `float32` に変換する場合、有効桁数が失われる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1791">When converting from an `float64` to an `float32`, precision can be lost.</span></span> <span data-ttu-id="45410-1792">が`value`大きすぎてに格納`float32 (F)`できない場合、正の無限`value`大 ( `value`が正の場合) または負の無限大 (が負の場合) が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1792">If `value` is too large to fit in a `float32 (F)`, positive infinity (if `value` is positive) or negative infinity (if `value` is negative) is returned.</span></span> <span data-ttu-id="45410-1793">ある整数型から別の整数型への変換でオーバーフローが発生した場合、上位ビットは切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1793">If overflow occurs converting one integer type to another, the high order bits are truncated.</span></span> <span data-ttu-id="45410-1794">結果がより`int32`小さい場合、値は、スロットを埋めるために符号拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1794">If the result is smaller than an `int32`, the value is sign-extended to fill the slot.</span></span>  
  
 <span data-ttu-id="45410-1795">浮動小数点型から整数への変換でオーバーフローが発生した場合、返される値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1795">If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</span></span>  
  
 <span data-ttu-id="45410-1796">このフィールドを使用する場合、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="45410-1796">No exceptions are ever thrown when using this field.</span></span> <span data-ttu-id="45410-1797">結果<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>の<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>型が結果の値を正しく表すことができない場合に例外をスローする同等の命令については、「」および「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1797">See <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> and <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</span></span>  
  
 <span data-ttu-id="45410-1798">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `conv.u8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1798">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `conv.u8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1799">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1799">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1800">始点アドレスからエンド ポイント アドレスに指定した数のバイトをコピーします。</span><span class="sxs-lookup"><span data-stu-id="45410-1800">Copies a specified number bytes from a source address to a destination address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1801">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1801">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1802">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1802">Format</span></span>|<span data-ttu-id="45410-1803">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1803">Assembly Format</span></span>|<span data-ttu-id="45410-1804">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1804">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1805">FE 17</span><span class="sxs-lookup"><span data-stu-id="45410-1805">FE 17</span></span>|<span data-ttu-id="45410-1806">cpblk</span><span class="sxs-lookup"><span data-stu-id="45410-1806">cpblk</span></span>|<span data-ttu-id="45410-1807">メモリブロック間でデータをコピーします。</span><span class="sxs-lookup"><span data-stu-id="45410-1807">Copy data from one memory block to another.</span></span>|  
  
 <span data-ttu-id="45410-1808">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1808">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1809">宛先アドレスはスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1809">The destination address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1810">ソースアドレスはスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1810">The source address is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-1811">コピーするバイト数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1811">The number of bytes to copy is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-1812">バイト数、送信元アドレス、および宛先アドレスがスタックからポップされます。指定されたバイト数が、転送元アドレスから宛先アドレスにコピーされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1812">The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</span></span>  
  
 <span data-ttu-id="45410-1813">命令`cpblk`は、 `&` `*` `unsigned int32` `&` `native int`送信元アドレス (、、または) から宛先アドレス (型、型、または型) に、バイトの数 (型) をコピーします。 `native int`  `*`</span><span class="sxs-lookup"><span data-stu-id="45410-1813">The `cpblk` instruction copies a number (type `unsigned int32`) of bytes from a source address (of type `*`, `native int`, or `&`) to a destination address (of type `*`, `native int`, or `&`).</span></span> <span data-ttu-id="45410-1814">コピー元と`cpblk`コピー先の領域が重複する場合、の動作は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-1814">The behavior of `cpblk` is unspecified if the source and destination areas overlap.</span></span>  
  
 <span data-ttu-id="45410-1815">`cpblk`送信元と送信先の両方がコンピューターの自然サイズに合わせて配置されていることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="45410-1815">`cpblk` assumes that both the source and destination addressed are aligned to the natural size of the machine.</span></span> <span data-ttu-id="45410-1816">命令は、転送元または転送`unaligned.<prefix>`先のどちらかが整列していないことを示す命令の直前に記述できます。 `cpblk`</span><span class="sxs-lookup"><span data-stu-id="45410-1816">The `cpblk` instruction can be immediately preceded by the `unaligned.<prefix>` instruction to indicate that either the source or the destination is unaligned.</span></span>  
  
 <span data-ttu-id="45410-1817">`cpblk`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1817">The operation of the `cpblk` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-1818"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1818"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-1819">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `cpblk`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1819">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpblk` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1820">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1820">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1821">オブジェクトのアドレス (<see langword="&amp;" />、<see langword="*" />、または <see langword="native int" /> の各型) にある値型をコピー先のオブジェクトのアドレス (<see langword="&amp;" />、<see langword="*" />、または <see langword="native int" /> の各型) にコピーします。</span><span class="sxs-lookup"><span data-stu-id="45410-1821">Copies the value type located at the address of an object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />) to the address of the destination object (type <see langword="&amp;" />, <see langword="*" /> or <see langword="native int" />).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1822">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1822">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1823">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1823">Format</span></span>|<span data-ttu-id="45410-1824">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1824">Assembly Format</span></span>|<span data-ttu-id="45410-1825">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1825">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1826">70 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-1826">70 < `T` ></span></span>|<span data-ttu-id="45410-1827">cpobj`classTok`</span><span class="sxs-lookup"><span data-stu-id="45410-1827">cpobj `classTok`</span></span>|<span data-ttu-id="45410-1828">ソースオブジェクトから変換先オブジェクトに値型をコピーします。</span><span class="sxs-lookup"><span data-stu-id="45410-1828">Copies a value type from a source object to a destination object.</span></span>|  
  
 <span data-ttu-id="45410-1829">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1829">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1830">ターゲットオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1830">The destination object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1831">ソースオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1831">The source object reference is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-1832">2つのオブジェクト参照がスタックからポップされます。ソースオブジェクトのアドレスの値の型が、コピー先のオブジェクトのアドレスにコピーされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1832">The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</span></span>  
  
 <span data-ttu-id="45410-1833">ソースオブジェクトと`cpobj`ターゲットオブジェクトの参照が、クラストークン`classTok` ( `typeref`または`typedef`) によって表されるクラスのインスタンスへのポインターではない場合、また`classTok`はがを表していない場合、の動作は指定されません。値の型。</span><span class="sxs-lookup"><span data-stu-id="45410-1833">The behavior of `cpobj` is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token `classTok` (a `typeref` or `typedef`), or if `classTok` does not represent a value type.</span></span>  
  
 <span data-ttu-id="45410-1834"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1834"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-1835">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `cpobj`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1835">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `cpobj` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1836">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-1836">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1837">2 つの値の除算を実行し、結果を浮動小数点値 (<see langword="F" /> 型) または商 (<see langword="int32" /> 型) として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1837">Divides two values and pushes the result as a floating-point (type <see langword="F" />) or quotient (type <see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1838">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1838">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1839">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1839">Format</span></span>|<span data-ttu-id="45410-1840">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1840">Assembly Format</span></span>|<span data-ttu-id="45410-1841">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1841">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1842">5B</span><span class="sxs-lookup"><span data-stu-id="45410-1842">5B</span></span>|<span data-ttu-id="45410-1843">div</span><span class="sxs-lookup"><span data-stu-id="45410-1843">div</span></span>|<span data-ttu-id="45410-1844">2つの値を除算して、商または浮動小数点の結果を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-1844">Divides two values to return a quotient or floating-point result.</span></span>|  
  
 <span data-ttu-id="45410-1845">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1845">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1846">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1846">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1847">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1847">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-1848">`value2`と`value1`はスタックからポップされます。はによっ`value2`て除算されます。 `value1`</span><span class="sxs-lookup"><span data-stu-id="45410-1848">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="45410-1849">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1849">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1850">`result` = `value1`div value2 は、次の条件を満たしています。</span><span class="sxs-lookup"><span data-stu-id="45410-1850">`result` = `value1` div value2 satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="45410-1851">&#124;`result` &#124; = &#124; / &#124;、および: &#124; &#124; `value1` `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-1851">&#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;, and:</span></span>  
  
 <span data-ttu-id="45410-1852">`value2``value1``value2`sign () = +、`value1`sign () = sign ()、または-、if sign () ~ = sign ()`result`</span><span class="sxs-lookup"><span data-stu-id="45410-1852">sign(`result`) = +, if sign(`value1`) = sign(`value2`), or -, if sign(`value1`) ~= sign(`value2`)</span></span>  
  
 <span data-ttu-id="45410-1853">命令`div`は、結果を計算してスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1853">The `div` instruction computes the result and pushes it on the stack.</span></span>  
  
 <span data-ttu-id="45410-1854">整数除算は0方向に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-1854">Integer division truncates towards zero.</span></span>  
  
 <span data-ttu-id="45410-1855">有限数を0で除算すると、正しい符号付きの無限値が生成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1855">Division of a finite number by zero produces the correctly signed infinite value.</span></span>  
  
 <span data-ttu-id="45410-1856">0をゼロまたは無限大で除算すると、NaN (非数) 値が生成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1856">Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</span></span> <span data-ttu-id="45410-1857">任意の数を無限大で除算すると、ゼロ値が生成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1857">Any number divided by infinity will produce a zero value.</span></span>  
  
 <span data-ttu-id="45410-1858">結果が結果<xref:System.ArithmeticException>の型で表現できない場合、整数演算はをスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-1858">Integral operations throw <xref:System.ArithmeticException> if the result cannot be represented in the result type.</span></span> <span data-ttu-id="45410-1859">これは、が`value1`負の最大値`value2`で、が-1 の場合に発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1859">This can happen if `value1` is the maximum negative value, and `value2` is -1.</span></span>  
  
 <span data-ttu-id="45410-1860">が0の<xref:System.DivideByZeroException>場合`value2` 、整数演算がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1860">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="45410-1861">Intel ベースのプラットフォームでは、( <xref:System.OverflowException> minint div-1) を計算すると、がスローされることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1861">Note that on Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint div -1).</span></span> <span data-ttu-id="45410-1862">浮動小数点演算では、例外がスローされることはありません (代わりに Nan または無限大が生成されます)。</span><span class="sxs-lookup"><span data-stu-id="45410-1862">Floating-point operations never throw an exception (they produce NaNs or infinities instead).</span></span>  
  
 <span data-ttu-id="45410-1863">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `div`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1863">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1864">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1864">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1865">2 つの符号なし整数値を除算し、結果 (<see langword="int32" />) を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1865">Divides two unsigned integer values and pushes the result (<see langword="int32" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1866">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1866">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1867">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1867">Format</span></span>|<span data-ttu-id="45410-1868">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1868">Assembly Format</span></span>|<span data-ttu-id="45410-1869">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1869">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1870">5C</span><span class="sxs-lookup"><span data-stu-id="45410-1870">5C</span></span>|<span data-ttu-id="45410-1871">div. un</span><span class="sxs-lookup"><span data-stu-id="45410-1871">div.un</span></span>|<span data-ttu-id="45410-1872">2つの値を符号なしで除算して商を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-1872">Divides two values, unsigned, returning a quotient.</span></span>|  
  
 <span data-ttu-id="45410-1873">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1873">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1874">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1874">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1875">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1875">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-1876">`value2`と`value1`はスタックからポップされます。はによっ`value2`て除算されます。 `value1`</span><span class="sxs-lookup"><span data-stu-id="45410-1876">`value2` and `value1` are popped from the stack; `value1` is divided by `value2`.</span></span>  
  
4.  <span data-ttu-id="45410-1877">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1877">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1878">命令は`div.un` 、符号なし`value2`整数として`result`取得されたによって除算され、をスタックにプッシュします。 `value1`</span><span class="sxs-lookup"><span data-stu-id="45410-1878">The `div.un` instruction computes `value1` divided by `value2`, both taken as unsigned integers, and pushes the `result` on the stack.</span></span>  
  
 <span data-ttu-id="45410-1879">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `div.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1879">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `div.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1880">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1880">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1881">現在評価スタックの一番上にある値をコピーし、そのコピーを評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-1881">Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1882">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1882">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1883">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1883">Format</span></span>|<span data-ttu-id="45410-1884">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1884">Assembly Format</span></span>|<span data-ttu-id="45410-1885">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1885">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1886">25</span><span class="sxs-lookup"><span data-stu-id="45410-1886">25</span></span>|<span data-ttu-id="45410-1887">dup</span><span class="sxs-lookup"><span data-stu-id="45410-1887">dup</span></span>|<span data-ttu-id="45410-1888">スタックの一番上の値を複製します。</span><span class="sxs-lookup"><span data-stu-id="45410-1888">Duplicates the value on the top of the stack.</span></span>|  
  
 <span data-ttu-id="45410-1889">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1889">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1890">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1890">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1891">`value`複製のためにスタックからポップされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1891">`value` is popped off of the stack for duplication.</span></span>  
  
3.  <span data-ttu-id="45410-1892">`value`はスタックに戻されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1892">`value` is pushed back onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-1893">重複する値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1893">A duplicate value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1894">命令`dup`はスタックの最上位要素を複製し、2つの同一の値をその上に残します。</span><span class="sxs-lookup"><span data-stu-id="45410-1894">The `dup` instruction duplicates the top element of the stack, and leaves two identical values atop it.</span></span>  
  
 <span data-ttu-id="45410-1895">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `dup`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1895">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `dup` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1896">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1896">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1897">例外の <see langword="filter" /> 句から共通言語基盤 (CLI) 例外ハンドラーに制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-1897">Transfers control from the <see langword="filter" /> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1898">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1898">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1899">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1899">Format</span></span>|<span data-ttu-id="45410-1900">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1900">Assembly Format</span></span>|<span data-ttu-id="45410-1901">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1901">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1902">FE 11</span><span class="sxs-lookup"><span data-stu-id="45410-1902">FE 11</span></span>|<span data-ttu-id="45410-1903">endfilter</span><span class="sxs-lookup"><span data-stu-id="45410-1903">endfilter</span></span>|<span data-ttu-id="45410-1904">SEH 例外処理のフィルター句を終了します。</span><span class="sxs-lookup"><span data-stu-id="45410-1904">End filter clause of SEH exception handling.</span></span>|  
  
 <span data-ttu-id="45410-1905">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1905">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1906">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1906">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1907">`value`スタックからポップされます。`endfilter`が実行され、制御が例外ハンドラーに転送されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1907">`value` is popped from the stack; `endfilter` is executed and control is transferred to the exception handler.</span></span>  
  
 <span data-ttu-id="45410-1908">`Value`(型`int32`であり、特定の値のセットの1つである必要があります) は、フィルター句から返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1908">`Value` (which must be of type `int32` and is one of a specific set of values) is returned from the filter clause.</span></span> <span data-ttu-id="45410-1909">次のいずれかである必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1909">It should be one of:</span></span>  
  
-   <span data-ttu-id="45410-1910">`exception_continue_search`(`value` = 0) 例外ハンドラーの検索を続行します。</span><span class="sxs-lookup"><span data-stu-id="45410-1910">`exception_continue_search` (`value` = 0) to continue searching for an exception handler</span></span>  
  
-   <span data-ttu-id="45410-1911">`exception_execute_handler`(`value` = 1) 例外処理の2番目のフェーズを開始します。 finally ブロックは、このフィルター句に関連付けられているハンドラーが見つかるまで実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1911">`exception_execute_handler` (`value` = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</span></span> <span data-ttu-id="45410-1912">検出が完了すると、ハンドラーが実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1912">Upon discovery, the handler is executed.</span></span>  
  
 <span data-ttu-id="45410-1913">その他の整数値は、指定されていない結果を生成します。</span><span class="sxs-lookup"><span data-stu-id="45410-1913">Other integer values will produce unspecified results.</span></span>  
  
 <span data-ttu-id="45410-1914">フィルターのエントリポイントは、メソッドの例外テーブルに示されているように、フィルターのコードブロックの最初の命令である必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1914">The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</span></span> <span data-ttu-id="45410-1915">命令`endfilter`は、フィルターのコードブロックの最後の命令である必要があります (したがって`endfilter` 、1つのフィルターブロックには1つしか存在できません)。</span><span class="sxs-lookup"><span data-stu-id="45410-1915">The `endfilter` instruction must be the last instruction in the filter's code block (hence there can only be one `endfilter` for any single filter block).</span></span> <span data-ttu-id="45410-1916">`endfilter`命令を実行した後、制御は CLI 例外処理機構に論理的に戻ります。</span><span class="sxs-lookup"><span data-stu-id="45410-1916">After executing the `endfilter` instruction, control logically flows back to the CLI exception handling mechanism.</span></span>  
  
 <span data-ttu-id="45410-1917">例外メカニズムを使用する場合を除き、コントロールをフィルターブロックに転送することはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-1917">Control cannot be transferred into a filter block except through the exception mechanism.</span></span> <span data-ttu-id="45410-1918">命令を使用する場合`throw` 、または最後`endfilter`の命令を実行する場合を除き、コントロールをフィルターブロックの外に移動することはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-1918">Control cannot be transferred out of a filter block except through the use of a `throw` instruction or by executing the final `endfilter` instruction.</span></span> <span data-ttu-id="45410-1919">ブロックを`filter`ブロック内`try`に埋め込むことはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-1919">You cannot embed a `try` block within a `filter` block.</span></span> <span data-ttu-id="45410-1920">`filter`ブロック内で例外がスローされると、その例外はインターセプトされ、値`exception_continue_search`0 () が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1920">If an exception is thrown inside the `filter` block, it is intercepted and a value of 0 (`exception_continue_search`) is returned.</span></span>  
  
 <span data-ttu-id="45410-1921">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `endfilter`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1921">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfilter` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1922">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1922">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1923">例外ブロックの <see langword="fault" /> 句または <see langword="finally" /> 句から共通言語基盤 (CLI) 例外ハンドラーに制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-1923">Transfers control from the <see langword="fault" /> or <see langword="finally" /> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1924">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1924">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1925">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1925">Format</span></span>|<span data-ttu-id="45410-1926">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1926">Assembly Format</span></span>|<span data-ttu-id="45410-1927">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1927">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1928">DC</span><span class="sxs-lookup"><span data-stu-id="45410-1928">DC</span></span>|<span data-ttu-id="45410-1929">endfinally</span><span class="sxs-lookup"><span data-stu-id="45410-1929">endfinally</span></span><br /><br /> <span data-ttu-id="45410-1930">endfault</span><span class="sxs-lookup"><span data-stu-id="45410-1930">endfault</span></span>|<span data-ttu-id="45410-1931">例外ブロック`finally`の`fault`句または句を終了します。</span><span class="sxs-lookup"><span data-stu-id="45410-1931">Ends the `finally` or `fault` clause of an exception block.</span></span>|  
  
 <span data-ttu-id="45410-1932">この命令に対するスタック移行の動作はありません。</span><span class="sxs-lookup"><span data-stu-id="45410-1932">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="45410-1933">`Endfinally`と`endfault`は、例外ハンドラーが`finally`呼び出されるまでスタックアンワインドが続行されるように、または`fault`句の末尾を通知します。</span><span class="sxs-lookup"><span data-stu-id="45410-1933">`Endfinally` and `endfault` signal the end of the `finally` or `fault` clause so that stack unwinding can continue until the exception handler is invoked.</span></span> <span data-ttu-id="45410-1934">また`endfinally` は `endfault` 命令は、CLI 例外機構に制御を戻します。</span><span class="sxs-lookup"><span data-stu-id="45410-1934">The `endfinally` or `endfault` instruction transfers control back to the CLI exception mechanism.</span></span> <span data-ttu-id="45410-1935">次に、leave 命令で保護`finally`されたブロックが終了した場合に、チェーン内の次の句を検索します。</span><span class="sxs-lookup"><span data-stu-id="45410-1935">The mechanism then searches for the next `finally` clause in the chain if the protected block was exited with a leave instruction.</span></span> <span data-ttu-id="45410-1936">例外を使用して保護されたブロックが終了した場合、CLI `finally`は`fault`次のまたはを検索します。または、例外処理の最初のパス中に選択された例外ハンドラーを入力します。</span><span class="sxs-lookup"><span data-stu-id="45410-1936">If the protected block was exited with an exception, the CLI will search for the next `finally` or `fault`, or enter the exception handler chosen during the first pass of exception handling.</span></span>  
  
 <span data-ttu-id="45410-1937">命令`endfinally`は、 `finally`ブロック内で構文的にのみ表示される場合があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1937">An `endfinally` instruction might only appear lexically within a `finally` block.</span></span> <span data-ttu-id="45410-1938">命令とは異なり、ブロックが`endfinally`命令で終了する必要はありません。また、ブロック内に`endfinally`必要な数の命令を指定することもできます。 `endfilter`</span><span class="sxs-lookup"><span data-stu-id="45410-1938">Unlike the `endfilter` instruction, there is no requirement that the block end with an `endfinally` instruction, and there can be as many `endfinally` instructions within the block as required.</span></span> <span data-ttu-id="45410-1939">これらの同じ制限は`endfault` 、命令`fault`とブロックにも適用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1939">These same restrictions apply to the `endfault` instruction and the `fault` block.</span></span>  
  
 <span data-ttu-id="45410-1940">例外メカニズムを使用する場合`finally`を除き`fault`、コントロールを (または) ブロックに転送することはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-1940">Control cannot be transferred into a `finally` (or `fault`) block except through the exception mechanism.</span></span> <span data-ttu-id="45410-1941">`finally` `fault`命令を `throw` 使用するか(また `endfault` は) 命令を実行する場合を除き、(または) ブロックから制御を転送することはできません。 `endfinally`</span><span class="sxs-lookup"><span data-stu-id="45410-1941">Control cannot be transferred out of a `finally` (or `fault`) block except through the use of a `throw` instruction or executing the `endfinally` (or `endfault`) instruction.</span></span> <span data-ttu-id="45410-1942">特に`finally` 、(または`fault`) <xref:System.Reflection.Emit.OpCodes.Ret>ブロックを "フォールアウト" したり、 `finally` ( `fault`または) <xref:System.Reflection.Emit.OpCodes.Leave>ブロック内でまたは命令を実行したりすることはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-1942">In particular, you cannot "fall out" of a `finally` (or `fault`) block or to execute a <xref:System.Reflection.Emit.OpCodes.Ret> or <xref:System.Reflection.Emit.OpCodes.Leave> instruction within a `finally` (or `fault`) block.</span></span>  
  
 <span data-ttu-id="45410-1943">`endfault` と `endfinally` の手順はエイリアスであり、同じオペコードに対応していることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-1943">Note that the `endfault` and `endfinally` instructions are aliases - they correspond to the same opcode.</span></span>  
  
 <span data-ttu-id="45410-1944">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `endfinally` (`endfault`) オペコードと`ILGenerator`メソッド<xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>を使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1944">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `endfinally` (`endfault`) opcode, as well as the `ILGenerator` method <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.</span></span>  
  
-   <span data-ttu-id="45410-1945">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1945">ILGenerator.Emit(OpCode)</span></span>  
  
-   <span data-ttu-id="45410-1946">ILGenerator Ceptionblock ()</span><span class="sxs-lookup"><span data-stu-id="45410-1946">ILGenerator.EndExceptionBlock()</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1947">指定したアドレスの指定したメモリ ブロックを指定のサイズと初期値に初期化します。</span><span class="sxs-lookup"><span data-stu-id="45410-1947">Initializes a specified block of memory at a specific address to a given size and initial value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1948">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1948">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1949">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1949">Format</span></span>|<span data-ttu-id="45410-1950">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1950">Assembly Format</span></span>|<span data-ttu-id="45410-1951">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1951">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1952">FE 18</span><span class="sxs-lookup"><span data-stu-id="45410-1952">FE 18</span></span>|<span data-ttu-id="45410-1953">initblk</span><span class="sxs-lookup"><span data-stu-id="45410-1953">initblk</span></span>|<span data-ttu-id="45410-1954">メモリブロック内の各場所を特定の値に設定します。</span><span class="sxs-lookup"><span data-stu-id="45410-1954">Set each location in a block of memory to a given value.</span></span>|  
  
 <span data-ttu-id="45410-1955">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1955">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1956">開始アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1956">A starting address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1957">初期化値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1957">An initialization value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-1958">初期化するバイト数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1958">The number of bytes to initialize is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-1959">バイト数、初期化値、および開始アドレスがスタックからポップされ、その値に従って初期化が実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1959">The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</span></span>  
  
 <span data-ttu-id="45410-1960">命令`initblk`は、指定され`unsigned int32`たアドレス (型、型、 `&`または`*`型`native int`) から始まるバイトの数 () を初期化値 ( `unsigned int8`型) に設定します。</span><span class="sxs-lookup"><span data-stu-id="45410-1960">The `initblk` instruction sets the number (`unsigned int32`) of bytes starting at the specified address (of type `native int`, `&`, or `*`) to the initialization value (of type `unsigned int8`).</span></span> <span data-ttu-id="45410-1961">`initblk`では、開始アドレスがマシンの自然サイズにアラインされることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="45410-1961">`initblk` assumes that the starting address is aligned to the natural size of the machine.</span></span>  
  
 <span data-ttu-id="45410-1962">`initblk`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1962">The operation of the `initblk` instructions can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-1963"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1963"><xref:System.NullReferenceException> may be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-1964">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `initblk`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1964">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initblk` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1965">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-1965">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1966">指定したアドレスにある値型の各フィールドを null 参照または適切なプリミティブ型の 0 に初期化します。</span><span class="sxs-lookup"><span data-stu-id="45410-1966">Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1967">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1967">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1968">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1968">Format</span></span>|<span data-ttu-id="45410-1969">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1969">Assembly Format</span></span>|<span data-ttu-id="45410-1970">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1970">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1971">FE 15 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-1971">FE 15 < `T` ></span></span>|<span data-ttu-id="45410-1972">`initobj` `typeTok`</span><span class="sxs-lookup"><span data-stu-id="45410-1972">`initobj` `typeTok`</span></span>|<span data-ttu-id="45410-1973">値型を初期化します。</span><span class="sxs-lookup"><span data-stu-id="45410-1973">Initializes a value type.</span></span>|  
  
 <span data-ttu-id="45410-1974">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1974">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1975">初期化する値の型のアドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1975">The address of the value type to initialize is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1976">アドレスはスタックからポップされます。指定されたアドレスの値型は、型`typeTok`として初期化されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1976">The address is popped from the stack; the value type at the specified address is initialized as type `typeTok`.</span></span>  
  
 <span data-ttu-id="45410-1977">命令`initobj`は、プッシュされたアドレス (型、型`&`、または`*`型`native int`) によって指定された値型の各フィールドを null 参照または適切なプリミティブ型の0に初期化します。</span><span class="sxs-lookup"><span data-stu-id="45410-1977">The `initobj` instruction initializes each field of the value type specified by the pushed address (of type `native int`, `&`, or `*`) to a null reference or a 0 of the appropriate primitive type.</span></span> <span data-ttu-id="45410-1978">このメソッドが呼び出されると、インスタンスは、コンストラクターメソッドを呼び出すことができる状態になります。</span><span class="sxs-lookup"><span data-stu-id="45410-1978">After this method is called, the instance is ready for a constructor method to be called.</span></span> <span data-ttu-id="45410-1979">が`typeTok`参照型の場合、この命令はの後に`stind.ref`続く`ldnull`場合と同じ効果があります。</span><span class="sxs-lookup"><span data-stu-id="45410-1979">If `typeTok` is a reference type, this instruction has the same effect as `ldnull` followed by `stind.ref`.</span></span>  
  
 <span data-ttu-id="45410-1980">と<xref:System.Reflection.Emit.OpCodes.Newobj>は`initobj`異なり、はコンストラクターメソッドを呼び出しません。</span><span class="sxs-lookup"><span data-stu-id="45410-1980">Unlike <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` does not call the constructor method.</span></span> <span data-ttu-id="45410-1981">`Initobj`は、値型を`newobj`初期化するためのものです。を使用して、オブジェクトの割り当てと初期化を行います。</span><span class="sxs-lookup"><span data-stu-id="45410-1981">`Initobj` is intended for initializing value types, while `newobj` is used to allocate and initialize objects.</span></span>  
  
 <span data-ttu-id="45410-1982">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `initobj`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-1982">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `initobj` opcode:</span></span>  
  
-   <span data-ttu-id="45410-1983">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-1983">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-1984">オブジェクト参照 (<see langword="O" /> 型) が特定のクラスのインスタンスかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="45410-1984">Tests whether an object reference (type <see langword="O" />) is an instance of a particular class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-1985">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-1985">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-1986">形式</span><span class="sxs-lookup"><span data-stu-id="45410-1986">Format</span></span>|<span data-ttu-id="45410-1987">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-1987">Assembly Format</span></span>|<span data-ttu-id="45410-1988">説明</span><span class="sxs-lookup"><span data-stu-id="45410-1988">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-1989">75 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-1989">75 < `T` ></span></span>|<span data-ttu-id="45410-1990">isinst`class`</span><span class="sxs-lookup"><span data-stu-id="45410-1990">isinst `class`</span></span>|<span data-ttu-id="45410-1991">オブジェクト参照がの`class`インスタンスであるかどうかをテストし、null 参照またはそのクラスまたはインターフェイスのインスタンスを返します。</span><span class="sxs-lookup"><span data-stu-id="45410-1991">Tests if an object reference is an instance of `class`, returning either a null reference or an instance of that class or interface.</span></span>|  
  
 <span data-ttu-id="45410-1992">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1992">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-1993">オブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1993">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-1994">オブジェクト参照はスタックからポップされ、渡されたクラスのインスタンスで`class`あるかどうかをテストします。</span><span class="sxs-lookup"><span data-stu-id="45410-1994">The object reference is popped from the stack and tested to see if it is an instance of the class passed in `class`.</span></span>  
  
3.  <span data-ttu-id="45410-1995">結果 (オブジェクト参照または null 参照) がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1995">The result (either an object reference or a null reference) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-1996">`Class`は、必要なクラスを示すメタデータトークンです。</span><span class="sxs-lookup"><span data-stu-id="45410-1996">`Class` is a metadata token indicating the desired class.</span></span> <span data-ttu-id="45410-1997">スタックの一番上にあるオブジェクトのクラスがを`class`実装している場合 (がインターフェイスである場合`class` )、また`class`はの`class`派生クラスである場合 (が通常のクラスの`class`場合)、型にキャストされ、結果がスタックにプッシュされます。が呼び出され<xref:System.Reflection.Emit.OpCodes.Castclass>た場合とまったく同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-1997">If the class of the object on the top of the stack implements `class` (if `class` is an interface) or is a derived class of `class` (if `class` is a regular class) then it is cast to type `class` and the result is pushed on the stack, exactly as though <xref:System.Reflection.Emit.OpCodes.Castclass> had been called.</span></span> <span data-ttu-id="45410-1998">それ以外の場合は、null 参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-1998">Otherwise, a null reference is pushed on the stack.</span></span> <span data-ttu-id="45410-1999">オブジェクト参照自体が null 参照`isinst`の場合は、同様に null 参照が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-1999">If the object reference itself is a null reference, then `isinst` likewise returns a null reference.</span></span>  
  
 <span data-ttu-id="45410-2000"><xref:System.TypeLoadException>クラスが見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2000"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="45410-2001">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2001">This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="45410-2002">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `isinst`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2002">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `isinst` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2003">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-2003">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2004">現在のメソッドを終了し、指定したメソッドにジャンプします。</span><span class="sxs-lookup"><span data-stu-id="45410-2004">Exits current method and jumps to specified method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2005">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2005">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2006">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2006">Format</span></span>|<span data-ttu-id="45410-2007">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2007">Assembly Format</span></span>|<span data-ttu-id="45410-2008">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2008">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2009">27 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-2009">27 < `T` ></span></span>|<span data-ttu-id="45410-2010">jmp`method`</span><span class="sxs-lookup"><span data-stu-id="45410-2010">jmp `method`</span></span>|<span data-ttu-id="45410-2011">現在のメソッドを終了し、指定したメソッドにジャンプします。</span><span class="sxs-lookup"><span data-stu-id="45410-2011">Exit current method and jump to specified method.</span></span>|  
  
 <span data-ttu-id="45410-2012">この命令に対するスタック移行の動作はありません。</span><span class="sxs-lookup"><span data-stu-id="45410-2012">There are no stack transition behaviors for this instruction.</span></span>  
  
 <span data-ttu-id="45410-2013">( `jmp`ジャンプ) 命令は、メソッド参照のメタデータトークン`method`であるによって指定されたメソッドに制御を転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-2013">The `jmp` (jump) instruction transfers control to the method specified by `method`, which is a metadata token for a method reference.</span></span> <span data-ttu-id="45410-2014">現在の引数は、転送先のメソッドに転送されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2014">The current arguments are transferred to the destination method.</span></span>  
  
 <span data-ttu-id="45410-2015">この命令の実行時には、評価スタックが空である必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2015">The evaluation stack must be empty when this instruction is executed.</span></span> <span data-ttu-id="45410-2016">呼び出し規約、宛先アドレスの引数の数と型は、現在のメソッドの引数と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2016">The calling convention, number and type of arguments at the destination address must match that of the current method.</span></span>  
  
 <span data-ttu-id="45410-2017">`jmp`命令は`try`、 `filter` 、、 `finally`  、またはブロックから制御を転送するためには使用できません。 `catch`</span><span class="sxs-lookup"><span data-stu-id="45410-2017">The `jmp` instruction cannot be used to transferred control out of a `try`, `filter`, `catch`, or `finally` block.</span></span>  
  
 <span data-ttu-id="45410-2018">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `jmp`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2018">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `jmp` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2019">ILGenerator (オペコード, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-2019">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2020">指定したインデックス値によって参照される引数をスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2020">Loads an argument (referenced by a specified index value) onto the stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2021">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2021">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2022">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2022">Format</span></span>|<span data-ttu-id="45410-2023">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2023">Assembly Format</span></span>|<span data-ttu-id="45410-2024">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2024">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2025">FE 09 <`unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45410-2025">FE 09 < `unsigned int16` ></span></span>|<span data-ttu-id="45410-2026">ldarg`index`</span><span class="sxs-lookup"><span data-stu-id="45410-2026">ldarg `index`</span></span>|<span data-ttu-id="45410-2027">引数をスタック`index`に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2027">Load argument at `index` onto stack.</span></span>|  
  
 <span data-ttu-id="45410-2028">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2028">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2029">の引数値`index`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2029">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2030">命令`ldarg`は、にインデックスが設定`index`された引数をプッシュします。引数は0以降から評価スタックにインデックスが付けられます。</span><span class="sxs-lookup"><span data-stu-id="45410-2030">The `ldarg` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="45410-2031">`ldarg`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-2031">The `ldarg` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45410-2032">引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-2032">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45410-2033">可変長の引数リストを受け取るプロシージャの場合、命令は`ldarg` 、シグネチャの変数部分に含まれるものではなく、初期の固定引数に対してのみ使用でき<xref:System.Reflection.Emit.OpCodes.Arglist>ます (詳細については、「」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="45410-2033">For procedures that take a variable-length argument list, the `ldarg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="45410-2034">長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2034">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-2035">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2035">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-2036">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2036">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2037">ILGenerator (オペコード、short)</span><span class="sxs-lookup"><span data-stu-id="45410-2037">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2038">インデックス 0 の引数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2038">Loads the argument at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2039">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2039">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2040">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2040">Format</span></span>|<span data-ttu-id="45410-2041">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2041">Assembly Format</span></span>|<span data-ttu-id="45410-2042">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2042">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2043">02</span><span class="sxs-lookup"><span data-stu-id="45410-2043">02</span></span>|<span data-ttu-id="45410-2044">ldarg</span><span class="sxs-lookup"><span data-stu-id="45410-2044">ldarg.0</span></span>|<span data-ttu-id="45410-2045">引数0をスタックに読み込みます</span><span class="sxs-lookup"><span data-stu-id="45410-2045">Load argument 0 onto stack</span></span>|  
  
 <span data-ttu-id="45410-2046">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2046">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2047">インデックス0の引数値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2047">The argument value at index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2048">`ldarg.0`命令は、インデックス0で引数値を読み込むための効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-2048">The `ldarg.0` instruction is an efficient encoding for loading the argument value at index 0.</span></span>  
  
 <span data-ttu-id="45410-2049">命令`ldarg.0`は、0にインデックスが付けられた引数を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2049">The `ldarg.0` instruction pushes the argument indexed at 0 onto the evaluation stack.</span></span> <span data-ttu-id="45410-2050">`ldarg.0`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-2050">The `ldarg.0` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45410-2051">引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-2051">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45410-2052">長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2052">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-2053">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2053">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-2054">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg.0`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2054">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.0` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2055">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2055">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2056">インデックス 1 の引数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2056">Loads the argument at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2057">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2057">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2058">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2058">Format</span></span>|<span data-ttu-id="45410-2059">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2059">Assembly Format</span></span>|<span data-ttu-id="45410-2060">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2060">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2061">03</span><span class="sxs-lookup"><span data-stu-id="45410-2061">03</span></span>|<span data-ttu-id="45410-2062">ldarg</span><span class="sxs-lookup"><span data-stu-id="45410-2062">ldarg.1</span></span>|<span data-ttu-id="45410-2063">引数1をスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2063">Load argument 1 onto stack.</span></span>|  
  
 <span data-ttu-id="45410-2064">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2064">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2065">インデックス1の引数値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2065">The argument value at index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2066">命令`ldarg.1`は、インデックス1で引数値を読み込むための効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-2066">The `ldarg.1` instruction is an efficient encoding for loading the argument value at index 1.</span></span>  
  
 <span data-ttu-id="45410-2067">命令`ldarg.1`は、1にインデックスが付けられた引数を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2067">The `ldarg.1` instruction pushes the argument indexed at 1 onto the evaluation stack.</span></span> <span data-ttu-id="45410-2068">`ldarg.1`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-2068">The `ldarg.1` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45410-2069">引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-2069">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45410-2070">長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2070">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-2071">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2071">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-2072">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg.1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2072">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2073">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2073">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2074">インデックス 2 の引数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2074">Loads the argument at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2075">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2075">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2076">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2076">Format</span></span>|<span data-ttu-id="45410-2077">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2077">Assembly Format</span></span>|<span data-ttu-id="45410-2078">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2078">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2079">04</span><span class="sxs-lookup"><span data-stu-id="45410-2079">04</span></span>|<span data-ttu-id="45410-2080">ldarg</span><span class="sxs-lookup"><span data-stu-id="45410-2080">ldarg.2</span></span>|<span data-ttu-id="45410-2081">引数2をスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2081">Load argument 2 onto stack.</span></span>|  
  
 <span data-ttu-id="45410-2082">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2082">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2083">インデックス2の引数値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2083">The argument value at index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2084">命令`ldarg.2`は、インデックス2で引数値を読み込むための効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-2084">The `ldarg.2` instruction is an efficient encoding for loading the argument value at index 2.</span></span>  
  
 <span data-ttu-id="45410-2085">命令`ldarg.2`は、2にインデックスが付けられた引数を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2085">The `ldarg.2` instruction pushes the argument indexed at 2 onto the evaluation stack.</span></span> <span data-ttu-id="45410-2086">`ldarg.2`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-2086">The `ldarg.2` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45410-2087">引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-2087">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45410-2088">長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2088">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-2089">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2089">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-2090">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg.2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2090">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2091">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2091">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2092">インデックス 3 の引数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2092">Loads the argument at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2093">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2093">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2094">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2094">Format</span></span>|<span data-ttu-id="45410-2095">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2095">Assembly Format</span></span>|<span data-ttu-id="45410-2096">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2096">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2097">05</span><span class="sxs-lookup"><span data-stu-id="45410-2097">05</span></span>|<span data-ttu-id="45410-2098">ldarg</span><span class="sxs-lookup"><span data-stu-id="45410-2098">ldarg.3</span></span>|<span data-ttu-id="45410-2099">引数3をスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2099">Load argument 3 onto stack.</span></span>|  
  
 <span data-ttu-id="45410-2100">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2100">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2101">インデックス3の引数値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2101">The argument value at index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2102">`ldarg.3`命令は、インデックス3で引数値を読み込むための効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-2102">The `ldarg.3` instruction is an efficient encoding for loading the argument value at index 3.</span></span>  
  
 <span data-ttu-id="45410-2103">命令`ldarg.3`は、3にインデックスが付けられた引数を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2103">The `ldarg.3` instruction pushes the argument indexed at 3 onto the evaluation stack.</span></span> <span data-ttu-id="45410-2104">`ldarg.3`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-2104">The `ldarg.3` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45410-2105">引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-2105">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45410-2106">長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2106">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-2107">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2107">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-2108">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg.3`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2108">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.3` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2109">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2109">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2110">指定した短い形式のインデックスによって参照される引数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2110">Loads the argument (referenced by a specified short form index) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2111">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2112">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2112">Format</span></span>|<span data-ttu-id="45410-2113">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2113">Assembly Format</span></span>|<span data-ttu-id="45410-2114">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2115">0E <`unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-2115">0E < `unsigned int8` ></span></span>|<span data-ttu-id="45410-2116">ldarg`index`</span><span class="sxs-lookup"><span data-stu-id="45410-2116">ldarg.s `index`</span></span>|<span data-ttu-id="45410-2117">引数`index`をスタック (短い形式) に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2117">Load argument at `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="45410-2118">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2119">の引数値`index`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2119">The argument value at `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2120">命令`ldarg.s`は、4 ~ 255 のインデックスが付けられた引数を読み込むための効率的なエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2120">The `ldarg.s` instruction is an efficient encoding for loading arguments indexed from 4 through 255.</span></span>  
  
 <span data-ttu-id="45410-2121">命令`ldarg.s`は、にインデックスが設定`index`された引数をプッシュします。引数は0以降から評価スタックにインデックスが付けられます。</span><span class="sxs-lookup"><span data-stu-id="45410-2121">The `ldarg.s` instruction pushes the argument indexed at `index`, where arguments are indexed from 0 onwards, onto the evaluation stack.</span></span> <span data-ttu-id="45410-2122">`ldarg.s`命令を使用すると、入力引数からコピーすることによって、値型またはプリミティブ値をスタックに読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-2122">The `ldarg.s` instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</span></span> <span data-ttu-id="45410-2123">引数の値の型は、現在のメソッドのシグネチャによって指定された引数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-2123">The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</span></span>  
  
 <span data-ttu-id="45410-2124">可変長の引数リストを受け取るプロシージャの場合、命令は`ldarg.s` 、シグネチャの変数部分に含まれるものではなく、初期の固定引数に対してのみ使用でき<xref:System.Reflection.Emit.OpCodes.Arglist>ます (詳細については、「」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="45410-2124">For procedures that take a variable-length argument list, the `ldarg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref:System.Reflection.Emit.OpCodes.Arglist> instruction for more details).</span></span>  
  
 <span data-ttu-id="45410-2125">長さが4バイトより小さい整数値を保持する引数は、スタック`int32`に読み込まれるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2125">Arguments that hold an integer value smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-2126">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2126">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-2127">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarg.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarg.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2128">ILGenerator (オペコード、byte)</span><span class="sxs-lookup"><span data-stu-id="45410-2128">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2129">引数アドレスを評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2129">Load an argument address onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2130">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2131">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2131">Format</span></span>|<span data-ttu-id="45410-2132">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2132">Assembly Format</span></span>|<span data-ttu-id="45410-2133">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2134">FE 0A <`unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45410-2134">FE 0A < `unsigned int16` ></span></span>|<span data-ttu-id="45410-2135">ldarga`index`</span><span class="sxs-lookup"><span data-stu-id="45410-2135">ldarga `index`</span></span>|<span data-ttu-id="45410-2136">によって`index`インデックス付けされた引数のアドレスを取得します。</span><span class="sxs-lookup"><span data-stu-id="45410-2136">Fetch the address of argument indexed by `index`.</span></span>|  
  
 <span data-ttu-id="45410-2137">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2138">によっ`addr`て`index`インデックス付けされた引数のアドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2138">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2139">命令`ldarga`は、によって`index`インデックスが`*`作成された引数のアドレス (型) をフェッチします。引数のインデックスは0以降です。</span><span class="sxs-lookup"><span data-stu-id="45410-2139">The `ldarga` instruction fetches the address (of type `*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="45410-2140">アドレス`addr`は、常にターゲットコンピューターの自然な境界に合わせて調整されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2140">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="45410-2141">可変長の引数リストを受け取るプロシージャの場合、命令は`ldarga` 、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2141">For procedures that take a variable-length argument list, the `ldarga` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="45410-2142">`ldarga`は、ref パラメーターを渡すために使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2142">`ldarga` is used for by-ref parameter passing.</span></span> <span data-ttu-id="45410-2143">その他の場合<xref:System.Reflection.Emit.OpCodes.Ldarg>は<xref:System.Reflection.Emit.OpCodes.Starg> 、とを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2143">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg> and <xref:System.Reflection.Emit.OpCodes.Starg> should be used.</span></span>  
  
 <span data-ttu-id="45410-2144">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarga`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2144">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2145">ILGenerator (オペコード、short)</span><span class="sxs-lookup"><span data-stu-id="45410-2145">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2146">引数アドレス (短い形式) を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2146">Load an argument address, in short form, onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2147">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2147">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2148">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2148">Format</span></span>|<span data-ttu-id="45410-2149">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2149">Assembly Format</span></span>|<span data-ttu-id="45410-2150">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2150">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2151">0F <`unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-2151">0F < `unsigned int8` ></span></span>|<span data-ttu-id="45410-2152">ldarga`index`</span><span class="sxs-lookup"><span data-stu-id="45410-2152">ldarga.s `index`</span></span>|<span data-ttu-id="45410-2153">によって`index`インデックス付けされた引数のアドレスを短縮形でフェッチします。</span><span class="sxs-lookup"><span data-stu-id="45410-2153">Fetch the address of argument indexed by `index`, short form.</span></span>|  
  
 <span data-ttu-id="45410-2154">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2154">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2155">によっ`addr`て`index`インデックス付けされた引数のアドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2155">The address `addr` of the argument indexed by `index` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2156">`ldarga.s`(の`ldarga`短い形式) は、0 ~ 255 の引数の数値に使用する必要があり、より効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-2156">`ldarga.s` (the short form of `ldarga`) should be used for argument numbers 0 through 255, and is a more efficient encoding.</span></span>  
  
 <span data-ttu-id="45410-2157">命令`ldarga.s`は、によって`index`インデックスが`*`作成された引数のアドレス (型) をフェッチします。引数のインデックスは0以降です。</span><span class="sxs-lookup"><span data-stu-id="45410-2157">The `ldarga.s` instruction fetches the address (of type`*`) of the argument indexed by `index`, where arguments are indexed from 0 onwards.</span></span> <span data-ttu-id="45410-2158">アドレス`addr`は、常にターゲットコンピューターの自然な境界に合わせて調整されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2158">The address `addr` is always aligned to a natural boundary on the target machine.</span></span>  
  
 <span data-ttu-id="45410-2159">可変長の引数リストを受け取るプロシージャの場合、命令は`ldarga.s` 、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2159">For procedures that take a variable-length argument list, the `ldarga.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="45410-2160">`ldarga.s`は、ref パラメーターを渡すために使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2160">`ldarga.s` is used for by-ref parameter passing.</span></span> <span data-ttu-id="45410-2161">その他の場合<xref:System.Reflection.Emit.OpCodes.Ldarg_S>は<xref:System.Reflection.Emit.OpCodes.Starg_S> 、とを使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2161">For other cases, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> and <xref:System.Reflection.Emit.OpCodes.Starg_S> should be used.</span></span>  
  
 <span data-ttu-id="45410-2162">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldarga.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2162">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldarga.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2163">ILGenerator (オペコード、byte)</span><span class="sxs-lookup"><span data-stu-id="45410-2163">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2164">提供された <see langword="int32" /> 型の値を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2164">Pushes a supplied value of type <see langword="int32" /> onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2165">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2165">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2166">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2166">Format</span></span>|<span data-ttu-id="45410-2167">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2167">Assembly Format</span></span>|<span data-ttu-id="45410-2168">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2168">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2169">20 <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-2169">20 < `int32` ></span></span>|<span data-ttu-id="45410-2170">ldc i4`num`</span><span class="sxs-lookup"><span data-stu-id="45410-2170">ldc.i4 `num`</span></span>|<span data-ttu-id="45410-2171">値`num`をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2171">Pushes the value `num` onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2172">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2172">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2173">値`num`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2173">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2174">整数-128 ~ 127、特に-1 ~ 8 の短いエンコーディングには、特別な短い (つまり、効率的な) エンコーディングがあることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2174">Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</span></span> <span data-ttu-id="45410-2175">すべての短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2175">All short encodings push 4 byte integers on the stack.</span></span> <span data-ttu-id="45410-2176">長いエンコーディングは、8バイトの整数、4および8バイトの浮動小数点数、および短い形式には適合しない4バイトの値に使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2176">Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</span></span> <span data-ttu-id="45410-2177">8バイトの整数定数をスタックにプッシュするには、3つの方法があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2177">There are three ways to push an 8 byte integer constant onto the stack</span></span>  
  
 1. <span data-ttu-id="45410-2178">32ビット<xref:System.Reflection.Emit.OpCodes.Ldc_I8>を超える定数を表現する必要がある場合は、この命令を使用します。</span><span class="sxs-lookup"><span data-stu-id="45410-2178">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruction for constants that must be expressed in more than 32 bits.</span></span>  
  
 2. <span data-ttu-id="45410-2179">9 ~ <xref:System.Reflection.Emit.OpCodes.Ldc_I4> 32 ビットが必要<xref:System.Reflection.Emit.OpCodes.Conv_I8>な定数には、命令の後にを使用します。</span><span class="sxs-lookup"><span data-stu-id="45410-2179">Use the <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that require 9 to 32 bits.</span></span>  
  
 3. <span data-ttu-id="45410-2180">短い形式の命令を使用して<xref:System.Reflection.Emit.OpCodes.Conv_I8> 、8以下のビットで表現できる定数を指定します。</span><span class="sxs-lookup"><span data-stu-id="45410-2180">Use a short form instruction followed by a <xref:System.Reflection.Emit.OpCodes.Conv_I8> for constants that can be expressed in 8 or fewer bits.</span></span>  
  
 <span data-ttu-id="45410-2181">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2181">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2182">ILGenerator (オペコード, int)</span><span class="sxs-lookup"><span data-stu-id="45410-2182">ILGenerator.Emit(OpCode, int)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2183">整数値 0 を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2183">Pushes the integer value of 0 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2184">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2184">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2185">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2185">Format</span></span>|<span data-ttu-id="45410-2186">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2186">Assembly Format</span></span>|<span data-ttu-id="45410-2187">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2187">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2188">16</span><span class="sxs-lookup"><span data-stu-id="45410-2188">16</span></span>|<span data-ttu-id="45410-2189">ldc. i 4.0</span><span class="sxs-lookup"><span data-stu-id="45410-2189">ldc.i4.0</span></span>|<span data-ttu-id="45410-2190">0をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2190">Pushes 0 onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2191">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2191">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2192">値0はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2192">The value 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2193">これは、整数値0のプッシュに対する特殊な短いエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2193">This is a special short encoding for the push of the integer value 0.</span></span> <span data-ttu-id="45410-2194">すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2194">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45410-2195">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.0`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2195">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.0` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2196">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2196">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2197">整数値 1 を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2197">Pushes the integer value of 1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2198">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2198">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2199">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2199">Format</span></span>|<span data-ttu-id="45410-2200">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2200">Assembly Format</span></span>|<span data-ttu-id="45410-2201">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2201">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2202">17</span><span class="sxs-lookup"><span data-stu-id="45410-2202">17</span></span>|<span data-ttu-id="45410-2203">ldc. i 4.1</span><span class="sxs-lookup"><span data-stu-id="45410-2203">ldc.i4.1</span></span>|<span data-ttu-id="45410-2204">1をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2204">Pushes 1 onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2205">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2205">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2206">値1がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2206">The value 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2207">これは、整数値1をプッシュするための特殊な短いエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2207">This is a special short encoding for the push of the integer value 1.</span></span> <span data-ttu-id="45410-2208">すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2208">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45410-2209">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2209">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2210">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2210">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2211">整数値 2 を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2211">Pushes the integer value of 2 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2212">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2212">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2213">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2213">Format</span></span>|<span data-ttu-id="45410-2214">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2214">Assembly Format</span></span>|<span data-ttu-id="45410-2215">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2215">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2216">18</span><span class="sxs-lookup"><span data-stu-id="45410-2216">18</span></span>|<span data-ttu-id="45410-2217">ldc. i 4.2</span><span class="sxs-lookup"><span data-stu-id="45410-2217">ldc.i4.2</span></span>|<span data-ttu-id="45410-2218">2をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2218">Pushes 2 onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2219">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2219">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2220">値2がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2220">The value 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2221">これは、整数値2のプッシュに対する特殊な短いエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2221">This is a special short encoding for the push of the integer value 2.</span></span> <span data-ttu-id="45410-2222">すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2222">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45410-2223">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2223">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2224">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2224">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2225">整数値 3 を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2225">Pushes the integer value of 3 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2226">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2226">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2227">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2227">Format</span></span>|<span data-ttu-id="45410-2228">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2228">Assembly Format</span></span>|<span data-ttu-id="45410-2229">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2229">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2230">19</span><span class="sxs-lookup"><span data-stu-id="45410-2230">19</span></span>|<span data-ttu-id="45410-2231">ldc. i 4.3</span><span class="sxs-lookup"><span data-stu-id="45410-2231">ldc.i4.3</span></span>|<span data-ttu-id="45410-2232">3をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2232">Pushes 3 onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2233">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2233">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2234">値3がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2234">The value 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2235">これは、整数値3をプッシュするための特殊な短いエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2235">This is a special short encoding for the push of the integer value 3.</span></span> <span data-ttu-id="45410-2236">すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2236">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45410-2237">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.3`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2237">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.3` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2238">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2238">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2239">整数値 4 を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2239">Pushes the integer value of 4 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2240">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2240">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2241">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2241">Format</span></span>|<span data-ttu-id="45410-2242">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2242">Assembly Format</span></span>|<span data-ttu-id="45410-2243">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2243">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2244">Sr-1</span><span class="sxs-lookup"><span data-stu-id="45410-2244">1A</span></span>|<span data-ttu-id="45410-2245">ldc. i 4.4</span><span class="sxs-lookup"><span data-stu-id="45410-2245">ldc.i4.4</span></span>|<span data-ttu-id="45410-2246">4をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2246">Pushes 4 onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2247">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2247">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2248">値4がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2248">The value 4 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2249">これは、整数値4のプッシュに対する特殊な短いエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2249">This is a special short encoding for the push of the integer value 4.</span></span> <span data-ttu-id="45410-2250">すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2250">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45410-2251">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2252">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2252">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2253">整数値 5 を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2253">Pushes the integer value of 5 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2254">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2254">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2255">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2255">Format</span></span>|<span data-ttu-id="45410-2256">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2256">Assembly Format</span></span>|<span data-ttu-id="45410-2257">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2257">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2258">ドル</span><span class="sxs-lookup"><span data-stu-id="45410-2258">1B</span></span>|<span data-ttu-id="45410-2259">ldc. i 4.5</span><span class="sxs-lookup"><span data-stu-id="45410-2259">ldc.i4.5</span></span>|<span data-ttu-id="45410-2260">5をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2260">Pushes 5 onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2261">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2261">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2262">値5がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2262">The value 5 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2263">これは、整数値5をプッシュするための特殊な短いエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2263">This is a special short encoding for the push of the integer value 5.</span></span> <span data-ttu-id="45410-2264">すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2264">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45410-2265">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.5`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2265">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.5` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2266">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2266">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2267">整数値 6 を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2267">Pushes the integer value of 6 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2268">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2268">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2269">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2269">Format</span></span>|<span data-ttu-id="45410-2270">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2270">Assembly Format</span></span>|<span data-ttu-id="45410-2271">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2271">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2272">1C</span><span class="sxs-lookup"><span data-stu-id="45410-2272">1C</span></span>|<span data-ttu-id="45410-2273">ldc. i 4.6</span><span class="sxs-lookup"><span data-stu-id="45410-2273">ldc.i4.6</span></span>|<span data-ttu-id="45410-2274">6をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2274">Pushes 6 onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2275">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2275">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2276">値6がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2276">The value 6 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2277">これは、整数値6のプッシュに対する特殊な短いエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2277">This is a special short encoding for the push of the integer value 6.</span></span> <span data-ttu-id="45410-2278">すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2278">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45410-2279">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.6`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2279">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.6` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2280">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2280">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2281">整数値 7 を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2281">Pushes the integer value of 7 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2282">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2282">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2283">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2283">Format</span></span>|<span data-ttu-id="45410-2284">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2284">Assembly Format</span></span>|<span data-ttu-id="45410-2285">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2285">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2286">引か</span><span class="sxs-lookup"><span data-stu-id="45410-2286">1D</span></span>|<span data-ttu-id="45410-2287">ldc. i 4.7</span><span class="sxs-lookup"><span data-stu-id="45410-2287">ldc.i4.7</span></span>|<span data-ttu-id="45410-2288">7をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2288">Pushes 7 onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2289">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2289">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2290">値7がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2290">The value 7 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2291">これは、整数値7のプッシュに対する特殊な短いエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2291">This is a special short encoding for the push of the integer value 7.</span></span> <span data-ttu-id="45410-2292">すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2292">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45410-2293">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.7`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2293">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.7` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2294">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2294">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2295">整数値 8 を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2295">Pushes the integer value of 8 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2296">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2296">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2297">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2297">Format</span></span>|<span data-ttu-id="45410-2298">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2298">Assembly Format</span></span>|<span data-ttu-id="45410-2299">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2299">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2300">1E</span><span class="sxs-lookup"><span data-stu-id="45410-2300">1E</span></span>|<span data-ttu-id="45410-2301">ldc. i 4.8</span><span class="sxs-lookup"><span data-stu-id="45410-2301">ldc.i4.8</span></span>|<span data-ttu-id="45410-2302">8をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2302">Pushes 8 onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2303">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2303">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2304">値8がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2304">The value 8 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2305">これは、整数値8をプッシュするための特殊な短いエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2305">This is a special short encoding for the push of the integer value 8.</span></span> <span data-ttu-id="45410-2306">すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2306">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45410-2307">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2307">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2308">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2308">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2309">整数値 -1 を <see langword="int32" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2309">Pushes the integer value of -1 onto the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2310">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2310">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2311">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2311">Format</span></span>|<span data-ttu-id="45410-2312">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2312">Assembly Format</span></span>|<span data-ttu-id="45410-2313">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2313">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2314">15</span><span class="sxs-lookup"><span data-stu-id="45410-2314">15</span></span>|<span data-ttu-id="45410-2315">ldc i4</span><span class="sxs-lookup"><span data-stu-id="45410-2315">ldc.i4.m1</span></span>|<span data-ttu-id="45410-2316">-1 をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2316">Pushes -1 onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2317">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2317">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2318">値-1 がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2318">The value -1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2319">これは、整数値-1 をプッシュするための特殊な短いエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-2319">This is a special short encoding for the push of the integer value -1.</span></span> <span data-ttu-id="45410-2320">すべての特殊な短いエンコーディングでは、4バイトの整数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2320">All special short encodings push 4 byte integers on the stack.</span></span>  
  
 <span data-ttu-id="45410-2321">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.m1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2321">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.m1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2322">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2322">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2323">提供された <see langword="int8" /> 値を <see langword="int32" /> として評価スタックにプッシュします (短い形式)。</span><span class="sxs-lookup"><span data-stu-id="45410-2323">Pushes the supplied <see langword="int8" /> value onto the evaluation stack as an <see langword="int32" />, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2324">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2324">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2325">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2325">Format</span></span>|<span data-ttu-id="45410-2326">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2326">Assembly Format</span></span>|<span data-ttu-id="45410-2327">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2327">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2328">1F <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-2328">1F < `int8` ></span></span>|<span data-ttu-id="45410-2329">ldc i4`num`</span><span class="sxs-lookup"><span data-stu-id="45410-2329">ldc.i4.s `num`</span></span>|<span data-ttu-id="45410-2330">`int32`は、短い形式でスタックにプッシュ`num`します。</span><span class="sxs-lookup"><span data-stu-id="45410-2330">Pushes `num` onto the stack as `int32`, short form.</span></span>|  
  
 <span data-ttu-id="45410-2331">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2331">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2332">値`num`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2332">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2333">`ldc.i4.s`は、-128 から127への整数を評価スタックにプッシュするためのより効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-2333">`ldc.i4.s` is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2334">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i4.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2334">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i4.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2335">ILGenerator (オペコード、byte)</span><span class="sxs-lookup"><span data-stu-id="45410-2335">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2336">提供された <see langword="int64" /> 型の値を <see langword="int64" /> として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2336">Pushes a supplied value of type <see langword="int64" /> onto the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2337">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2337">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2338">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2338">Format</span></span>|<span data-ttu-id="45410-2339">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2339">Assembly Format</span></span>|<span data-ttu-id="45410-2340">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2340">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2341">21 <`int64` ></span><span class="sxs-lookup"><span data-stu-id="45410-2341">21 < `int64` ></span></span>|<span data-ttu-id="45410-2342">ldc. i8`num`</span><span class="sxs-lookup"><span data-stu-id="45410-2342">ldc.i8 `num`</span></span>|<span data-ttu-id="45410-2343">を`num`として`int64`スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2343">Pushes `num` onto the stack as `int64`.</span></span>|  
  
 <span data-ttu-id="45410-2344">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2344">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2345">値`num`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2345">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2346">このエンコーディングは`int64` 、値をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2346">This encoding pushes an `int64` value onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2347">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.i8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2347">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2348">ILGenerator (オペコード、long)</span><span class="sxs-lookup"><span data-stu-id="45410-2348">ILGenerator.Emit(OpCode, long)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2349">提供された <see langword="float32" /> 型の値を <see langword="F" /> (float) 型として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2349">Pushes a supplied value of type <see langword="float32" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2350">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2350">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2351">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2351">Format</span></span>|<span data-ttu-id="45410-2352">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2352">Assembly Format</span></span>|<span data-ttu-id="45410-2353">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2353">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2354">22 <`float32` ></span><span class="sxs-lookup"><span data-stu-id="45410-2354">22 < `float32` ></span></span>|<span data-ttu-id="45410-2355">ldc. r4`num`</span><span class="sxs-lookup"><span data-stu-id="45410-2355">ldc.r4 `num`</span></span>|<span data-ttu-id="45410-2356">を`num`として`F`スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2356">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="45410-2357">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2357">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2358">値`num`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2358">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2359">このエンコーディングは`float32` 、値をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2359">This encoding pushes a `float32` value onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2360">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.r4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2360">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2361">ILGenerator (オペコード、single)</span><span class="sxs-lookup"><span data-stu-id="45410-2361">ILGenerator.Emit(OpCode, single)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2362">提供された <see langword="float64" /> 型の値を <see langword="F" /> (float) 型として評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2362">Pushes a supplied value of type <see langword="float64" /> onto the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2363">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2363">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2364">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2364">Format</span></span>|<span data-ttu-id="45410-2365">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2365">Assembly Format</span></span>|<span data-ttu-id="45410-2366">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2366">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2367">23 <`float64` ></span><span class="sxs-lookup"><span data-stu-id="45410-2367">23 < `float64` ></span></span>|<span data-ttu-id="45410-2368">ldc r8`num`</span><span class="sxs-lookup"><span data-stu-id="45410-2368">ldc.r8 `num`</span></span>|<span data-ttu-id="45410-2369">を`num`として`F`スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2369">Pushes `num` onto the stack as `F`.</span></span>|  
  
 <span data-ttu-id="45410-2370">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2370">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2371">値`num`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2371">The value `num` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2372">このエンコーディングは`float64` 、値をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2372">This encoding pushes a `float64` value onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2373">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldc.r8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2373">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldc.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2374">ILGenerator (オペコード、double)</span><span class="sxs-lookup"><span data-stu-id="45410-2374">ILGenerator.Emit(OpCode, double)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2375">指定した配列インデックスの要素を命令で指定された型として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2375">Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2376">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2376">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2377">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2377">Format</span></span>|<span data-ttu-id="45410-2378">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2378">Assembly Format</span></span>|<span data-ttu-id="45410-2379">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2379">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2380">A3 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-2380">A3 < `T` ></span></span>|<span data-ttu-id="45410-2381">ldelem`typeTok`</span><span class="sxs-lookup"><span data-stu-id="45410-2381">ldelem `typeTok`</span></span>|<span data-ttu-id="45410-2382">の要素`index`を、型`typeTok`としてスタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2382">Loads the element at `index` onto the top of the stack as type `typeTok`.</span></span>|  
  
 <span data-ttu-id="45410-2383">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2383">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2384">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2384">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2385">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2385">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2386">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2386">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2387">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2387">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2388">命令`ldelem`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2388">The `ldelem` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2389">配列はオブジェクトであり、したがって型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2389">Arrays are objects, and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2390">戻り値の型は、命令のトークン`typeTok`によって指定されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2390">The type of the return value is specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="45410-2391"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2391"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2392"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`上限より大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2392"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the upper bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2393">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2393">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2394">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-2394">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2395">指定した配列インデックスの <see langword="native int" /> 型の要素を <see langword="native int" /> として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2395">Loads the element with type <see langword="native int" /> at a specified array index onto the top of the evaluation stack as a <see langword="native int" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2396">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2396">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2397">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2397">Format</span></span>|<span data-ttu-id="45410-2398">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2398">Assembly Format</span></span>|<span data-ttu-id="45410-2399">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2399">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2400">97</span><span class="sxs-lookup"><span data-stu-id="45410-2400">97</span></span>|<span data-ttu-id="45410-2401">ldelem. i</span><span class="sxs-lookup"><span data-stu-id="45410-2401">ldelem.i</span></span>|<span data-ttu-id="45410-2402">の`native int` 型 `native int` の要素をとしてスタックの一番上に読み込みます `index`  。</span><span class="sxs-lookup"><span data-stu-id="45410-2402">Loads the element with type `native int` at `index` onto the top of the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="45410-2403">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2403">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2404">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2404">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2405">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2405">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2406">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2406">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2407">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2407">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2408">命令`ldelem.i`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2408">The `ldelem.i` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2409">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2409">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2410">の`ldelem.i`戻り値は`native int`です。</span><span class="sxs-lookup"><span data-stu-id="45410-2410">The return value for `ldelem.i` is `native int`.</span></span>  
  
 <span data-ttu-id="45410-2411">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2411">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2412"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2412"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2413"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2413"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2414"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2414"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2415">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.i`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2415">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2416">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2416">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2417">指定した配列インデックスの <see langword="int8" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2417">Loads the element with type <see langword="int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2418">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2418">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2419">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2419">Format</span></span>|<span data-ttu-id="45410-2420">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2420">Assembly Format</span></span>|<span data-ttu-id="45410-2421">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2421">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2422">90</span><span class="sxs-lookup"><span data-stu-id="45410-2422">90</span></span>|<span data-ttu-id="45410-2423">ldelem. i1</span><span class="sxs-lookup"><span data-stu-id="45410-2423">ldelem.i1</span></span>|<span data-ttu-id="45410-2424">の型`int8` `int32`の要素をとしてスタックの一番上に読み込みます。 `index`</span><span class="sxs-lookup"><span data-stu-id="45410-2424">Loads the element with type `int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2425">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2425">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2426">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2426">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2427">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2427">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2428">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2428">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2429">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2429">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2430">命令`ldelem.i1`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2430">The `ldelem.i1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2431">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2431">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2432">の`ldelem.i1`戻り値は`int8`です。</span><span class="sxs-lookup"><span data-stu-id="45410-2432">The return value for `ldelem.i1` is `int8`.</span></span>  
  
 <span data-ttu-id="45410-2433">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2433">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2434"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2434"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2435"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2435"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2436"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2436"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2437">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.i1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2437">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2438">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2438">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2439">指定した配列インデックスの <see langword="int16" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2439">Loads the element with type <see langword="int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2440">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2440">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2441">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2441">Format</span></span>|<span data-ttu-id="45410-2442">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2442">Assembly Format</span></span>|<span data-ttu-id="45410-2443">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2443">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2444">92</span><span class="sxs-lookup"><span data-stu-id="45410-2444">92</span></span>|<span data-ttu-id="45410-2445">ldelem. i2</span><span class="sxs-lookup"><span data-stu-id="45410-2445">ldelem.i2</span></span>|<span data-ttu-id="45410-2446">の型`int16` `int32`の要素をとしてスタックの一番上に読み込みます。 `index`</span><span class="sxs-lookup"><span data-stu-id="45410-2446">Loads the element with type `int16` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2447">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2447">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2448">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2448">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2449">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2449">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2450">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2450">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2451">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2451">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2452">命令`ldelem.i2`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2452">The `ldelem.i2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2453">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2453">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2454">の`ldelem.i2`戻り値は`int16`です。</span><span class="sxs-lookup"><span data-stu-id="45410-2454">The return value for `ldelem.i2` is `int16`.</span></span>  
  
 <span data-ttu-id="45410-2455">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2455">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2456"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2456"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2457"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2457"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2458"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2458"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2459">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.i2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2460">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2460">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2461">指定した配列インデックスの <see langword="int32" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2461">Loads the element with type <see langword="int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2462">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2462">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2463">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2463">Format</span></span>|<span data-ttu-id="45410-2464">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2464">Assembly Format</span></span>|<span data-ttu-id="45410-2465">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2466">94</span><span class="sxs-lookup"><span data-stu-id="45410-2466">94</span></span>|<span data-ttu-id="45410-2467">ldelem. i4</span><span class="sxs-lookup"><span data-stu-id="45410-2467">ldelem.i4</span></span>|<span data-ttu-id="45410-2468">の型`int32` `int32`の要素をとしてスタックの一番上に読み込みます。 `index`</span><span class="sxs-lookup"><span data-stu-id="45410-2468">Loads the element with type `int32` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2469">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2470">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2470">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2471">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2471">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2472">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2472">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2473">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2473">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2474">命令`ldelem.i4`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2474">The `ldelem.i4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2475">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2475">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2476">の`ldelem.i4`戻り値は`int32`です。</span><span class="sxs-lookup"><span data-stu-id="45410-2476">The return value for `ldelem.i4` is `int32`.</span></span>  
  
 <span data-ttu-id="45410-2477">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2477">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2478"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2478"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2479"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2479"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2480"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2480"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2481">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.i4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2481">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2482">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2482">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2483">指定した配列インデックスの <see langword="int64" /> 型の要素を <see langword="int64" /> として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2483">Loads the element with type <see langword="int64" /> at a specified array index onto the top of the evaluation stack as an <see langword="int64" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2484">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2484">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2485">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2485">Format</span></span>|<span data-ttu-id="45410-2486">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2486">Assembly Format</span></span>|<span data-ttu-id="45410-2487">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2487">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2488">96</span><span class="sxs-lookup"><span data-stu-id="45410-2488">96</span></span>|<span data-ttu-id="45410-2489">ldelem. i8</span><span class="sxs-lookup"><span data-stu-id="45410-2489">ldelem.i8</span></span>|<span data-ttu-id="45410-2490">の型`int64` `int64`の要素をとしてスタックの一番上に読み込みます。 `index`</span><span class="sxs-lookup"><span data-stu-id="45410-2490">Loads the element with type `int64` at `index` onto the top of the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="45410-2491">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2491">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2492">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2492">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2493">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2493">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2494">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2494">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2495">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2495">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2496">命令`ldelem.i8`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2496">The `ldelem.i8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2497">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2497">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2498">の`ldelem.i8`戻り値は`int64`です。</span><span class="sxs-lookup"><span data-stu-id="45410-2498">The return value for `ldelem.i8` is `int64`.</span></span>  
  
 <span data-ttu-id="45410-2499">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2499">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2500"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2500"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2501"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2501"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2502"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2502"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2503">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.i8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2503">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2504">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2504">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2505">指定した配列インデックスの <see langword="float32" /> 型の要素を <see langword="F" /> (float) 型として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2505">Loads the element with type <see langword="float32" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2506">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2506">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2507">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2507">Format</span></span>|<span data-ttu-id="45410-2508">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2508">Assembly Format</span></span>|<span data-ttu-id="45410-2509">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2509">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2510">98</span><span class="sxs-lookup"><span data-stu-id="45410-2510">98</span></span>|<span data-ttu-id="45410-2511">ldelem r4</span><span class="sxs-lookup"><span data-stu-id="45410-2511">ldelem.r4</span></span>|<span data-ttu-id="45410-2512">の型`float32` `F`の要素を、型としてスタックの一番上に読み込みます。 `index`</span><span class="sxs-lookup"><span data-stu-id="45410-2512">Loads the element with type `float32` at `index` onto the top of the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="45410-2513">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2513">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2514">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2514">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2515">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2515">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2516">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2516">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2517">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2517">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2518">命令`ldelem.r4`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2518">The `ldelem.r4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2519">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2519">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2520">の`ldelem.r4`戻り値は`float32`です。</span><span class="sxs-lookup"><span data-stu-id="45410-2520">The return value for `ldelem.r4` is `float32`.</span></span>  
  
 <span data-ttu-id="45410-2521">浮動小数点値は、評価スタック`F`に読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2521">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2522"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2522"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2523"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2523"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2524"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2524"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2525">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.r4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2525">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2526">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2526">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2527">指定した配列インデックスの <see langword="float64" /> 型の要素を <see langword="F" /> (float) 型として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2527">Loads the element with type <see langword="float64" /> at a specified array index onto the top of the evaluation stack as type <see langword="F" /> (float).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2528">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2528">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2529">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2529">Format</span></span>|<span data-ttu-id="45410-2530">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2530">Assembly Format</span></span>|<span data-ttu-id="45410-2531">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2531">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2532">99</span><span class="sxs-lookup"><span data-stu-id="45410-2532">99</span></span>|<span data-ttu-id="45410-2533">ldelem r8</span><span class="sxs-lookup"><span data-stu-id="45410-2533">ldelem.r8</span></span>|<span data-ttu-id="45410-2534">の型`float64` `F`の要素を、型としてスタックの一番上に読み込みます。 `index`</span><span class="sxs-lookup"><span data-stu-id="45410-2534">Loads the element with type `float64` at `index` onto the top of the stack as type `F`.</span></span>|  
  
 <span data-ttu-id="45410-2535">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2535">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2536">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2536">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2537">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2537">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2538">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2538">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2539">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2539">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2540">命令`ldelem.r8`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2540">The `ldelem.r8` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2541">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2541">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2542">の`ldelem.r8`戻り値は`float64`です。</span><span class="sxs-lookup"><span data-stu-id="45410-2542">The return value for `ldelem.r8` is `float64`.</span></span>  
  
 <span data-ttu-id="45410-2543">浮動小数点値は、評価スタック`F`に読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2543">Floating-point values are converted to type `F` when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2544"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2544"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2545"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2545"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2546"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2546"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2547">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.r8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2547">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2548">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2548">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2549">指定した配列インデックスのオブジェクト参照を格納している要素を <see langword="O" /> 型 (オブジェクト参照) として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2549">Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <see langword="O" /> (object reference).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2550">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2550">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2551">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2551">Format</span></span>|<span data-ttu-id="45410-2552">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2552">Assembly Format</span></span>|<span data-ttu-id="45410-2553">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2553">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2554">9A-z</span><span class="sxs-lookup"><span data-stu-id="45410-2554">9A</span></span>|<span data-ttu-id="45410-2555">ldelem. ref</span><span class="sxs-lookup"><span data-stu-id="45410-2555">ldelem.ref</span></span>|<span data-ttu-id="45410-2556">のオブジェクト参照`index`を持つ要素を、型`O`としてスタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2556">Loads the element with an object reference at `index` onto the top of the stack as type `O`.</span></span>|  
  
 <span data-ttu-id="45410-2557">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2557">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2558">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2558">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2559">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2559">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2560">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2560">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2561">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2561">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2562">命令`ldelem.ref`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2562">The `ldelem.ref` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2563">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2563">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2564">の`ldelem.ref`戻り値は、型`O` (オブジェクト参照) です。</span><span class="sxs-lookup"><span data-stu-id="45410-2564">The return value for `ldelem.ref` is type `O` (object reference).</span></span>  
  
 <span data-ttu-id="45410-2565"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2565"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2566"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2566"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2567"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2567"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2568">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.ref`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2568">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2569">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2569">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2570">指定した配列インデックスの <see langword="unsigned int8" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2570">Loads the element with type <see langword="unsigned int8" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2571">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2571">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2572">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2572">Format</span></span>|<span data-ttu-id="45410-2573">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2573">Assembly Format</span></span>|<span data-ttu-id="45410-2574">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2574">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2575">91</span><span class="sxs-lookup"><span data-stu-id="45410-2575">91</span></span>|<span data-ttu-id="45410-2576">ldelem u1</span><span class="sxs-lookup"><span data-stu-id="45410-2576">ldelem.u1</span></span>|<span data-ttu-id="45410-2577">の型`unsigned int8` `int32`の要素をとしてスタックの一番上に読み込みます。 `index`</span><span class="sxs-lookup"><span data-stu-id="45410-2577">Loads the element with type `unsigned int8` at `index` onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2578">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2578">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2579">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2579">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2580">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2580">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2581">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2581">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2582">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2582">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2583">命令`ldelem.u1`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2583">The `ldelem.u1` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2584">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2584">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2585">の`ldelem.u1`戻り値は`int8`です。</span><span class="sxs-lookup"><span data-stu-id="45410-2585">The return value for `ldelem.u1` is `int8`.</span></span>  
  
 <span data-ttu-id="45410-2586">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2586">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2587"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2587"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2588"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2588"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2589"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2589"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2590">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.u1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2590">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2591">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2591">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2592">指定した配列インデックスの <see langword="unsigned int16" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2592">Loads the element with type <see langword="unsigned int16" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2593">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2593">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2594">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2594">Format</span></span>|<span data-ttu-id="45410-2595">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2595">Assembly Format</span></span>|<span data-ttu-id="45410-2596">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2596">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2597">93</span><span class="sxs-lookup"><span data-stu-id="45410-2597">93</span></span>|<span data-ttu-id="45410-2598">ldelem. u2</span><span class="sxs-lookup"><span data-stu-id="45410-2598">ldelem.u2</span></span>|<span data-ttu-id="45410-2599">インデックスの型`unsigned int16`の要素を`int32`としてスタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2599">Loads the element with type `unsigned int16` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2600">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2600">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2601">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2601">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2602">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2602">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2603">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2603">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2604">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2604">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2605">命令`ldelem.u2`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2605">The `ldelem.u2` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2606">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2606">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2607">の`ldelem.u2`戻り値は`int16`です。</span><span class="sxs-lookup"><span data-stu-id="45410-2607">The return value for `ldelem.u2` is `int16`.</span></span>  
  
 <span data-ttu-id="45410-2608">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2608">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2609"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2609"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2610"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2610"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2611"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2611"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2612">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.u2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2612">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2613">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2613">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2614">指定した配列インデックスの <see langword="unsigned int32" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2614">Loads the element with type <see langword="unsigned int32" /> at a specified array index onto the top of the evaluation stack as an <see langword="int32" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2615">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2615">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2616">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2616">Format</span></span>|<span data-ttu-id="45410-2617">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2617">Assembly Format</span></span>|<span data-ttu-id="45410-2618">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2618">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2619">95</span><span class="sxs-lookup"><span data-stu-id="45410-2619">95</span></span>|<span data-ttu-id="45410-2620">ldelem. u4</span><span class="sxs-lookup"><span data-stu-id="45410-2620">ldelem.u4</span></span>|<span data-ttu-id="45410-2621">インデックスの型`unsigned int32`の要素を`int32`としてスタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2621">Loads the element with type `unsigned int32` at index onto the top of the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2622">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2622">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2623">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2623">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2624">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2624">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2625">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されている値が検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2625">`index` and `array` are popped from the stack; the value stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2626">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2626">The value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2627">命令`ldelem.u4`は、0から始まる1次元配列`array`内`index`の index `native int`(型) を持つ要素の値を読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2627">The `ldelem.u4` instruction loads the value of the element with index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2628">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2628">Arrays are objects and hence represented by a value of type `O`.</span></span>  
  
 <span data-ttu-id="45410-2629">の`ldelem.u4`戻り値は`int32`です。</span><span class="sxs-lookup"><span data-stu-id="45410-2629">The return value for `ldelem.u4` is `int32`.</span></span>  
  
 <span data-ttu-id="45410-2630">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2630">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2631"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2631"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2632"><xref:System.ArrayTypeMismatchException>は、配列が必要な型の要素を保持していない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2632"><xref:System.ArrayTypeMismatchException> is thrown if array does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2633"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2633"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2634">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelem.u4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2634">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelem.u4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2635">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2635">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2636">指定した配列インデックスにある配列要素のアドレスを <see langword="&amp;" /> 型 (マネージド ポインター) として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2636">Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <see langword="&amp;" /> (managed pointer).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2637">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2637">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2638">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2638">Format</span></span>|<span data-ttu-id="45410-2639">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2639">Assembly Format</span></span>|<span data-ttu-id="45410-2640">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2640">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2641">8F <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-2641">8F < `T` ></span></span>|<span data-ttu-id="45410-2642">ldelema`class`</span><span class="sxs-lookup"><span data-stu-id="45410-2642">ldelema `class`</span></span>|<span data-ttu-id="45410-2643">の`index`配列要素のアドレスを型`&` (マネージポインター) として評価スタックの一番上に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2643">Loads the address of the array element at `index` onto the top of the evaluation stack as type `&` (managed pointer).</span></span>|  
  
 <span data-ttu-id="45410-2644">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2644">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2645">オブジェクト参照`array`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2645">An object reference `array` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2646">インデックス値`index`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2646">An index value `index` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-2647">`index`と`array`はスタックからポップされ、の`array`位置`index`に格納されているアドレスが検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2647">`index` and `array` are popped from the stack; the address stored at position `index` in `array` is looked up.</span></span>  
  
4.  <span data-ttu-id="45410-2648">アドレスはスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2648">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2649">は`ldelema` 、オブジェクトの配列 (型`class`) の特定のインデックス位置にあるオブジェクトのアドレスを取得するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2649">The `ldelema` is used to retrieve the address of an object at a particular index in an array of objects (of type `class`).</span></span> <span data-ttu-id="45410-2650">命令`ldelema`は、0から始まる1次元配列`array`の`index`インデックス ( `native int`型) に値のアドレスを読み込み、スタックの一番上に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-2650">The `ldelema` instruction loads the address of the value at index `index` (type `native int`) in the zero-based one-dimensional array `array` and places it on the top of the stack.</span></span> <span data-ttu-id="45410-2651">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2651">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-2652">この値は、命令で`class`渡された型である必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2652">The value must be of type `class` passed with the instruction.</span></span>  
  
 <span data-ttu-id="45410-2653">の`ldelema`戻り値はマネージポインター (型`&`) です。</span><span class="sxs-lookup"><span data-stu-id="45410-2653">The return value for `ldelema` is a managed pointer (type `&`).</span></span>  
  
 <span data-ttu-id="45410-2654">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2654">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2655"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2655"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-2656"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2656"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-2657"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2657"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-2658">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldelema`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2658">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldelema` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2659">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-2659">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2660">参照が現在評価スタック上にあるオブジェクト内のフィールドの値を検索します。</span><span class="sxs-lookup"><span data-stu-id="45410-2660">Finds the value of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2661">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2661">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2662">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2662">Format</span></span>|<span data-ttu-id="45410-2663">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2663">Assembly Format</span></span>|<span data-ttu-id="45410-2664">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2664">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2665">7B <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-2665">7B < `T` ></span></span>|<span data-ttu-id="45410-2666">ldfld`field`</span><span class="sxs-lookup"><span data-stu-id="45410-2666">ldfld `field`</span></span>|<span data-ttu-id="45410-2667">指定したオブジェクトのフィールドの値をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2667">Pushes the value of a field in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2668">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2668">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2669">オブジェクト参照 (またはポインター) がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2669">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2670">オブジェクト参照 (またはポインター) がスタックからポップされます。オブジェクト内の指定されたフィールドの値が見つかりました。</span><span class="sxs-lookup"><span data-stu-id="45410-2670">The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="45410-2671">フィールドに格納されている値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2671">The value stored in the field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2672">命令`ldfld`は、オブジェクトにあるフィールドの値をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2672">The `ldfld` instruction pushes the value of a field located in an object onto the stack.</span></span> <span data-ttu-id="45410-2673">オブジェクトは、 `O`オブジェクト参照 (型)、マネージポインター (型`&`)、アンマネージポインター ( `native int`型)、遷移ポインター (型`*`)、または値型のインスタンスとしてスタック上にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2673">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="45410-2674">アンマネージポインターを使用することは、検証可能なコードでは許可されていません。</span><span class="sxs-lookup"><span data-stu-id="45410-2674">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="45410-2675">オブジェクトのフィールドは、フィールドメンバーを参照する必要があるメタデータトークンによって指定されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2675">The object's field is specified by a metadata token that must refer to a field member.</span></span> <span data-ttu-id="45410-2676">戻り値の型は、フィールドに関連付けられているものと同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-2676">The return type is the same as the one associated with the field.</span></span> <span data-ttu-id="45410-2677">フィールドは、インスタンスフィールド (この場合は、オブジェクトを null 参照にすることはできません) または静的フィールドのいずれかになります。</span><span class="sxs-lookup"><span data-stu-id="45410-2677">The field may be either an instance field (in which case the object must not be a null reference) or a static field.</span></span>  
  
 <span data-ttu-id="45410-2678">命令`ldfld`の前に、プレフィックス<xref:System.Reflection.Emit.OpCodes.Unaligned>と<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックスのどちらかまたは両方を付けることができます。</span><span class="sxs-lookup"><span data-stu-id="45410-2678">The `ldfld` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="45410-2679"><xref:System.NullReferenceException>オブジェクトが null で、フィールドが静的でない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2679"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="45410-2680"><xref:System.MissingFieldException>指定したフィールドがメタデータ内に見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2680"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="45410-2681">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2681">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="45410-2682">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldfld`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2682">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldfld` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2683">ILGenerator (オペコード、FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-2683">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2684">参照が現在評価スタック上にあるオブジェクト内のフィールドのアドレスを検索します。</span><span class="sxs-lookup"><span data-stu-id="45410-2684">Finds the address of a field in the object whose reference is currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2685">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2685">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2686">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2686">Format</span></span>|<span data-ttu-id="45410-2687">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2687">Assembly Format</span></span>|<span data-ttu-id="45410-2688">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2688">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2689">7C <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-2689">7C < `T` ></span></span>|<span data-ttu-id="45410-2690">ldflda`field`</span><span class="sxs-lookup"><span data-stu-id="45410-2690">ldflda `field`</span></span>|<span data-ttu-id="45410-2691">指定したオブジェクト`field`ののアドレスをスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2691">Pushes the address of `field` in a specified object onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-2692">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2692">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2693">オブジェクト参照 (またはポインター) がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2693">An object reference (or pointer) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2694">オブジェクト参照 (またはポインター) がスタックからポップされます。オブジェクト内の指定されたフィールドのアドレスが見つかりました。</span><span class="sxs-lookup"><span data-stu-id="45410-2694">The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</span></span>  
  
3.  <span data-ttu-id="45410-2695">指定されたフィールドのアドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2695">The address of the specified field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2696">命令`ldflda`は、オブジェクトにあるフィールドのアドレスをスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2696">The `ldflda` instruction pushes the address of a field located in an object onto the stack.</span></span> <span data-ttu-id="45410-2697">オブジェクトは、 `O`オブジェクト参照 (型)、マネージポインター (型`&`)、アンマネージポインター ( `native int`型)、遷移ポインター (型`*`)、または値型のインスタンスとしてスタック上にある必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2697">The object must be on the stack as an object reference (type `O`), a managed pointer (type `&`), an unmanaged pointer (type `native int`), a transient pointer (type `*`), or an instance of a value type.</span></span> <span data-ttu-id="45410-2698">アンマネージポインターを使用することは、検証可能なコードでは許可されていません。</span><span class="sxs-lookup"><span data-stu-id="45410-2698">The use of an unmanaged pointer is not permitted in verifiable code.</span></span> <span data-ttu-id="45410-2699">オブジェクトのフィールドは、フィールドメンバーを参照する必要があるメタデータトークンによって指定されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2699">The object's field is specified by a metadata token that must refer to a field member.</span></span>  
  
 <span data-ttu-id="45410-2700">によって`ldflda`返される値は、オブジェクトが`&`アンマネージポインターとしてスタックにプッシュされない限り、マネージポインター (型) です。この場合、戻りアドレスも`native int`アンマネージポインター (型) になります。</span><span class="sxs-lookup"><span data-stu-id="45410-2700">The value returned by `ldflda` is a managed pointer (type `&`) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type `native int`).</span></span>  
  
 <span data-ttu-id="45410-2701">命令`ldflda`の前に、プレフィックス<xref:System.Reflection.Emit.OpCodes.Unaligned>と<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックスのどちらかまたは両方を付けることができます。</span><span class="sxs-lookup"><span data-stu-id="45410-2701">The `ldflda` instruction can be preceded by either or both of the <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile> prefixes.</span></span>  
  
 <span data-ttu-id="45410-2702"><xref:System.InvalidOperationException>オブジェクトがアクセス元のアプリケーションドメイン内にない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2702"><xref:System.InvalidOperationException> is thrown if the object is not within the application domain from which it is being accessed.</span></span> <span data-ttu-id="45410-2703">アクセスしているアプリケーションドメインに含まれていないフィールドのアドレスを読み込むことができません。</span><span class="sxs-lookup"><span data-stu-id="45410-2703">The address of a field that is not inside the accessing application domain cannot be loaded.</span></span>  
  
 <span data-ttu-id="45410-2704"><xref:System.NullReferenceException>オブジェクトが null で、フィールドが静的でない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2704"><xref:System.NullReferenceException> is thrown if the object is null and the field is not static.</span></span>  
  
 <span data-ttu-id="45410-2705"><xref:System.MissingFieldException>指定したフィールドがメタデータ内に見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2705"><xref:System.MissingFieldException> is thrown if the specified field is not found in the metadata.</span></span> <span data-ttu-id="45410-2706">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2706">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="45410-2707">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldflda`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2707">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldflda` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2708">ILGenerator (オペコード、FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-2708">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2709">特定のメソッドを実装しているネイディブ コードへのアンマネージ ポインター (<see langword="native int" /> 型) を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2709">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a specific method onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2710">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2710">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2711">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2711">Format</span></span>|<span data-ttu-id="45410-2712">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2712">Assembly Format</span></span>|<span data-ttu-id="45410-2713">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2713">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2714">FE 06 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-2714">FE 06 < `T` ></span></span>|<span data-ttu-id="45410-2715">ldftn`method`</span><span class="sxs-lookup"><span data-stu-id="45410-2715">ldftn `method`</span></span>|<span data-ttu-id="45410-2716">スタック上のによって`method`参照されるメソッドへのポインターをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2716">Pushes a pointer to a method referenced by `method` on the stack.</span></span>|  
  
 <span data-ttu-id="45410-2717">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2717">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2718">特定のメソッドへのアンマネージポインターがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2718">The unmanaged pointer to a specific method is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2719">特定のメソッド (`method`) は、マネージメソッド ( <xref:System.Reflection.Emit.OpCodes.Calli>またはマネージコードからアンマネージコードに遷移するスタブ) を参照する場合は、命令を使用して呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-2719">The specific method (`method`) can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="45410-2720">返される値は、CLR 呼び出し規約を使用してネイティブコードを指します。</span><span class="sxs-lookup"><span data-stu-id="45410-2720">The value returned points to native code using the CLR calling convention.</span></span> <span data-ttu-id="45410-2721">このメソッドポインターは、アンマネージネイティブコードにコールバックルーチンとして渡すことはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-2721">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="45410-2722">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldftn`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2722">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldftn` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2723">ILGenerator (オペコード, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-2723">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2724"><see langword="native int" /> 型の値を <see langword="native int" /> として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2724">Loads a value of type <see langword="native int" /> as a <see langword="native int" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2725">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2725">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2726">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2726">Format</span></span>|<span data-ttu-id="45410-2727">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2727">Assembly Format</span></span>|<span data-ttu-id="45410-2728">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2728">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2729">4D</span><span class="sxs-lookup"><span data-stu-id="45410-2729">4D</span></span>|<span data-ttu-id="45410-2730">ldind</span><span class="sxs-lookup"><span data-stu-id="45410-2730">ldind.i</span></span>|<span data-ttu-id="45410-2731">`native int`アドレス`native int` の値をとしてスタック `addr` に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2731">Loads the `native int` value at address `addr` onto the stack as a `native int`.</span></span>|  
  
 <span data-ttu-id="45410-2732">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2732">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2733">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2733">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2734">アドレスはスタックからポップされます。アドレスにある値がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2734">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2735">フェッチされた値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2735">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2736">命令`ldind.i`は、指定さ`native int`れたアドレス (型、型`native int`、 `&`または \*) からの値をとし`native int`て間接的にスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2736">The `ldind.i` instruction indirectly loads a `native int` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `native int`.</span></span>  
  
 <span data-ttu-id="45410-2737">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2737">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2738">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2738">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2739">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2739">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2740">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2740">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2741">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2741">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2742">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2742">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2743">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2743">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2744">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2744">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2745"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2745"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2746">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.i`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2746">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2747">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2747">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2748"><see langword="int8" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2748">Loads a value of type <see langword="int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2749">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2749">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2750">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2750">Format</span></span>|<span data-ttu-id="45410-2751">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2751">Assembly Format</span></span>|<span data-ttu-id="45410-2752">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2752">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2753">46</span><span class="sxs-lookup"><span data-stu-id="45410-2753">46</span></span>|<span data-ttu-id="45410-2754">ldind</span><span class="sxs-lookup"><span data-stu-id="45410-2754">ldind.i1</span></span>|<span data-ttu-id="45410-2755">`int32`アドレス`int8` の値をとしてスタック `addr` に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2755">Loads the `int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2756">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2756">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2757">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2757">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2758">アドレスはスタックからポップされます。アドレスにある値がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2758">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2759">フェッチされた値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2759">The fetched value is pushed onto the stack.</span></span> 
  
 <span data-ttu-id="45410-2760">命令`ldind.i1`は、指定さ`int8`れたアドレス (型、型`native int`、 `&`または \*) からの値をとし`int32`て間接的にスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2760">The `ldind.i1` instruction indirectly loads an `int8` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45410-2761">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2761">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2762">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2762">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2763">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2763">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2764">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2764">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2765">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2765">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2766">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2766">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2767">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2767">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2768">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2768">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2769"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2769"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2770">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.i1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2770">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2771">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2771">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2772"><see langword="int16" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2772">Loads a value of type <see langword="int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2773">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2773">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2774">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2774">Format</span></span>|<span data-ttu-id="45410-2775">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2775">Assembly Format</span></span>|<span data-ttu-id="45410-2776">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2776">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2777">48</span><span class="sxs-lookup"><span data-stu-id="45410-2777">48</span></span>|<span data-ttu-id="45410-2778">ldind</span><span class="sxs-lookup"><span data-stu-id="45410-2778">ldind.i2</span></span>|<span data-ttu-id="45410-2779">`int32`アドレス`int16` の値をとしてスタック `addr` に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2779">Loads the `int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2780">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2780">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2781">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2781">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2782">アドレスはスタックからポップされます。アドレスにある値がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2782">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2783">フェッチされた値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2783">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2784">命令`ldind.i2`は、指定さ`int16`れたアドレス (型、型`native int`、 `&`または \*) からの値をとし`int32`て間接的にスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2784">The `ldind.i2` instruction indirectly loads an `int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45410-2785">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2785">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2786">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2786">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2787">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2787">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2788">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2788">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2789">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2789">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2790">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2790">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2791">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2791">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2792">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2792">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2793"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2793"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2794">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.i2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2794">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2795">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2795">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2796"><see langword="int32" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2796">Loads a value of type <see langword="int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2797">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2797">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2798">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2798">Format</span></span>|<span data-ttu-id="45410-2799">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2799">Assembly Format</span></span>|<span data-ttu-id="45410-2800">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2800">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2801">4A</span><span class="sxs-lookup"><span data-stu-id="45410-2801">4A</span></span>|<span data-ttu-id="45410-2802">ldind</span><span class="sxs-lookup"><span data-stu-id="45410-2802">ldind.i4</span></span>|<span data-ttu-id="45410-2803">`int32`アドレス`int32` の値をとしてスタック `addr` に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2803">Loads the `int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2804">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2804">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2805">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2805">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2806">アドレスはスタックからポップされます。アドレスにある値がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2806">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2807">フェッチされた値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2807">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2808">命令`ldind.i4`は、指定さ`int32`れたアドレス (型、型`native int`、 `&`または \*) からの値をとし`int32`て間接的にスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2808">The `ldind.i4` instruction indirectly loads an `int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45410-2809">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2809">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2810">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2810">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2811">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2811">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2812">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2812">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2813">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2813">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2814">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2814">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2815">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2815">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2816">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2816">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2817"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2817"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2818">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.i4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2818">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2819">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2819">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2820"><see langword="int64" /> 型の値を <see langword="int64" /> として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2820">Loads a value of type <see langword="int64" /> as an <see langword="int64" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2821">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2821">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2822">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2822">Format</span></span>|<span data-ttu-id="45410-2823">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2823">Assembly Format</span></span>|<span data-ttu-id="45410-2824">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2824">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2825">4C</span><span class="sxs-lookup"><span data-stu-id="45410-2825">4C</span></span>|<span data-ttu-id="45410-2826">ldind i8</span><span class="sxs-lookup"><span data-stu-id="45410-2826">ldind.i8</span></span>|<span data-ttu-id="45410-2827">`int64`アドレス`int64` の値をとしてスタック `addr` に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2827">Loads the `int64` value at address `addr` onto the stack as an `int64`.</span></span>|  
  
 <span data-ttu-id="45410-2828">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2828">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2829">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2829">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2830">アドレスはスタックからポップされます。アドレスにある値がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2830">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2831">フェッチされた値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2831">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2832">命令`ldind.i8`は、指定さ`int64`れたアドレス (型、型`native int`、 `&`または \*) からの値をとし`int64`て間接的にスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2832">The `ldind.i8` instruction indirectly loads an `int64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int64`.</span></span>  
  
 <span data-ttu-id="45410-2833">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2833">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2834">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2834">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2835">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2835">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2836">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2836">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2837">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2837">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2838">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2838">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2839">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2839">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2840">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2840">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2841"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2841"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2842">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.i8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2842">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2843">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2843">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2844"><see langword="float32" /> 型の値を <see langword="F" /> (float) 型として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2844">Loads a value of type <see langword="float32" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2845">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2845">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2846">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2846">Format</span></span>|<span data-ttu-id="45410-2847">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2847">Assembly Format</span></span>|<span data-ttu-id="45410-2848">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2848">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2849">4E</span><span class="sxs-lookup"><span data-stu-id="45410-2849">4E</span></span>|<span data-ttu-id="45410-2850">ldind</span><span class="sxs-lookup"><span data-stu-id="45410-2850">ldind.r4</span></span>|<span data-ttu-id="45410-2851">`F`アドレス`float32` の値を型としてスタックに読み込みます。 `addr`</span><span class="sxs-lookup"><span data-stu-id="45410-2851">Loads the `float32` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="45410-2852">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2852">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2853">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2853">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2854">アドレスはスタックからポップされます。アドレスにある値がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2854">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2855">フェッチされた値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2855">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2856">命令`ldind.r4`は、指定さ`float32`れたアドレス (型、型`native int`、 `&`または \*) からの値を、型`F`としてスタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2856">The `ldind.r4` instruction indirectly loads a `float32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a type `F`.</span></span>  
  
 <span data-ttu-id="45410-2857">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2857">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2858">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2858">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2859">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2859">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2860">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2860">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2861">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2861">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2862">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2862">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2863">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2863">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2864">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2864">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2865"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2865"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2866">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.r4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2866">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2867">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2867">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2868"><see langword="float64" /> 型の値を <see langword="F" /> (float) 型として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2868">Loads a value of type <see langword="float64" /> as a type <see langword="F" /> (float) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2869">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2869">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2870">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2870">Format</span></span>|<span data-ttu-id="45410-2871">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2871">Assembly Format</span></span>|<span data-ttu-id="45410-2872">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2872">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2873">4F</span><span class="sxs-lookup"><span data-stu-id="45410-2873">4F</span></span>|<span data-ttu-id="45410-2874">ldind</span><span class="sxs-lookup"><span data-stu-id="45410-2874">ldind.r8</span></span>|<span data-ttu-id="45410-2875">`F`アドレス`float64` の値を型としてスタックに読み込みます。 `addr`</span><span class="sxs-lookup"><span data-stu-id="45410-2875">Loads the `float64` value at address `addr` onto the stack as a type `F`.</span></span>|  
  
 <span data-ttu-id="45410-2876">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2876">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2877">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2877">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2878">アドレスはスタックからポップされます。アドレスにある値がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2878">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2879">フェッチされた値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2879">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2880">命令`ldind.r8`は、指定さ`float64`れたアドレス (型、型`native int`、 `&`または \*) からの値をとし`float64`て間接的にスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2880">The `ldind.r8` instruction indirectly loads a `float64` value from the specified address (of type `native int`, `&`, or \*) onto the stack as a `float64`.</span></span>  
  
 <span data-ttu-id="45410-2881">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2881">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2882">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2882">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2883">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2883">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2884">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2884">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2885">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2885">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2886">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2886">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2887">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2887">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2888">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2888">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2889"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2889"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2890">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.r8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2890">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2891">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2891">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2892">オブジェクト参照を <see langword="O" /> 型 (オブジェクト参照) として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2892">Loads an object reference as a type <see langword="O" /> (object reference) onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2893">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2893">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2894">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2894">Format</span></span>|<span data-ttu-id="45410-2895">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2895">Assembly Format</span></span>|<span data-ttu-id="45410-2896">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2896">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2897">50</span><span class="sxs-lookup"><span data-stu-id="45410-2897">50</span></span>|<span data-ttu-id="45410-2898">ldind</span><span class="sxs-lookup"><span data-stu-id="45410-2898">ldind.ref</span></span>|<span data-ttu-id="45410-2899">アドレス`addr`にあるオブジェクト参照を型としてスタックに読み込みます`O`</span><span class="sxs-lookup"><span data-stu-id="45410-2899">Loads the object reference at address `addr` onto the stack as a type `O`</span></span>|  
  
 <span data-ttu-id="45410-2900">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2900">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2901">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2901">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2902">アドレスはスタックからポップされます。アドレスにあるオブジェクト参照がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2902">The address is popped from the stack; the object reference located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2903">フェッチされた参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2903">The fetched reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2904">命令`ldind.ref`は、指定されたアドレス (型`native int`、 `&`、または \*) のオブジェクト参照を、型`O`としてスタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2904">The `ldind.ref` instruction indirectly loads the object reference the specified address (of type `native int`, `&`, or \*) onto the stack as type `O`.</span></span>  
  
 <span data-ttu-id="45410-2905">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2905">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2906">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2906">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2907">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2907">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2908">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2908">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2909">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2909">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2910">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2910">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2911">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2911">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2912">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2912">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2913"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2913"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2914">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.ref`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2914">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2915">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2915">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2916"><see langword="unsigned int8" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2916">Loads a value of type <see langword="unsigned int8" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2917">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2917">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2918">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2918">Format</span></span>|<span data-ttu-id="45410-2919">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2919">Assembly Format</span></span>|<span data-ttu-id="45410-2920">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2920">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2921">47</span><span class="sxs-lookup"><span data-stu-id="45410-2921">47</span></span>|<span data-ttu-id="45410-2922">ldind</span><span class="sxs-lookup"><span data-stu-id="45410-2922">ldind.u1</span></span>|<span data-ttu-id="45410-2923">`int32`アドレス`unsigned int8` の値をとしてスタック `addr` に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2923">Loads the `unsigned int8` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2924">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2924">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2925">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2925">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2926">アドレスはスタックからポップされます。アドレスにある値がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2926">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2927">フェッチされた値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2927">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2928">命令`ldind.u1`は、指定さ`unsigned int8`れたアドレス (型、型`native int`、 `&`または \*) からの値をとし`int32`て間接的にスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2928">The `ldind.u1` instruction indirectly loads an `unsigned int8` value from the specified address (of type`native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45410-2929">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2929">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2930">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2930">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2931">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2931">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2932">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2932">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2933">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2933">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2934">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2934">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2935">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2935">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2936">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2936">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2937"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2937"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2938">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.u1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2938">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2939">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2939">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2940"><see langword="unsigned int16" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2940">Loads a value of type <see langword="unsigned int16" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2941">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2941">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2942">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2942">Format</span></span>|<span data-ttu-id="45410-2943">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2943">Assembly Format</span></span>|<span data-ttu-id="45410-2944">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2944">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2945">49</span><span class="sxs-lookup"><span data-stu-id="45410-2945">49</span></span>|<span data-ttu-id="45410-2946">ldind</span><span class="sxs-lookup"><span data-stu-id="45410-2946">ldind.u2</span></span>|<span data-ttu-id="45410-2947">`int32`アドレス`unsigned int16` の値をとしてスタック `addr` に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2947">Loads the `unsigned int16` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2948">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2948">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2949">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2949">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2950">アドレスはスタックからポップされます。アドレスにある値がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2950">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2951">フェッチされた値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2951">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2952">命令`ldind.u2`は、指定さ`unsigned int16`れたアドレス (型、型`native int`、 `&`または \*) からの値をとし`int32`て間接的にスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2952">The `ldind.u2` instruction indirectly loads an `unsigned int16` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45410-2953">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2953">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2954">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2954">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2955">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2955">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2956">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2956">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2957">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2957">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2958">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2958">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2959">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2959">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2960">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2960">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2961"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2961"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2962">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.u2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2962">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2963">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2963">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2964"><see langword="unsigned int32" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2964">Loads a value of type <see langword="unsigned int32" /> as an <see langword="int32" /> onto the evaluation stack indirectly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2965">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2965">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2966">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2966">Format</span></span>|<span data-ttu-id="45410-2967">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2967">Assembly Format</span></span>|<span data-ttu-id="45410-2968">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2968">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2969">4B</span><span class="sxs-lookup"><span data-stu-id="45410-2969">4B</span></span>|<span data-ttu-id="45410-2970">ldind u4</span><span class="sxs-lookup"><span data-stu-id="45410-2970">ldind.u4</span></span>|<span data-ttu-id="45410-2971">`int32`アドレス`unsigned int32` の値をとしてスタック `addr` に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2971">Loads the `unsigned int32` value at address `addr` onto the stack as an `int32`.</span></span>|  
  
 <span data-ttu-id="45410-2972">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2972">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2973">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2973">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2974">アドレスはスタックからポップされます。アドレスにある値がフェッチされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2974">The address is popped from the stack; the value located at the address is fetched.</span></span>  
  
3.  <span data-ttu-id="45410-2975">フェッチされた値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2975">The fetched value is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-2976">命令`ldind.u4`は、指定さ`unsigned int32`れたアドレス (型、型`native int`、 `&`または \*) からの値をとし`int32`て間接的にスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-2976">The `ldind.u4` instruction indirectly loads an `unsigned int32` value from the specified address (of type `native int`, `&`, or \*) onto the stack as an `int32`.</span></span>  
  
 <span data-ttu-id="45410-2977">すべての`ldind`手順は、対応する組み込み<xref:System.Reflection.Emit.OpCodes.Ldobj>値クラスを指定する命令のショートカットです。</span><span class="sxs-lookup"><span data-stu-id="45410-2977">All of the `ldind` instructions are shortcuts for a <xref:System.Reflection.Emit.OpCodes.Ldobj> instruction that specifies the corresponding built-in value class.</span></span>  
  
 <span data-ttu-id="45410-2978">4バイト未満の整数値は、評価スタックに読み込ま`int32`れるとき`native int`に (ではなく) に拡張されることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-2978">Note that integer values of less than 4 bytes are extended to `int32` (not `native int`) when they are loaded onto the evaluation stack.</span></span> <span data-ttu-id="45410-2979">浮動小数点値は、評価`F`スタックに読み込まれるときに型に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2979">Floating-point values are converted to `F` type when loaded onto the evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-2980">正しい形式の Microsoft 中間言語 (MSIL) `ldind`では、命令がポインターの型と一貫性のある方法で使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2980">Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the `ldind` instructions are used in a manner consistent with the type of the pointer.</span></span>  
  
 <span data-ttu-id="45410-2981">最初にスタックにプッシュされたアドレスは、コンピューター上のオブジェクトの自然サイズに合わせる必要<xref:System.NullReferenceException>があります。また<xref:System.Reflection.Emit.OpCodes.Unaligned>は、が発生する可能性があります (予防的対策のプレフィックス命令を参照)。</span><span class="sxs-lookup"><span data-stu-id="45410-2981">The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref:System.NullReferenceException> can occur (see the <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction for preventative measures).</span></span> <span data-ttu-id="45410-2982">アドレスを返すすべての MSIL 命令 (や<xref:System.Reflection.Emit.OpCodes.Ldloca> <xref:System.Reflection.Emit.OpCodes.Ldarga>など) の結果は、安全にアラインされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2982">The results of all MSIL instructions that return addresses (for example, <xref:System.Reflection.Emit.OpCodes.Ldloca> and <xref:System.Reflection.Emit.OpCodes.Ldarga>) are safely aligned.</span></span> <span data-ttu-id="45410-2983">1バイトを超えるデータ型の場合、バイトの順序付けはターゲット CPU に依存します。</span><span class="sxs-lookup"><span data-stu-id="45410-2983">For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</span></span> <span data-ttu-id="45410-2984">バイト順に依存するコードは、すべてのプラットフォームで実行されない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2984">Code that depends on byte ordering might not run on all platforms.</span></span>  
  
 <span data-ttu-id="45410-2985"><xref:System.NullReferenceException>無効なアドレスが検出された場合にスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-2985"><xref:System.NullReferenceException> can be thrown if an invalid address is detected.</span></span>  
  
 <span data-ttu-id="45410-2986">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldind.u4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-2986">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldind.u4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-2987">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-2987">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-2988">インデックス番号が 0 から始まる 1 次元配列の要素数を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2988">Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-2989">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-2989">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-2990">形式</span><span class="sxs-lookup"><span data-stu-id="45410-2990">Format</span></span>|<span data-ttu-id="45410-2991">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-2991">Assembly Format</span></span>|<span data-ttu-id="45410-2992">説明</span><span class="sxs-lookup"><span data-stu-id="45410-2992">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-2993">8E</span><span class="sxs-lookup"><span data-stu-id="45410-2993">8E</span></span>|<span data-ttu-id="45410-2994">ldlen</span><span class="sxs-lookup"><span data-stu-id="45410-2994">ldlen</span></span>|<span data-ttu-id="45410-2995">配列の長さ (型`natural unsigned int`) をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-2995">Pushes the length (of type `natural unsigned int`) of an array on the stack.</span></span>|  
  
 <span data-ttu-id="45410-2996">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2996">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-2997">配列へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2997">An object reference to an array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-2998">配列参照がスタックからポップされ、長さが計算されます。</span><span class="sxs-lookup"><span data-stu-id="45410-2998">The array reference is popped from the stack and the length is computed.</span></span>  
  
3.  <span data-ttu-id="45410-2999">長さはスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-2999">The length is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3000">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3000">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-3001">長さはとして`natural unsigned int`返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3001">The length is returned as a `natural unsigned int`.</span></span>  
  
 <span data-ttu-id="45410-3002"><xref:System.NullReferenceException>配列参照が null 参照の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3002"><xref:System.NullReferenceException> is thrown if the array reference is a null reference.</span></span>  
  
 <span data-ttu-id="45410-3003">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldlen`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3003">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldlen` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3004">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3004">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3005">特定のインデックスのローカル変数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3005">Loads the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3006">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3006">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3007">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3007">Format</span></span>|<span data-ttu-id="45410-3008">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3008">Assembly Format</span></span>|<span data-ttu-id="45410-3009">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3009">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3010">FE 0C <`unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45410-3010">FE 0C < `unsigned int16` ></span></span>|<span data-ttu-id="45410-3011">ldloc`index`</span><span class="sxs-lookup"><span data-stu-id="45410-3011">ldloc `index`</span></span>|<span data-ttu-id="45410-3012">インデックス`index`位置にあるローカル変数をスタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3012">Loads the local variable at index `index` onto stack.</span></span>|  
  
 <span data-ttu-id="45410-3013">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3013">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3014">指定したインデックス位置にあるローカル変数の値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3014">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3015">命令`ldloc`は、渡されたインデックスのローカル変数番号の内容を評価スタックにプッシュします。この場合、ローカル変数の番号は0以降になります。</span><span class="sxs-lookup"><span data-stu-id="45410-3015">The `ldloc` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45410-3016">ローカル変数は、メソッドの initialize フラグが true の場合にのみ、メソッドに入る前に0に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3016">Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</span></span> <span data-ttu-id="45410-3017">65535 (2 ^ 16-1) ローカル変数を使用できます (0 ~ 65534)。</span><span class="sxs-lookup"><span data-stu-id="45410-3017">There are 65,535 (2^16-1) local variables possible (0-65,534).</span></span> <span data-ttu-id="45410-3018">インデックス65535は有効ではありません。実装では、2バイトの整数を使用して、ローカルのインデックスと、特定のメソッドのローカルの合計数が追跡されるためです。</span><span class="sxs-lookup"><span data-stu-id="45410-3018">Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</span></span> <span data-ttu-id="45410-3019">65535のインデックスが有効になっている場合は、このようなメソッドでローカルの数を追跡するために、より広い整数が必要になります。</span><span class="sxs-lookup"><span data-stu-id="45410-3019">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="45410-3020">、 、、および `ldloc.0` の `ldloc.3` 各命令は、最初の4つのローカル変数にアクセスするための効率的なエンコーディングを提供します。 `ldloc.2` `ldloc.1`</span><span class="sxs-lookup"><span data-stu-id="45410-3020">The `ldloc.0`, `ldloc.1`, `ldloc.2`, and `ldloc.3` instructions provide an efficient encoding for accessing the first four local variables.</span></span>  
  
 <span data-ttu-id="45410-3021">値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-3021">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45410-3022">「パーティション I」を参照してください。長さが4バイトより小さいローカル`int32`変数は、スタックに読み込まれるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3022">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-3023">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3023">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-3024">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3024">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3025">ILGenerator (オペコード、LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="45410-3025">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="45410-3026">ILGenerator (オペコード、short)</span><span class="sxs-lookup"><span data-stu-id="45410-3026">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3027">インデックス 0 のローカル変数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3027">Loads the local variable at index 0 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3028">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3028">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3029">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3029">Format</span></span>|<span data-ttu-id="45410-3030">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3030">Assembly Format</span></span>|<span data-ttu-id="45410-3031">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3031">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3032">06</span><span class="sxs-lookup"><span data-stu-id="45410-3032">06</span></span>|<span data-ttu-id="45410-3033">ldloc</span><span class="sxs-lookup"><span data-stu-id="45410-3033">ldloc.0</span></span>|<span data-ttu-id="45410-3034">インデックス 0 のローカル変数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3034">Loads the local variable at index 0 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="45410-3035">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3035">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3036">インデックス0のローカル変数値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3036">The local variable value at the index 0 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3037">`ldloc.0`は、インデックス0のローカル<xref:System.Reflection.Emit.OpCodes.Ldloc>変数にアクセスできるようにするための、特に効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-3037">`ldloc.0` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 0.</span></span>  
  
 <span data-ttu-id="45410-3038">値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-3038">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45410-3039">長さが4バイトより小さいローカル変数は、スタックに読み込ま`int32`れるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3039">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-3040">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3040">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-3041">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc.0`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3041">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3042">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3042">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3043">インデックス 1 のローカル変数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3043">Loads the local variable at index 1 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3044">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3044">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3045">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3045">Format</span></span>|<span data-ttu-id="45410-3046">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3046">Assembly Format</span></span>|<span data-ttu-id="45410-3047">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3047">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3048">07</span><span class="sxs-lookup"><span data-stu-id="45410-3048">07</span></span>|<span data-ttu-id="45410-3049">ldloc</span><span class="sxs-lookup"><span data-stu-id="45410-3049">ldloc.1</span></span>|<span data-ttu-id="45410-3050">インデックス 1 のローカル変数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3050">Loads the local variable at index 1 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="45410-3051">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3051">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3052">インデックス1のローカル変数値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3052">The local variable value at the index 1 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3053">`ldloc.1`は、インデックス1のローカル<xref:System.Reflection.Emit.OpCodes.Ldloc>変数にアクセスできるようにするための、特に効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-3053">`ldloc.1` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 1.</span></span>  
  
 <span data-ttu-id="45410-3054">値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-3054">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45410-3055">長さが4バイトより小さいローカル変数は、スタックに読み込ま`int32`れるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3055">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-3056">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3056">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-3057">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc.1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3057">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3058">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3058">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3059">インデックス 2 のローカル変数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3059">Loads the local variable at index 2 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3060">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3060">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3061">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3061">Format</span></span>|<span data-ttu-id="45410-3062">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3062">Assembly Format</span></span>|<span data-ttu-id="45410-3063">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3063">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3064">08</span><span class="sxs-lookup"><span data-stu-id="45410-3064">08</span></span>|<span data-ttu-id="45410-3065">ldloc</span><span class="sxs-lookup"><span data-stu-id="45410-3065">ldloc.2</span></span>|<span data-ttu-id="45410-3066">インデックス 2 のローカル変数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3066">Loads the local variable at index 2 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="45410-3067">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3067">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3068">インデックス2のローカル変数値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3068">The local variable value at the index 2 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3069">`ldloc.2`は、インデックス2でローカル<xref:System.Reflection.Emit.OpCodes.Ldloc>変数にアクセスできるようにするための、特に効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-3069">`ldloc.2` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 2.</span></span>  
  
 <span data-ttu-id="45410-3070">値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-3070">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45410-3071">長さが4バイトより小さいローカル変数は、スタックに読み込ま`int32`れるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3071">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-3072">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3072">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-3073">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc.2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3073">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3074">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3074">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3075">インデックス 3 のローカル変数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3075">Loads the local variable at index 3 onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3076">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3076">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3077">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3077">Format</span></span>|<span data-ttu-id="45410-3078">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3078">Assembly Format</span></span>|<span data-ttu-id="45410-3079">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3079">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3080">09</span><span class="sxs-lookup"><span data-stu-id="45410-3080">09</span></span>|<span data-ttu-id="45410-3081">ldloc</span><span class="sxs-lookup"><span data-stu-id="45410-3081">ldloc.3</span></span>|<span data-ttu-id="45410-3082">インデックス 3 のローカル変数を評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3082">Loads the local variable at index 3 onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="45410-3083">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3083">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3084">インデックス3のローカル変数値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3084">The local variable value at the index 3 is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3085">`ldloc.3`は、インデックス3でローカル<xref:System.Reflection.Emit.OpCodes.Ldloc>変数にアクセスできるようにするための、特に効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-3085">`ldloc.3` is an especially efficient encoding for <xref:System.Reflection.Emit.OpCodes.Ldloc>, allowing access to the local variable at index 3.</span></span>  
  
 <span data-ttu-id="45410-3086">値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-3086">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45410-3087">長さが4バイトより小さいローカル変数は、スタックに読み込ま`int32`れるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3087">Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-3088">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3088">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-3089">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc.3`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3089">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3090">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3090">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3091">特定のインデックスのローカル変数を評価スタックに読み込みます (短い形式)。</span><span class="sxs-lookup"><span data-stu-id="45410-3091">Loads the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3092">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3092">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3093">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3093">Format</span></span>|<span data-ttu-id="45410-3094">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3094">Assembly Format</span></span>|<span data-ttu-id="45410-3095">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3095">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3096">11 <`unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-3096">11 < `unsigned int8` ></span></span>|<span data-ttu-id="45410-3097">ldloc`index`</span><span class="sxs-lookup"><span data-stu-id="45410-3097">ldloc.s `index`</span></span>|<span data-ttu-id="45410-3098">インデックス`index`でローカル変数をスタックに読み込みます (短い形式)。</span><span class="sxs-lookup"><span data-stu-id="45410-3098">Loads the local variable at index `index` onto stack, short form.</span></span>|  
  
 <span data-ttu-id="45410-3099">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3099">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3100">指定したインデックス位置にあるローカル変数の値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3100">The local variable value at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3101">命令`ldloc.s`は、渡されたインデックスのローカル変数番号の内容を評価スタックにプッシュします。この場合、ローカル変数の番号は0以降になります。</span><span class="sxs-lookup"><span data-stu-id="45410-3101">The `ldloc.s` instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45410-3102">メソッドの initialize フラグが true の場合は、メソッドに入る前にローカル変数が0に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3102">Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</span></span> <span data-ttu-id="45410-3103">短い形式では、256 (2 ^ 8) ローカル変数 (0-255) が使用できます。これはより`ldloc`効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-3103">There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than `ldloc`.</span></span>  
  
 <span data-ttu-id="45410-3104">値の型は、メソッドヘッダーで指定されているローカル変数の型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-3104">The type of the value is the same as the type of the local variable, which is specified in the method header.</span></span> <span data-ttu-id="45410-3105">「パーティション I」を参照してください。長さが4バイトより小さいローカル`int32`変数は、スタックに読み込まれるときに型に拡張されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3105">See Partition I. Local variables that are smaller than 4 bytes long are expanded to type `int32` when they are loaded onto the stack.</span></span> <span data-ttu-id="45410-3106">浮動小数点値は、ネイティブサイズ (型`F`) に展開されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3106">Floating-point values are expanded to their native size (type `F`).</span></span>  
  
 <span data-ttu-id="45410-3107">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloc.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3107">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3108">ILGenerator (オペコード、LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="45410-3108">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="45410-3109">ILGenerator (オペコード、byte)</span><span class="sxs-lookup"><span data-stu-id="45410-3109">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3110">特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3110">Loads the address of the local variable at a specific index onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3111">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3111">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3112">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3112">Format</span></span>|<span data-ttu-id="45410-3113">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3113">Assembly Format</span></span>|<span data-ttu-id="45410-3114">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3114">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3115">FE OD <`unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45410-3115">FE OD < `unsigned int16` ></span></span>|<span data-ttu-id="45410-3116">ldloca`index`</span><span class="sxs-lookup"><span data-stu-id="45410-3116">ldloca `index`</span></span>|<span data-ttu-id="45410-3117">のローカル変数`index`のアドレスを評価スタックに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3117">Loads the address of the local variable at `index` onto the evaluation stack.</span></span>|  
  
 <span data-ttu-id="45410-3118">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3118">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3119">指定したインデックス位置にあるローカル変数に格納されているアドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3119">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3120">命令`ldloca`は、渡されたインデックスにあるローカル変数番号のアドレスをスタックにプッシュします。ローカル変数には、0以降の番号が付けられます。</span><span class="sxs-lookup"><span data-stu-id="45410-3120">The `ldloca` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45410-3121">スタックにプッシュされた値は、や<xref:System.Reflection.Emit.OpCodes.Ldind_I> <xref:System.Reflection.Emit.OpCodes.Stind_I>などの命令で使用するために、既に正しく調整されています。</span><span class="sxs-lookup"><span data-stu-id="45410-3121">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="45410-3122">結果は、遷移ポインター (型`*`) です。</span><span class="sxs-lookup"><span data-stu-id="45410-3122">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="45410-3123">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloca`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3123">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3124">ILGenerator (オペコード、short)</span><span class="sxs-lookup"><span data-stu-id="45410-3124">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3125">特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます (短い形式)。</span><span class="sxs-lookup"><span data-stu-id="45410-3125">Loads the address of the local variable at a specific index onto the evaluation stack, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3126">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3126">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3127">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3127">Format</span></span>|<span data-ttu-id="45410-3128">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3128">Assembly Format</span></span>|<span data-ttu-id="45410-3129">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3129">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3130">12 <`unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-3130">12 < `unsigned int8` ></span></span>|<span data-ttu-id="45410-3131">ldloca`index`</span><span class="sxs-lookup"><span data-stu-id="45410-3131">ldloca.s `index`</span></span>|<span data-ttu-id="45410-3132">のローカル変数`index`のアドレスを評価スタック (短い形式) に読み込みます。</span><span class="sxs-lookup"><span data-stu-id="45410-3132">Loads the address of the local variable at `index` onto the evaluation stack, short form.</span></span>|  
  
 <span data-ttu-id="45410-3133">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3133">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3134">指定したインデックス位置にあるローカル変数に格納されているアドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3134">The address stored in the local variable at the specified index is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3135">命令`ldloca.s`は、渡されたインデックスにあるローカル変数番号のアドレスをスタックにプッシュします。ローカル変数には、0以降の番号が付けられます。</span><span class="sxs-lookup"><span data-stu-id="45410-3135">The `ldloca.s` instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45410-3136">スタックにプッシュされた値は、や<xref:System.Reflection.Emit.OpCodes.Ldind_I> <xref:System.Reflection.Emit.OpCodes.Stind_I>などの命令で使用するために、既に正しく調整されています。</span><span class="sxs-lookup"><span data-stu-id="45410-3136">The value pushed on the stack is already aligned correctly for use with instructions like <xref:System.Reflection.Emit.OpCodes.Ldind_I> and <xref:System.Reflection.Emit.OpCodes.Stind_I>.</span></span> <span data-ttu-id="45410-3137">結果は、遷移ポインター (型`*`) です。</span><span class="sxs-lookup"><span data-stu-id="45410-3137">The result is a transient pointer (type `*`).</span></span>  
  
 <span data-ttu-id="45410-3138">命令`ldloca.s`は、ローカル変数 0 ~ 255 で使用するための効率的なエンコードを提供します。</span><span class="sxs-lookup"><span data-stu-id="45410-3138">The `ldloca.s` instruction provides an efficient encoding for use with the local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="45410-3139">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldloca.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3139">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldloca.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3140">ILGenerator (オペコード、byte)</span><span class="sxs-lookup"><span data-stu-id="45410-3140">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3141">null 参照 (<see langword="O" /> 型) を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3141">Pushes a null reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3142">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3142">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3143">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3143">Format</span></span>|<span data-ttu-id="45410-3144">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3144">Assembly Format</span></span>|<span data-ttu-id="45410-3145">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3145">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3146">14</span><span class="sxs-lookup"><span data-stu-id="45410-3146">14</span></span>|<span data-ttu-id="45410-3147">ldnull</span><span class="sxs-lookup"><span data-stu-id="45410-3147">ldnull</span></span>|<span data-ttu-id="45410-3148">null 参照をスタックにプッシュします</span><span class="sxs-lookup"><span data-stu-id="45410-3148">push a null reference onto the stack</span></span>|  
  
 <span data-ttu-id="45410-3149">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3149">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3150">Null オブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3150">A null object reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3151">`ldnull`null 参照 (型`O`) をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3151">`ldnull` pushes a null reference (type `O`) on the stack.</span></span> <span data-ttu-id="45410-3152">これは、データを格納する前に、または非推奨になったときに、場所を初期化するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3152">This is used to initialize locations before they are populated with data, or when they become deprecated.</span></span>  
  
 <span data-ttu-id="45410-3153">`ldnull`サイズに依存しない null 参照を提供します。</span><span class="sxs-lookup"><span data-stu-id="45410-3153">`ldnull` provides a null reference that is size-independent.</span></span>  
  
 <span data-ttu-id="45410-3154">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldnull`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3154">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldnull` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3155">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3155">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3156">アドレスが指す値型オブジェクトを評価スタックの一番上にコピーします。</span><span class="sxs-lookup"><span data-stu-id="45410-3156">Copies the value type object pointed to by an address to the top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3157">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3157">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3158">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3158">Format</span></span>|<span data-ttu-id="45410-3159">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3159">Assembly Format</span></span>|<span data-ttu-id="45410-3160">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3160">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3161">71 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3161">71 < `T` ></span></span>|<span data-ttu-id="45410-3162">ldobj`class`</span><span class="sxs-lookup"><span data-stu-id="45410-3162">ldobj `class`</span></span>|<span data-ttu-id="45410-3163">値の型`class`のインスタンスをスタックにコピーします。</span><span class="sxs-lookup"><span data-stu-id="45410-3163">Copy instance of value type `class` to the stack.</span></span>|  
  
 <span data-ttu-id="45410-3164">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3164">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3165">値型のオブジェクトのアドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3165">The address of a value type object is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3166">アドレスはスタックからポップされ、その特定のアドレスのインスタンスが検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3166">The address is popped from the stack and the instance at that particular address is looked up.</span></span>  
  
3.  <span data-ttu-id="45410-3167">そのアドレスに格納されているオブジェクトの値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3167">The value of the object stored at that address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3168">`ldobj`命令は、値型をパラメーターとして渡すために使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3168">The `ldobj` instruction is used to pass a value type as a parameter.</span></span>  
  
 <span data-ttu-id="45410-3169">命令`ldobj`は、(、 `addrOfValObj` `&` `native int`、または型の) によってポイントされた値をスタックの一番上にコピーします。 `*`</span><span class="sxs-lookup"><span data-stu-id="45410-3169">The `ldobj` instruction copies the value pointed to by `addrOfValObj` (of type `&`, `*`, or `native int`) to the top of the stack.</span></span> <span data-ttu-id="45410-3170">コピーされるバイト数は、 `class`パラメーターによって指定されたクラスのサイズによって異なります。</span><span class="sxs-lookup"><span data-stu-id="45410-3170">The number of bytes copied depends on the size of the class (as specified by the `class` parameter).</span></span> <span data-ttu-id="45410-3171">`class`パラメーターは、値の型を表すメタデータトークンです。</span><span class="sxs-lookup"><span data-stu-id="45410-3171">The `class` parameter is a metadata token representing the value type.</span></span>  
  
 <span data-ttu-id="45410-3172">`ldobj`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3172">The operation of the `ldobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-3173"><xref:System.TypeLoadException>クラスが見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3173"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="45410-3174">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3174">This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="45410-3175">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldobj`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3175">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldobj` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3176">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-3176">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3177">静的フィールドの値を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3177">Pushes the value of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3178">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3178">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3179">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3179">Format</span></span>|<span data-ttu-id="45410-3180">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3180">Assembly Format</span></span>|<span data-ttu-id="45410-3181">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3181">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3182">7E <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3182">7E < `T` ></span></span>|<span data-ttu-id="45410-3183">ldsfld`field`</span><span class="sxs-lookup"><span data-stu-id="45410-3183">ldsfld `field`</span></span>|<span data-ttu-id="45410-3184">スタックでの`field`値をプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3184">Push the value of `field` on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3185">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3185">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3186">特定のフィールドの値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3186">The value of the specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3187">命令`ldsfld`は、静的 (クラスのすべてのインスタンスで共有される) フィールドの値をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3187">The `ldsfld` instruction pushes the value of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="45410-3188">戻り値の型は、渡されたメタデータ`field`トークンに関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="45410-3188">The return type is that associated with the passed metadata token `field`.</span></span>  
  
 <span data-ttu-id="45410-3189">命令`ldsfld`はプレフィックスを<xref:System.Reflection.Emit.OpCodes.Volatile>持つことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-3189">The `ldsfld` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="45410-3190">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldsfld`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3190">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsfld` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3191">ILGenerator (オペコード、FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-3191">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3192">静的フィールドのアドレスを評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3192">Pushes the address of a static field onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3193">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3193">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3194">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3194">Format</span></span>|<span data-ttu-id="45410-3195">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3195">Assembly Format</span></span>|<span data-ttu-id="45410-3196">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3196">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3197">7F <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3197">7F < `T` ></span></span>|<span data-ttu-id="45410-3198">ldsflda`field`</span><span class="sxs-lookup"><span data-stu-id="45410-3198">ldsflda `field`</span></span>|<span data-ttu-id="45410-3199">スタック上のの`field`アドレスをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3199">Push the address of `field` on the stack</span></span>|  
  
 <span data-ttu-id="45410-3200">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3200">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3201">特定のフィールドのアドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3201">The address of a specific field is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3202">命令`ldsflda`は、スタック上の静的 (クラスのすべてのインスタンス間で共有される) フィールドのアドレスをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3202">The `ldsflda` instruction pushes the address of a static (shared among all instances of a class) field on the stack.</span></span> <span data-ttu-id="45410-3203">メタデータトークン`field`が、メモリが管理されて`*`いる型を参照している場合は、このアドレスを transient ポインター (型) として表すことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-3203">The address may be represented as a transient pointer (type `*`) if the metadata token `field` refers to a type whose memory is managed.</span></span> <span data-ttu-id="45410-3204">それ以外の場合は、アンマネージポインター ( `native int`型) に対応します。</span><span class="sxs-lookup"><span data-stu-id="45410-3204">Otherwise, it corresponds to an unmanaged pointer (type `native int`).</span></span> <span data-ttu-id="45410-3205">は、割り当てられた相対仮想アドレス (それを含む PE ファイルがメモリに読み込まれるベースアドレスからのフィールドのオフセット) を持つ静的グローバルで、メモリが管理されていないことに注意してください。 `field`</span><span class="sxs-lookup"><span data-stu-id="45410-3205">Note that `field` may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</span></span>  
  
 <span data-ttu-id="45410-3206">命令`ldsflda`はプレフィックスを<xref:System.Reflection.Emit.OpCodes.Volatile>持つことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-3206">The `ldsflda` instruction can have a <xref:System.Reflection.Emit.OpCodes.Volatile> prefix.</span></span>  
  
 <span data-ttu-id="45410-3207"><xref:System.MissingFieldException>メタデータ内にフィールドが見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3207"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="45410-3208">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3208">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="45410-3209">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldsflda`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3209">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldsflda` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3210">ILGenerator (オペコード、FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-3210">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3211">メタデータに格納されているリテラル文字列への新しいオブジェクト参照をプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3211">Pushes a new object reference to a string literal stored in the metadata.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3212">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3212">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3213">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3213">Format</span></span>|<span data-ttu-id="45410-3214">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3214">Assembly Format</span></span>|<span data-ttu-id="45410-3215">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3215">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3216">72 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3216">72 < `T` ></span></span>|<span data-ttu-id="45410-3217">ldstr`mdToken`</span><span class="sxs-lookup"><span data-stu-id="45410-3217">ldstr `mdToken`</span></span>|<span data-ttu-id="45410-3218">メタデータ文字列トークン`mdToken`の文字列オブジェクトをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3218">Pushes a string object for the metadata string token `mdToken`.</span></span>|  
  
 <span data-ttu-id="45410-3219">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3219">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3220">文字列へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3220">An object reference to a string is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3221">命令`ldstr`は、メタデータに格納さ`O`れている特定の文字列リテラルを表す新しい文字列オブジェクトにオブジェクト参照 (型) をプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3221">The `ldstr` instruction pushes an object reference (type `O`) to a new string object representing the specific string literal stored in the metadata.</span></span> <span data-ttu-id="45410-3222">命令`ldstr`は、必要な量のメモリを割り当て、ファイルで使用されている形式の文字列リテラルを実行時に必要な文字列形式に変換するために必要な任意の形式変換を実行します。</span><span class="sxs-lookup"><span data-stu-id="45410-3222">The `ldstr` instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</span></span>  
  
 <span data-ttu-id="45410-3223">共通言語基盤 (CLI) では、2つの`ldstr`命令の結果、同じ文字シーケンスを持つ2つのメタデータトークンを参照すると、正確に同じ文字列オブジェクト ("文字列インターン" と呼ばれるプロセス) が返されることが保証されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3223">The Common Language Infrastructure (CLI) guarantees that the result of two `ldstr` instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</span></span>  
  
 <span data-ttu-id="45410-3224">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldstr`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3224">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldstr` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3225">ILGenerator (オペコード, string)</span><span class="sxs-lookup"><span data-stu-id="45410-3225">ILGenerator.Emit(OpCode, string)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3226">メタデータ トークンをそのランタイム表現に変換し、評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3226">Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3227">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3227">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3228">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3228">Format</span></span>|<span data-ttu-id="45410-3229">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3229">Assembly Format</span></span>|<span data-ttu-id="45410-3230">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3230">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3231">D0 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3231">D0 < `T` ></span></span>|<span data-ttu-id="45410-3232">ldtoken`token`</span><span class="sxs-lookup"><span data-stu-id="45410-3232">ldtoken `token`</span></span>|<span data-ttu-id="45410-3233">メタデータトークンをそのランタイム表現に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-3233">Converts a metadata token to its runtime representation.</span></span>|  
  
 <span data-ttu-id="45410-3234">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3234">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3235">渡されたトークンはに`RuntimeHandle`変換され、スタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3235">The passed token is converted to a `RuntimeHandle` and pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3236">命令`ldtoken`は、指定`RuntimeHandle`されたメタデータトークンのをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3236">The `ldtoken` instruction pushes a `RuntimeHandle` for the specified metadata token.</span></span> <span data-ttu-id="45410-3237">には、、 `fieldref/fielddef`、また`methodref/methoddef`は`typeref/typedef`を指定できます。 `RuntimeHandle`</span><span class="sxs-lookup"><span data-stu-id="45410-3237">A `RuntimeHandle` can be a `fieldref/fielddef`, a `methodref/methoddef`, or a `typeref/typedef`.</span></span>  
  
 <span data-ttu-id="45410-3238">スタックにプッシュされた値は、システムクラスライブラリ`Reflection`のメソッドの呼び出しで使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3238">The value pushed on the stack can be used in calls to `Reflection` methods in the system class library.</span></span>  
  
 <span data-ttu-id="45410-3239">ランタイムハンドルの詳細については、 <xref:System.RuntimeFieldHandle>、 <xref:System.RuntimeTypeHandle>、および<xref:System.RuntimeMethodHandle>の各クラスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-3239">For information on runtime handles, see the following classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, and <xref:System.RuntimeMethodHandle>.</span></span>  
  
 <span data-ttu-id="45410-3240">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldtoken`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3240">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `ldtoken` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3241">ILGenerator (オペコード, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-3241">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
-   <span data-ttu-id="45410-3242">ILGenerator (オペコード、FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-3242">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
-   <span data-ttu-id="45410-3243">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-3243">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3244">指定したオブジェクトに関連付けられた特定の仮想メソッドを実装しているネイティブ コードへのアンマネージ ポインター (<see langword="native int" /> 型) を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3244">Pushes an unmanaged pointer (type <see langword="native int" />) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3245">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3245">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3246">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3246">Format</span></span>|<span data-ttu-id="45410-3247">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3247">Assembly Format</span></span>|<span data-ttu-id="45410-3248">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3248">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3249">FE 07 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3249">FE 07 < `T` ></span></span>|<span data-ttu-id="45410-3250">ldvirtftn`method`</span><span class="sxs-lookup"><span data-stu-id="45410-3250">ldvirtftn `method`</span></span>|<span data-ttu-id="45410-3251">オブジェクトの仮想メソッド`method`へのポインターをスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3251">Pushes the pointer to an object's virtual method `method` on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3252">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3252">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3253">オブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3253">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3254">オブジェクト参照がスタックからポップされ、(メタデータトークン`method`によって指定された) メソッドへのエントリポイントのアドレスが検索されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3254">The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token `method`) is looked up.</span></span>  
  
3.  <span data-ttu-id="45410-3255">へ`method`のポインターがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3255">The pointer to `method` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3256">`ldvirtftn`命令によってスタックにプッシュされたアンマネージポインターは、マネージ<xref:System.Reflection.Emit.OpCodes.Calli>メソッド (またはマネージコードからアンマネージコードに遷移するスタブ) を参照する場合、命令を使用して呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-3256">The resulting unmanaged pointer pushed onto the stack by the `ldvirtftn` instruction can be called using the <xref:System.Reflection.Emit.OpCodes.Calli> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</span></span>  
  
 <span data-ttu-id="45410-3257">アンマネージポインターは、CLR 呼び出し規約を使用してネイティブコードを指します。</span><span class="sxs-lookup"><span data-stu-id="45410-3257">The unmanaged pointer points to native code using the CLR calling convention.</span></span> <span data-ttu-id="45410-3258">このメソッドポインターは、アンマネージネイティブコードにコールバックルーチンとして渡すことはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-3258">This method pointer should not be passed to unmanaged native code as a callback routine.</span></span>  
  
 <span data-ttu-id="45410-3259">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ldvirtftn`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3259">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ldvirtftn` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3260">ILGenerator (オペコード, MethodInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-3260">ILGenerator.Emit(OpCode, MethodInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3261">コードの保護領域を終了し、制御を特定のターゲット命令に無条件で転送します。</span><span class="sxs-lookup"><span data-stu-id="45410-3261">Exits a protected region of code, unconditionally transferring control to a specific target instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3262">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3262">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3263">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3263">Format</span></span>|<span data-ttu-id="45410-3264">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3264">Assembly Format</span></span>|<span data-ttu-id="45410-3265">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3265">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3266">DD <`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-3266">DD < `int32` ></span></span>|<span data-ttu-id="45410-3267">出る`target`</span><span class="sxs-lookup"><span data-stu-id="45410-3267">leave `target`</span></span>|<span data-ttu-id="45410-3268">コードの保護された領域を終了します。</span><span class="sxs-lookup"><span data-stu-id="45410-3268">Exits a protected region of code.</span></span>|  
  
 <span data-ttu-id="45410-3269">この命令にはスタック移行動作が指定されていません。</span><span class="sxs-lookup"><span data-stu-id="45410-3269">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="45410-3270">命令`leave`は無条件で特定のターゲット命令に制御を転送します。これは、現在の命令の後に続く命令の先頭から4バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3270">The `leave` instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-3271">`br` `try` `filter`命令は命令に似ていますが、、、または`catch`ブロックを終了するために使用できます。一方、通常の分岐命令は、このようなブロック内でのみ使用できます。 `leave`し.</span><span class="sxs-lookup"><span data-stu-id="45410-3271">The `leave` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="45410-3272">命令`leave`によって、評価スタックが空になり、 `finally`適切な周辺ブロックが実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3272">The `leave` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="45410-3273">命令を`leave`使用してブロックを`finally`終了することはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-3273">You cannot use a `leave` instruction to exit a `finally` block.</span></span> <span data-ttu-id="45410-3274">例外ハンドラーのコード生成を簡単にするために、catch ブロック内から有効な`leave`のは、関連付けられている`try`ブロック内の任意の命令に制御を転送する命令を使用することです。</span><span class="sxs-lookup"><span data-stu-id="45410-3274">To ease code generation for exception handlers it is valid from within a catch block to use a `leave` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="45410-3275">命令にプレフィックスコードが1つ以上含まれている場合は、これらのプレフィックスの最初の部分にのみ制御を転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3275">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="45410-3276">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `leave`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3276">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `leave` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3277">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-3277">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3278">コードの保護領域を終了し、制御をターゲット命令に無条件で転送します (短い形式)。</span><span class="sxs-lookup"><span data-stu-id="45410-3278">Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3279">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3279">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3280">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3280">Format</span></span>|<span data-ttu-id="45410-3281">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3281">Assembly Format</span></span>|<span data-ttu-id="45410-3282">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3282">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3283">DE <`int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-3283">DE < `int8` ></span></span>|<span data-ttu-id="45410-3284">そのままにします。`target`</span><span class="sxs-lookup"><span data-stu-id="45410-3284">leave.s `target`</span></span>|<span data-ttu-id="45410-3285">コードの保護された領域 (短い形式) を終了します。</span><span class="sxs-lookup"><span data-stu-id="45410-3285">Exit a protected region of code, short form.</span></span>|  
  
 <span data-ttu-id="45410-3286">この命令にはスタック移行動作が指定されていません。</span><span class="sxs-lookup"><span data-stu-id="45410-3286">There is no stack transition behavior specified for this instruction.</span></span>  
  
 <span data-ttu-id="45410-3287">命令`leave.s`は、渡されたターゲット命令に無条件で制御を転送します。これは、現在の命令の後に続く命令の先頭から1バイト符号付きオフセットとして表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3287">The `leave.s` instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</span></span>  
  
 <span data-ttu-id="45410-3288">`br` `try` `filter`命令は命令に似ていますが、、、または`catch`ブロックを終了するために使用できます。一方、通常の分岐命令は、このようなブロック内でのみ使用できます。 `leave.s`し.</span><span class="sxs-lookup"><span data-stu-id="45410-3288">The `leave.s` instruction is similar to the `br` instruction, but it can be used to exit a `try`, `filter`, or `catch` block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</span></span> <span data-ttu-id="45410-3289">命令`leave.s`によって、評価スタックが空になり、 `finally`適切な周辺ブロックが実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3289">The `leave.s` instruction empties the evaluation stack and ensures that the appropriate surrounding `finally` blocks are executed.</span></span>  
  
 <span data-ttu-id="45410-3290">命令を`leave.s`使用してブロックを`finally`終了することはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-3290">You cannot use a `leave.s` instruction to exit a `finally` block.</span></span> <span data-ttu-id="45410-3291">例外ハンドラーのコード生成を簡単にするために、catch ブロック内から有効な`leave.s`のは、関連付けられている`try`ブロック内の任意の命令に制御を転送する命令を使用することです。</span><span class="sxs-lookup"><span data-stu-id="45410-3291">To ease code generation for exception handlers it is valid from within a catch block to use a `leave.s` instruction to transfer control to any instruction within the associated `try` block.</span></span>  
  
 <span data-ttu-id="45410-3292">命令にプレフィックスコードが1つ以上含まれている場合は、これらのプレフィックスの最初の部分にのみ制御を転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3292">If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="45410-3293">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `leave.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3293">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `leave.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3294">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-3294">ILGenerator.Emit(OpCode, Label)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3295">ローカル動的メモリ プールから特定のバイト数を割り当て、最初に割り当てたバイトのアドレス (遷移ポインター、<see langword="*" /> 型) を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3295">Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <see langword="*" />) of the first allocated byte onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3296">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3296">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3297">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3297">Format</span></span>|<span data-ttu-id="45410-3298">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3298">Assembly Format</span></span>|<span data-ttu-id="45410-3299">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3299">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3300">FE 0F</span><span class="sxs-lookup"><span data-stu-id="45410-3300">FE 0F</span></span>|<span data-ttu-id="45410-3301">localloc</span><span class="sxs-lookup"><span data-stu-id="45410-3301">localloc</span></span>|<span data-ttu-id="45410-3302">ローカルヒープから領域を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="45410-3302">Allocate space from the local heap.</span></span>|  
  
 <span data-ttu-id="45410-3303">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3303">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3304">割り当てられるバイト数はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3304">The number of bytes to be allocated is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3305">スタックからポップされたバイト数。サイズに対応するメモリ量は、ローカルヒープから割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-3305">The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</span></span>  
  
3.  <span data-ttu-id="45410-3306">割り当てられたメモリの最初のバイトへのポインターがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3306">A pointer to the first byte of the allocated memory is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3307">命令`localloc`は、ローカルの`natural unsigned int`動的メモリプールから (型) バイトを割り当て`size` 、最初に割り当てられたバイト`*`のアドレス (遷移ポインター、型) を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-3307">The `localloc` instruction allocates `size` (type `natural unsigned int`) bytes from the local dynamic memory pool and returns the address (a transient pointer, type `*`) of the first allocated byte.</span></span> <span data-ttu-id="45410-3308">返されるメモリブロックは、メソッドの initialize フラグが`true`の場合にのみ、0に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3308">The block of memory returned is initialized to 0 only if the initialize flag on the method is `true`.</span></span> <span data-ttu-id="45410-3309">現在のメソッドがを<xref:System.Reflection.Emit.OpCodes.Ret>実行すると、ローカルメモリプールを再利用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="45410-3309">When the current method executes a <xref:System.Reflection.Emit.OpCodes.Ret>, the local memory pool is made available for reuse.</span></span>  
  
 <span data-ttu-id="45410-3310">生成された`stind`アドレスは、命令 ( <xref:System.Reflection.Emit.OpCodes.Stind_I4>など`ldind` ) を使用してそのデータ型を格納し、命令 ( <xref:System.Reflection.Emit.OpCodes.Ldind_I4>など) を使用して読み込むことができるように、配置されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3310">The resulting address is aligned so that any primitive data type can be stored there using the `stind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Stind_I4>) and loaded using the `ldind` instructions (such as <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).</span></span>  
  
 <span data-ttu-id="45410-3311">命令`localloc` `filter`は、 `catch` 、、 `fault`  、またはブロック内では実行できません。 `finally`</span><span class="sxs-lookup"><span data-stu-id="45410-3311">The `localloc` instruction cannot occur within a `filter`, `catch`, `finally`, or `fault` block.</span></span>  
  
 <span data-ttu-id="45410-3312"><xref:System.StackOverflowException>は、要求を処理するためのメモリが不足している場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3312"><xref:System.StackOverflowException> is thrown if there is insufficient memory to service the request.</span></span>  
  
 <span data-ttu-id="45410-3313">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `localloc`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3313">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `localloc` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3314">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3314">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3315">特定の型のインスタンスへの型指定された参照を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3315">Pushes a typed reference to an instance of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3316">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3316">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3317">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3317">Format</span></span>|<span data-ttu-id="45410-3318">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3318">Assembly Format</span></span>|<span data-ttu-id="45410-3319">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3319">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3320">C6 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3320">C6 < `T` ></span></span>|<span data-ttu-id="45410-3321">mkrefany`class`</span><span class="sxs-lookup"><span data-stu-id="45410-3321">mkrefany `class`</span></span>|<span data-ttu-id="45410-3322">型`class`の型指定された参照をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3322">Pushes a typed reference of type `class` onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-3323">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3323">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3324">データへのポインターがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3324">A pointer to piece of data is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3325">ポインターがポップされ、型の型`class`指定された参照に変換されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3325">The pointer is popped and converted to a typed reference of type `class`.</span></span>  
  
3.  <span data-ttu-id="45410-3326">型指定された参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3326">The typed reference is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3327">この`mkrefany`命令は、動的に型指定された参照を渡すことをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="45410-3327">The `mkrefany` instruction supports the passing of dynamically typed references.</span></span> <span data-ttu-id="45410-3328">ポインターの型`&` `*`は、、、または`native int`で、データの有効なアドレスを保持している必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3328">The pointer must be of type `&`, `*`, or `native int`, and hold the valid address of a piece of data.</span></span> <span data-ttu-id="45410-3329">`Class`は、ポインターによって参照されるデータの型を記述するクラストークンです。</span><span class="sxs-lookup"><span data-stu-id="45410-3329">`Class` is the class token describing the type of the data referenced by the pointer.</span></span> <span data-ttu-id="45410-3330">`Mkrefany`型指定された参照をスタックにプッシュし、ポインターと型`class`の不透明な記述子を提供します。</span><span class="sxs-lookup"><span data-stu-id="45410-3330">`Mkrefany` pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type `class`.</span></span>  
  
 <span data-ttu-id="45410-3331">型指定された参照に対して許可される有効な操作は、パラメーターとして型指定された参照を必要とするメソッドに渡すことだけです。</span><span class="sxs-lookup"><span data-stu-id="45410-3331">The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</span></span> <span data-ttu-id="45410-3332">呼び出し先は、 <xref:System.Reflection.Emit.OpCodes.Refanytype>および<xref:System.Reflection.Emit.OpCodes.Refanyval>命令を使用して、それぞれ型 (クラス) とアドレスを取得できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3332">The callee can then use the <xref:System.Reflection.Emit.OpCodes.Refanytype> and <xref:System.Reflection.Emit.OpCodes.Refanyval> instructions to retrieve the type (class) and the address respectively.</span></span>  
  
 <span data-ttu-id="45410-3333"><xref:System.TypeLoadException>が見つからない`class`場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3333"><xref:System.TypeLoadException> is thrown if `class` cannot be found.</span></span> <span data-ttu-id="45410-3334">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3334">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</span></span>  
  
 <span data-ttu-id="45410-3335">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `mkrefany`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3335">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mkrefany` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3336">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-3336">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3337">2 つの値を乗算し、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3337">Multiplies two values and pushes the result on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3338">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3338">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3339">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3339">Format</span></span>|<span data-ttu-id="45410-3340">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3340">Assembly Format</span></span>|<span data-ttu-id="45410-3341">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3341">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3342">5A</span><span class="sxs-lookup"><span data-stu-id="45410-3342">5A</span></span>|<span data-ttu-id="45410-3343">mul</span><span class="sxs-lookup"><span data-stu-id="45410-3343">mul</span></span>|<span data-ttu-id="45410-3344">スタックの2つの値を乗算します。</span><span class="sxs-lookup"><span data-stu-id="45410-3344">Multiplies two values on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3345">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3345">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3346">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3346">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3347">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3347">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3348">`value2`と`value1`はスタックからポップされます。`value1`にを `value2` 乗算します。</span><span class="sxs-lookup"><span data-stu-id="45410-3348">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`.</span></span>  
  
4.  <span data-ttu-id="45410-3349">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3349">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3350">命令`mul`はを`value1`乗算し、結果をスタックにプッシュします。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-3350">The `mul` instruction multiplies `value1` by `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="45410-3351">整数演算では、オーバーフロー時に上位ビットが自動的に切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-3351">Integer operations silently truncate the upper bits on overflow.</span></span>  
  
 <span data-ttu-id="45410-3352">オーバーフロー <xref:System.Reflection.Emit.OpCodes.Mul_Ovf>処理を伴う整数固有の乗算演算については、「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-3352">See <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> for an integer-specific multiply operation with overflow handling.</span></span>  
  
 <span data-ttu-id="45410-3353">浮動小数点型の場合は 0 \* 無限大 = NaN。</span><span class="sxs-lookup"><span data-stu-id="45410-3353">For floating-point types, 0 \* infinity = NaN.</span></span>  
  
 <span data-ttu-id="45410-3354">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `mul`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3354">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3355">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3355">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3356">2 つの整数を乗算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3356">Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3357">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3357">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3358">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3358">Format</span></span>|<span data-ttu-id="45410-3359">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3359">Assembly Format</span></span>|<span data-ttu-id="45410-3360">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3360">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3361">D8</span><span class="sxs-lookup"><span data-stu-id="45410-3361">D8</span></span>|<span data-ttu-id="45410-3362">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-3362">mul.ovf</span></span>|<span data-ttu-id="45410-3363">オーバーフローチェックを使用して、スタック上の2つの整数値を乗算します。</span><span class="sxs-lookup"><span data-stu-id="45410-3363">Multiplies two integer values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="45410-3364">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3364">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3365">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3365">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3366">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3366">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3367">`value2`と`value1`はスタックからポップされます。`value1`にを`value2`乗算し、オーバーフローチェックを行います。</span><span class="sxs-lookup"><span data-stu-id="45410-3367">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="45410-3368">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3368">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3369">命令`mul.ovf`は整数`value1`を整数`value2`で乗算し、結果をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3369">The `mul.ovf` instruction multiplies integer `value1` by integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="45410-3370">結果が結果の型に合わない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3370">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="45410-3371"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3371"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-3372">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `mul.ovf`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3372">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3373">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3373">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3374">2 つの符号なし整数を乗算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3374">Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3375">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3375">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3376">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3376">Format</span></span>|<span data-ttu-id="45410-3377">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3377">Assembly Format</span></span>|<span data-ttu-id="45410-3378">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3378">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3379">D9</span><span class="sxs-lookup"><span data-stu-id="45410-3379">D9</span></span>|<span data-ttu-id="45410-3380">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-3380">mul.ovf.un</span></span>|<span data-ttu-id="45410-3381">オーバーフローチェックを使用して、スタック上の2つの符号なしの値を乗算します。</span><span class="sxs-lookup"><span data-stu-id="45410-3381">Multiplies two unsigned values on the stack with an overflow check.</span></span>|  
  
 <span data-ttu-id="45410-3382">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3382">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3383">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3383">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3384">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3384">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3385">`value2`と`value1`はスタックからポップされます。`value1`にを`value2`乗算し、オーバーフローチェックを行います。</span><span class="sxs-lookup"><span data-stu-id="45410-3385">`value2` and `value1` are popped from the stack; `value1` is multiplied by `value2`, with an overflow check.</span></span>  
  
4.  <span data-ttu-id="45410-3386">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3386">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3387">命令`mul.ovf.un`は、符号なし`value1`整数を符号`value2`なし整数で乗算し、結果をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3387">The `mul.ovf.un` instruction multiplies unsigned integer `value1` by unsigned integer `value2` and pushes the result on the stack.</span></span> <span data-ttu-id="45410-3388">結果が結果の型に合わない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3388">An exception is thrown if the result will not fit in the result type.</span></span>  
  
 <span data-ttu-id="45410-3389"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3389"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-3390">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `mul.ovf.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3390">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `mul.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3391">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3391">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3392">値を無効にし、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3392">Negates a value and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3393">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3393">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3394">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3394">Format</span></span>|<span data-ttu-id="45410-3395">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3395">Assembly Format</span></span>|<span data-ttu-id="45410-3396">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3396">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3397">65</span><span class="sxs-lookup"><span data-stu-id="45410-3397">65</span></span>|<span data-ttu-id="45410-3398">neg</span><span class="sxs-lookup"><span data-stu-id="45410-3398">neg</span></span>|<span data-ttu-id="45410-3399">スタックの現在の上にある値を否定します。</span><span class="sxs-lookup"><span data-stu-id="45410-3399">Negates the value currently on top of the stack.</span></span>|  
  
 <span data-ttu-id="45410-3400">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3400">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3401">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3401">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3402">値はスタックからポップされ、否定されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3402">A value is popped from the stack and negated.</span></span>  
  
3.  <span data-ttu-id="45410-3403">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3403">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3404">命令`neg`は、値を否定し、結果をスタックの一番上にプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3404">The `neg` instruction negates value and pushes the result on top of the stack.</span></span> <span data-ttu-id="45410-3405">戻り値の型は、オペランドの型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-3405">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="45410-3406">整数値の否定は、標準の2の補数否定です。</span><span class="sxs-lookup"><span data-stu-id="45410-3406">Negation of integral values is standard two's complement negation.</span></span> <span data-ttu-id="45410-3407">特に、負の数 (正の値に対応する正の数値) を否定すると、最も負の数値が得られます。</span><span class="sxs-lookup"><span data-stu-id="45410-3407">In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</span></span> <span data-ttu-id="45410-3408">このオーバーフローを検出するに<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>は、代わりに命令を使用します (つまり、0から減算します)。</span><span class="sxs-lookup"><span data-stu-id="45410-3408">To detect this overflow use the <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instruction instead (that is, subtract from 0).</span></span>  
  
 <span data-ttu-id="45410-3409">浮動小数点数を否定することはできません。また、NaN を否定すると NaN が返されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3409">Negating a floating-point number cannot overflow, and negating NaN returns NaN.</span></span>  
  
 <span data-ttu-id="45410-3410">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `neg`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3410">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `neg` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3411">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3411">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3412">特定の型の要素を持つ、インデックス番号が 0 から始まる新しい 1 次元配列へのオブジェクト参照を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3412">Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3413">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3413">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3414">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3414">Format</span></span>|<span data-ttu-id="45410-3415">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3415">Assembly Format</span></span>|<span data-ttu-id="45410-3416">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3416">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3417">8D<`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3417">8D < `T` ></span></span>|<span data-ttu-id="45410-3418">newarr`etype`</span><span class="sxs-lookup"><span data-stu-id="45410-3418">newarr `etype`</span></span>|<span data-ttu-id="45410-3419">型`etype`の要素を使用して、新しい配列を作成します。</span><span class="sxs-lookup"><span data-stu-id="45410-3419">Creates a new array with elements of type `etype`.</span></span>|  
  
 <span data-ttu-id="45410-3420">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3420">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3421">配列内の要素の数がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3421">The number of elements in the array is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3422">要素の数がスタックからポップされ、配列が作成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3422">The number of elements is popped from the stack and the array is created.</span></span>  
  
3.  <span data-ttu-id="45410-3423">新しい配列へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3423">An object reference to the new array is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3424">命令`newarr`は、オブジェクト参照 (型`O`) を、要素が型`etype` (型を記述するメタデータトークン) である、新しい0から始まる1次元配列にプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3424">The `newarr` instruction pushes an object reference (type `O`) to a new zero-based, one-dimensional array whose elements are of type `etype` (a metadata token describing the type).</span></span> <span data-ttu-id="45410-3425">新しい配列内の要素の数は、 `native int`として指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3425">The number of elements in the new array should be specified as a `native int`.</span></span> <span data-ttu-id="45410-3426">有効な配列のインデックスの範囲は、0から最大で1を引いた数までです。</span><span class="sxs-lookup"><span data-stu-id="45410-3426">Valid array indexes range from zero to the maximum number of elements minus one.</span></span>  
  
 <span data-ttu-id="45410-3427">配列の要素は、値型を含む任意の型にすることができます。</span><span class="sxs-lookup"><span data-stu-id="45410-3427">The elements of an array can be any type, including value types.</span></span>  
  
 <span data-ttu-id="45410-3428">0から始まる、数値の1次元配列は、適切な値型 (<xref:System.Int32>など) を参照するメタデータトークンを使用して作成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3428">Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref:System.Int32>, and so on).</span></span> <span data-ttu-id="45410-3429">配列の要素は、適切な型の0に初期化されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3429">Elements of the array are initialized to 0 of the appropriate type.</span></span>  
  
 <span data-ttu-id="45410-3430">0以外のベースの1次元配列と多次元配列は、 <xref:System.Reflection.Emit.OpCodes.Newobj> `newarr`ではなくを使用して作成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3430">Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newobj> rather than `newarr`.</span></span> <span data-ttu-id="45410-3431">一般的には、.NET Framework の<xref:System.Array>クラスのメソッドを使用して作成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3431">More commonly, they are created using the methods of the <xref:System.Array> class in the .NET Framework.</span></span>  
  
 <span data-ttu-id="45410-3432"><xref:System.OutOfMemoryException>要求を満たすのに十分なメモリがない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3432"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="45410-3433"><xref:System.OverflowException>が0未満`numElems`の場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3433"><xref:System.OverflowException> is thrown if `numElems` is less than 0.</span></span>  
  
 <span data-ttu-id="45410-3434">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `newarr`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3434">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newarr` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3435">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-3435">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3436">新しいオブジェクトまたは値型の新しいインスタンスを作成し、オブジェクト参照 (<see langword="O" /> 型) を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3436">Creates a new object or a new instance of a value type, pushing an object reference (type <see langword="O" />) onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3437">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3437">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3438">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3438">Format</span></span>|<span data-ttu-id="45410-3439">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3439">Assembly Format</span></span>|<span data-ttu-id="45410-3440">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3440">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3441">73 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3441">73 < `T` ></span></span>|<span data-ttu-id="45410-3442">newobj`ctor`</span><span class="sxs-lookup"><span data-stu-id="45410-3442">newobj `ctor`</span></span>|<span data-ttu-id="45410-3443">初期化されていないオブジェクトまたは値型`ctor`を割り当て、コンストラクターメソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-3443">Allocates an uninitialized object or value type and calls the constructor method `ctor`.</span></span>|  
  
 <span data-ttu-id="45410-3444">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3444">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3445">`arg1` から `argn` の引数は、順番にスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3445">Arguments `arg1` through `argn` are pushed on the stack in sequence.</span></span>  
  
2.  <span data-ttu-id="45410-3446">から`argn` `ctor`の引数はスタックからポップされ、オブジェクトの作成のためにに渡されます。 `arg1`</span><span class="sxs-lookup"><span data-stu-id="45410-3446">Arguments `argn` through `arg1` are popped from the stack and passed to `ctor` for object creation.</span></span>  
  
3.  <span data-ttu-id="45410-3447">新しいオブジェクトへの参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3447">A reference to the new object is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3448">命令`newobj`は、新しいオブジェクトまたは値型の新しいインスタンスを作成します。</span><span class="sxs-lookup"><span data-stu-id="45410-3448">The `newobj` instruction creates a new object or a new instance of a value type.</span></span> <span data-ttu-id="45410-3449">`Ctor`は、呼び出すコンストラクターの名前`methodref` 、 `methoddef`クラス、およびシグネチャを示すメタデータトークン (またはコンストラクターとしてマークされる必要がある) です。</span><span class="sxs-lookup"><span data-stu-id="45410-3449">`Ctor` is a metadata token (a `methodref` or `methoddef` that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</span></span>  
  
 <span data-ttu-id="45410-3450">命令`newobj`は、に関連付けられたクラスの`ctor`新しいインスタンスを割り当て、新しいインスタンス内のすべてのフィールドを 0 (適切な型の) または null 参照 (適切な場合) に初期化します。</span><span class="sxs-lookup"><span data-stu-id="45410-3450">The `newobj` instruction allocates a new instance of the class associated with `ctor` and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</span></span> <span data-ttu-id="45410-3451">次に、新しく作成`ctor`されたインスタンスと共に、指定された引数を使用してコンストラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="45410-3451">It then calls the constructor `ctor` with the given arguments along with the newly created instance.</span></span> <span data-ttu-id="45410-3452">コンストラクターが呼び出されると、現在初期化されているオブジェクト参照`O`(型) がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3452">After the constructor has been called, the now initialized object reference (type `O`) is pushed on the stack.</span></span>  
  
 <span data-ttu-id="45410-3453">コンストラクターの観点からは、初期化されていないオブジェクトは引数0であり、newobj に渡される他の引数は順に続きます。</span><span class="sxs-lookup"><span data-stu-id="45410-3453">From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</span></span>  
  
 <span data-ttu-id="45410-3454">0から始まるすべての1次元配列は、では<xref:System.Reflection.Emit.OpCodes.Newarr>なく`newobj`、を使用して作成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3454">All zero-based, one-dimensional arrays are created using <xref:System.Reflection.Emit.OpCodes.Newarr>, not `newobj`.</span></span> <span data-ttu-id="45410-3455">一方、を使用して`newobj`、他のすべての配列 (複数の次元、または1次元であるが0から始まらない配列) が作成されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3455">On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using `newobj`.</span></span>  
  
 <span data-ttu-id="45410-3456">値型は、通常はを`newobj`使用して作成されません。</span><span class="sxs-lookup"><span data-stu-id="45410-3456">Value types are not usually created using `newobj`.</span></span> <span data-ttu-id="45410-3457">通常、これらは引数またはローカル変数として`newarr` 、(0 から始まる、1次元の配列の場合)、またはオブジェクトのフィールドとして割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-3457">They are usually allocated either as arguments or local variables, using `newarr` (for zero-based, one-dimensional arrays), or as fields of objects.</span></span> <span data-ttu-id="45410-3458">割り当てられると、を使用<xref:System.Reflection.Emit.OpCodes.Initobj>して初期化されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3458">Once allocated, they are initialized using <xref:System.Reflection.Emit.OpCodes.Initobj>.</span></span> <span data-ttu-id="45410-3459">ただし、 `newobj`命令を使用して、スタック上に値型の新しいインスタンスを作成し、そのインスタンスを引数として渡したり、ローカルに格納したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="45410-3459">However, the `newobj` instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</span></span>  
  
 <span data-ttu-id="45410-3460"><xref:System.OutOfMemoryException>要求を満たすのに十分なメモリがない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3460"><xref:System.OutOfMemoryException> is thrown if there is insufficient memory to satisfy the request.</span></span>  
  
 <span data-ttu-id="45410-3461"><xref:System.MissingMethodException>は、指定された`ctor`名前、クラス、およびシグネチャを持つコンストラクターメソッドが見つからない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3461"><xref:System.MissingMethodException> is thrown if a constructor method `ctor` with the indicated name, class and signature could not be found.</span></span> <span data-ttu-id="45410-3462">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3462">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="45410-3463">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `newobj`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3463">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `newobj` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3464">ILGenerator (オペコード, ConstructorInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-3464">ILGenerator.Emit(OpCode, ConstructorInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3465">オペコードがパッチされている場合は、領域を補完します。</span><span class="sxs-lookup"><span data-stu-id="45410-3465">Fills space if opcodes are patched.</span></span> <span data-ttu-id="45410-3466">循環参照の処理を利用することはできますが、意味のある演算は行われません。</span><span class="sxs-lookup"><span data-stu-id="45410-3466">No meaningful operation is performed although a processing cycle can be consumed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3467">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3467">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3468">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3468">Format</span></span>|<span data-ttu-id="45410-3469">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3469">Assembly Format</span></span>|<span data-ttu-id="45410-3470">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3470">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3471">00</span><span class="sxs-lookup"><span data-stu-id="45410-3471">00</span></span>|<span data-ttu-id="45410-3472">nop</span><span class="sxs-lookup"><span data-stu-id="45410-3472">nop</span></span>|<span data-ttu-id="45410-3473">動作を指定せずに操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="45410-3473">Performs an operation without behavior.</span></span>|  
  
 <span data-ttu-id="45410-3474">この命令には、スタック移行動作は定義されていません。</span><span class="sxs-lookup"><span data-stu-id="45410-3474">There is no stack transitional behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="45410-3475">`nop`操作は何も行いません。</span><span class="sxs-lookup"><span data-stu-id="45410-3475">The `nop` operation does nothing.</span></span> <span data-ttu-id="45410-3476">これは、オペコードにパッチが適用されている場合に領域を埋めることを目的としています。</span><span class="sxs-lookup"><span data-stu-id="45410-3476">It is intended to fill in space if opcodes are patched.</span></span>  
  
 <span data-ttu-id="45410-3477">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `nop`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3477">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `nop` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3478">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3478">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3479">スタックの一番上にある整数値のビットごとの補数を計算し、結果を同じ型として評価スタックの一番上にプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3479">Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3480">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3480">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3481">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3481">Format</span></span>|<span data-ttu-id="45410-3482">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3482">Assembly Format</span></span>|<span data-ttu-id="45410-3483">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3483">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3484">66</span><span class="sxs-lookup"><span data-stu-id="45410-3484">66</span></span>|<span data-ttu-id="45410-3485">not</span><span class="sxs-lookup"><span data-stu-id="45410-3485">not</span></span>|<span data-ttu-id="45410-3486">値のビットごとの補数を計算します。</span><span class="sxs-lookup"><span data-stu-id="45410-3486">Computes the bitwise complement of a value.</span></span>|  
  
 <span data-ttu-id="45410-3487">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3487">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3488">`value`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3488">`value` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3489">`value`スタックからポップされ、ビットごとの補数が計算されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3489">`value` is popped from the stack and its bitwise complement computed.</span></span>  
  
3.  <span data-ttu-id="45410-3490">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3490">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3491">命令`not`は、整数値のビットごとの補数を計算し、結果をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3491">The `not` instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</span></span> <span data-ttu-id="45410-3492">戻り値の型は、オペランドの型と同じです。</span><span class="sxs-lookup"><span data-stu-id="45410-3492">The return type is the same as the operand type.</span></span>  
  
 <span data-ttu-id="45410-3493">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `not`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3493">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `not` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3494">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3494">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3495">スタックの一番上にある 2 つの整数値のビットごとの補数を計算し、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3495">Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3496">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3496">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3497">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3497">Format</span></span>|<span data-ttu-id="45410-3498">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3498">Assembly Format</span></span>|<span data-ttu-id="45410-3499">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3499">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3500">60</span><span class="sxs-lookup"><span data-stu-id="45410-3500">60</span></span>|<span data-ttu-id="45410-3501">or</span><span class="sxs-lookup"><span data-stu-id="45410-3501">or</span></span>|<span data-ttu-id="45410-3502">2つの整数値のビットごとの OR を計算し、整数を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-3502">Computes the bitwise OR of two integer values, returns an integer.</span></span>|  
  
 <span data-ttu-id="45410-3503">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3503">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3504">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3504">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3505">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3505">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3506">`value2`と`value1`はスタックからポップされ、ビットごとの or 演算が計算されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3506">`value2` and `value1` are popped from the stack and their bitwise OR computed.</span></span>  
  
4.  <span data-ttu-id="45410-3507">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3507">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3508">命令`or`は、スタックの一番上にある2つの値のビットごとの or を計算し、結果をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3508">The `or` instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3509">`Or`は整数固有の演算です。</span><span class="sxs-lookup"><span data-stu-id="45410-3509">`Or` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="45410-3510">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `or`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3510">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `or` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3511">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3511">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3512">現在評価スタックの一番上にある値を削除します。</span><span class="sxs-lookup"><span data-stu-id="45410-3512">Removes the value currently on top of the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3513">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3513">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3514">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3514">Format</span></span>|<span data-ttu-id="45410-3515">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3515">Assembly Format</span></span>|<span data-ttu-id="45410-3516">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3516">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3517">26</span><span class="sxs-lookup"><span data-stu-id="45410-3517">26</span></span>|<span data-ttu-id="45410-3518">pop</span><span class="sxs-lookup"><span data-stu-id="45410-3518">pop</span></span>|<span data-ttu-id="45410-3519">スタックから上位の値をポップします。</span><span class="sxs-lookup"><span data-stu-id="45410-3519">Pops the top value from the stack.</span></span>|  
  
 <span data-ttu-id="45410-3520">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3520">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3521">最上位の値がスタックからポップされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3521">The top value is popped from the stack.</span></span>  
  
 <span data-ttu-id="45410-3522">命令`pop`は、スタックから最上位の要素を削除します。</span><span class="sxs-lookup"><span data-stu-id="45410-3522">The `pop` instruction removes the top element from the stack.</span></span>  
  
 <span data-ttu-id="45410-3523">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `pop`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3523">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `pop` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3524">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3524">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3525">これは予約済みの命令です。</span><span class="sxs-lookup"><span data-stu-id="45410-3525">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3526">これは予約済みの命令です。</span><span class="sxs-lookup"><span data-stu-id="45410-3526">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3527">これは予約済みの命令です。</span><span class="sxs-lookup"><span data-stu-id="45410-3527">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3528">これは予約済みの命令です。</span><span class="sxs-lookup"><span data-stu-id="45410-3528">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3529">これは予約済みの命令です。</span><span class="sxs-lookup"><span data-stu-id="45410-3529">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3530">これは予約済みの命令です。</span><span class="sxs-lookup"><span data-stu-id="45410-3530">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3531">これは予約済みの命令です。</span><span class="sxs-lookup"><span data-stu-id="45410-3531">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3532">これは予約済みの命令です。</span><span class="sxs-lookup"><span data-stu-id="45410-3532">This is a reserved instruction.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3533">以降の配列アドレス演算で、実行時に型チェックを実行しないこと、および変更可能性が制限されたマネージド ポインターを返すことを指定します。</span><span class="sxs-lookup"><span data-stu-id="45410-3533">Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3534">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3534">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3535">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3535">Format</span></span>|<span data-ttu-id="45410-3536">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3536">Assembly Format</span></span>|<span data-ttu-id="45410-3537">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3537">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3538">FE 1E</span><span class="sxs-lookup"><span data-stu-id="45410-3538">FE 1E</span></span>|<span data-ttu-id="45410-3539">readonly.</span><span class="sxs-lookup"><span data-stu-id="45410-3539">readonly.</span></span>|<span data-ttu-id="45410-3540">後続の配列アドレス操作が実行時に型チェックを実行しないことと、制限された可能性が制限されたマネージポインターを返すことを指定します。</span><span class="sxs-lookup"><span data-stu-id="45410-3540">Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</span></span>|  
  
 <span data-ttu-id="45410-3541">このプレフィックスは、命令の`ldelema`直前にのみ表示され、配列で特別な`Address`メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-3541">This prefix can only appear immediately preceding the `ldelema` instruction and calls to the special `Address` method on arrays.</span></span> <span data-ttu-id="45410-3542">後続の操作に対する影響は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="45410-3542">Its effect on the subsequent operation is twofold:</span></span>  
  
1.  <span data-ttu-id="45410-3543">実行時には、型チェック操作は実行されません。</span><span class="sxs-lookup"><span data-stu-id="45410-3543">At run time, no type check operation is performed.</span></span> <span data-ttu-id="45410-3544">参照型の配列で使用する場合は、通常`ldelema` 、 `stelem`および命令に対して暗黙的な型チェックがあることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-3544">Note that there is normally an implicit type check for the `ldelema` and `stelem` instructions when used on reference type arrays.</span></span> <span data-ttu-id="45410-3545">値クラスに対して実行時の型チェックが行われること`readonly`はありません。そのため、その場合は no op が使用されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3545">There is never a run-time type check for value classes, so `readonly` is a no-op in that case.</span></span>  
  
2.  <span data-ttu-id="45410-3546">検証ツールは、アドレス操作の結果を、相互実行性が制限されたマネージポインターとして扱います。</span><span class="sxs-lookup"><span data-stu-id="45410-3546">The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</span></span>  
  
 <span data-ttu-id="45410-3547">ポインターは、値を変換できるかどうかを定義する型によって制御されるので、このポインターは、制限性が制限されていると言います。</span><span class="sxs-lookup"><span data-stu-id="45410-3547">The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</span></span> <span data-ttu-id="45410-3548">パブリックフィールドまたは値を更新するメソッドを公開しない値クラスの場合、ポインターは読み取り専用になります (したがって、プレフィックスの名前)。</span><span class="sxs-lookup"><span data-stu-id="45410-3548">For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</span></span> <span data-ttu-id="45410-3549">特に、プリミティブ型 (system.string など) を表すクラスは、ミューテーターを公開しないため、読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="45410-3549">In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</span></span>  
  
 <span data-ttu-id="45410-3550">この方法で制限されているマネージポインターは、次の方法でのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3550">A managed pointer restricted in this fashion can be used only in the following ways:</span></span>  
  
-   <span data-ttu-id="45410-3551">`ldfld` `object` 、 、、 `call` 、の各命令のパラメーターとして。 `constrained callvirt`  `ldflda` `stfld`</span><span class="sxs-lookup"><span data-stu-id="45410-3551">As the `object` parameter for the `ldfld`, `ldflda`, `stfld`, `call`, or`constrained callvirt` instructions.</span></span>  
  
-   <span data-ttu-id="45410-3552">`ldobj`命令の`ldind`パラメーターとして、またはいずれかの命令に指定します。 `pointer`</span><span class="sxs-lookup"><span data-stu-id="45410-3552">As the `pointer` parameter to the `ldobj` instruction or to one of the `ldind` instructions.</span></span>  
  
-   <span data-ttu-id="45410-3553">命令の`source` `cpobj`パラメーターとして指定します。</span><span class="sxs-lookup"><span data-stu-id="45410-3553">As the `source` parameter to the `cpobj` instruction.</span></span>  
  
 <span data-ttu-id="45410-3554">`stobj`、 `stind` 、または `mkrefany` 操作、またはいずれかの命令を含む、許可されていない他のすべての操作。 `initobj`</span><span class="sxs-lookup"><span data-stu-id="45410-3554">All other operations disallowed, including the `stobj`, `initobj`, or `mkrefany` operations, or any of the `stind` instructions.</span></span>  
  
 <span data-ttu-id="45410-3555">`readonly`プレフィックスの目的は、ジェネリックコードで配列から要素をフェッチするときに型チェックが行われないようにすることです。</span><span class="sxs-lookup"><span data-stu-id="45410-3555">The purpose of the `readonly` prefix is to avoid a type check when fetching an element from an array in generic code.</span></span> <span data-ttu-id="45410-3556">たとえば、という式`arr[i].m()`では、配列`arr`の要素型は、メソッド`m`を使用してインターフェイスを持つように制約されたジェネリック型であるため、次の MSIL にコンパイルされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3556">For example, the expression `arr[i].m()`, where the element type of the array `arr` is a generic type that has been constrained to have an interface with method `m`, might compile to the following MSIL.</span></span>  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 <span data-ttu-id="45410-3557">プレフィックスが`readonly`ない場合、 `ldelema`命令は、! 0 が参照型である場合に型チェックを実行します。</span><span class="sxs-lookup"><span data-stu-id="45410-3557">Without the `readonly` prefix, the `ldelema` instruction would perform a type check in the case where !0 was a reference type.</span></span> <span data-ttu-id="45410-3558">この型チェックは非効率的ですが、意味が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="45410-3558">Not only is this type check inefficient, but it is semantically incorrect.</span></span> <span data-ttu-id="45410-3559">の`ldelema`型チェックは厳密に一致していますが、これは厳密なものではありません。</span><span class="sxs-lookup"><span data-stu-id="45410-3559">The type check for `ldelema` is an exact match, which is too strong.</span></span> <span data-ttu-id="45410-3560">配列に型! 0 のサブクラスが保持されている場合、上記のコードは型チェックに失敗します。</span><span class="sxs-lookup"><span data-stu-id="45410-3560">If the array held subclasses of type !0, the code above would fail the type check.</span></span>  
  
 <span data-ttu-id="45410-3561">配列要素のアドレスは、要素自体ではなく、値型と参照型の両方で動作する`arr[i]`のハンドルを持つためにフェッチされます。したがって、 `constrained callvirt`命令に渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-3561">The address of the array element is fetched, instead of the element itself, in order to have a handle for `arr[i]` that works for both value types and reference types, and thus can be passed to the `constrained callvirt` instruction.</span></span>  
  
 <span data-ttu-id="45410-3562">一般に、参照型の要素が配列に保持されている場合、実行時チェックをスキップすることは安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="45410-3562">In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</span></span> <span data-ttu-id="45410-3563">安全にするには、このポインターを使用して配列を変更しないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3563">To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</span></span> <span data-ttu-id="45410-3564">検証規則によってこのことが保証されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3564">The verifier rules ensure this.</span></span> <span data-ttu-id="45410-3565">制限付きマネージポインターは、インスタンスメソッド呼び出しのオブジェクトとして渡すことができるため、厳密には値型の読み取り専用ではありませんが、値型にはタイプセーフの問題はありません。</span><span class="sxs-lookup"><span data-stu-id="45410-3565">The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</span></span>  
  
 <span data-ttu-id="45410-3566">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `readonly`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3566">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `readonly` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3567">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3567">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3568">型指定された参照に埋め込まれている型トークンを取得します。</span><span class="sxs-lookup"><span data-stu-id="45410-3568">Retrieves the type token embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3569">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3569">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3570">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3570">Format</span></span>|<span data-ttu-id="45410-3571">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3571">Assembly Format</span></span>|<span data-ttu-id="45410-3572">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3572">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3573">FE 1D</span><span class="sxs-lookup"><span data-stu-id="45410-3573">FE 1D</span></span>|<span data-ttu-id="45410-3574">refanytype</span><span class="sxs-lookup"><span data-stu-id="45410-3574">refanytype</span></span>|<span data-ttu-id="45410-3575">型指定された参照に格納されている型トークンをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3575">Pushes the type token stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="45410-3576">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3576">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3577">値型参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3577">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3578">型指定された参照がスタックからポップされ、対応する型トークンが取得されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3578">The typed reference is popped from the stack and its corresponding type token retrieved.</span></span>  
  
3.  <span data-ttu-id="45410-3579">型トークンがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3579">The type token is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3580">型指定された参照には、型トークンとオブジェクトインスタンスへのアドレスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="45410-3580">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="45410-3581">命令`refanytype`は、型指定された参照に埋め込まれている型トークンを取得します。</span><span class="sxs-lookup"><span data-stu-id="45410-3581">The `refanytype` instruction retrieves the type token embedded in the typed reference.</span></span> <span data-ttu-id="45410-3582">型指定<xref:System.Reflection.Emit.OpCodes.Mkrefany>された参照の作成については、「」の手順を参照してください。</span><span class="sxs-lookup"><span data-stu-id="45410-3582">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for information on creating typed references.</span></span>  
  
 <span data-ttu-id="45410-3583">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `refanytype`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3583">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanytype` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3584">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3584">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3585">型指定された参照に埋め込まれているアドレス (<see langword="&amp;" /> 型) を取得します。</span><span class="sxs-lookup"><span data-stu-id="45410-3585">Retrieves the address (type <see langword="&amp;" />) embedded in a typed reference.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3586">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3586">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3587">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3587">Format</span></span>|<span data-ttu-id="45410-3588">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3588">Assembly Format</span></span>|<span data-ttu-id="45410-3589">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3589">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3590">C2 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3590">C2 < `T` ></span></span>|<span data-ttu-id="45410-3591">refanyval`type`</span><span class="sxs-lookup"><span data-stu-id="45410-3591">refanyval `type`</span></span>|<span data-ttu-id="45410-3592">型指定された参照に格納されているアドレスをプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3592">Pushes the address stored in a typed reference.</span></span>|  
  
 <span data-ttu-id="45410-3593">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3593">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3594">値型参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3594">A value type reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3595">型指定された参照がスタックからポップされ、対応するアドレスが取得されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3595">The typed reference is popped from the stack and the corresponding address retrieved.</span></span>  
  
3.  <span data-ttu-id="45410-3596">アドレスはスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3596">The address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3597">型指定された参照には、型トークンとオブジェクトインスタンスへのアドレスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="45410-3597">A typed reference contains a type token and an address to an object instance.</span></span>  
  
 <span data-ttu-id="45410-3598">命令`refanyval`は、型指定された参照に埋め込まれているアドレスを取得します。</span><span class="sxs-lookup"><span data-stu-id="45410-3598">The `refanyval` instruction retrieves the address embedded in the a typed reference.</span></span> <span data-ttu-id="45410-3599">スタックに指定された型指定された参照に埋め込まれた`type`型は、によって指定`typedef`され`typeref`た型 (またはのいずれか) と一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3599">The type embedded in the typed reference supplied on the stack must match the type specified by `type` (a metadata token, either a `typedef` or a `typeref`).</span></span> <span data-ttu-id="45410-3600">関連するコンテンツの指示を参照してください。 <xref:System.Reflection.Emit.OpCodes.Mkrefany></span><span class="sxs-lookup"><span data-stu-id="45410-3600">See the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction for related content.</span></span>  
  
 <span data-ttu-id="45410-3601"><xref:System.InvalidCastException>が型参照`type`に格納されている型と同一でない場合 (この場合`type`は、型指定され<xref:System.Reflection.Emit.OpCodes.Mkrefany>た参照を構築した命令に提供されるクラス)、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3601"><xref:System.InvalidCastException> is thrown if `type` is not identical to the type stored in the type reference (in this case, `type` is the class supplied to the <xref:System.Reflection.Emit.OpCodes.Mkrefany> instruction that constructed said typed reference).</span></span>  
  
 <span data-ttu-id="45410-3602"><xref:System.TypeLoadException>が見つからない`type`場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3602"><xref:System.TypeLoadException> is thrown if `type` cannot be found.</span></span>  
  
 <span data-ttu-id="45410-3603">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `refanyval`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3603">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `refanyval` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3604">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-3604">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3605">2 つの値を除算し、剰余を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3605">Divides two values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3606">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3606">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3607">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3607">Format</span></span>|<span data-ttu-id="45410-3608">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3608">Assembly Format</span></span>|<span data-ttu-id="45410-3609">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3609">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3610">5D</span><span class="sxs-lookup"><span data-stu-id="45410-3610">5D</span></span>|<span data-ttu-id="45410-3611">rem</span><span class="sxs-lookup"><span data-stu-id="45410-3611">rem</span></span>|<span data-ttu-id="45410-3612">`value1` で `value2` 除算した剰余をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3612">Pushes the remainder of dividing `value1` by `value2` onto the stack.</span></span>|  
  
  
 <span data-ttu-id="45410-3613">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3613">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3614">`value1`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3614">A `value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3615">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3615">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3616">`value2`および`value1`はスタックからポップされ、計算の`value1` `div` `value2`残りの部分からポップされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3616">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="45410-3617">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3617">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3618">`result` = `value1``rem` 次 `value2` の条件を満たす:</span><span class="sxs-lookup"><span data-stu-id="45410-3618">`result` = `value1` `rem` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="45410-3619">`result` = `value1` - `value2``×` ( )、 `value1` および: `div` `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-3619">`result` = `value1` - `value2` `×` (`value1` `div` `value2`), and:</span></span>  
  
 <span data-ttu-id="45410-3620">0 = &#124; `result` &#124; < &#124; ( `result` ) = `div` sign (`value1`)。ここで、は0方向に切り捨てられる除算命令です。 `value2` &#124;</span><span class="sxs-lookup"><span data-stu-id="45410-3620">0 = &#124; `result` &#124; < &#124; `value2` &#124;, sign(`result`) = sign(`value1`), where `div` is the division instruction that truncates towards zero.</span></span>  
  
 <span data-ttu-id="45410-3621">が`value2` 0 また`value1`は無限大の場合、結果は NaN になります。</span><span class="sxs-lookup"><span data-stu-id="45410-3621">If `value2` is zero or `value1` is infinity the result is NaN.</span></span> <span data-ttu-id="45410-3622">が`value2`無限大の場合、結果`value1`はになり`-infinity`ます (に対しては否定されます)。</span><span class="sxs-lookup"><span data-stu-id="45410-3622">If `value2` is infinity, the result is `value1` (negated for `-infinity`).</span></span>  
  
 <span data-ttu-id="45410-3623">が0の<xref:System.DivideByZeroException>場合`value2` 、整数演算がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3623">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="45410-3624">Intel ベースのプラットフォームでは、(minint <xref:System.OverflowException> `rem` -1) を計算すると、がスローされることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-3624">Note that on the Intel-based platforms an <xref:System.OverflowException> is thrown when computing (minint `rem` -1).</span></span>  
  
 <span data-ttu-id="45410-3625">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `rem`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3625">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3626">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3626">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3627">2 つの符号なしの値を除算し、剰余を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3627">Divides two unsigned values and pushes the remainder onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3628">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3628">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3629">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3629">Format</span></span>|<span data-ttu-id="45410-3630">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3630">Assembly Format</span></span>|<span data-ttu-id="45410-3631">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3631">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3632">5E</span><span class="sxs-lookup"><span data-stu-id="45410-3632">5E</span></span>|<span data-ttu-id="45410-3633">rem</span><span class="sxs-lookup"><span data-stu-id="45410-3633">rem.un</span></span>|<span data-ttu-id="45410-3634">符号なし`value1`のを符号`value2`なしで除算した剰余をスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3634">Pushes the remainder of dividing unsigned `value1` by unsigned `value2` onto the stack.</span></span>|  
  
 <span data-ttu-id="45410-3635">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3635">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3636">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3636">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3637">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3637">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3638">`value2`および`value1`はスタックからポップされ、計算の`value1` `div` `value2`残りの部分からポップされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3638">`value2` and `value1` are popped from the stack and the remainder of `value1` `div` `value2` computed.</span></span>  
  
4.  <span data-ttu-id="45410-3639">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3639">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3640">`result` = `value1``rem.un` 次 `value2` の条件を満たす:</span><span class="sxs-lookup"><span data-stu-id="45410-3640">`result` = `value1` `rem.un` `value2` satisfies the following conditions:</span></span>  
  
 <span data-ttu-id="45410-3641">`result` = `value1` - `value2`x (`value1` `div.un` )、および `value2` :</span><span class="sxs-lookup"><span data-stu-id="45410-3641">`result` = `value1` - `value2` x(`value1` `div.un` `value2`), and:</span></span>  
  
 <span data-ttu-id="45410-3642">0 = `result`  <  。ここ `div.un` で、は符号なし除算命令です。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-3642">0 = `result` < `value2`, where `div.un` is the unsigned division instruction.</span></span>  
  
 <span data-ttu-id="45410-3643">命令`rem.un`は、 `result`を計算してスタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3643">The `rem.un` instruction computes `result` and pushes it on the stack.</span></span> <span data-ttu-id="45410-3644">`Rem.un`は、引数を符号なし整数と<xref:System.Reflection.Emit.OpCodes.Rem>して処理し、は符号付き整数として扱います。</span><span class="sxs-lookup"><span data-stu-id="45410-3644">`Rem.un` treats its arguments as unsigned integers, while <xref:System.Reflection.Emit.OpCodes.Rem> treats them as signed integers.</span></span>  
  
 <span data-ttu-id="45410-3645">`Rem.un`は、浮動小数点数では指定されていません。</span><span class="sxs-lookup"><span data-stu-id="45410-3645">`Rem.un` is unspecified for floating-point numbers.</span></span>  
  
 <span data-ttu-id="45410-3646">が0の<xref:System.DivideByZeroException>場合`value2` 、整数演算がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3646">Integral operations throw <xref:System.DivideByZeroException> if `value2` is zero.</span></span>  
  
 <span data-ttu-id="45410-3647">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `rem.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3647">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rem.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3648">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3648">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3649">現在のメソッドから戻り、呼び出し先の評価スタックから呼び出し元の評価スタックに戻り値 (存在する場合) をプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3649">Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3650">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3650">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3651">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3651">Format</span></span>|<span data-ttu-id="45410-3652">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3652">Assembly Format</span></span>|<span data-ttu-id="45410-3653">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3653">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3654">2A></span><span class="sxs-lookup"><span data-stu-id="45410-3654">2A</span></span>|<span data-ttu-id="45410-3655">ret</span><span class="sxs-lookup"><span data-stu-id="45410-3655">ret</span></span>|<span data-ttu-id="45410-3656">はメソッドからを返します。値を返す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3656">Returns from method, possibly returning a value.</span></span>|  
  
 <span data-ttu-id="45410-3657">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3657">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3658">戻り値は、呼び出し先の評価スタックからポップされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3658">The return value is popped from the callee evaluation stack.</span></span>  
  
2.  <span data-ttu-id="45410-3659">手順 1. で取得した戻り値は、呼び出し元の評価スタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3659">The return value obtained in step 1 is pushed onto the caller evaluation stack.</span></span>  
  
 <span data-ttu-id="45410-3660">呼び出し先の評価スタックに戻り値が存在しない場合、値は返されません (呼び出し先または呼び出し元のメソッドのスタック遷移動作はありません)。</span><span class="sxs-lookup"><span data-stu-id="45410-3660">If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</span></span>  
  
 <span data-ttu-id="45410-3661">現在のメソッドの戻り値の型によって、スタックの一番上からフェッチされ、現在のメソッドを呼び出したメソッドのスタックにコピーされる値の型が決まります。</span><span class="sxs-lookup"><span data-stu-id="45410-3661">The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</span></span> <span data-ttu-id="45410-3662">返される値を除き、現在のメソッドの評価スタックは空である必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3662">The evaluation stack for the current method must be empty except for the value to be returned.</span></span>  
  
 <span data-ttu-id="45410-3663">命令`ret`を使用して`try`、、 `filter` `catch`、、または`finally`ブロックから制御を移すことはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-3663">The `ret` instruction cannot be used to transfer control out of a`try`, `filter`, `catch`, or `finally` block.</span></span> <span data-ttu-id="45410-3664">`try`または`catch`内から、命令を<xref:System.Reflection.Emit.OpCodes.Leave> `ret` 、外側のすべての例外ブロックの外側にある命令の出力先と共に使用します。</span><span class="sxs-lookup"><span data-stu-id="45410-3664">From within a `try` or `catch`, use the <xref:System.Reflection.Emit.OpCodes.Leave> instruction with a destination of a `ret` instruction that is outside all enclosing exception blocks.</span></span> <span data-ttu-id="45410-3665">`filter`ブロックと`finally`ブロックは論理的には例外処理の一部であり、コードが埋め込まれているメソッドではないため、正しく生成された Microsoft 中間言語 (MSIL) 命令は、内部からメソッドを返しません。`filter`または`finally`。</span><span class="sxs-lookup"><span data-stu-id="45410-3665">Because the `filter` and `finally` blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a `filter` or `finally`.</span></span>  
  
 <span data-ttu-id="45410-3666">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `ret`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3666">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `ret` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3667">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3667">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3668">現在の例外を再スローします。</span><span class="sxs-lookup"><span data-stu-id="45410-3668">Rethrows the current exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3669">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3669">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3670">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3670">Format</span></span>|<span data-ttu-id="45410-3671">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3671">Assembly Format</span></span>|<span data-ttu-id="45410-3672">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3672">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3673">FE 1A</span><span class="sxs-lookup"><span data-stu-id="45410-3673">FE 1A</span></span>|<span data-ttu-id="45410-3674">スロー</span><span class="sxs-lookup"><span data-stu-id="45410-3674">rethrow</span></span>|<span data-ttu-id="45410-3675">現在の例外を再スローします</span><span class="sxs-lookup"><span data-stu-id="45410-3675">Rethrows the current exception</span></span>|  
  
 <span data-ttu-id="45410-3676">この命令には、スタック移行動作は定義されていません。</span><span class="sxs-lookup"><span data-stu-id="45410-3676">No stack transition behavior is defined for this instruction.</span></span>  
  
 <span data-ttu-id="45410-3677">命令`rethrow`は、 `catch`ハンドラーの本体内でのみ許可されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3677">The `rethrow` instruction is only permitted within the body of a `catch` handler.</span></span> <span data-ttu-id="45410-3678">このハンドラーでキャッチされたのと同じ例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-3678">It throws the same exception that was caught by this handler.</span></span>  
  
 <span data-ttu-id="45410-3679">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `rethrow`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3679">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `rethrow` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3680">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3680">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3681">整数値を指定したビット数だけ、0 を使用して左にシフトし、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3681">Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3682">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3682">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3683">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3683">Format</span></span>|<span data-ttu-id="45410-3684">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3684">Assembly Format</span></span>|<span data-ttu-id="45410-3685">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3685">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3686">62</span><span class="sxs-lookup"><span data-stu-id="45410-3686">62</span></span>|<span data-ttu-id="45410-3687">shl</span><span class="sxs-lookup"><span data-stu-id="45410-3687">shl</span></span>|<span data-ttu-id="45410-3688">整数を左にシフトします (0 でシフト)。</span><span class="sxs-lookup"><span data-stu-id="45410-3688">Shifts an integer to the left (shifting in zeros).</span></span>|  
  
 <span data-ttu-id="45410-3689">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3689">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3690">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3690">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3691">シフトされるビットの量がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3691">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3692">シフトするビット数。値はスタックからポップされます。値は、指定されたビット数だけ左にシフトされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3692">The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="45410-3693">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3693">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3694">命令`shl`は、指定されたビット`int64`数`native int`だけ左に値 (型、型、または型`int32`) をシフトします。</span><span class="sxs-lookup"><span data-stu-id="45410-3694">The `shl` instruction shifts the value (type `int32`, `int64` or `native int`) left by the specified number of bits.</span></span> <span data-ttu-id="45410-3695">ビット数は、型または`int32` `native int`型の値です。</span><span class="sxs-lookup"><span data-stu-id="45410-3695">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="45410-3696">シフトするビット数が、指定された値の幅 (ビット単位) 以上の場合、戻り値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-3696">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="45410-3697">`Shl`各シフトの最小位置に0ビットを挿入します。</span><span class="sxs-lookup"><span data-stu-id="45410-3697">`Shl` inserts a zero bit in the lowest position on each shift.</span></span>  
  
 <span data-ttu-id="45410-3698">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `shl`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3698">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shl` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3699">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3699">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3700">整数値を指定したビット数だけ、符号を付けて右にシフトし、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3700">Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3701">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3701">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3702">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3702">Format</span></span>|<span data-ttu-id="45410-3703">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3703">Assembly Format</span></span>|<span data-ttu-id="45410-3704">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3704">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3705">63</span><span class="sxs-lookup"><span data-stu-id="45410-3705">63</span></span>|<span data-ttu-id="45410-3706">shr</span><span class="sxs-lookup"><span data-stu-id="45410-3706">shr</span></span>|<span data-ttu-id="45410-3707">整数を右にシフトします (符号でシフトします)。</span><span class="sxs-lookup"><span data-stu-id="45410-3707">Shifts an integer to the right (shifting in sign).</span></span>|  
  
 <span data-ttu-id="45410-3708">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3708">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3709">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3709">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3710">シフトされるビットの量がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3710">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3711">シフトするビット数。値はスタックからポップされます。値は、指定されたビット数だけ右にシフトされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3711">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="45410-3712">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3712">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3713">命令`shr.un`は、指定されたビット`int64`数`native int`だけ右に値 (型、型、または型`int32`) をシフトします。</span><span class="sxs-lookup"><span data-stu-id="45410-3713">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="45410-3714">ビット数は、型または`int32` `native int`型の値です。</span><span class="sxs-lookup"><span data-stu-id="45410-3714">The number of bits is a value of type `int32` or `native int`.</span></span> <span data-ttu-id="45410-3715">シフトするビット数が、指定された値の幅 (ビット単位) 以上の場合、戻り値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-3715">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="45410-3716">`Shr`各シフトの上位ビットをレプリケートし、の`result`元の値の符号を保持します。</span><span class="sxs-lookup"><span data-stu-id="45410-3716">`Shr` replicates the high order bit on each shift, preserving the sign of the original value in the `result`.</span></span>  
  
 <span data-ttu-id="45410-3717">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `shr`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3717">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3718">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3718">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3719">符号なし整数値を指定したビット数だけ、0 を使用して右にシフトし、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3719">Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3720">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3720">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3721">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3721">Format</span></span>|<span data-ttu-id="45410-3722">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3722">Assembly Format</span></span>|<span data-ttu-id="45410-3723">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3723">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3724">64</span><span class="sxs-lookup"><span data-stu-id="45410-3724">64</span></span>|<span data-ttu-id="45410-3725">shr</span><span class="sxs-lookup"><span data-stu-id="45410-3725">shr.un</span></span>|<span data-ttu-id="45410-3726">整数を右にシフトします (0 でシフト)。</span><span class="sxs-lookup"><span data-stu-id="45410-3726">Shifts an integer to the right (shifting in zeroes).</span></span>|  
  
 <span data-ttu-id="45410-3727">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3727">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3728">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3728">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3729">シフトされるビットの量がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3729">The amount of bits to be shifted is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3730">シフトするビット数。値はスタックからポップされます。値は、指定されたビット数だけ右にシフトされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3730">The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</span></span>  
  
4.  <span data-ttu-id="45410-3731">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3731">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3732">命令`shr.un`は、指定されたビット`int64`数`native int`だけ右に値 (型、型、または型`int32`) をシフトします。</span><span class="sxs-lookup"><span data-stu-id="45410-3732">The `shr.un` instruction shifts the value (type `int32`, `int64` or `native int`) right by the specified number of bits.</span></span> <span data-ttu-id="45410-3733">ビット数は、 `int32` `int64`型または`native int`型の値です。</span><span class="sxs-lookup"><span data-stu-id="45410-3733">The number of bits is a value of type `int32`, `int64` or `native int`.</span></span> <span data-ttu-id="45410-3734">シフトするビット数が、指定された値の幅 (ビット単位) 以上の場合、戻り値は指定されません。</span><span class="sxs-lookup"><span data-stu-id="45410-3734">The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</span></span>  
  
 <span data-ttu-id="45410-3735">`Shr.un`各シフトの最大位置にゼロビットを挿入します。</span><span class="sxs-lookup"><span data-stu-id="45410-3735">`Shr.un` inserts a zero bit in the highest position on each shift.</span></span>  
  
 <span data-ttu-id="45410-3736">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `shr.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3736">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `shr.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3737">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3737">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3738">提供された値型のサイズ (バイト単位) を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3738">Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3739">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3739">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3740">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3740">Format</span></span>|<span data-ttu-id="45410-3741">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3741">Assembly Format</span></span>|<span data-ttu-id="45410-3742">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3742">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3743">FE 1C <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3743">FE 1C < `T` ></span></span>|<span data-ttu-id="45410-3744">sizeof`valType`</span><span class="sxs-lookup"><span data-stu-id="45410-3744">sizeof `valType`</span></span>|<span data-ttu-id="45410-3745">値型のサイズをとして`unsigned int32`バイト単位でプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-3745">Push the size, in bytes, of a value type as an `unsigned int32`.</span></span>|  
  
 <span data-ttu-id="45410-3746">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3746">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3747">指定した値の型 (`valType`) のサイズ (バイト単位) がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3747">The size (in bytes) of the supplied value type (`valType`) is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3748">`valType`は、値型、参照型`typeref` 、 `typedef`またはジェネリック型パラメーターを指定するメタデータトークン (または) である必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3748">`valType` must be a metadata token (a `typeref` or `typedef`) that specifies a value type, reference type, or generic type parameter.</span></span>  
  
 <span data-ttu-id="45410-3749">参照型の場合、返されるサイズは、対応する型の参照値のサイズ (32 ビットシステムでは4バイト) であり、参照値で参照されるオブジェクトに格納されているデータのサイズではありません。</span><span class="sxs-lookup"><span data-stu-id="45410-3749">For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</span></span> <span data-ttu-id="45410-3750">ジェネリック型パラメーターは、それを定義する型またはメソッドの本体でのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3750">A generic type parameter can be used only in the body of the type or method that defines it.</span></span> <span data-ttu-id="45410-3751">その型またはメソッドがインスタンス化されると、ジェネリック型パラメーターは値型または参照型に置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="45410-3751">When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</span></span>  
  
 <span data-ttu-id="45410-3752">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `sizeof`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3752">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sizeof` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3753">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-3753">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3754">評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-3754">Stores the value on top of the evaluation stack in the argument slot at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3755">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3755">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3756">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3756">Format</span></span>|<span data-ttu-id="45410-3757">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3757">Assembly Format</span></span>|<span data-ttu-id="45410-3758">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3758">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3759">FE 0B <`unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45410-3759">FE 0B < `unsigned int16` ></span></span>|<span data-ttu-id="45410-3760">starg`num`</span><span class="sxs-lookup"><span data-stu-id="45410-3760">starg `num`</span></span>|<span data-ttu-id="45410-3761">スタックから上位の値をポップし、引数スロット`num`に格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-3761">Pops the top value from the stack and stores it in argument slot `num`.</span></span>|  
  
 <span data-ttu-id="45410-3762">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3762">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3763">現在スタックの一番上にある値がポップされ、引数スロット`num`に配置されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3763">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="45410-3764">命令`starg`はスタックから値をポップし、引数スロット`num`に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-3764">The `starg` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="45410-3765">値の型は、現在のメソッドのシグネチャで指定されている引数の型と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3765">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="45410-3766">可変個引数リストを受け取るプロシージャの場合、 `starg`命令は、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3766">For procedures that take a variable argument list, the `starg` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="45410-3767">4バイト未満の整数値を保持する引数にストアを実行すると、スタックから引数に移動するときに値が切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-3767">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="45410-3768">浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。</span><span class="sxs-lookup"><span data-stu-id="45410-3768">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45410-3769">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `starg`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3769">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3770">ILGenerator (オペコード、short)</span><span class="sxs-lookup"><span data-stu-id="45410-3770">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3771">評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します (短い形式)。</span><span class="sxs-lookup"><span data-stu-id="45410-3771">Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3772">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3772">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3773">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3773">Format</span></span>|<span data-ttu-id="45410-3774">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3774">Assembly Format</span></span>|<span data-ttu-id="45410-3775">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3775">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3776">10 <`unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-3776">10 < `unsigned int8` ></span></span>|<span data-ttu-id="45410-3777">starg`num`</span><span class="sxs-lookup"><span data-stu-id="45410-3777">starg.s `num`</span></span>|<span data-ttu-id="45410-3778">スタックから最上位の値をポップし、引数スロット`num`(短い形式) に格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-3778">Pops the top value from the stack and stores it in argument slot `num`, short form.</span></span>|  
  
 <span data-ttu-id="45410-3779">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3779">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3780">現在スタックの一番上にある値がポップされ、引数スロット`num`に配置されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3780">The value currently on top of the stack is popped and placed in argument slot `num`.</span></span>  
  
 <span data-ttu-id="45410-3781">命令`starg.s`はスタックから値をポップし、引数スロット`num`に配置します。</span><span class="sxs-lookup"><span data-stu-id="45410-3781">The `starg.s` instruction pops a value from the stack and places it in argument slot `num`.</span></span> <span data-ttu-id="45410-3782">値の型は、現在のメソッドのシグネチャで指定されている引数の型と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3782">The type of the value must match the type of the argument, as specified in the current method's signature.</span></span>  
  
 <span data-ttu-id="45410-3783">命令`starg.s`は、最初の256引数で使用するための効率的なエンコーディングを提供します。</span><span class="sxs-lookup"><span data-stu-id="45410-3783">The `starg.s` instruction provides an efficient encoding for use with the first 256 arguments.</span></span>  
  
 <span data-ttu-id="45410-3784">可変個引数リストを受け取るプロシージャの場合、 `starg.s`命令は、シグネチャの変数部分ではなく、初期の固定引数に対してのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3784">For procedures that take a variable argument list, the `starg.s` instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</span></span>  
  
 <span data-ttu-id="45410-3785">4バイト未満の整数値を保持する引数にストアを実行すると、スタックから引数に移動するときに値が切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-3785">Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</span></span> <span data-ttu-id="45410-3786">浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。</span><span class="sxs-lookup"><span data-stu-id="45410-3786">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45410-3787">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `starg.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3787">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `starg.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3788">ILGenerator (オペコード、byte)</span><span class="sxs-lookup"><span data-stu-id="45410-3788">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3789">指定のインデックス位置にある配列要素を評価スタックの、命令で指定された型の値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3789">Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3790">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3790">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3791">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3791">Format</span></span>|<span data-ttu-id="45410-3792">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3792">Assembly Format</span></span>|<span data-ttu-id="45410-3793">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3793">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3794">A4 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3794">A4 < `T` ></span></span>|<span data-ttu-id="45410-3795">stelem`typeTok`</span><span class="sxs-lookup"><span data-stu-id="45410-3795">stelem `typeTok`</span></span>|<span data-ttu-id="45410-3796">指定したインデックス位置にある配列要素を、スタック上`typeTok`の型の値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3796">Replaces the array element at the supplied index with a value of type `typeTok` on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3797">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3797">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3798">配列`array`へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3798">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3799">内の`index` `array`要素へのインデックス値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3799">An index value, `index`, to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3800">命令で指定された型の値がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3800">A value of the type specified in the instruction is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-3801">値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3801">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45410-3802">命令`stelem`は、1次元配列`array`内の指定された0から始まるインデックス位置にある要素の値を、値で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3802">The `stelem` instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array `array` with the value.</span></span> <span data-ttu-id="45410-3803">この値には、命令のトークン`typeTok`によって指定された型があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3803">The value has the type specified by the token `typeTok` in the instruction.</span></span>  
  
 <span data-ttu-id="45410-3804">配列はオブジェクトであり、したがって型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3804">Arrays are objects, and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-3805">インデックスは type `native int`です。</span><span class="sxs-lookup"><span data-stu-id="45410-3805">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45410-3806"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3806"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-3807"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3807"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-3808"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3808"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-3809">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3809">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3810">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-3810">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3811">指定のインデックス位置にある配列要素を評価スタックの <see langword="native int" /> 値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3811">Replaces the array element at a given index with the <see langword="native int" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3812">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3812">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3813">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3813">Format</span></span>|<span data-ttu-id="45410-3814">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3814">Assembly Format</span></span>|<span data-ttu-id="45410-3815">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3815">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3816">9B</span><span class="sxs-lookup"><span data-stu-id="45410-3816">9B</span></span>|<span data-ttu-id="45410-3817">stelem. i</span><span class="sxs-lookup"><span data-stu-id="45410-3817">stelem.i</span></span>|<span data-ttu-id="45410-3818">指定したインデックス位置にある配列要素を`native int`スタックの値で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3818">Replaces an array element at the supplied index with the `native int` value on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3819">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3819">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3820">配列`array`へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3820">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3821">内の`array`要素への有効なインデックスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3821">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3822">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3822">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-3823">値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3823">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45410-3824">命令`stelem.i`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`native int`された値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3824">The `stelem.i` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `native int` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3825">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3825">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-3826">インデックスは type `native int`です。</span><span class="sxs-lookup"><span data-stu-id="45410-3826">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45410-3827"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3827"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-3828"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3828"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-3829"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3829"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-3830">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.i`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3830">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3831">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3831">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3832">指定のインデックス位置にある配列要素を評価スタックの <see langword="int8" /> 値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3832">Replaces the array element at a given index with the <see langword="int8" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3833">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3833">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3834">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3834">Format</span></span>|<span data-ttu-id="45410-3835">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3835">Assembly Format</span></span>|<span data-ttu-id="45410-3836">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3836">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3837">9C</span><span class="sxs-lookup"><span data-stu-id="45410-3837">9C</span></span>|<span data-ttu-id="45410-3838">stelem. i1</span><span class="sxs-lookup"><span data-stu-id="45410-3838">stelem.i1</span></span>|<span data-ttu-id="45410-3839">指定したインデックス位置にある配列要素を`int8`スタックの値で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3839">Replaces an array element at the supplied index with the `int8` value on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3840">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3840">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3841">配列`array`へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3841">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3842">内の`array`要素への有効なインデックスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3842">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3843">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3843">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-3844">値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3844">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45410-3845">命令`stelem.i1`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`int8`された値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3845">The `stelem.i1` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int8` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3846">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3846">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-3847">インデックスは type `native int`です。</span><span class="sxs-lookup"><span data-stu-id="45410-3847">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45410-3848"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3848"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-3849"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3849"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-3850"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3850"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-3851">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.i1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3851">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3852">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3852">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3853">指定のインデックス位置にある配列要素を評価スタックの <see langword="int16" /> 値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3853">Replaces the array element at a given index with the <see langword="int16" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3854">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3854">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3855">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3855">Format</span></span>|<span data-ttu-id="45410-3856">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3856">Assembly Format</span></span>|<span data-ttu-id="45410-3857">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3857">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3858">9D</span><span class="sxs-lookup"><span data-stu-id="45410-3858">9D</span></span>|<span data-ttu-id="45410-3859">stelem. i2</span><span class="sxs-lookup"><span data-stu-id="45410-3859">stelem.i2</span></span>|<span data-ttu-id="45410-3860">指定したインデックス位置にある配列要素を`int16`スタックの値で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3860">Replaces an array element at the supplied index with the `int16` value on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3861">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3861">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3862">配列`array`へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3862">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3863">内の`array`要素への有効なインデックスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3863">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3864">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3864">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-3865">値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3865">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45410-3866">命令`stelem.i2`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`int16`された値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3866">The `stelem.i2` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int16` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3867">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3867">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-3868">インデックスは type `native int`です。</span><span class="sxs-lookup"><span data-stu-id="45410-3868">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45410-3869"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3869"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-3870"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3870"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-3871"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3871"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-3872">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.i2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3872">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3873">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3873">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3874">指定のインデックス位置にある配列要素を評価スタックの <see langword="int32" /> 値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3874">Replaces the array element at a given index with the <see langword="int32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3875">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3875">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3876">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3876">Format</span></span>|<span data-ttu-id="45410-3877">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3877">Assembly Format</span></span>|<span data-ttu-id="45410-3878">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3878">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3879">9E</span><span class="sxs-lookup"><span data-stu-id="45410-3879">9E</span></span>|<span data-ttu-id="45410-3880">stelem. i4</span><span class="sxs-lookup"><span data-stu-id="45410-3880">stelem.i4</span></span>|<span data-ttu-id="45410-3881">指定したインデックス位置にある配列要素を`int32`スタックの値で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3881">Replaces an array element at the supplied index with the `int32` value on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3882">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3882">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3883">配列`array`へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3883">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3884">内の`array`要素への有効なインデックスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3884">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3885">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3885">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-3886">値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3886">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45410-3887">命令`stelem.i4`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`int32`された値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3887">The `stelem.i4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3888">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3888">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-3889">インデックスは type `native int`です。</span><span class="sxs-lookup"><span data-stu-id="45410-3889">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45410-3890"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3890"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-3891"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3891"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-3892"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3892"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-3893">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.i4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3893">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3894">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3894">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3895">指定のインデックス位置にある配列要素を評価スタックの <see langword="int64" /> 値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3895">Replaces the array element at a given index with the <see langword="int64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3896">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3896">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3897">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3897">Format</span></span>|<span data-ttu-id="45410-3898">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3898">Assembly Format</span></span>|<span data-ttu-id="45410-3899">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3899">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3900">9F</span><span class="sxs-lookup"><span data-stu-id="45410-3900">9F</span></span>|<span data-ttu-id="45410-3901">stelem. i8</span><span class="sxs-lookup"><span data-stu-id="45410-3901">stelem.i8</span></span>|<span data-ttu-id="45410-3902">指定したインデックス位置にある配列要素を`int64`スタックの値で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3902">Replaces an array element at the supplied index with the `int64` value on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3903">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3903">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3904">配列`array`へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3904">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3905">内の`array`要素への有効なインデックスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3905">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3906">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3906">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-3907">値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3907">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45410-3908">命令`stelem.i8`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`int64`された値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3908">The `stelem.i8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `int64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3909">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3909">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-3910">インデックスは type `native int`です。</span><span class="sxs-lookup"><span data-stu-id="45410-3910">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45410-3911"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3911"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-3912"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3912"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-3913"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3913"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-3914">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.i8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3914">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3915">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3915">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3916">指定のインデックス位置にある配列要素を評価スタックの <see langword="float32" /> 値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3916">Replaces the array element at a given index with the <see langword="float32" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3917">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3917">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3918">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3918">Format</span></span>|<span data-ttu-id="45410-3919">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3919">Assembly Format</span></span>|<span data-ttu-id="45410-3920">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3920">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3921">A0</span><span class="sxs-lookup"><span data-stu-id="45410-3921">A0</span></span>|<span data-ttu-id="45410-3922">stelem. r4</span><span class="sxs-lookup"><span data-stu-id="45410-3922">stelem.r4</span></span>|<span data-ttu-id="45410-3923">指定したインデックス位置にある配列要素を`float32`スタックの値で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3923">Replaces an array element at the supplied index with the `float32` value on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3924">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3924">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3925">配列`array`へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3925">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3926">内の`array`要素への有効なインデックスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3926">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3927">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3927">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-3928">値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3928">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45410-3929">命令`stelem.r4`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`float32`された値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3929">The `stelem.r4` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float32` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3930">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3930">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-3931">インデックスは type `native int`です。</span><span class="sxs-lookup"><span data-stu-id="45410-3931">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45410-3932"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3932"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-3933"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3933"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-3934"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3934"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-3935">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.r4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3935">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3936">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3936">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3937">指定のインデックス位置にある配列要素を評価スタックの <see langword="float64" /> 値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3937">Replaces the array element at a given index with the <see langword="float64" /> value on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3938">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3938">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3939">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3939">Format</span></span>|<span data-ttu-id="45410-3940">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3940">Assembly Format</span></span>|<span data-ttu-id="45410-3941">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3941">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3942">A1</span><span class="sxs-lookup"><span data-stu-id="45410-3942">A1</span></span>|<span data-ttu-id="45410-3943">stelem. r8</span><span class="sxs-lookup"><span data-stu-id="45410-3943">stelem.r8</span></span>|<span data-ttu-id="45410-3944">指定したインデックス位置にある配列要素を`float64`スタックの値で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3944">Replaces an array element at the supplied index with the `float64` value on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3945">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3945">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3946">配列`array`へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3946">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3947">内の`array`要素への有効なインデックスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3947">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3948">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3948">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-3949">値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3949">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45410-3950">命令`stelem.r8`は、1次元`array`配列内の`index`要素の値を、スタックにプッシュ`float64`された値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3950">The `stelem.r8` instruction replaces the value of the element `index` in the one-dimensional array `array` with the `float64` value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3951">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3951">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-3952">インデックスは type `native int`です。</span><span class="sxs-lookup"><span data-stu-id="45410-3952">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45410-3953"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3953"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-3954"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3954"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-3955"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3955"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-3956">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.r8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3956">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3957">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3957">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3958">指定のインデックス位置にある配列要素をオブジェクト参照値 (<see langword="O" /> 型) に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3958">Replaces the array element at a given index with the object ref value (type <see langword="O" />) on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3959">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3959">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3960">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3960">Format</span></span>|<span data-ttu-id="45410-3961">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3961">Assembly Format</span></span>|<span data-ttu-id="45410-3962">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3962">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3963">A2</span><span class="sxs-lookup"><span data-stu-id="45410-3963">A2</span></span>|<span data-ttu-id="45410-3964">stelem. ref</span><span class="sxs-lookup"><span data-stu-id="45410-3964">stelem.ref</span></span>|<span data-ttu-id="45410-3965">指定したインデックス位置にある配列要素を`ref`スタックの値`O`(型) に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3965">Replaces an array element at the supplied index with the `ref` value (type `O`) on the stack.</span></span>|  
  
 <span data-ttu-id="45410-3966">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3966">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3967">配列`array`へのオブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3967">An object reference to an array, `array`, is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3968">内の`array`要素への有効なインデックスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3968">A valid index to an element in `array` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3969">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3969">A value is pushed onto the stack.</span></span>  
  
4.  <span data-ttu-id="45410-3970">値、インデックス、および配列参照がスタックからポップされます。値は、指定されたインデックス位置にある配列要素に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3970">The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</span></span>  
  
 <span data-ttu-id="45410-3971">命令`stelem.ref`は、1次元配列`array`内の指定されたインデックス位置にある要素の値を`ref` 、スタック`O`にプッシュされた (型) 値で置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3971">The `stelem.ref` instruction replaces the value of the element at the supplied index in the one-dimensional array `array` with the `ref` (type `O`) value pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-3972">配列はオブジェクトであるため、型`O`の値によって表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3972">Arrays are objects and hence represented by a value of type `O`.</span></span> <span data-ttu-id="45410-3973">インデックスは type `native int`です。</span><span class="sxs-lookup"><span data-stu-id="45410-3973">The index is type `native int`.</span></span>  
  
 <span data-ttu-id="45410-3974">は、 `stelem.ref`配列要素に値を代入する前に、 `array`指定された値をの要素型に暗黙的にキャストすることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-3974">Note that `stelem.ref` implicitly casts the supplied value to the element type of `array` before assigning the value to the array element.</span></span> <span data-ttu-id="45410-3975">検証されたコードの場合でも、このキャストは失敗する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3975">This cast can fail, even for verified code.</span></span> <span data-ttu-id="45410-3976">したがって`stelem.ref` 、命令に<xref:System.InvalidCastException>よってスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="45410-3976">Thus the `stelem.ref` instruction can throw <xref:System.InvalidCastException>.</span></span> <span data-ttu-id="45410-3977">0から始まらない1次元配列、および多次元配列の場合、クラスに<xref:System.Array>はメソッドが<xref:System.Array.SetValue%2A>用意されています。</span><span class="sxs-lookup"><span data-stu-id="45410-3977">For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref:System.Array> class provides a <xref:System.Array.SetValue%2A> method.</span></span>  
  
 <span data-ttu-id="45410-3978"><xref:System.NullReferenceException>が null 参照`array`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3978"><xref:System.NullReferenceException> is thrown if `array` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-3979"><xref:System.IndexOutOfRangeException>が負の`index`場合、またはの`array`バインドより大きい場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3979"><xref:System.IndexOutOfRangeException> is thrown if `index` is negative, or larger than the bound of `array`.</span></span>  
  
 <span data-ttu-id="45410-3980"><xref:System.ArrayTypeMismatchException>は、必須`array`の型の要素を保持しない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3980"><xref:System.ArrayTypeMismatchException> is thrown if `array` does not hold elements of the required type.</span></span>  
  
 <span data-ttu-id="45410-3981">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stelem.ref`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-3981">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stelem.ref` opcode:</span></span>  
  
-   <span data-ttu-id="45410-3982">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-3982">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-3983">オブジェクト参照またはポインターのフィールドに格納された値を新しい値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3983">Replaces the value stored in the field of an object reference or pointer with a new value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-3984">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-3984">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-3985">形式</span><span class="sxs-lookup"><span data-stu-id="45410-3985">Format</span></span>|<span data-ttu-id="45410-3986">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-3986">Assembly Format</span></span>|<span data-ttu-id="45410-3987">説明</span><span class="sxs-lookup"><span data-stu-id="45410-3987">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-3988">7D <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-3988">7D < `T` ></span></span>|<span data-ttu-id="45410-3989">stfld`field`</span><span class="sxs-lookup"><span data-stu-id="45410-3989">stfld `field`</span></span>|<span data-ttu-id="45410-3990">オブジェクトのの`field`値を新しい値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3990">Replaces the value of `field` of the object with a new value.</span></span>|  
  
 <span data-ttu-id="45410-3991">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-3991">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-3992">オブジェクト参照またはポインターがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3992">An object reference or pointer is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-3993">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3993">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-3994">値とオブジェクト参照/ポインターがスタックからポップされます。オブジェクトのの`field`値は、指定された値に置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="45410-3994">The value and the object reference/pointer are popped from the stack; the value of `field` in the object is replaced with the supplied value.</span></span>  
  
 <span data-ttu-id="45410-3995">命令`stfld`は、オブジェクト (型`O`) のフィールドの値、またはポインター (型`native int`、 `&`、または`*`) を使用して、指定された値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-3995">The `stfld` instruction replaces the value of a field of an object (type `O`) or via a pointer (type `native int`, `&`, or `*`) with a given value.</span></span> <span data-ttu-id="45410-3996">`Field`は、フィールドメンバー参照を参照するメタデータトークンです。</span><span class="sxs-lookup"><span data-stu-id="45410-3996">`Field` is a metadata token that refers to a field member reference.</span></span> <span data-ttu-id="45410-3997">命令`stfld`は、 <xref:System.Reflection.Emit.OpCodes.Unaligned> と <xref:System.Reflection.Emit.OpCodes.Volatile> のいずれかまたは両方のプレフィックスを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="45410-3997">The `stfld` instruction can have a prefix of either or both of <xref:System.Reflection.Emit.OpCodes.Unaligned> and <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="45410-3998"><xref:System.NullReferenceException>オブジェクト参照またはポインターが null 参照で、フィールドが静的でない場合に、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3998"><xref:System.NullReferenceException> is thrown if the object reference or pointer is a null reference and the field isn't static.</span></span>  
  
 <span data-ttu-id="45410-3999"><xref:System.MissingFieldException>メタデータに`field`が見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-3999"><xref:System.MissingFieldException> is thrown if `field` is not found in the metadata.</span></span> <span data-ttu-id="45410-4000">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換される場合にチェックされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4000">This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</span></span>  
  
 <span data-ttu-id="45410-4001">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stfld`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4001">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stfld` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4002">ILGenerator (オペコード、FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-4002">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4003">提供されたアドレスに <see langword="native int" /> 型の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4003">Stores a value of type <see langword="native int" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4004">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4004">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4005">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4005">Format</span></span>|<span data-ttu-id="45410-4006">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4006">Assembly Format</span></span>|<span data-ttu-id="45410-4007">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4007">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4008">DF</span><span class="sxs-lookup"><span data-stu-id="45410-4008">DF</span></span>|<span data-ttu-id="45410-4009">stind</span><span class="sxs-lookup"><span data-stu-id="45410-4009">stind.i</span></span>|<span data-ttu-id="45410-4010">指定さ`native int`れたアドレスに値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4010">Stores a `native int` value at a given address.</span></span>|  
  
 <span data-ttu-id="45410-4011">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4011">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4012">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4012">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4013">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4013">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4014">値とアドレスはスタックからポップされます。値はアドレスに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4014">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45410-4015">命令`stind.i`は、指定`native int`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4015">The `stind.i` instruction stores a `native int` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45410-4016">タイプセーフ操作では、 `stind.i`ポインターの型と一貫性のある方法で命令を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4016">Type safe operation requires that the `stind.i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45410-4017">`stind.i`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4017">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-4018"><xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4018"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45410-4019">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.i`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4019">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4020">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4020">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4021">提供されたアドレスに <see langword="int8" /> 型の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4021">Stores a value of type <see langword="int8" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4022">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4022">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4023">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4023">Format</span></span>|<span data-ttu-id="45410-4024">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4024">Assembly Format</span></span>|<span data-ttu-id="45410-4025">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4025">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4026">52</span><span class="sxs-lookup"><span data-stu-id="45410-4026">52</span></span>|<span data-ttu-id="45410-4027">stind</span><span class="sxs-lookup"><span data-stu-id="45410-4027">stind.i1</span></span>|<span data-ttu-id="45410-4028">指定さ`int8`れたアドレスに値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4028">Stores an `int8` value at a given address.</span></span>|  
  
 <span data-ttu-id="45410-4029">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4029">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4030">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4030">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4031">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4031">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4032">値とアドレスはスタックからポップされます。値はアドレスに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4032">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45410-4033">命令`stind.i1`は、指定`int8`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4033">The `stind.i1` instruction stores an `int8` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45410-4034">タイプセーフ操作では、 `stind.i1`ポインターの型と一貫性のある方法で命令を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4034">Type safe operation requires that the `stind.i1` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45410-4035">`stind.i1`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4035">The operation of the `stind.i1` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-4036"><xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4036"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45410-4037">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.i1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4037">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4038">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4038">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4039">提供されたアドレスに <see langword="int16" /> 型の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4039">Stores a value of type <see langword="int16" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4040">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4040">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4041">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4041">Format</span></span>|<span data-ttu-id="45410-4042">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4042">Assembly Format</span></span>|<span data-ttu-id="45410-4043">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4043">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4044">53</span><span class="sxs-lookup"><span data-stu-id="45410-4044">53</span></span>|<span data-ttu-id="45410-4045">stind</span><span class="sxs-lookup"><span data-stu-id="45410-4045">stind.i2</span></span>|<span data-ttu-id="45410-4046">指定さ`int16`れたアドレスに値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4046">Stores an `int16` value at a given address.</span></span>|  
  
 <span data-ttu-id="45410-4047">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4047">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4048">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4048">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4049">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4049">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4050">値とアドレスはスタックからポップされます。値はアドレスに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4050">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45410-4051">命令`stind.i2`は、指定`int16`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4051">The `stind.i2` instruction stores an `int16` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45410-4052">タイプセーフ操作では、 `stind.2i`ポインターの型と一貫性のある方法で命令を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4052">Type safe operation requires that the `stind.2i` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45410-4053">`stind.i2`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4053">The operation of the `stind.i2` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-4054"><xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4054"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45410-4055">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.i2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4055">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4056">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4056">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4057">提供されたアドレスに <see langword="int32" /> 型の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4057">Stores a value of type <see langword="int32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4058">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4058">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4059">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4059">Format</span></span>|<span data-ttu-id="45410-4060">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4060">Assembly Format</span></span>|<span data-ttu-id="45410-4061">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4061">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4062">54</span><span class="sxs-lookup"><span data-stu-id="45410-4062">54</span></span>|<span data-ttu-id="45410-4063">stind</span><span class="sxs-lookup"><span data-stu-id="45410-4063">stind.i4</span></span>|<span data-ttu-id="45410-4064">指定さ`int32`れたアドレスに値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4064">Stores an `int32` value at a given address.</span></span>|  
  
 <span data-ttu-id="45410-4065">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4065">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4066">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4066">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4067">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4067">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4068">値とアドレスはスタックからポップされます。値はアドレスに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4068">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45410-4069">命令`stind.i4`は、指定`int32`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4069">The `stind.i4` instruction stores an `int32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45410-4070">タイプセーフ操作では、 `stind.i4`ポインターの型と一貫性のある方法で命令を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4070">Type safe operation requires that the `stind.i4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45410-4071">`stind.i4`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4071">The operation of the `stind.i4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-4072"><xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4072"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45410-4073">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.i4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4073">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4074">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4074">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4075">提供されたアドレスに <see langword="int64" /> 型の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4075">Stores a value of type <see langword="int64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4076">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4076">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4077">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4077">Format</span></span>|<span data-ttu-id="45410-4078">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4078">Assembly Format</span></span>|<span data-ttu-id="45410-4079">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4079">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4080">55</span><span class="sxs-lookup"><span data-stu-id="45410-4080">55</span></span>|<span data-ttu-id="45410-4081">stind i8</span><span class="sxs-lookup"><span data-stu-id="45410-4081">stind.i8</span></span>|<span data-ttu-id="45410-4082">指定さ`int64`れたアドレスに値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4082">Stores an `int64` value at a given address.</span></span>|  
  
 <span data-ttu-id="45410-4083">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4083">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4084">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4084">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4085">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4085">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4086">値とアドレスはスタックからポップされます。値はアドレスに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4086">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45410-4087">命令`stind.i8`は、指定`int64`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4087">The `stind.i8` instruction stores an `int64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45410-4088">タイプセーフ操作では、 `stind.i8`ポインターの型と一貫性のある方法で命令を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4088">Type safe operation requires that the `stind.i8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45410-4089">`stind.i`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4089">The operation of the `stind.i` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-4090"><xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4090"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45410-4091">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.i8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4091">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.i8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4092">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4092">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4093">提供されたアドレスに <see langword="float32" /> 型の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4093">Stores a value of type <see langword="float32" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4094">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4094">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4095">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4095">Format</span></span>|<span data-ttu-id="45410-4096">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4096">Assembly Format</span></span>|<span data-ttu-id="45410-4097">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4097">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4098">56</span><span class="sxs-lookup"><span data-stu-id="45410-4098">56</span></span>|<span data-ttu-id="45410-4099">stind</span><span class="sxs-lookup"><span data-stu-id="45410-4099">stind.r4</span></span>|<span data-ttu-id="45410-4100">指定さ`float32`れたアドレスに値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4100">Stores a `float32` value at a given address.</span></span>|  
  
 <span data-ttu-id="45410-4101">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4101">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4102">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4102">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4103">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4103">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4104">値とアドレスはスタックからポップされます。値はアドレスに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4104">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45410-4105">命令`stind.r4`は、指定`float32`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4105">The `stind.r4` instruction stores a `float32` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45410-4106">タイプセーフ操作では、 `stind.r4`ポインターの型と一貫性のある方法で命令を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4106">Type safe operation requires that the `stind.r4` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45410-4107">`stind.r4`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4107">The operation of the `stind.r4` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-4108"><xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4108"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45410-4109">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.r4`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4109">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r4` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4110">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4110">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4111">提供されたアドレスに <see langword="float64" /> 型の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4111">Stores a value of type <see langword="float64" /> at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4112">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4112">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4113">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4113">Format</span></span>|<span data-ttu-id="45410-4114">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4114">Assembly Format</span></span>|<span data-ttu-id="45410-4115">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4115">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4116">57</span><span class="sxs-lookup"><span data-stu-id="45410-4116">57</span></span>|<span data-ttu-id="45410-4117">stind</span><span class="sxs-lookup"><span data-stu-id="45410-4117">stind.r8</span></span>|<span data-ttu-id="45410-4118">指定さ`float64`れたアドレスに値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4118">Stores a `float64` value at a given address.</span></span>|  
  
 <span data-ttu-id="45410-4119">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4119">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4120">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4120">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4121">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4121">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4122">値とアドレスはスタックからポップされます。値はアドレスに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4122">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45410-4123">命令`stind.r8`は、指定`float64`されたアドレス (型、 `native int` `*`型、また`&`は型) に値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4123">The `stind.r8` instruction stores a `float64` value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45410-4124">タイプセーフ操作では、 `stind.r8`ポインターの型と一貫性のある方法で命令を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4124">Type safe operation requires that the `stind.r8` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45410-4125">`stind.r8`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4125">The operation of the `stind.r8` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-4126"><xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4126"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45410-4127">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.r8`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4127">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.r8` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4128">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4128">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4129">提供されたアドレスにオブジェクト参照値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4129">Stores a object reference value at a supplied address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4130">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4130">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4131">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4131">Format</span></span>|<span data-ttu-id="45410-4132">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4132">Assembly Format</span></span>|<span data-ttu-id="45410-4133">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4133">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4134">51</span><span class="sxs-lookup"><span data-stu-id="45410-4134">51</span></span>|<span data-ttu-id="45410-4135">stind</span><span class="sxs-lookup"><span data-stu-id="45410-4135">stind.ref</span></span>|<span data-ttu-id="45410-4136">指定されたアドレスに`O`オブジェクト参照 (型) の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4136">Stores an object reference (type `O`) value at a given address.</span></span>|  
  
 <span data-ttu-id="45410-4137">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4137">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4138">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4138">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4139">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4139">A value is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4140">値とアドレスはスタックからポップされます。値はアドレスに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4140">The value and the address are popped from the stack; the value is stored at the address.</span></span>  
  
 <span data-ttu-id="45410-4141">命令`stind.ref`は、指定されたアドレス (型`*`、型、 `native int`または`&`型) にオブジェクト参照値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4141">The `stind.ref` instruction stores an object reference value at the supplied address (type `native int`, `*`, or `&`).</span></span>  
  
 <span data-ttu-id="45410-4142">タイプセーフ操作では、 `stind.ref`ポインターの型と一貫性のある方法で命令を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4142">Type safe operation requires that the `stind.ref` instruction be used in a manner consistent with the type of the pointer.</span></span> <span data-ttu-id="45410-4143">`stind.ref`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4143">The operation of the `stind.ref` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-4144"><xref:System.NullReferenceException>が、命令`addr`サフィックスによって暗黙的に指定された引数の型に対して自然にアラインされていない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4144"><xref:System.NullReferenceException> is thrown if `addr` is not naturally aligned for the argument type implied by the instruction suffix.</span></span>  
  
 <span data-ttu-id="45410-4145">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stind.ref`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4145">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stind.ref` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4146">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4146">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4147">評価スタックの一番上から現在の値をポップし、指定したインデックスのローカル変数リストに格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4147">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4148">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4148">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4149">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4149">Format</span></span>|<span data-ttu-id="45410-4150">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4150">Assembly Format</span></span>|<span data-ttu-id="45410-4151">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4151">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4152">FE 0E <`unsigned int16` ></span><span class="sxs-lookup"><span data-stu-id="45410-4152">FE 0E < `unsigned int16` ></span></span>|<span data-ttu-id="45410-4153">stloc`index`</span><span class="sxs-lookup"><span data-stu-id="45410-4153">stloc `index`</span></span>|<span data-ttu-id="45410-4154">スタックから値をポップし、ローカル変数`index`に格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4154">Pops a value from the stack and stores it in local variable `index`.</span></span>|  
  
 <span data-ttu-id="45410-4155">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4155">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4156">値はスタックからポップされ、ローカル変数`index`に配置されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4156">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="45410-4157">この`stloc`命令は、トップの値を評価スタックからポップし、ローカル変数の`index`数値に移動します。ローカル変数には、0以降の番号が付けられます。</span><span class="sxs-lookup"><span data-stu-id="45410-4157">The `stloc` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45410-4158">値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4158">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45410-4159">4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-4159">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45410-4160">浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。</span><span class="sxs-lookup"><span data-stu-id="45410-4160">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45410-4161">Microsoft 中間言語 (MSIL) 命令を修正する`index`には、有効なローカルインデックスである必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4161">Correct Microsoft Intermediate Language (MSIL) instructions require that `index` be a valid local index.</span></span> <span data-ttu-id="45410-4162">命令の場合、 `index`は 0 ~ 65534 の範囲で指定する必要があります (具体的には65535は無効です)。 `stloc`</span><span class="sxs-lookup"><span data-stu-id="45410-4162">For the `stloc` instruction, `index` must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</span></span> <span data-ttu-id="45410-4163">65535を除外する理由は実用的であると考えられます。実装では、2バイトの整数を使用して、ローカルのインデックスと、特定のメソッドのローカルの合計数を追跡します。</span><span class="sxs-lookup"><span data-stu-id="45410-4163">The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</span></span> <span data-ttu-id="45410-4164">65535のインデックスが有効になっている場合は、このようなメソッドでローカルの数を追跡するために、より広い整数が必要になります。</span><span class="sxs-lookup"><span data-stu-id="45410-4164">If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</span></span>  
  
 <span data-ttu-id="45410-4165">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4165">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4166">ILGenerator (オペコード、LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="45410-4166">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="45410-4167">ILGenerator (オペコード、short)</span><span class="sxs-lookup"><span data-stu-id="45410-4167">ILGenerator.Emit(OpCode, short)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4168">評価スタックの一番上から現在の値をポップし、インデックス 0 のローカル変数リストに格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4168">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4169">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4169">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4170">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4170">Format</span></span>|<span data-ttu-id="45410-4171">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4171">Assembly Format</span></span>|<span data-ttu-id="45410-4172">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4172">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4173">0A</span><span class="sxs-lookup"><span data-stu-id="45410-4173">0A</span></span>|<span data-ttu-id="45410-4174">stloc</span><span class="sxs-lookup"><span data-stu-id="45410-4174">stloc.0</span></span>|<span data-ttu-id="45410-4175">スタックからローカル変数0に値をポップします。</span><span class="sxs-lookup"><span data-stu-id="45410-4175">Pops a value from the stack into local variable 0.</span></span>|  
  
 <span data-ttu-id="45410-4176">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4176">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4177">値はスタックからポップされ、0によってインデックスが作成されたローカル変数に配置されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4177">A value is popped off of the stack and placed in the local variable indexed by 0.</span></span>  
  
 <span data-ttu-id="45410-4178">この`stloc.0`命令は、トップ値を評価スタックからポップし、0によってインデックスが作成されたローカル変数に移動します。</span><span class="sxs-lookup"><span data-stu-id="45410-4178">The `stloc.0` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</span></span> <span data-ttu-id="45410-4179">値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4179">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45410-4180">`stloc.0`は、ローカル変数0に値を格納するための、特に効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-4180">`stloc.0` is an especially efficient encoding for storing values in local variable 0.</span></span>  
  
 <span data-ttu-id="45410-4181">4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-4181">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45410-4182">浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。</span><span class="sxs-lookup"><span data-stu-id="45410-4182">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45410-4183">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc.0`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4183">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.0` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4184">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4184">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4185">評価スタックの一番上から現在の値をポップし、インデックス 1 のローカル変数リストに格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4185">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4186">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4186">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4187">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4187">Format</span></span>|<span data-ttu-id="45410-4188">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4188">Assembly Format</span></span>|<span data-ttu-id="45410-4189">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4189">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4190">0B</span><span class="sxs-lookup"><span data-stu-id="45410-4190">0B</span></span>|<span data-ttu-id="45410-4191">stloc</span><span class="sxs-lookup"><span data-stu-id="45410-4191">stloc.1</span></span>|<span data-ttu-id="45410-4192">スタックからローカル変数1に値をポップします。</span><span class="sxs-lookup"><span data-stu-id="45410-4192">Pops a value from the stack into local variable 1.</span></span>|  
  
 <span data-ttu-id="45410-4193">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4193">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4194">値はスタックからポップされ、1によってインデックスが作成されたローカル変数に配置されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4194">A value is popped off of the stack and placed in the local variable indexed by 1.</span></span>  
  
 <span data-ttu-id="45410-4195">この`stloc.1`命令は、トップ値を評価スタックからポップし、1でインデックス付けされたローカル変数に移動します。</span><span class="sxs-lookup"><span data-stu-id="45410-4195">The `stloc.1` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</span></span> <span data-ttu-id="45410-4196">値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4196">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45410-4197">`stloc.1`は、ローカル変数1に値を格納するための、特に効率的なエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-4197">`stloc.1` is an especially efficient encoding for storing values in local variable 1.</span></span>  
  
 <span data-ttu-id="45410-4198">4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-4198">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45410-4199">浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。</span><span class="sxs-lookup"><span data-stu-id="45410-4199">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45410-4200">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc.1`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4200">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.1` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4201">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4201">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4202">評価スタックの一番上から現在の値をポップし、インデックス 2 のローカル変数リストに格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4202">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4203">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4203">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4204">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4204">Format</span></span>|<span data-ttu-id="45410-4205">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4205">Assembly Format</span></span>|<span data-ttu-id="45410-4206">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4206">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4207">0C</span><span class="sxs-lookup"><span data-stu-id="45410-4207">0C</span></span>|<span data-ttu-id="45410-4208">stloc</span><span class="sxs-lookup"><span data-stu-id="45410-4208">stloc.2</span></span>|<span data-ttu-id="45410-4209">スタックからローカル変数2に値をポップします。</span><span class="sxs-lookup"><span data-stu-id="45410-4209">Pops a value from the stack into local variable 2</span></span>|  
  
 <span data-ttu-id="45410-4210">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4210">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4211">値はスタックからポップされ、2によってインデックスが作成されたローカル変数に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4211">A value is popped off of the stack and placed in the local variable indexed by 2.</span></span>  
  
 <span data-ttu-id="45410-4212">この`stloc.2`命令は、トップ値を評価スタックからポップし、2によってインデックスが作成されたローカル変数に移動します。</span><span class="sxs-lookup"><span data-stu-id="45410-4212">The `stloc.2` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</span></span> <span data-ttu-id="45410-4213">値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4213">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45410-4214">`stloc.2`は、ローカル変数2に値を格納するための、特に効率的なエンコーディングです。</span><span class="sxs-lookup"><span data-stu-id="45410-4214">`stloc.2` is an especially efficient encoding for storing values in local variable 2.</span></span>  
  
 <span data-ttu-id="45410-4215">4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-4215">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45410-4216">浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。</span><span class="sxs-lookup"><span data-stu-id="45410-4216">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45410-4217">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc.2`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4217">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.2` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4218">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4218">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4219">評価スタックの一番上から現在の値をポップし、インデックス 3 のローカル変数リストに格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4219">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4220">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4220">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4221">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4221">Format</span></span>|<span data-ttu-id="45410-4222">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4222">Assembly Format</span></span>|<span data-ttu-id="45410-4223">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4223">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4224">0D</span><span class="sxs-lookup"><span data-stu-id="45410-4224">0D</span></span>|<span data-ttu-id="45410-4225">stloc</span><span class="sxs-lookup"><span data-stu-id="45410-4225">stloc.3</span></span>|<span data-ttu-id="45410-4226">スタックからローカル変数3に値をポップします。</span><span class="sxs-lookup"><span data-stu-id="45410-4226">Pops a value from the stack into local variable 3</span></span>|  
  
 <span data-ttu-id="45410-4227">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4227">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4228">値はスタックからポップされ、3によってインデックスが作成されたローカル変数に格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4228">A value is popped off of the stack and placed in the local variable indexed by 3.</span></span>  
  
 <span data-ttu-id="45410-4229">この`stloc.3`命令は、トップ値を評価スタックからポップし、3によってインデックスが作成されたローカル変数に移動します。</span><span class="sxs-lookup"><span data-stu-id="45410-4229">The `stloc.3` instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</span></span> <span data-ttu-id="45410-4230">値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4230">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45410-4231">`stloc.3`は、ローカル変数3に値を格納するための、特に効率的なエンコードです。</span><span class="sxs-lookup"><span data-stu-id="45410-4231">`stloc.3` is an especially efficient encoding for storing values in local variable 3.</span></span>  
  
 <span data-ttu-id="45410-4232">4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-4232">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45410-4233">浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。</span><span class="sxs-lookup"><span data-stu-id="45410-4233">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45410-4234">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc.3`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4234">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stloc.3` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4235">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4235">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4236">評価スタックの一番上から現在の値をポップし、<paramref name="index" /> のローカル変数リストに格納します (短い形式)。</span><span class="sxs-lookup"><span data-stu-id="45410-4236">Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <paramref name="index" /> (short form).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4237">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4237">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4238">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4238">Format</span></span>|<span data-ttu-id="45410-4239">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4239">Assembly Format</span></span>|<span data-ttu-id="45410-4240">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4240">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4241">13 <`unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-4241">13 < `unsigned int8` ></span></span>|<span data-ttu-id="45410-4242">stloc`index`</span><span class="sxs-lookup"><span data-stu-id="45410-4242">stloc.s `index`</span></span>|<span data-ttu-id="45410-4243">スタックから値をポップし、ローカル変数`index`である短い形式で格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4243">Pops a value from the stack and stores it in local variable `index`, short form.</span></span>|  
  
 <span data-ttu-id="45410-4244">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4244">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4245">値はスタックからポップされ、ローカル変数`index`に配置されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4245">A value is popped off of the stack and placed in local variable `index`.</span></span>  
  
 <span data-ttu-id="45410-4246">この`stloc.s`命令は、トップの値を評価スタックからポップし、ローカル変数の`index`数値に移動します。ローカル変数には、0以降の番号が付けられます。</span><span class="sxs-lookup"><span data-stu-id="45410-4246">The `stloc.s` instruction pops the top value off the evaluation stack and moves it into local variable number `index`, where local variables are numbered 0 onwards.</span></span> <span data-ttu-id="45410-4247">値の型は、現在のメソッドのローカルシグネチャで指定されているローカル変数の型と一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4247">The type of the value must match the type of the local variable as specified in the current method's local signature.</span></span>  
  
 <span data-ttu-id="45410-4248">命令`stloc.s`は、ローカル変数 0 ~ 255 の効率的なエンコードを提供します。</span><span class="sxs-lookup"><span data-stu-id="45410-4248">The `stloc.s` instruction provides an efficient encoding for local variables 0 through 255.</span></span>  
  
 <span data-ttu-id="45410-4249">4バイトよりも小さい整数値を保持しているローカル変数に格納すると、スタックからローカル変数に移動するときに値が切り捨てられます。</span><span class="sxs-lookup"><span data-stu-id="45410-4249">Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</span></span> <span data-ttu-id="45410-4250">浮動小数点値は、ネイティブサイズ (型`F`) から引数に関連付けられているサイズに丸められます。</span><span class="sxs-lookup"><span data-stu-id="45410-4250">Floating-point values are rounded from their native size (type `F`) to the size associated with the argument.</span></span>  
  
 <span data-ttu-id="45410-4251">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stloc.s`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4251">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `stloc.s` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4252">ILGenerator (オペコード、LocalBuilder)</span><span class="sxs-lookup"><span data-stu-id="45410-4252">ILGenerator.Emit(OpCode, LocalBuilder)</span></span>  
  
-   <span data-ttu-id="45410-4253">ILGenerator (オペコード、byte)</span><span class="sxs-lookup"><span data-stu-id="45410-4253">ILGenerator.Emit(OpCode, byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4254">評価スタックから提供されたメモリ アドレスに、指定した型の値をコピーします。</span><span class="sxs-lookup"><span data-stu-id="45410-4254">Copies a value of a specified type from the evaluation stack into a supplied memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4255">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4255">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4256">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4256">Format</span></span>|<span data-ttu-id="45410-4257">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4257">Assembly Format</span></span>|<span data-ttu-id="45410-4258">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4258">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4259">81 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-4259">81 < `T` ></span></span>|<span data-ttu-id="45410-4260">stobj`class`</span><span class="sxs-lookup"><span data-stu-id="45410-4260">stobj `class`</span></span>|<span data-ttu-id="45410-4261">スタックからメモリに型`class`の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="45410-4261">Stores a value of type `class` from the stack into memory.</span></span>|  
  
 <span data-ttu-id="45410-4262">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4262">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4263">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4263">An address is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4264">型`class`の値型のオブジェクトがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4264">A value type object of type `class` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4265">オブジェクトとアドレスがスタックからポップされます。値型のオブジェクトはアドレスに格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4265">The object and the address are popped from the stack; the value type object is stored at the address.</span></span>  
  
 <span data-ttu-id="45410-4266">命令`stobj`は、アドレス (型`*`、型、または`&`型`native int`のポインター) によって指定されたアドレスに、値型オブジェクトをコピーします。</span><span class="sxs-lookup"><span data-stu-id="45410-4266">The `stobj` instruction copies the value type object into the address specified by the address (a pointer of type `native int`, `*`, or `&`).</span></span> <span data-ttu-id="45410-4267">コピーされるバイト数は、によって表されるクラスの`class`サイズによって異なります。これは、値型を表すメタデータトークンです。</span><span class="sxs-lookup"><span data-stu-id="45410-4267">The number of bytes copied depends on the size of the class represented by `class`, a metadata token representing a value type.</span></span>  
  
 <span data-ttu-id="45410-4268">`stobj`命令の操作は、直前<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>前置命令によって変更できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4268">The operation of the `stobj` instruction can be altered by an immediately preceding <xref:System.Reflection.Emit.OpCodes.Volatile> or <xref:System.Reflection.Emit.OpCodes.Unaligned> prefix instruction.</span></span>  
  
 <span data-ttu-id="45410-4269"><xref:System.TypeLoadException>クラスが見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4269"><xref:System.TypeLoadException> is thrown if class cannot be found.</span></span> <span data-ttu-id="45410-4270">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4270">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</span></span>  
  
 <span data-ttu-id="45410-4271">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stobj`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4271">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stobj` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4272">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-4272">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4273">静的フィールドの値を評価スタックの値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-4273">Replaces the value of a static field with a value from the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4274">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4274">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4275">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4275">Format</span></span>|<span data-ttu-id="45410-4276">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4276">Assembly Format</span></span>|<span data-ttu-id="45410-4277">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4277">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4278">80 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-4278">80 < `T` ></span></span>|<span data-ttu-id="45410-4279">stsfld`field`</span><span class="sxs-lookup"><span data-stu-id="45410-4279">stsfld `field`</span></span>|<span data-ttu-id="45410-4280">の`field`値を指定された値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-4280">Replaces the value in `field` with a supplied value.</span></span>|  
  
 <span data-ttu-id="45410-4281">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4281">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4282">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4282">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4283">値はスタックからポップされ、に`field`格納されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4283">A value is popped from the stack and stored in `field`.</span></span>  
  
 <span data-ttu-id="45410-4284">命令`stsfld`は、静的フィールドの値をスタックの値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="45410-4284">The `stsfld` instruction replaces the value of a static field with a value from the stack.</span></span> <span data-ttu-id="45410-4285">`field`は、静的フィールドメンバーを参照する必要があるメタデータトークンです。</span><span class="sxs-lookup"><span data-stu-id="45410-4285">`field` is a metadata token that must refer to a static field member.</span></span>  
  
 <span data-ttu-id="45410-4286">命令`stsfld`の先頭にを<xref:System.Reflection.Emit.OpCodes.Volatile>付けることができます。</span><span class="sxs-lookup"><span data-stu-id="45410-4286">The `stsfld` instruction may be prefixed by <xref:System.Reflection.Emit.OpCodes.Volatile>.</span></span>  
  
 <span data-ttu-id="45410-4287"><xref:System.MissingFieldException>メタデータ内にフィールドが見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4287"><xref:System.MissingFieldException> is thrown if field is not found in the metadata.</span></span> <span data-ttu-id="45410-4288">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合にチェックされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4288">This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</span></span>  
  
 <span data-ttu-id="45410-4289">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `stsfld`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4289">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `stsfld` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4290">ILGenerator (オペコード、FieldInfo)</span><span class="sxs-lookup"><span data-stu-id="45410-4290">ILGenerator.Emit(OpCode, FieldInfo)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4291">ある値から別の値を減算し、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-4291">Subtracts one value from another and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4292">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4292">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4293">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4293">Format</span></span>|<span data-ttu-id="45410-4294">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4294">Assembly Format</span></span>|<span data-ttu-id="45410-4295">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4295">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4296">59</span><span class="sxs-lookup"><span data-stu-id="45410-4296">59</span></span>|<span data-ttu-id="45410-4297">sub</span><span class="sxs-lookup"><span data-stu-id="45410-4297">sub</span></span>|<span data-ttu-id="45410-4298">ある値を別の値から減算し、新しい数値を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-4298">Subtracts one value from another, returning a new numeric value.</span></span>|  
  
 <span data-ttu-id="45410-4299">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4299">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4300">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4300">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4301">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4301">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4302">`value2`と`value1`はスタックからポップされます。`value2`はから `value1` 減算されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4302">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1`.</span></span>  
  
4.  <span data-ttu-id="45410-4303">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4303">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-4304">整数演算のオーバーフローは検出されません (適切なオーバーフロー <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>処理の場合は、「」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="45410-4304">Overflow is not detected for integer operations (for proper overflow handling, see <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).</span></span>  
  
 <span data-ttu-id="45410-4305">整数の減算は、によって飽和するのではなく、ラップします。</span><span class="sxs-lookup"><span data-stu-id="45410-4305">Integer subtraction wraps, rather than saturates.</span></span> <span data-ttu-id="45410-4306">たとえば、 `value1`が0に設定され、が1に設定され`value2`ている場合は、8ビット整数と想定します。 "ラップされた" 結果は255になります。</span><span class="sxs-lookup"><span data-stu-id="45410-4306">For example: assuming 8-bit integers, where `value1` is set to 0 and `value2` is set to 1, the "wrapped" result will be 255.</span></span>  
  
 <span data-ttu-id="45410-4307">浮動小数点オーバーフローは`+inf` 、`PositiveInfinity`() `-inf`また`NegativeInfinity`は () を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-4307">Floating-point overflow returns `+inf` (`PositiveInfinity`) or `-inf` (`NegativeInfinity`).</span></span>  
  
 <span data-ttu-id="45410-4308">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `sub`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4308">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4309">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4309">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4310">ある整数値を別の整数値から減算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-4310">Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4311">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4311">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4312">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4312">Format</span></span>|<span data-ttu-id="45410-4313">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4313">Assembly Format</span></span>|<span data-ttu-id="45410-4314">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4314">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4315">オーディオ</span><span class="sxs-lookup"><span data-stu-id="45410-4315">DA</span></span>|<span data-ttu-id="45410-4316">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-4316">sub.ovf</span></span>|<span data-ttu-id="45410-4317">オーバーフローチェックを使用して、ある整数値を別の整数値から減算します。</span><span class="sxs-lookup"><span data-stu-id="45410-4317">Subtracts one integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="45410-4318">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4318">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4319">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4319">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4320">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4320">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4321">`value2`と`value1`はスタックからポップされます。は、オーバーフロー `value1`のチェックを使用してから減算されます。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-4321">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="45410-4322">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4322">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-4323"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4323"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-4324">この操作は、符号付き整数に対して実行されます。浮動小数点値の場合は<xref:System.Reflection.Emit.OpCodes.Sub>、を使用します。</span><span class="sxs-lookup"><span data-stu-id="45410-4324">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="45410-4325">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `sub.ovf`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4325">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4326">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4326">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4327">ある符号なし整数値を別の符号なし整数値から減算し、オーバーフローをチェックし、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-4327">Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4328">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4328">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4329">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4329">Format</span></span>|<span data-ttu-id="45410-4330">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4330">Assembly Format</span></span>|<span data-ttu-id="45410-4331">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4331">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4332">DB</span><span class="sxs-lookup"><span data-stu-id="45410-4332">DB</span></span>|<span data-ttu-id="45410-4333">ovf</span><span class="sxs-lookup"><span data-stu-id="45410-4333">sub.ovf.un</span></span>|<span data-ttu-id="45410-4334">オーバーフローチェックを使用して、1つの符号なし整数値を別の符号なし整数値から減算します。</span><span class="sxs-lookup"><span data-stu-id="45410-4334">Subtracts one unsigned integer value from another with an overflow check.</span></span>|  
  
 <span data-ttu-id="45410-4335">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4335">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4336">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4336">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4337">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4337">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4338">`value2`と`value1`はスタックからポップされます。は、オーバーフロー `value1`のチェックを使用してから減算されます。 `value2`</span><span class="sxs-lookup"><span data-stu-id="45410-4338">`value2` and `value1` are popped from the stack; `value2` is subtracted from `value1` with a check for overflow.</span></span>  
  
4.  <span data-ttu-id="45410-4339">結果がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4339">The result is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-4340"><xref:System.OverflowException>結果を結果の型で表すことができない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4340"><xref:System.OverflowException> is thrown if the result can not be represented in the result type.</span></span>  
  
 <span data-ttu-id="45410-4341">この操作は、符号付き整数に対して実行されます。浮動小数点値の場合は<xref:System.Reflection.Emit.OpCodes.Sub>、を使用します。</span><span class="sxs-lookup"><span data-stu-id="45410-4341">This operation is performed on signed integers; for floating-point values, use <xref:System.Reflection.Emit.OpCodes.Sub>.</span></span>  
  
 <span data-ttu-id="45410-4342">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `sub.ovf.un`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4342">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `sub.ovf.un` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4343">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4343">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4344">ジャンプ テーブルを実装します。</span><span class="sxs-lookup"><span data-stu-id="45410-4344">Implements a jump table.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4345">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4345">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4346">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4346">Format</span></span>|<span data-ttu-id="45410-4347">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4347">Assembly Format</span></span>|<span data-ttu-id="45410-4348">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4348">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4349">45 < `unsigned int32` > < `int32` >...<`int32` ></span><span class="sxs-lookup"><span data-stu-id="45410-4349">45 < `unsigned int32` > < `int32` >... < `int32` ></span></span>|<span data-ttu-id="45410-4350">スイッチ (`N`、 `t1`、 `t2`...`tN`)</span><span class="sxs-lookup"><span data-stu-id="45410-4350">switch (`N`, `t1`, `t2`... `tN`)</span></span>|<span data-ttu-id="45410-4351">値の`N`いずれかにジャンプします。</span><span class="sxs-lookup"><span data-stu-id="45410-4351">Jumps to one of `N` values.</span></span>|  
  
 <span data-ttu-id="45410-4352">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4352">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4353">値はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4353">A value is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4354">値はスタックからポップされ、値によってインデックス付けされたオフセットの命令に実行が転送されます。 `N`このとき、値はより小さくなります。</span><span class="sxs-lookup"><span data-stu-id="45410-4354">The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than `N`.</span></span>  
  
 <span data-ttu-id="45410-4355">この`switch`命令は、ジャンプテーブルを実装します。</span><span class="sxs-lookup"><span data-stu-id="45410-4355">The `switch` instruction implements a jump table.</span></span> <span data-ttu-id="45410-4356">命令の形式は、ターゲット`unsigned int32` `N`の数を表すであり、その後`N`にジャンプターゲットを指定する int32 値が続きます。</span><span class="sxs-lookup"><span data-stu-id="45410-4356">The format of the instruction is an `unsigned int32` representing the number of targets `N`, followed by `N` int32 values specifying jump targets.</span></span> <span data-ttu-id="45410-4357">これらのターゲットは、この`switch`命令に続く命令の先頭からのオフセット (正または負) として表されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4357">These targets are represented as offsets (positive or negative) from the beginning of the instruction following this `switch` instruction.</span></span>  
  
 <span data-ttu-id="45410-4358">命令`switch`は、値をスタックからポップし、符号なし整数としてに`N`比較します。</span><span class="sxs-lookup"><span data-stu-id="45410-4358">The `switch` instruction pops a value off the stack and compares it, as an unsigned integer, to `N`.</span></span> <span data-ttu-id="45410-4359">値が未満`N`の場合、実行は値でインデックス付けされたターゲットに転送されます。この場合、ターゲットは0から番号が付けられます (たとえば、0の値は最初のターゲットを、1は2番目のターゲットを受け取ります)。</span><span class="sxs-lookup"><span data-stu-id="45410-4359">If value is less than `N`, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</span></span> <span data-ttu-id="45410-4360">値が以上の場合`N`、次の命令 (フォールスルー) で実行が続行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4360">If the value is greater than or equal to `N`, execution continues at the next instruction (fall through).</span></span>  
  
 <span data-ttu-id="45410-4361">ターゲット命令に1つ以上のプレフィックスコードがある場合、control はこれらのプレフィックスの最初の部分にのみ転送できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4361">If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</span></span>  
  
 <span data-ttu-id="45410-4362">`try`この命令では`catch` `finally` 、、、、およびブロックへの、、、およびブロックへの送受信の制御を実行できません。 `filter`</span><span class="sxs-lookup"><span data-stu-id="45410-4362">Control transfers into and out of `try`, `catch`, `filter`, and `finally` blocks cannot be performed by this instruction.</span></span> <span data-ttu-id="45410-4363">(このような転送は厳しく制限されており、代わりに leave 命令を使用する必要があります)。</span><span class="sxs-lookup"><span data-stu-id="45410-4363">(Such transfers are severely restricted and must use the leave instruction instead).</span></span>  
  
 <span data-ttu-id="45410-4364">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `switch`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4364">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `switch` opcode.</span></span> <span data-ttu-id="45410-4365">引数`Label[]`は、32ビットオフセットを表すラベルの配列です。</span><span class="sxs-lookup"><span data-stu-id="45410-4365">The `Label[]` argument is an array of Labels representing 32-bit offsets.</span></span>  
  
-   <span data-ttu-id="45410-4366">ILGenerator (オペコード, Label [])</span><span class="sxs-lookup"><span data-stu-id="45410-4366">ILGenerator.Emit(OpCode, Label[])</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="45410-4367">次のコードサンプルは、の`Switch` <xref:System.Reflection.Emit.Label>配列を使用して、オペコードを使用してジャンプテーブルを生成する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4367">The following code sample illustrates the use of the `Switch` opcode to generate a jump table using an array of <xref:System.Reflection.Emit.Label>.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4368">実際の呼び出し命令が実行される前に、現在のメソッドのスタック フレームが削除されるように、後置のメソッド呼び出し命令を実行します。</span><span class="sxs-lookup"><span data-stu-id="45410-4368">Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4369">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4369">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4370">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4370">Format</span></span>|<span data-ttu-id="45410-4371">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4371">Assembly Format</span></span>|<span data-ttu-id="45410-4372">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4372">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4373">FE 14</span><span class="sxs-lookup"><span data-stu-id="45410-4373">FE 14</span></span>|<span data-ttu-id="45410-4374">テイ.</span><span class="sxs-lookup"><span data-stu-id="45410-4374">tail.</span></span>|<span data-ttu-id="45410-4375">後続の呼び出しは、現在のメソッドを終了します</span><span class="sxs-lookup"><span data-stu-id="45410-4375">Subsequent call terminates current methods</span></span>|  
  
 <span data-ttu-id="45410-4376">この命令には、スタック移行動作は定義されていません。</span><span class="sxs-lookup"><span data-stu-id="45410-4376">There is no stack transition behavior defined for this instruction.</span></span>  
  
 <span data-ttu-id="45410-4377">プレフィックス命令は<xref:System.Reflection.Emit.OpCodes.Call> <xref:System.Reflection.Emit.OpCodes.Callvirt> 、 <xref:System.Reflection.Emit.OpCodes.Calli>、、または命令の直前に配置する必要があります。 `tail`</span><span class="sxs-lookup"><span data-stu-id="45410-4377">The `tail` prefix instruction must immediately precede a <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, or <xref:System.Reflection.Emit.OpCodes.Callvirt> instruction.</span></span> <span data-ttu-id="45410-4378">これは、呼び出し命令が実行される前に、現在のメソッドのスタックフレームを削除する必要があることを示します。</span><span class="sxs-lookup"><span data-stu-id="45410-4378">It indicates that the current method's stack frame should be removed before the call instruction is executed.</span></span> <span data-ttu-id="45410-4379">また、次の呼び出しから返される値も、現在のメソッドによって返される値であることを意味します。この呼び出しは、メソッド間のジャンプに変換できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4379">It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</span></span>  
  
 <span data-ttu-id="45410-4380">スタックは、次の呼び出しによって転送される引数を除いて、空である必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4380">The stack must be empty except for the arguments being transferred by the following call.</span></span> <span data-ttu-id="45410-4381">呼び出し命令の後の命令は、ret である必要があります。したがって、有効なコードシーケンス`tail. call`は ( `calli`また`callvirt`は) だけです。</span><span class="sxs-lookup"><span data-stu-id="45410-4381">The instruction following the call instruction must be a ret. Thus the only valid code sequence is `tail. call` (or `calli` or `callvirt`).</span></span> <span data-ttu-id="45410-4382">正しい MSIL (Microsoft 中間言語) 命令を`call`命令に分岐することはできませんが、後続<xref:System.Reflection.Emit.OpCodes.Ret>のに分岐する場合があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4382">Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the `call` instruction, but they may branch to the subsequent <xref:System.Reflection.Emit.OpCodes.Ret>.</span></span>  
  
 <span data-ttu-id="45410-4383">コード id のセキュリティが損なわれる可能性があるため、信頼されていないコードから信頼されるコードに制御が転送されるときに、現在のフレームを破棄することはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-4383">The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</span></span> <span data-ttu-id="45410-4384">このため、.NET Framework セキュリティチェックによっ`tail`てが無視され、標準<xref:System.Reflection.Emit.OpCodes.Call>の命令が残されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4384">The .NET Framework security checks can therefore cause the `tail` to be ignored, leaving a standard <xref:System.Reflection.Emit.OpCodes.Call> instruction.</span></span> <span data-ttu-id="45410-4385">同様に、呼び出しから制御が戻っ`tail`た後に同期された領域の終了が発生するようにするために、同期済みとマークされたメソッドを終了するために使用した場合、プレフィックスは無視されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4385">Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the `tail` prefix is ignored when used to exit a method that is marked synchronized.</span></span>  
  
 <span data-ttu-id="45410-4386">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `tail`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4386">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `tail` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4387">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4387">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst"><span data-ttu-id="45410-4388">Opcode オブジェクトのインスタンス。</span><span class="sxs-lookup"><span data-stu-id="45410-4388">An instance of an Opcode object.</span></span></param>
        <summary><span data-ttu-id="45410-4389">提供されたオペコードが 1 バイト引数をとる場合は、true または false を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-4389">Returns true or false if the supplied opcode takes a single byte argument.</span></span></summary>
        <returns><span data-ttu-id="45410-4390"><see langword="true" /> または <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="45410-4390"><see langword="true" /> or <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4391">このメソッドを使用すると、最適化されたコードで使用される "短い形式" の MSIL オペコードを見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="45410-4391">This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</span></span>  
  
 <span data-ttu-id="45410-4392">`TakesSingleByteArgument`インスタンス`true`が次<xref:System.Reflection.Emit.OpCode>の場合に1バイトの引数を受け取る場合は、を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-4392">`TakesSingleByteArgument` returns `true` if the <xref:System.Reflection.Emit.OpCode> instance takes a single byte argument in the following cases:</span></span>  
  
-   <span data-ttu-id="45410-4393">オペコードは、バイトサイズのアドレス (たとえば、 <xref:System.Reflection.Emit.OpCodes.Br_S>や<xref:System.Reflection.Emit.OpCodes.Bgt_S>) に対する分岐命令を実行します。</span><span class="sxs-lookup"><span data-stu-id="45410-4393">The opcode performs a branch instruction to a byte-sized address (for example, <xref:System.Reflection.Emit.OpCodes.Br_S> and <xref:System.Reflection.Emit.OpCodes.Bgt_S>).</span></span>  
  
-   <span data-ttu-id="45410-4394">オペコードは、バイト値をスタックにプッシュします (たとえば<xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>、)。</span><span class="sxs-lookup"><span data-stu-id="45410-4394">The opcode pushes a byte value onto the stack (for example, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).</span></span>  
  
-   <span data-ttu-id="45410-4395">オペコードは、バイトサイズの "短い形式" (や<xref:System.Reflection.Emit.OpCodes.Ldloc_S> <xref:System.Reflection.Emit.OpCodes.Stloc_S>など) を使用して、変数または引数を参照します。</span><span class="sxs-lookup"><span data-stu-id="45410-4395">The opcode references a variable or argument via the byte-sized "short form" (for example, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> and <xref:System.Reflection.Emit.OpCodes.Stloc_S>).</span></span>  
  
 <span data-ttu-id="45410-4396">それ以外の場合は、 `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-4396">Otherwise, it returns `false`.</span></span>  
  
 <span data-ttu-id="45410-4397">次の例では、を`TakesSingleByteArgument` `OpCodes`クラスに反映することによってを使用し、 `OpCode`各フィールドが1バイトの引数を受け取るかどうかをテストしています。</span><span class="sxs-lookup"><span data-stu-id="45410-4397">The example below demonstrates the use of `TakesSingleByteArgument` by reflecting on to the `OpCodes` class and testing to see whether each `OpCode` field takes a single-byte argument.</span></span>  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4398">現在評価スタックにある例外オブジェクトをスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-4398">Throws the exception object currently on the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4399">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4399">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4400">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4400">Format</span></span>|<span data-ttu-id="45410-4401">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4401">Assembly Format</span></span>|<span data-ttu-id="45410-4402">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4402">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4403">7A</span><span class="sxs-lookup"><span data-stu-id="45410-4403">7A</span></span>|<span data-ttu-id="45410-4404">throw</span><span class="sxs-lookup"><span data-stu-id="45410-4404">throw</span></span>|<span data-ttu-id="45410-4405">例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-4405">Throws an exception.</span></span>|  
  
 <span data-ttu-id="45410-4406">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4406">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4407">(例外への) オブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4407">An object reference (to an exception) is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4408">オブジェクト参照がスタックからポップされ、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4408">The object reference is popped from the stack and the exception thrown.</span></span>  
  
 <span data-ttu-id="45410-4409">命令`throw`は、現在スタックにある例外`O`オブジェクト (型) をスローします。</span><span class="sxs-lookup"><span data-stu-id="45410-4409">The `throw` instruction throws the exception object (type `O`) currently on the stack.</span></span>  
  
 <span data-ttu-id="45410-4410"><xref:System.NullReferenceException>オブジェクト参照が null 参照の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4410"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="45410-4411">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `throw`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4411">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `throw` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4412">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4412">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4413">現在評価スタックの一番上にあるアドレスが、直後の <see langword="ldind" />、<see langword="stind" />、<see langword="ldfld" />、<see langword="stfld" />、<see langword="ldobj" />、<see langword="stobj" />、<see langword="initblk" /> または <see langword="cpblk" /> の各命令の通常サイズに合わせて配置されていない可能性があることを示します。</span><span class="sxs-lookup"><span data-stu-id="45410-4413">Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, or <see langword="cpblk" /> instruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4414">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4414">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4415">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4415">Format</span></span>|<span data-ttu-id="45410-4416">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4416">Assembly Format</span></span>|<span data-ttu-id="45410-4417">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4417">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4418">FE 12 <`unsigned int8` ></span><span class="sxs-lookup"><span data-stu-id="45410-4418">FE 12 < `unsigned int8` ></span></span>|<span data-ttu-id="45410-4419">揃え.</span><span class="sxs-lookup"><span data-stu-id="45410-4419">unaligned.</span></span> `alignment`|<span data-ttu-id="45410-4420">後続のポインター命令が整列していない可能性があることを示します。</span><span class="sxs-lookup"><span data-stu-id="45410-4420">Indicates that the subsequent pointer instruction may be unaligned.</span></span>|  
  
 <span data-ttu-id="45410-4421">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4421">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4422">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4422">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-4423">`Unaligned`スタック上のアドレス`native int`(アンマネージポインター) が、の`ldind`直後`stobj` `stind` `ldfld` `stfld` `ldobj`のの自然サイズにアラインされていない可能性があることを指定します。、、 `cpblk`または命令。 `initblk`</span><span class="sxs-lookup"><span data-stu-id="45410-4423">`Unaligned` specifies that the address (an unmanaged pointer, `native int`) on the stack might not be aligned to the natural size of the immediately following `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="45410-4424">つまり、 <xref:System.Reflection.Emit.OpCodes.Ldind_I4>命令の場合、アドレスのアラインメントを4バイト境界にすることはできません。</span><span class="sxs-lookup"><span data-stu-id="45410-4424">That is, for a <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instruction the alignment of the address may not be to a 4-byte boundary.</span></span> <span data-ttu-id="45410-4425">`initblk` と `cpblk` では、既定のアラインメントはアーキテクチャに依存します (32 ビット cpu では4バイト、64ビット cpu では8バイト)。</span><span class="sxs-lookup"><span data-stu-id="45410-4425">For `initblk` and `cpblk` the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</span></span> <span data-ttu-id="45410-4426">コンパイル時に8バイトになるように配置が認識されない場合、 `unaligned`出力を32ビットワードサイズに制限しないコードジェネレーターでは、を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4426">Code generators that do not restrict their output to a 32-bit word size must use `unaligned` if the alignment is not known at compile time to be 8-byte.</span></span>  
  
 <span data-ttu-id="45410-4427">アラインメントの値は1、2、または4である必要があります。生成されたコードでは、アドレスがバイト、2バイト、または4バイトでアラインされていると想定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4427">The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</span></span> <span data-ttu-id="45410-4428">一時的なポインター (型`*`) は常にアラインされることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="45410-4428">Note that transient pointers (type `*`) are always aligned.</span></span>  
  
 <span data-ttu-id="45410-4429">`cpblk`命令の配置では、論理的に2つの数値が必要になりますが (1 つはソース用、もう1つは変換先に対して)、低い数値のみが指定されている場合、パフォーマンスに大きな影響はありません。</span><span class="sxs-lookup"><span data-stu-id="45410-4429">While the alignment for a `cpblk` instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</span></span>  
  
 <span data-ttu-id="45410-4430">プレフィックス`unaligned` と `volatile` プレフィックスは、どちらの順序でも組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="45410-4430">The `unaligned` and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="45410-4431">これら`ldind`は、 `stobj`  、、 `cpblk`  、、、、 、または命令の直前に配置する必要があります。 `initblk`  `stind` `ldfld` `stfld` `ldobj`</span><span class="sxs-lookup"><span data-stu-id="45410-4431">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="45410-4432">との手順ではプレフィックスのみを使用できます。 <xref:System.Reflection.Emit.OpCodes.Volatile> <xref:System.Reflection.Emit.OpCodes.Ldsfld> <xref:System.Reflection.Emit.OpCodes.Stsfld></span><span class="sxs-lookup"><span data-stu-id="45410-4432">Only the <xref:System.Reflection.Emit.OpCodes.Volatile> prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="45410-4433">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `unaligned`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4433">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overloads can use the `unaligned` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4434">ILGenerator (オペコード, Label)</span><span class="sxs-lookup"><span data-stu-id="45410-4434">ILGenerator.Emit(OpCode, Label)</span></span>  
  
-   <span data-ttu-id="45410-4435">ILGenerator (オペコード、Byte)</span><span class="sxs-lookup"><span data-stu-id="45410-4435">ILGenerator.Emit(Opcode, Byte)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4436">値型のボックス化変換された形式をボックス化が解除された形式に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-4436">Converts the boxed representation of a value type to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4437">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4437">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4438">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4438">Format</span></span>|<span data-ttu-id="45410-4439">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4439">Assembly Format</span></span>|<span data-ttu-id="45410-4440">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4440">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4441">79 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-4441">79 < `T` ></span></span>|<span data-ttu-id="45410-4442">アン`valType`</span><span class="sxs-lookup"><span data-stu-id="45410-4442">unbox `valType`</span></span>|<span data-ttu-id="45410-4443">ボックス化された表現`obj`から値型データを抽出します。</span><span class="sxs-lookup"><span data-stu-id="45410-4443">Extracts the value type data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="45410-4444">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4444">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4445">オブジェクト参照がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4445">An object reference is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4446">オブジェクト参照はスタックからポップされ、ボックス化が解除されて値型のポインターになります。</span><span class="sxs-lookup"><span data-stu-id="45410-4446">The object reference is popped from the stack and unboxed to a value type pointer.</span></span>  
  
3.  <span data-ttu-id="45410-4447">値型のポインターがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4447">The value type pointer is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-4448">値型には、共通言語基盤 (CLI) 内の2つの異なる表現があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4448">A value type has two separate representations within the Common Language Infrastructure (CLI):</span></span>  
  
-   <span data-ttu-id="45410-4449">値型が別のオブジェクトに埋め込まれている場合に使用される ' 未加工 ' フォーム。</span><span class="sxs-lookup"><span data-stu-id="45410-4449">A 'raw' form used when a value type is embedded within another object.</span></span>  
  
-   <span data-ttu-id="45410-4450">' ボックス化された ' フォーム。値型のデータは、独立したエンティティとして存在できるように、オブジェクトにラップ (ボックス化) されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4450">A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</span></span>  
  
 <span data-ttu-id="45410-4451">命令`unbox`は、オブジェクト参照 (型`O`)、値型のボックス化された表現を、値型のポインター (マネージポインター、型`&`)、およびボックス化解除された形式に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-4451">The `unbox` instruction converts the object reference (type `O`), the boxed representation of a value type, to a value type pointer (a managed pointer, type `&`), its unboxed form.</span></span> <span data-ttu-id="45410-4452">指定された値`valType`型 () は、ボックス化されたオブジェクト内に含まれる値型の型を示すメタデータトークンです。</span><span class="sxs-lookup"><span data-stu-id="45410-4452">The supplied value type (`valType`) is a metadata token indicating the type of value type contained within the boxed object.</span></span>  
  
 <span data-ttu-id="45410-4453">オブジェクト<xref:System.Reflection.Emit.OpCodes.Box>で使用するために値型のコピーを作成するために必要なとは`unbox`異なり、では、オブジェクトから値型をコピーする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="45410-4453">Unlike <xref:System.Reflection.Emit.OpCodes.Box>, which is required to make a copy of a value type for use in the object, `unbox` is not required to copy the value type from the object.</span></span> <span data-ttu-id="45410-4454">通常は、ボックス化されたオブジェクト内に既に存在する値の型のアドレスを計算するだけです。</span><span class="sxs-lookup"><span data-stu-id="45410-4454">Typically it simply computes the address of the value type that is already present inside of the boxed object.</span></span>  
  
 <span data-ttu-id="45410-4455"><xref:System.InvalidCastException>オブジェクトがとして`valType`ボックス化されていない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4455"><xref:System.InvalidCastException> is thrown if the object is not boxed as `valType`.</span></span>  
  
 <span data-ttu-id="45410-4456"><xref:System.NullReferenceException>オブジェクト参照が null 参照の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4456"><xref:System.NullReferenceException> is thrown if the object reference is a null reference.</span></span>  
  
 <span data-ttu-id="45410-4457"><xref:System.TypeLoadException>値の型`valType`が見つからない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4457"><xref:System.TypeLoadException> is thrown if the value type `valType` cannot be found.</span></span> <span data-ttu-id="45410-4458">これは通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブコードに変換された場合に検出されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4458">This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</span></span>  
  
 <span data-ttu-id="45410-4459">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `unbox`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4459">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4460">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-4460">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4461">命令で指定された型のボックス化変換された形式を、ボックス化が解除された形式に変換します。</span><span class="sxs-lookup"><span data-stu-id="45410-4461">Converts the boxed representation of a type specified in the instruction to its unboxed form.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4462">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4462">The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4463">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4463">Format</span></span>|<span data-ttu-id="45410-4464">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4464">Assembly Format</span></span>|<span data-ttu-id="45410-4465">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4465">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4466">A5 <`T` ></span><span class="sxs-lookup"><span data-stu-id="45410-4466">A5 < `T` ></span></span>|<span data-ttu-id="45410-4467">ボックス解除。任意`typeTok`</span><span class="sxs-lookup"><span data-stu-id="45410-4467">unbox.any `typeTok`</span></span>|<span data-ttu-id="45410-4468">ボックス化され`obj`た表現からデータを抽出します。</span><span class="sxs-lookup"><span data-stu-id="45410-4468">Extract the data from `obj`, its boxed representation.</span></span>|  
  
 <span data-ttu-id="45410-4469">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4469">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4470">オブジェクト参照`obj`がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4470">An object reference `obj` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4471">オブジェクト参照がスタックからポップされ、その命令で指定された型にボックス化解除されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4471">The object reference is popped from the stack and unboxed to the type specified in the instruction.</span></span>  
  
3.  <span data-ttu-id="45410-4472">結果として得られるオブジェクト参照または値型がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4472">The resulting object reference or value type is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-4473">値型のボックス化された形式に適用さ`unbox.any`れる場合、命令は`obj` (型`O`の) に含まれる値を抽出する`unbox`ため、 `ldobj`の後に続くと同じ結果になります。</span><span class="sxs-lookup"><span data-stu-id="45410-4473">When applied to the boxed form of a value type, the `unbox.any` instruction extracts the value contained within `obj` (of type `O`), and is therefore equivalent to `unbox` followed by `ldobj`.</span></span>  
  
 <span data-ttu-id="45410-4474">参照型`unbox.any`に適用された場合、命令はと`castclass` `typeTok`同じ効果を持ちます。</span><span class="sxs-lookup"><span data-stu-id="45410-4474">When applied to a reference type, the `unbox.any` instruction has the same effect as `castclass` `typeTok`.</span></span>  
  
 <span data-ttu-id="45410-4475">オペランド`typeTok`がジェネリック型パラメーターの場合、ランタイムの動作は、そのジェネリック型パラメーターに対して指定されている型によって決まります。</span><span class="sxs-lookup"><span data-stu-id="45410-4475">If the operand `typeTok` is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</span></span>  
  
 <span data-ttu-id="45410-4476"><xref:System.InvalidCastException>がボックス化`obj`された型でない場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4476"><xref:System.InvalidCastException> is thrown if `obj` is not a boxed type.</span></span>  
  
 <span data-ttu-id="45410-4477"><xref:System.NullReferenceException>が null 参照`obj`の場合は、がスローされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4477"><xref:System.NullReferenceException> is thrown if `obj` is a null reference.</span></span>  
  
 <span data-ttu-id="45410-4478">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `unbox.any`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4478">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `unbox.any` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4479">ILGenerator (オペコード, Type)</span><span class="sxs-lookup"><span data-stu-id="45410-4479">ILGenerator.Emit(OpCode, Type)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4480">現在評価スタックの一番上にあるアドレスが揮発性である可能性があるため、この位置の読み取り結果をキャッシュできないこと、またはこの位置への複数の格納を中止できないことを指定します。</span><span class="sxs-lookup"><span data-stu-id="45410-4480">Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4481">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4481">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4482">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4482">Format</span></span>|<span data-ttu-id="45410-4483">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4483">Assembly Format</span></span>|<span data-ttu-id="45410-4484">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4484">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4485">FE 13</span><span class="sxs-lookup"><span data-stu-id="45410-4485">FE 13</span></span>|<span data-ttu-id="45410-4486">やすい.</span><span class="sxs-lookup"><span data-stu-id="45410-4486">volatile.</span></span>|<span data-ttu-id="45410-4487">後続のポインター参照が volatile であることを示します。</span><span class="sxs-lookup"><span data-stu-id="45410-4487">Indicates that the subsequent pointer reference is volatile.</span></span>|  
  
 <span data-ttu-id="45410-4488">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4488">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4489">アドレスがスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4489">An address is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-4490">`volatile`。</span><span class="sxs-lookup"><span data-stu-id="45410-4490">`volatile`.</span></span> <span data-ttu-id="45410-4491">アドレスが volatile アドレスである (つまり、現在実行されているスレッドの外部で参照できる) ことを指定します。また、その場所の読み取り結果をキャッシュできないか、またはその場所への複数のストアを抑制できないことを示します。</span><span class="sxs-lookup"><span data-stu-id="45410-4491">specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</span></span> <span data-ttu-id="45410-4492">アクセスをとし`volatile`てマークすると、その単一のアクセスのみに影響します。同じ場所への他のアクセスは、個別にマークする必要があります。</span><span class="sxs-lookup"><span data-stu-id="45410-4492">Marking an access as `volatile` affects only that single access; other accesses to the same location must be marked separately.</span></span> <span data-ttu-id="45410-4493">揮発性の場所へのアクセスは、アトミックに実行する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="45410-4493">Access to volatile locations need not be performed atomically.</span></span>  
  
 <span data-ttu-id="45410-4494">プレフィックス<xref:System.Reflection.Emit.OpCodes.Unaligned> と `volatile` プレフィックスは、どちらの順序でも組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="45410-4494">The <xref:System.Reflection.Emit.OpCodes.Unaligned> and `volatile` prefixes can be combined in either order.</span></span> <span data-ttu-id="45410-4495">これら`ldind`は、 `stobj`  、、 `cpblk`  、、、、 、または命令の直前に配置する必要があります。 `initblk`  `stind` `ldfld` `stfld` `ldobj`</span><span class="sxs-lookup"><span data-stu-id="45410-4495">They must immediately precede a `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, or `cpblk` instruction.</span></span> <span data-ttu-id="45410-4496">との手順ではプレフィックスのみを使用できます。 `volatile` <xref:System.Reflection.Emit.OpCodes.Ldsfld> <xref:System.Reflection.Emit.OpCodes.Stsfld></span><span class="sxs-lookup"><span data-stu-id="45410-4496">Only the `volatile` prefix is allowed for the <xref:System.Reflection.Emit.OpCodes.Ldsfld> and <xref:System.Reflection.Emit.OpCodes.Stsfld> instructions.</span></span>  
  
 <span data-ttu-id="45410-4497">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `volatile`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4497">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `volatile` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4498">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4498">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="45410-4499">スタックの一番上にある 2 つの値のビットごとの XOR を計算し、結果を評価スタックにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="45410-4499">Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="45410-4500">次の表は、命令の16進形式と Microsoft 中間言語 (MSIL) のアセンブリ形式と、簡単なリファレンスの概要を示しています。</span><span class="sxs-lookup"><span data-stu-id="45410-4500">The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</span></span>  
  
|<span data-ttu-id="45410-4501">形式</span><span class="sxs-lookup"><span data-stu-id="45410-4501">Format</span></span>|<span data-ttu-id="45410-4502">アセンブリ形式</span><span class="sxs-lookup"><span data-stu-id="45410-4502">Assembly Format</span></span>|<span data-ttu-id="45410-4503">説明</span><span class="sxs-lookup"><span data-stu-id="45410-4503">Description</span></span>|  
|------------|---------------------|-----------------|  
|<span data-ttu-id="45410-4504">61</span><span class="sxs-lookup"><span data-stu-id="45410-4504">61</span></span>|<span data-ttu-id="45410-4505">xor</span><span class="sxs-lookup"><span data-stu-id="45410-4505">xor</span></span>|<span data-ttu-id="45410-4506">2つの整数値のビットごとの XOR を計算し、整数を返します。</span><span class="sxs-lookup"><span data-stu-id="45410-4506">Computes the bitwise XOR of two integer values and returns an integer.</span></span>|  
  
 <span data-ttu-id="45410-4507">スタックの移行動作は、次の順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4507">The stack transitional behavior, in sequential order, is:</span></span>  
  
1.  <span data-ttu-id="45410-4508">`value1`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4508">`value1` is pushed onto the stack.</span></span>  
  
2.  <span data-ttu-id="45410-4509">`value2`はスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4509">`value2` is pushed onto the stack.</span></span>  
  
3.  <span data-ttu-id="45410-4510">`value2`と`value1`はスタックからポップされ、ビットごとの XOR が計算されます。</span><span class="sxs-lookup"><span data-stu-id="45410-4510">`value2` and `value1` are popped from the stack and their bitwise XOR computed.</span></span>  
  
4.  <span data-ttu-id="45410-4511">`value2` と `value1` のビットごとの XOR がスタックにプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="45410-4511">The bitwise XOR of `value2` and `value1` is pushed onto the stack.</span></span>  
  
 <span data-ttu-id="45410-4512">命令`xor`は、スタックの上位2つの値のビットごとの XOR を計算し、結果をスタックに残します。</span><span class="sxs-lookup"><span data-stu-id="45410-4512">The `xor` instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</span></span>  
  
 <span data-ttu-id="45410-4513">`Xor`は整数固有の演算です。</span><span class="sxs-lookup"><span data-stu-id="45410-4513">`Xor` is an integer-specific operation.</span></span>  
  
 <span data-ttu-id="45410-4514">次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>のメソッドオーバーロードでは、 `xor`オペコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="45410-4514">The following <xref:System.Reflection.Emit.ILGenerator.Emit%2A> method overload can use the `xor` opcode:</span></span>  
  
-   <span data-ttu-id="45410-4515">ILGenerator (オペコード)</span><span class="sxs-lookup"><span data-stu-id="45410-4515">ILGenerator.Emit(OpCode)</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
