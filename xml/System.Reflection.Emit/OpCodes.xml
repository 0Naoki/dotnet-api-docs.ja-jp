<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="OpCodes.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a136bc8fb48fe619f1be21928afbfcd9094d7463.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a136bc8fb48fe619f1be21928afbfcd9094d7463</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.Emit.OpCodes">
          <source>Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> class members (such as <ph id="ph2">&lt;see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Reflection.Emit.ILGenerator" /&gt;</ph> クラス メンバー (<ph id="ph2">&lt;see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /&gt;</ph> など) による出力に対する MSIL (Microsoft Intermediate Language) 命令のフィールド表現を提供します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially "Partition III: CIL Instruction Set" and "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">メンバー オペコードの詳細については、共通言語基盤 (CLI) ドキュメント、特に「Partition III: CIL Instruction Set」と「Partition II:: Metadata Definition and Semantics」を参照してください。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">ドキュメントはオンラインで入手できます。MSDN の「<bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept>」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「<bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept>」を参照してください。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.Emit.OpCodes">
          <source>The following example demonstrates the construction of a dynamic method using <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph> to emit <ph id="ph2">`OpCodes`</ph> into a <ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>.</source>
          <target state="translated">次の例では、動的メソッドを使用して、構築<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator&gt;</ph>を出力する<ph id="ph2">`OpCodes`</ph>に、<ph id="ph3">&lt;xref:System.Reflection.Emit.MethodBuilder&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Adds two values and pushes the result onto the evaluation stack.</source>
          <target state="translated">2 つの値を加算し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>58</source>
          <target state="translated">58</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Adds two numeric values, returning a new numeric value.</source>
          <target state="translated">2 つの数値があり、新しい数値を返すことを追加します。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value1`</ph>に追加<ph id="ph4">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Overflow is not detected for integer operations (for proper overflow handling, see <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add_Ovf&gt;</ph>).</source>
          <target state="translated">整数演算のオーバーフローが検出されない (適切なオーバーフロー処理では、次を参照してください。 <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add_Ovf&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Integer addition wraps, rather than saturates.</source>
          <target state="translated">整数の加算飽和するのではなく、ラップします。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>For example, assuming 8-bit integers where <ph id="ph1">`value1`</ph> is set to 255 and <ph id="ph2">`value2`</ph> is set to 1, the wrapped result is 0 rather than 256.</source>
          <target state="translated">たとえば、8 ビット整数値を想定して場所<ph id="ph1">`value1`</ph>255 に設定されていると<ph id="ph2">`value2`</ph>が設定されて、ラップされた結果は 256 ではなく 0 を 1 にします。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>Floating-point overflow returns <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) or <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</source>
          <target state="translated">浮動小数点オーバーフロー <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) または<ph id="ph3">`-inf`</ph>(<ph id="ph4">`NegativeInfinity`</ph>)。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">許容されるオペランドの型と、対応する結果のデータ型は、次の表に一覧表示されます。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</source>
          <target state="translated">特定の型の組み合わせのエントリがないかどうか (たとえば、<ph id="ph1">`int32`</ph>と<ph id="ph2">`float`</ph>です。<ph id="ph3">`int32`</ph>と<ph id="ph4">`int64`</ph>) を無効な Microsoft Intermediate Language (MSIL) であり、エラーが発生します。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>operand</source>
          <target state="translated">オペランド</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>value1 type</source>
          <target state="translated">value1 型</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>value2 type</source>
          <target state="translated">value2 型</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>result type</source>
          <target state="translated">結果の型</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`add`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">2 つの整数値を加算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>D6</source>
          <target state="translated">D6</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add.ovf</source>
          <target state="translated">add.ovf</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>Adds two signed integer values with an overflow check.</source>
          <target state="translated">2 つの符号付き整数値、オーバーフロー チェックを追加します。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value1`</ph>に追加<ph id="ph4">`value2`</ph>オーバーフローをチェックします。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>You can perform this operation on signed integers.</source>
          <target state="translated">符号付き整数で、この操作を実行することができます。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>For floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</source>
          <target state="translated">浮動小数点の値を使用して<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">許容されるオペランドの型と、対応する結果のデータ型は、次の表に一覧表示されます。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</source>
          <target state="translated">特定の型の組み合わせのエントリがないかどうか (たとえば、<ph id="ph1">`int32`</ph>と<ph id="ph2">`float`</ph>です。<ph id="ph3">`int32`</ph>と<ph id="ph4">`int64`</ph>)、Microsoft Intermediate Language (MSIL) の無効な命令であり、エラーが発生します。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>operand</source>
          <target state="translated">オペランド</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>value1 type</source>
          <target state="translated">value1 型</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>value2 type</source>
          <target state="translated">value2 型</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>result type</source>
          <target state="translated">結果の型</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add.ovf`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`add.ovf`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">2 つの符号なし整数値を加算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>D7</source>
          <target state="translated">D7</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add.ovf.un</source>
          <target state="translated">add.ovf.un</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>Adds two unsigned integer values with an overflow check.</source>
          <target state="translated">2 つの符号なし整数値、オーバーフロー チェックを追加します。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is added to <ph id="ph4">`value2`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value1`</ph>に追加<ph id="ph4">`value2`</ph>オーバーフローをチェックします。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result is not represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>You can perform this operation on signed integers.</source>
          <target state="translated">符号付き整数で、この操作を実行することができます。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>For floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>.</source>
          <target state="translated">浮動小数点の値を使用して<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Add&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The acceptable operand types and their corresponding result data type are listed in the table below.</source>
          <target state="translated">許容されるオペランドの型と、対応する結果のデータ型は、次の表に一覧表示されます。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>If there is no entry for a particular type combination (for example, <ph id="ph1">`int32`</ph> and <ph id="ph2">`float`</ph>; <ph id="ph3">`int32`</ph> and <ph id="ph4">`int64`</ph>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</source>
          <target state="translated">特定の型の組み合わせのエントリがないかどうか (たとえば、<ph id="ph1">`int32`</ph>と<ph id="ph2">`float`</ph>です。<ph id="ph3">`int32`</ph>と<ph id="ph4">`int64`</ph>)、Microsoft Intermediate Language (MSIL) の無効な命令であり、エラーが発生します。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>operand</source>
          <target state="translated">オペランド</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>value1 type</source>
          <target state="translated">value1 型</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>value2 type</source>
          <target state="translated">value2 型</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>result type</source>
          <target state="translated">結果の型</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>add</source>
          <target state="translated">追加</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`add.ovf.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`add.ovf.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</source>
          <target state="translated">2 つの値のビットごとの AND を計算し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Instruction</source>
          <target state="translated">命令</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>5F</source>
          <target state="translated">5F</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>and</source>
          <target state="translated">と、呼び出し</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>Determines the bitwise AND of two integer values.</source>
          <target state="translated">2 つの整数値のビットごとの AND を決定します。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`value1`</ph> and <ph id="ph2">`value2`</ph> are popped from the stack; the bitwise AND of the two values is computed.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> および<ph id="ph2">`value2`</ph>スタックからポップされます。 2 つの値のビットごとの AND を計算します。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The <ph id="ph1">`and`</ph> instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</source>
          <target state="translated"><ph id="ph1">`and`</ph>命令がスタックの上位 2 値のビットごとの AND を計算し、結果をスタックに残します。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source><ph id="ph1">`And`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`And`</ph> 整数固有操作です。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`and`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`and`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.And">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Returns an unmanaged pointer to the argument list of the current method.</source>
          <target state="translated">現在のメソッドの引数リストへのアンマネージ ポインターを返します。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>FE 00</source>
          <target state="translated">FE 00</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>arglist</source>
          <target state="translated">arglist</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>Returns an argument list handle for the current method.</source>
          <target state="translated">現在のメソッドの引数リスト ハンドルを返します。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">この操作では、評価スタックの動作は実行されません。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The <ph id="ph1">`arglist`</ph> instruction returns an opaque handle (an unmanaged pointer, of type <ph id="ph2">`native int`</ph>) that represents the argument list of the current method.</source>
          <target state="translated"><ph id="ph1">`arglist`</ph>命令の不透明なハンドルを返します (型のアンマネージ ポインター <ph id="ph2">`native int`</ph>) を表す、現在のメソッドの引数リスト。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>This handle is valid only during the lifetime of the current method.</source>
          <target state="translated">このハンドルは、現在のメソッドの有効期間中にのみ有効です。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>You can, however, pass the handle to other methods as long as the current method is on the thread of control.</source>
          <target state="translated">ただし、現在のメソッドがコントロールのスレッドである限り、ハンドルを他のメソッドを渡すことができます。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>You can only execute the <ph id="ph1">`arglist`</ph> instruction within a method that takes a variable number of arguments.</source>
          <target state="translated">のみを実行することができます、<ph id="ph1">`arglist`</ph>を可変個の引数を受け取るメソッド内の命令。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`arglist`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`arglist`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Arglist">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Transfers control to a target instruction if two values are equal.</source>
          <target state="translated">2 つの値が等しい場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>3B &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3B &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>beq <ph id="ph1">`target`</ph></source>
          <target state="translated">beq <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Branch to the target instruction at offset <ph id="ph1">`target`</ph> if the two values are equal.</source>
          <target state="translated">オフセットでターゲット命令にブランチ<ph id="ph1">`target`</ph>2 つの値が等しい場合。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>がと等しい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The <ph id="ph1">`beq`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`beq`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>と等しい<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The effect is the same as performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">実行すると同じ効果は、<ph id="ph1">`ceq`</ph>命令を実行して、<ph id="ph2">`brtrue`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The acceptable operand types are encapsulated below:</source>
          <target state="translated">以下は、許容されるオペランドの型がカプセル化します。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません (このような移動は厳しく制限されると、使用する必要があります、<ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph>命令代わりに)。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`beq`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`beq`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Transfers control to a target instruction (short form) if two values are equal.</source>
          <target state="translated">2 つの値が等しい場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>2E &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2E &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>beq.s <ph id="ph1">`target`</ph></source>
          <target state="translated">beq.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Branch to the target instruction at offset <ph id="ph1">`target`</ph> if equal, short form</source>
          <target state="translated">オフセットでターゲット命令にブランチ<ph id="ph1">`target`</ph>の場合、短い形式</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>がと等しい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The <ph id="ph1">`beq.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`beq.s`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>と等しい<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The effect is the same as performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">実行すると同じ効果は、<ph id="ph1">`ceq`</ph>命令を実行して、<ph id="ph2">`brtrue`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The acceptable operand types are encapsulated below:</source>
          <target state="translated">以下は、許容されるオペランドの型がカプセル化します。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction instead).</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません (このような移動は厳しく制限されると、使用する必要があります、<ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph>命令代わりに)。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`beq.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`beq.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Beq_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Transfers control to a target instruction if the first value is greater than or equal to the second value.</source>
          <target state="translated">最初の値が 2 番目の値以上の場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>3C <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">3C <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>bge <ph id="ph1">`target`</ph></source>
          <target state="translated">bge <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value.</source>
          <target state="translated">最初の値が 2 番目の値以上の場合は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>がより大きいまたは等しい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The <ph id="ph1">`bge`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`bge`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>がより大きいまたは等しい<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`clt.un`</ph>命令を実行して、<ph id="ph2">`brfalse`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`bge`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</source>
          <target state="translated">最初の値が 2 番目の値以上の場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>2F <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">2F <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>bge.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bge.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value, short form.</source>
          <target state="translated">最初の値がより大きいか等しい 2 番目の値では、短い形式の場合は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>がより大きいまたは等しい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The <ph id="ph1">`bge.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`bge.s`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>がより大きいまたは等しい<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`clt.un`</ph>命令を実行して、<ph id="ph2">`brfalse`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`bge.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>41 <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">41 <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>bge.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bge.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values).</source>
          <target state="translated">最初の値が 2 番目の値 (符号なしの値) 以上の場合は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>がより大きいまたは等しい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The <ph id="ph1">`bge.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bge.un`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>がより大きいまたは等しい<ph id="ph3">`value2`</ph>符号なし整数値または順序なし float 値を使って比較した場合、します。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`clt`</ph>命令を実行して、<ph id="ph2">`brfalse`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`bge.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>34 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">34 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>bge.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bge.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than or equal to the second value (unsigned values), short form.</source>
          <target state="translated">最初の値がより大きいか等しい 2 番目の値 (符号なしの値)、短い形式の場合は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>がより大きいまたは等しい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The <ph id="ph1">`bge.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bge.un.s`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>がより大きいまたは等しい<ph id="ph3">`value2`</ph>符号なし整数値または順序なし float 値を使って比較した場合、します。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`clt`</ph>命令を実行して、<ph id="ph2">`brfalse`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bge.un.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`bge.un.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bge_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Transfers control to a target instruction if the first value is greater than the second value.</source>
          <target state="translated">最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>3D &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3D &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>bgt <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value.</source>
          <target state="translated">最初の値が 2 番目の値より大きい場合、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>がより大きい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The <ph id="ph1">`bgt`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`bgt`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>がより大きい<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`cgt`</ph>命令を実行して、<ph id="ph2">`brtrue`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`bgt`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value.</source>
          <target state="translated">最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>30 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">30 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>bgt.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value, short form.</source>
          <target state="translated">最初の値が 2 番目の値では、短い形式よりも大きい場合は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>がより大きい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The <ph id="ph1">`bgt.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`bgt.s`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>がより大きい<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`cgt`</ph>命令を実行して、<ph id="ph2">`brtrue`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`bgt.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>42 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">42 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>bgt.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values).</source>
          <target state="translated">最初の値が 2 番目の値 (符号なしの値) より大きい場合、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>がより大きい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The <ph id="ph1">`bgt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bgt.un`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>がより大きい<ph id="ph3">`value2`</ph>符号なし整数値または順序なし float 値を使って比較した場合、します。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`cgt.un`</ph>命令を実行して、<ph id="ph2">`brtrue`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`bgt.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>35 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">35 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>bgt.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bgt.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is greater than the second value (unsigned values), short form.</source>
          <target state="translated">最初の値が 2 番目の値 (符号なしの値)、短縮形より大きい場合、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is greater than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>がより大きい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The <ph id="ph1">`bgt.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is greater than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bgt.un.s`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>がより大きい<ph id="ph3">`value2`</ph>符号なし整数値または順序なし float 値を使って比較した場合、します。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`cgt.un`</ph>命令を実行して、<ph id="ph2">`brtrue`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bgt.un.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`bgt.un.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bgt_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Transfers control to a target instruction if the first value is less than or equal to the second value.</source>
          <target state="translated">最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>3E <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">3E <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>ble <ph id="ph1">`target`</ph></source>
          <target state="translated">ble <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value.</source>
          <target state="translated">最初の値が 2 番目の値に等しいまたはそれよりも小さい場合は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>をと同じかそれよりも少ない<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The <ph id="ph1">`ble`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`ble`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>と同じかそれよりも少ない<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction (<ph id="ph2">`cgt.un`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`cgt`</ph>命令 (<ph id="ph2">`cgt.un`</ph>浮動小数点数の) 続けて、<ph id="ph3">`brfalse`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ble`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</source>
          <target state="translated">最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>31 <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">31 <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>ble.s <ph id="ph1">`target`</ph></source>
          <target state="translated">ble.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value, short form.</source>
          <target state="translated">最初の値が短い形式として、2 番目の値に等しいまたはそれよりも小さい場合は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>をと同じかそれよりも少ない<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The <ph id="ph1">`ble.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`ble.s`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>と同じかそれよりも少ない<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt`</ph> instruction (<ph id="ph2">`cgt.un`</ph> for floats) instruction followed by a<ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`cgt`</ph>命令 (<ph id="ph2">`cgt.un`</ph>浮動小数点数の) 命令を実行して、<ph id="ph3">`brfalse`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ble.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>43 <ph id="ph1">`&lt;int32&gt;`</ph></source>
          <target state="translated">43 <ph id="ph1">`&lt;int32&gt;`</ph></target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>ble.un <ph id="ph1">`target`</ph></source>
          <target state="translated">ble.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values).</source>
          <target state="translated">最初の値が 2 番目の値 (符号なしの値) に等しいまたはそれよりも小さい場合は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>をと同じかそれよりも少ない<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The <ph id="ph1">`ble.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`ble.un`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>と同じかそれよりも少ない<ph id="ph3">`value2`</ph>符号なし整数値または順序なし float 値を使って比較した場合、します。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction (<ph id="ph2">`cgt`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`cgt.un`</ph>命令 (<ph id="ph2">`cgt`</ph>浮動小数点数の) 続けて、<ph id="ph3">`brfalse`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ble.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>36 <ph id="ph1">`&lt;int8&gt;`</ph></source>
          <target state="translated">36 <ph id="ph1">`&lt;int8&gt;`</ph></target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>ble.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">ble.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than or equal to the second value (unsigned values), short form.</source>
          <target state="translated">最初の値が以下の 2 番目の値 (符号なしの値)、短い形式の場合は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than or equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>をと同じかそれよりも少ない<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The <ph id="ph1">`ble.un.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`ble.un.s`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>と同じかそれよりも少ない<ph id="ph3">`value2`</ph>符号なし整数値または順序なし float 値を使って比較した場合、します。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`cgt.un`</ph> instruction (<ph id="ph2">`cgt`</ph> for floats) followed by a <ph id="ph3">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`cgt.un`</ph>命令 (<ph id="ph2">`cgt`</ph>浮動小数点数の) 続けて、<ph id="ph3">`brfalse`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ble.un.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ble.un.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ble_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Transfers control to a target instruction if the first value is less than the second value.</source>
          <target state="translated">最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>3F &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3F &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>blt <ph id="ph1">`target`</ph></source>
          <target state="translated">blt <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value.</source>
          <target state="translated">2 番目の値より小さい場合は、最初の値は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>はより小さい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The <ph id="ph1">`blt`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than or equal to <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`blt`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>と同じかそれよりも少ない<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`clt`</ph>命令を実行して、<ph id="ph2">`brtrue`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`blt`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than the second value.</source>
          <target state="translated">最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>32 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">32 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>blt.s <ph id="ph1">`target`</ph></source>
          <target state="translated">blt.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value, short form.</source>
          <target state="translated">短い形式として、2 番目の値より小さい場合は、最初の値は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>はより小さい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The <ph id="ph1">`blt.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`blt.s`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>はより小さい<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`clt`</ph>命令を実行して、<ph id="ph2">`brtrue`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`blt.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>44 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">44 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>blt.un <ph id="ph1">`target`</ph></source>
          <target state="translated">blt.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values).</source>
          <target state="translated">2 番目の値 (符号なしの値) より小さい場合は、最初の値は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>はより小さい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The <ph id="ph1">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`blt.un`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>はより小さい<ph id="ph3">`value2`</ph>符号なし整数値または順序なし float 値を使って比較した場合、します。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`clt.un`</ph>命令を実行して、<ph id="ph2">`brtrue`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`blt.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</source>
          <target state="translated">符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>37 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">37 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>blt.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">blt.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Branch to the target instruction at the specified offset if the first value is less than the second value (unsigned values), short form.</source>
          <target state="translated">2 番目の値 (符号なしの値)、短縮形より小さい場合は、最初の値は、指定したオフセットでターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is less than <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>はより小さい<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The <ph id="ph1">`blt.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is less than <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`blt.un`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>はより小さい<ph id="ph3">`value2`</ph>符号なし整数値または順序なし float 値を使って比較した場合、します。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`clt.un`</ph> instruction followed by a <ph id="ph2">`brtrue`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`clt.un`</ph>命令を実行して、<ph id="ph2">`brtrue`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`blt.un.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`blt.un.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Blt_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</source>
          <target state="translated">2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>40 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">40 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>bne.un <ph id="ph1">`target`</ph></source>
          <target state="translated">bne.un <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values).</source>
          <target state="translated">分岐ターゲット命令は 2 つの符号なし整数値の場合は、指定したオフセットでは (符号なしの値) と等しくないです。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is not equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>は等しくありません<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The <ph id="ph1">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is not equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bne.un`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>は等しくありません<ph id="ph3">`value2`</ph>符号なし整数値または順序なし float 値を使って比較した場合、します。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The effect is identical to performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`ceq`</ph>命令を実行して、<ph id="ph2">`brfalse`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bne.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`bne.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</source>
          <target state="translated">2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>33 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">33 &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>bne.un.s <ph id="ph1">`target`</ph></source>
          <target state="translated">bne.un.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Branch to the target instruction at the specified offset if two unsigned integer values are not equal (unsigned values), short form.</source>
          <target state="translated">分岐ターゲットに 2 つの符号なし整数値の場合は、指定したオフセットで命令は、されません (符号なしの値) と等しく、短縮形です。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; if <ph id="ph3">`value1`</ph> is not equal to <ph id="ph4">`value2`</ph>, the branch operation is performed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>場合、スタックからポップされます。<ph id="ph3">`value1`</ph>は等しくありません<ph id="ph4">`value2`</ph>、分岐操作を実行します。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The <ph id="ph1">`bne.un`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value1`</ph> is not equal to <ph id="ph3">`value2`</ph>, when compared using unsigned integer or unordered float values.</source>
          <target state="translated"><ph id="ph1">`bne.un`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value1`</ph>は等しくありません<ph id="ph3">`value2`</ph>符号なし整数値または順序なし float 値を使って比較した場合、します。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The effect is identical to performing a <ph id="ph1">`ceq`</ph> instruction followed by a <ph id="ph2">`brfalse`</ph> branch to the specific target instruction.</source>
          <target state="translated">この効果を実行するため、<ph id="ph1">`ceq`</ph>命令を実行して、<ph id="ph2">`brfalse`</ph>特定のターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`bne.un.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`bne.un.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Bne_Un_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Converts a value type to an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>).</source>
          <target state="translated">値型をオブジェクト参照 (<ph id="ph1">&lt;see langword="O" /&gt;</ph> 型) に変換します。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>8C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>box <ph id="ph1">`valTypeToken`</ph></source>
          <target state="translated">box <ph id="ph1">`valTypeToken`</ph></target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>Convert a value type (of the type specified in <ph id="ph1">`valTypeToken`</ph>) to a true object reference.</source>
          <target state="translated">値の型に変換 (で指定された型の<ph id="ph1">`valTypeToken`</ph>) を真のオブジェクト参照にします。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A value type is pushed onto the stack.</source>
          <target state="translated">値の型は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The value type is popped from the stack; the <ph id="ph1">`box`</ph> operation is performed.</source>
          <target state="translated">値の型がスタックからポップされます。<ph id="ph1">`box`</ph>操作を実行します。</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>An object reference to the resulting "boxed" value type is pushed onto the stack.</source>
          <target state="translated">結果として得られる「ボックス化された」の値の型にオブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A value type has two separate representations within the Common Language Infrastructure (CLI):</source>
          <target state="translated">値型は、2 つの独立した表現内で共通言語基盤 (CLI) には。</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A 'raw' form used when a value type is embedded within another object or on the stack.</source>
          <target state="translated">値の型が別のオブジェクト、スタックの上に埋め込まれている場合に使用される '生' のフォームです。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</source>
          <target state="translated">ここで値の型のデータがラップされる (のボックス化された) オブジェクトのため、個別のエンティティとして存在する可能性が 'ボックス化' の形式です。</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The <ph id="ph1">`box`</ph> instruction converts the 'raw' (unboxed) value type into an object reference (type <ph id="ph2">`O`</ph>).</source>
          <target state="translated"><ph id="ph1">`box`</ph>命令は、オブジェクト参照に '生' の (ボックス化解除された) 値の型を変換 (型<ph id="ph2">`O`</ph>)。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>This is accomplished by creating a new object and copying the data from the value type into the newly allocated object.</source>
          <target state="translated">これは、新しいオブジェクトを作成し、新しく割り当てられたオブジェクトに値の型からデータをコピーして行います。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">`valTypeToken`</ph> is a metadata token indicating the type of the value type on the stack.</source>
          <target state="translated"><ph id="ph1">`valTypeToken`</ph> スタックに値型の型をメタデータ トークンを示すです。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> メモリ不足のため、要求を満たす場合にスローされます。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> クラスが見つからない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) が実行時ではなく、ネイティブ コードに変換されるときに検出します。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`box`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`box`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Box">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Unconditionally transfers control to a target instruction.</source>
          <target state="translated">無条件でターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>38 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">38 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>br <ph id="ph1">`target`</ph></source>
          <target state="translated">ブラジル <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Branches to a target instruction at the specified offset.</source>
          <target state="translated">指定したオフセットで、ターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">この操作では、評価スタックの動作は実行されません。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The <ph id="ph1">`br`</ph> instruction unconditionally transfers control to a target instruction.</source>
          <target state="translated"><ph id="ph1">`br`</ph>命令は無条件でターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`br`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`br`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Unconditionally transfers control to a target instruction (short form).</source>
          <target state="translated">無条件でターゲット命令に制御を転送します (短い形式)。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>2B &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2B &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>br.s <ph id="ph1">`target`</ph></source>
          <target state="translated">br.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Branches to a target instruction at the specified offset, short form.</source>
          <target state="translated">短い形式として、指定したオフセットで、ターゲット命令に分岐します。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">この操作では、評価スタックの動作は実行されません。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The <ph id="ph1">`br.s`</ph> instruction unconditionally transfers control to a target instruction.</source>
          <target state="translated"><ph id="ph1">`br.s`</ph>命令は無条件でターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`br.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`br.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Br_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</source>
          <target state="translated">ブレークポイントがトリップしたことをデバッガーに通知するように、共通言語基盤 (CLI) に通知します。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>01</source>
          <target state="translated">01</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>break</source>
          <target state="translated">break</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>inform a debugger that a breakpoint has been reached.</source>
          <target state="translated">ブレークポイントに達していることをデバッガーに通知します。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>No evaluation stack behaviors are performed by this operation.</source>
          <target state="translated">この操作では、評価スタックの動作は実行されません。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction is for debugging support.</source>
          <target state="translated"><ph id="ph1">`break`</ph>命令はデバッグをサポートします。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>It signals the CLI to inform the debugger that a break point has been tripped.</source>
          <target state="translated">ブレークポイントがトリップしたことをデバッガーに通知するために、CLI を通知します。</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>It has no other effect on the interpreter state.</source>
          <target state="translated">インタープリターの状態には、その他の影響を与えません。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</source>
          <target state="translated"><ph id="ph1">`break`</ph>命令にはコードが含まれて、最小命令にはサイズには有効にすると、中断ポイントと修正プログラムの適用を前後のコードを最小限が生成されます。</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The <ph id="ph1">`break`</ph> instruction can trap to a debugger, do nothing, or raise a security exception.</source>
          <target state="translated"><ph id="ph1">`break`</ph>命令は、デバッガーにトラップ、何もしない、またはセキュリティ例外が発生します。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The exact behavior is implementation-defined.</source>
          <target state="translated">実際の動作では、実装定義されます。</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`break`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`break`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Break">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="false" /&gt;</ph>, a null reference (<ph id="ph3">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> が <ph id="ph2">&lt;see langword="false" /&gt;</ph>、null 参照 (Visual Basic の場合は <ph id="ph3">&lt;see langword="Nothing" /&gt;</ph>)、または 0 の場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>39 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">39 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brfalse <ph id="ph1">`target`</ph></source>
          <target state="translated">brfalse <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brnull <ph id="ph1">`target`</ph></source>
          <target state="translated">brnull <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>brzero <ph id="ph1">`target`</ph></source>
          <target state="translated">brzero <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Branches to a target instruction at the specified offset if <ph id="ph1">`false`</ph>.</source>
          <target state="translated">場合は、指定したオフセットでターゲット命令に分岐<ph id="ph1">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> 前の操作によってスタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`false`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックからポップされます。場合<ph id="ph2">`value`</ph>は<ph id="ph3">`false`</ph>、分岐<ph id="ph4">`target`</ph>です。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The <ph id="ph1">`brfalse`</ph> instruction (and its aliases <ph id="ph2">`brnull`</ph> and <ph id="ph3">`brzero`</ph>) transfers control to the specified target instruction if <ph id="ph4">`value`</ph> (of type <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, object reference <ph id="ph7">`O`</ph>, managed pointer <ph id="ph8">`&amp;`</ph>, transient pointer <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) is zero (<ph id="ph11">`false`</ph>).</source>
          <target state="translated"><ph id="ph1">`brfalse`</ph>命令 (とそのエイリアス<ph id="ph2">`brnull`</ph>と<ph id="ph3">`brzero`</ph>) 場合は、指定したターゲット命令に制御を移します<ph id="ph4">`value`</ph>(型の<ph id="ph5">`int32`</ph>、 <ph id="ph6">`int64`</ph>、オブジェクト参照<ph id="ph7">`O`</ph>、マネージ ポインター <ph id="ph8">`&amp;`</ph>、一時的なポインター <ph id="ph9">`*`</ph>、 <ph id="ph10">`native int`</ph>) ゼロ (<ph id="ph11">`false`</ph>)。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>If <ph id="ph1">`value`</ph> is non-zero (<ph id="ph2">`true`</ph>) execution continues at the next instruction.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>ゼロ以外 (<ph id="ph2">`true`</ph>) 次の命令で実行が続行します。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brfalse`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`brfalse`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="false" /&gt;</ph>, a null reference, or zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> が <ph id="ph2">&lt;see langword="false" /&gt;</ph>、null 参照または 0 の場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>2C &lt;<ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2C &lt;<ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brfalse.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brfalse.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brnull.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brnull.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>brzero.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brzero.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Branches to a target instruction at the specified offset if <ph id="ph1">`false`</ph>, short form.</source>
          <target state="translated">場合は、指定したオフセットでターゲット命令に分岐<ph id="ph1">`false`</ph>、短縮形です。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> 前の操作によってスタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`false`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックからポップされます。場合<ph id="ph2">`value`</ph>は<ph id="ph3">`false`</ph>、分岐<ph id="ph4">`target`</ph>です。</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The <ph id="ph1">`brfalse.s`</ph> instruction (and its aliases <ph id="ph2">`brnull`</ph> and <ph id="ph3">`brzero`</ph>) transfers control to the specified target instruction if <ph id="ph4">`value`</ph> (of type <ph id="ph5">`int32`</ph>, <ph id="ph6">`int64`</ph>, object reference <ph id="ph7">`O`</ph>, managed pointer <ph id="ph8">`&amp;`</ph>, transient pointer <ph id="ph9">`*`</ph>, <ph id="ph10">`native int`</ph>) is zero (<ph id="ph11">`false`</ph>).</source>
          <target state="translated"><ph id="ph1">`brfalse.s`</ph>命令 (とそのエイリアス<ph id="ph2">`brnull`</ph>と<ph id="ph3">`brzero`</ph>) 場合は、指定したターゲット命令に制御を移します<ph id="ph4">`value`</ph>(型の<ph id="ph5">`int32`</ph>、 <ph id="ph6">`int64`</ph>、オブジェクト参照<ph id="ph7">`O`</ph>、マネージ ポインター <ph id="ph8">`&amp;`</ph>、一時的なポインター <ph id="ph9">`*`</ph>、 <ph id="ph10">`native int`</ph>) ゼロ (<ph id="ph11">`false`</ph>)。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>If <ph id="ph1">`value`</ph> is non-zero (<ph id="ph2">`true`</ph>) execution continues at the next instruction.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>ゼロ以外 (<ph id="ph2">`true`</ph>) 次の命令で実行が続行します。</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brfalse.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`brfalse.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brfalse_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Transfers control to a target instruction if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, not null, or non-zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph>、null 以外、または 0 以外の場合は、ターゲット命令に制御を転送します。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>3A &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">3A &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>brtrue <ph id="ph1">`target`</ph></source>
          <target state="translated">brtrue <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>brinst <ph id="ph1">`target`</ph></source>
          <target state="translated">brinst <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Branch to a target instruction at the specified offset if non-zero (<ph id="ph1">`true`</ph>).</source>
          <target state="translated">0 以外の場合は、指定したオフセットで、ターゲット命令に分岐 (<ph id="ph1">`true`</ph>)。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> 前の操作によってスタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`true`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックからポップされます。場合<ph id="ph2">`value`</ph>は<ph id="ph3">`true`</ph>、分岐<ph id="ph4">`target`</ph>です。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The <ph id="ph1">`brtrue`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value`</ph> (type <ph id="ph3">`native int`</ph>) is nonzero (<ph id="ph4">`true`</ph>).</source>
          <target state="translated"><ph id="ph1">`brtrue`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value`</ph>(型<ph id="ph3">`native int`</ph>) がゼロ以外 (<ph id="ph4">`true`</ph>)。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If <ph id="ph1">`value`</ph> is zero (<ph id="ph2">`false`</ph>) execution continues at the next instruction.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>ゼロ (<ph id="ph2">`false`</ph>) 次の命令で実行が続行します。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If <ph id="ph1">`value`</ph> is an object reference (type <ph id="ph2">`O`</ph>) then <ph id="ph3">`brinst`</ph> (an alias for <ph id="ph4">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>オブジェクト参照 (型<ph id="ph2">`O`</ph>) し、 <ph id="ph3">`brinst`</ph> (のエイリアスを<ph id="ph4">`brtrue`</ph>) を表している場合、オブジェクトのインスタンスに制御を転送する (たとえば、見つからなかった場合は、null オブジェクト参照を参照してください<ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brtrue`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`brtrue`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Transfers control to a target instruction (short form) if <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph>, not null, or non-zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> が <ph id="ph2">&lt;see langword="true" /&gt;</ph>、null 以外、または 0 以外の場合は、ターゲット命令 (短い形式) に制御を転送します。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>2D &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">2D &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>brtrue.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brtrue.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>brinst.s <ph id="ph1">`target`</ph></source>
          <target state="translated">brinst.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Branch to a target instruction at the specified offset if non-zero (<ph id="ph1">`true`</ph>), short form.</source>
          <target state="translated">0 以外の場合は、指定したオフセットで、ターゲット命令に分岐 (<ph id="ph1">`true`</ph>)、短縮形です。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack by a previous operation.</source>
          <target state="translated"><ph id="ph1">`value`</ph> 前の操作によってスタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source><ph id="ph1">`value`</ph> is popped from the stack; if <ph id="ph2">`value`</ph> is <ph id="ph3">`true`</ph>, branch to <ph id="ph4">`target`</ph>.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックからポップされます。場合<ph id="ph2">`value`</ph>は<ph id="ph3">`true`</ph>、分岐<ph id="ph4">`target`</ph>です。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The <ph id="ph1">`brtrue.s`</ph> instruction transfers control to the specified target instruction if <ph id="ph2">`value`</ph> (type <ph id="ph3">`native int`</ph>) is nonzero (<ph id="ph4">`true`</ph>).</source>
          <target state="translated"><ph id="ph1">`brtrue.s`</ph>命令が場合に、指定したターゲット命令に制御を転送<ph id="ph2">`value`</ph>(型<ph id="ph3">`native int`</ph>) がゼロ以外 (<ph id="ph4">`true`</ph>)。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If <ph id="ph1">`value`</ph> is zero (<ph id="ph2">`false`</ph>) execution continues at the next instruction.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>ゼロ (<ph id="ph2">`false`</ph>) 次の命令で実行が続行します。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If <ph id="ph1">`value`</ph> is an object reference (type <ph id="ph2">`O`</ph>) then <ph id="ph3">`brinst`</ph> (an alias for <ph id="ph4">`brtrue`</ph>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>).</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>オブジェクト参照 (型<ph id="ph2">`O`</ph>) し、 <ph id="ph3">`brinst`</ph> (のエイリアスを<ph id="ph4">`brtrue`</ph>) を表している場合、オブジェクトのインスタンスに制御を転送する (たとえば、見つからなかった場合は、null オブジェクト参照を参照してください<ph id="ph5">&lt;xref:System.Reflection.Emit.OpCodes.Ldnull&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated">ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`brtrue.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`brtrue.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Brtrue_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Calls the method indicated by the passed method descriptor.</source>
          <target state="translated">渡されたメソッド記述子によって示されているメソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>28 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">28 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>call <ph id="ph1">`methodDesc`</ph></source>
          <target state="translated">呼び出し <ph id="ph1">`methodDesc`</ph></target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Call the method described by <ph id="ph1">`methodDesc`</ph>.</source>
          <target state="translated">により記述されたメソッドを呼び出す<ph id="ph1">`methodDesc`</ph>です。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">メソッドの引数<ph id="ph1">`arg1`</ph>を通じて<ph id="ph2">`argN`</ph>スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor.</source>
          <target state="translated">メソッドの引数<ph id="ph1">`arg1`</ph>を通じて<ph id="ph2">`argN`</ph>スタックからポップされます。 これらの引数で、メソッドの呼び出しが行われるとメソッド記述子によって参照されるメソッドに制御が移ります。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">完了したら、戻り値は、呼び出し先のメソッドによって生成され、呼び出し元に送信します。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">戻り値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">`call`</ph> instruction calls the method indicated by the method descriptor passed with the instruction.</source>
          <target state="translated"><ph id="ph1">`call`</ph>命令は、命令と共に渡されたメソッド記述子によって指定されているメソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used.</source>
          <target state="translated">メソッドの記述子は、メソッド呼び出しと数、種類、および使用する呼び出し規約と同様にそのメソッドに渡されるスタックに配置されている引数の順序を示すメタデータ トークンです。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">`call`</ph> instruction can be immediately preceded by a <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix instruction to specify that the current method state should be released before transferring control.</source>
          <target state="translated"><ph id="ph1">`call`</ph>命令のすぐ前に、 <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) メソッドの現在の状態が制御を転送する前に解放することを指定する命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>If the call transfers control to a method of higher trust than the origin method, the stack frame is not released.</source>
          <target state="translated">呼び出しは、元のメソッドより信頼性の高いメソッドに制御を転送、スタック フレームは解放されません。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Instead, the execution continues silently as if the <ph id="ph1">`tail`</ph> had not been supplied.</source>
          <target state="translated">代わりに、実行が継続として、<ph id="ph1">`tail`</ph>が指定されていません。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function.</source>
          <target state="translated">メタデータ トークンには、呼び出しが静的メソッド、インスタンス メソッド、仮想メソッドまたはグローバル関数かどうかを決定するための十分な情報です。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>).</source>
          <target state="translated">送信先アドレスはメソッドの記述子から判断これらすべての場合 (とこれに対し、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>命令は、宛先アドレスもインスタンスの参照のランタイムの型によって異なります。 仮想メソッドを呼び出す前に、プッシュ、 <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">引数は、左から右の順序でスタックに配置されます。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">つまり、最初の引数が計算され、すべての必要な引数は、降順でスタックの一番上まで、スタックし、2 番目の引数、3 番目に配置されます。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>There are three important special cases:</source>
          <target state="translated">これには次の 3 つの重要な特殊なケースがあります。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments.</source>
          <target state="translated">呼び出しインスタンス (または仮想) メソッドが任意のユーザーに表示される引数の前にそのインスタンスの参照をプッシュする必要があります。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The instance reference must not be a null reference.</source>
          <target state="translated">インスタンス参照では、null 参照をすることはできません。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The signature carried in the metadata does not contain an entry in the parameter list for the <ph id="ph1">`this`</ph> pointer; instead, it uses a bit to indicate whether the method requires passing the <ph id="ph2">`this`</ph> pointer.</source>
          <target state="translated">メタデータに送られるシグネチャのパラメーター リスト内のエントリを含まない、<ph id="ph1">`this`</ph>ポインターです。 代わりに、メソッドに渡すことが必要かどうかを示すために、ビットを使用して、<ph id="ph2">`this`</ph>ポインター。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>It is valid to call a virtual method using <ph id="ph1">`call`</ph> (rather than <ph id="ph2">`callvirt`</ph>); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</source>
          <target state="translated">使用して、仮想メソッドの呼び出しは無効である<ph id="ph1">`call`</ph>(なく<ph id="ph2">`callvirt`</ph>) です。 これは、メソッドが呼び出されているオブジェクトから動的に指定ではなく、メソッドによって指定されたクラスを使用して解決することを示します。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Note that a delegate's <ph id="ph1">`Invoke`</ph> method can be called with either the <ph id="ph2">`call`</ph> or <ph id="ph3">`callvirt`</ph> instruction.</source>
          <target state="translated">なおデリゲートの<ph id="ph1">`Invoke`</ph>いずれかでメソッドを呼び出すことができます、<ph id="ph2">`call`</ph>または<ph id="ph3">`callvirt`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> システムのセキュリティは、呼び出されたメソッドを呼び出し元アクセスを許可していない場合にスローされる可能性がします。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</source>
          <target state="translated">セキュリティ チェックは、Microsoft Intermediate Language (MSIL) の手順が実行時ではなくネイティブ コードに変換された場合に発生する可能性があります。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>When calling methods of System.Object on value types, consider using the <ph id="ph1">`constrained`</ph> prefix with the <ph id="ph2">`callvirt`</ph> instruction instead of emitting a <ph id="ph3">`call`</ph> instruction.</source>
          <target state="translated">値型で System.Object のメソッドを呼び出すときに、使用を検討して、<ph id="ph1">`constrained`</ph>プレフィックス、<ph id="ph2">`callvirt`</ph>命令の出力ではなく、<ph id="ph3">`call`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</source>
          <target state="translated">これにより、潜在的なバージョン管理の問題を回避する値の型がメソッドをオーバーライドするかどうかに応じて異なる IL を生成する必要があるされます。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Consider using the <ph id="ph1">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated">使用を検討して、<ph id="ph1">`constrained`</ph>を使用してメソッドを呼び出すとき、値の型のインターフェイス メソッドので、値型インターフェイス メソッドの実装のプレフィックスを変更することができます、<ph id="ph2">`MethodImpl`</ph>です。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>These issues are described in more detail in the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</source>
          <target state="translated">これらの問題がで詳しく説明されている、 <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode です。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`call`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードを使用できる、<ph id="ph2">`call`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、MethodInfo)</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</source>
          <target state="translated">ILGenerator.EmitCall (オペコード、MethodInfo、Type[])</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCall%2A&gt;</ph> method is provided for <ph id="ph2">`varargs`</ph> calls.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCall%2A&gt;</ph>のメソッドが用意されて<ph id="ph2">`varargs`</ph>呼び出しです。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Call">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method for normal calls.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>標準呼び出しのメソッドです。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</source>
          <target state="translated">呼び出し規則によって記述されている引数を使用して、評価スタックで (エントリ ポイントへのポインターとして) 指定されているメソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>29 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">29 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>calli <ph id="ph1">`callSiteDescr`</ph></source>
          <target state="translated">calli <ph id="ph1">`callSiteDescr`</ph></target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Calls the method pointed to with arguments described by the calling convention.</source>
          <target state="translated">呼び出し規約によって記述されている引数を指すメソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">メソッドの引数<ph id="ph1">`arg1`</ph>を通じて<ph id="ph2">`argN`</ph>スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The method entry pointer is pushed onto the stack.</source>
          <target state="translated">メソッドのエントリのポインターは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> and the method entry pointer are popped from the stack; the call to the method is performed.</source>
          <target state="translated">メソッドの引数<ph id="ph1">`arg1`</ph>を通じて<ph id="ph2">`argN`</ph>とメソッドのエントリのポインターは、スタックからポップされます。 以外の場合は、メソッドの呼び出しを実行します。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">完了したら、戻り値は、呼び出し先のメソッドによって生成され、呼び出し元に送信します。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">戻り値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The <ph id="ph1">`calli`</ph> instruction calls the method entry pointer with the arguments <ph id="ph2">`arg1`</ph> through <ph id="ph3">`argN`</ph>.</source>
          <target state="translated"><ph id="ph1">`calli`</ph>命令は、引数を持つメソッドのエントリのポインターを呼び出します<ph id="ph2">`arg1`</ph>を通じて<ph id="ph3">`argN`</ph>です。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The types of these arguments are described by the specific calling convention (<ph id="ph1">`callSiteDesc`</ph>).</source>
          <target state="translated">これらの引数の型は、特定の呼び出し規約によって記述されます (<ph id="ph1">`callSiteDesc`</ph>)。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The <ph id="ph1">`calli`</ph> instruction may be immediately preceded by a <ph id="ph2">`tail`</ph> prefix (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) to specify that the current method state should be released before transferring control.</source>
          <target state="translated"><ph id="ph1">`calli`</ph>命令ではすぐに付くことがあります、<ph id="ph2">`tail`</ph>プレフィックス (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) を現在のメソッドの状態が制御を転送する前に解放することを指定します。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the <ph id="ph1">`tail`</ph> had not been supplied.</source>
          <target state="translated">呼び出しが転送される場合、元のメソッド、スタック フレームより信頼性の高いメソッドに制御は解放されません。代わりに、実行が継続されますよう、<ph id="ph1">`tail`</ph>が指定されていません。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature).</source>
          <target state="translated">メソッドのエントリのポインターは、呼び出し規約 (スタンドアロン シグネチャのメタデータ トークン) で説明されている引数で正規に呼び出すことができる (ターゲット コンピューター) のネイティブ コードに特定のポインターであると見なされます。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Such a pointer can be created using the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldftn&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldvirtftn&gt;</ph> instructions, or passed in from native code.</source>
          <target state="translated">使用してこのようなポインターを作成することができます、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldftn&gt;</ph>または<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldvirtftn&gt;</ph>手順については、ネイティブ コードから渡されたか。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The calling convention is not checked dynamically, so code that uses a <ph id="ph1">`calli`</ph> instruction does not work correctly if the destination does not actually use the specified calling convention.</source>
          <target state="translated">呼び出し規約が動的にチェックされませんが、これを使用するコード、<ph id="ph1">`calli`</ph>実際には、先に指定した呼び出し規約が使用していない場合、命令が正常に動作しません。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">引数は、左から右の順序でスタックに配置されます。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">つまり、最初の引数が計算され、すべての必要な引数は、降順でスタックの一番上まで、スタックし、2 番目の引数、3 番目に配置されます。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</source>
          <target state="translated">インスタンスまたは仮想メソッドの引数構築コード シーケンスは、任意のユーザーに表示される引数の前に、そのインスタンス参照 (参照を null することはできません) をプッシュする必要があります。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> may be thrown if the system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> システムのセキュリティは、呼び出されたメソッドを呼び出し元アクセスを許可していない場合にスローされる可能性がします。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">セキュリティ チェックは、Microsoft Intermediate Language (MSIL) の手順が実行時ではなくネイティブ コードに変換された場合に発生することができます。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A&gt;</ph> methods can be used to perform a <ph id="ph2">`calli`</ph> instruction on the stack.</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A&gt;</ph>を実行するメソッドを使用することができます、<ph id="ph2">`calli`</ph>スタックに命令します。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>Note that <ph id="ph1">`calli`</ph> should be called through the below methods rather than using the <ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> class to place the instruction directly on the stack.</source>
          <target state="translated">なお<ph id="ph1">`calli`</ph>を介して呼び出す必要がありますを使用するのではなく、メソッドの下、<ph id="ph2">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>スタック上で直接、命令を配置するクラス。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</source>
          <target state="translated">ILGenerator.EmitCalli (オペコード、CallingConventions、種類は、マネージ呼び出し規約を使用して、呼び出しの Type[]) を入力します。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Calli">
          <source>ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</source>
          <target state="translated">ILGenerator.EmitCalli (オペコード、アンマネージ呼び出し規約を使用して、呼び出しの CallingConvention、型、Type[]) です。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</source>
          <target state="translated">オブジェクト上で遅延バインディング メソッドを呼び出し、戻り値を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>6F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">6F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>callvirt <ph id="ph1">`method`</ph></source>
          <target state="translated">callvirt <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Calls a specific method associated with <ph id="ph1">`obj`</ph>.</source>
          <target state="translated">関連付けられている特定のメソッドを呼び出して<ph id="ph1">`obj`</ph>です。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>An object reference <ph id="ph1">`obj`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`obj`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack.</source>
          <target state="translated">メソッドの引数<ph id="ph1">`arg1`</ph>を通じて<ph id="ph2">`argN`</ph>スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> and the object reference <ph id="ph3">`obj`</ph> are popped from the stack; the method call is performed with these arguments and control is transferred to the method in <ph id="ph4">`obj`</ph> referred to by the method metadata token.</source>
          <target state="translated">メソッドの引数<ph id="ph1">`arg1`</ph>を通じて<ph id="ph2">`argN`</ph>とオブジェクト参照<ph id="ph3">`obj`</ph>スタックからポップされます。 これらの引数で、メソッドの呼び出しが行われると、メソッドに制御が移ります<ph id="ph4">`obj`</ph>メソッドのメタデータ トークンによって参照されます。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>When complete, a return value is generated by the callee method and sent to the caller.</source>
          <target state="translated">完了したら、戻り値は、呼び出し先のメソッドによって生成され、呼び出し元に送信します。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The return value is pushed onto the stack.</source>
          <target state="translated">戻り値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The <ph id="ph1">`callvirt`</ph> instruction calls a late-bound method on an object.</source>
          <target state="translated"><ph id="ph1">`callvirt`</ph>命令がオブジェクトで遅延バインディング メソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>That is, the method is chosen based on the runtime type of <ph id="ph1">`obj`</ph> rather than the compile-time class visible in the method pointer.</source>
          <target state="translated">つまり、メソッドのランタイムの型に基づいて選択<ph id="ph1">`obj`</ph>メソッド ポインターで参照できるコンパイル クラスではなくです。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">`Callvirt`</ph> can be used to call both virtual and instance methods.</source>
          <target state="translated"><ph id="ph1">`Callvirt`</ph> 仮想両方を呼び出すし、インスタンス メソッドを使用できます。</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The <ph id="ph1">`callvirt`</ph> instruction may be immediately preceded by a <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) prefix to specify that the current stack frame should be released before transferring control.</source>
          <target state="translated"><ph id="ph1">`callvirt`</ph>命令ではすぐに付くことがあります、 <ph id="ph2">`tail`</ph> (<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Tailcall&gt;</ph>) プレフィックスを制御を転送する前に、現在のスタック フレームを解放することを指定します。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</source>
          <target state="translated">呼び出しが転送される場合、スタック フレームの元のメソッドよりも信頼性の高いメソッドに制御は解放されません。</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The method metadata token provides the name, class and signature of the method to call.</source>
          <target state="translated">メソッドのメタデータ トークンは、クラスの名前とシグネチャに呼び出すメソッドを提供します。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The class associated with <ph id="ph1">`obj`</ph> is the class of which it is an instance.</source>
          <target state="translated">関連付けられたクラス<ph id="ph1">`obj`</ph>インスタンスがクラスです。</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the class defines a non-static method that matches the indicated method name and signature, this method is called.</source>
          <target state="translated">クラスには、示されたメソッドの名前とシグネチャに一致する非静的メソッドが定義されている場合は、このメソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Otherwise all classes in the base class chain of this class are checked in order.</source>
          <target state="translated">それ以外の場合、このクラスの基底クラスのチェーンのすべてのクラスは順番にチェックします。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>It is an error if no method is found.</source>
          <target state="translated">メソッドが見つからない場合は、エラーになります。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">`Callvirt`</ph> pops the object and the associated arguments off the evaluation stack before calling the method.</source>
          <target state="translated"><ph id="ph1">`Callvirt`</ph> メソッドを呼び出す前に、オブジェクトと関連付けられている引数を評価スタックからをポップします。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>If the method has a return value, it is pushed on the stack upon method completion.</source>
          <target state="translated">メソッドの戻り値の場合は、メソッドの完了時にスタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>On the callee side, the <ph id="ph1">`obj`</ph> parameter is accessed as argument 0, <ph id="ph2">`arg1`</ph> as argument 1, and so on.</source>
          <target state="translated">呼び出し側に、<ph id="ph1">`obj`</ph>パラメーターが 0 の引数としてアクセス<ph id="ph2">`arg1`</ph>として引数 1 というようにします。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The arguments are placed on the stack in left-to-right order.</source>
          <target state="translated">引数は、左から右の順序でスタックに配置されます。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order.</source>
          <target state="translated">つまり、最初の引数が計算され、すべての必要な引数は、降順でスタックの一番上まで、スタックし、2 番目の引数、3 番目に配置されます。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The instance reference <ph id="ph1">`obj`</ph> (always required for <ph id="ph2">`callvirt`</ph>) must be pushed before any of the user-visible arguments.</source>
          <target state="translated">インスタンス参照<ph id="ph1">`obj`</ph>(常に必要な<ph id="ph2">`callvirt`</ph>) 任意のユーザーに表示される引数の前にプッシュする必要があります。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</source>
          <target state="translated">(メタデータ トークンに含まれる)、署名含める必要はありません、パラメーター リスト内のエントリをこのポインター。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Note that a virtual method can also be called using the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.</source>
          <target state="translated">仮想メソッドできますも呼び出すことを使用して、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>命令します。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with <ph id="ph2">`obj`</ph> or any of its base classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> 関連付けられているクラスで指定された名前およびシグネチャを持つ非静的メソッドが見つかりませんだった場合にスローされる<ph id="ph2">`obj`</ph>またはその基本クラスのいずれか。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) 命令が実行時ではなく、ネイティブ コードに変換されるときに検出します。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if obj is null.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> obj が null の場合にスローされます。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> is thrown if system security does not grant the caller access to the called method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> システムのセキュリティは、呼び出されたメソッドを呼び出し元アクセスを許可していない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The security check may occur when the CIL is converted to native code rather than at run time.</source>
          <target state="translated">セキュリティ チェックは、CIL が実行時ではなくネイティブ コードに変換されるときに発生する可能性があります。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>When calling methods of System.Object on value types, consider using the <ph id="ph1">`constrained`</ph> prefix with the <ph id="ph2">`callvirt`</ph> instruction.</source>
          <target state="translated">値型で System.Object のメソッドを呼び出すときに、使用を検討して、<ph id="ph1">`constrained`</ph>プレフィックス、<ph id="ph2">`callvirt`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem.</source>
          <target state="translated">これにより、潜在的なバージョン管理の問題を回避する値の型がメソッドをオーバーライドするかどうかに応じて異なる IL を生成する必要があるされます。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>Consider using the <ph id="ph1">`constrained`</ph> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated">使用を検討して、<ph id="ph1">`constrained`</ph>を使用してメソッドを呼び出すとき、値の型のインターフェイス メソッドので、値型インターフェイス メソッドの実装のプレフィックスを変更することができます、<ph id="ph2">`MethodImpl`</ph>です。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>These issues are described in more detail in the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode.</source>
          <target state="translated">これらの問題がで詳しく説明されている、 <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Constrained&gt;</ph> opcode です。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`callvirt`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`callvirt`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、MethodInfo)</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Callvirt">
          <source>ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</source>
          <target state="translated">ILGenerator.EmitCall (オペコード、MethodInfo、Type[])</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Attempts to cast an object passed by reference to the specified class.</source>
          <target state="translated">指定したクラスへの参照により渡されたオブジェクトをキャストしようとします。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>74 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">74 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>castclass <ph id="ph1">`class`</ph></source>
          <target state="translated">castclass <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>Casts an object to a new object of type <ph id="ph1">`class`</ph>.</source>
          <target state="translated">型の新しいオブジェクトにキャスト<ph id="ph1">`class`</ph>です。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The object reference is popped from the stack; the referenced object is cast as the specified <ph id="ph1">`class`</ph>.</source>
          <target state="translated">オブジェクト参照がスタックからポップされます。参照先オブジェクトにキャストは、指定された<ph id="ph1">`class`</ph>です。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If successful, a new object reference is pushed onto the stack.</source>
          <target state="translated">成功した場合、新しいオブジェクト参照がスタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The <ph id="ph1">`castclass`</ph> instruction attempts to cast the object reference (type <ph id="ph2">`O`</ph>) atop the stack to a specified class.</source>
          <target state="translated"><ph id="ph1">`castclass`</ph>命令は、オブジェクト参照をキャストしようとしています (型<ph id="ph2">`O`</ph>) を指定したクラスにスタックの一番上。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The new class is specified by a metadata token indicating the desired class.</source>
          <target state="translated">新しいクラスは、目的のクラスを示すメタデータ トークンによって指定されます。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown.</source>
          <target state="translated">スタックの一番上のオブジェクトのクラスは (新しいクラスはインターフェイスと仮定した場合)、新しいクラスを実装していませんし、新しいクラスの派生クラスではない場合、<ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>If the object reference is a null reference, <ph id="ph1">`castclass`</ph> succeeds and returns the new object as a null reference.</source>
          <target state="translated">オブジェクト参照が null 参照では、<ph id="ph1">`castclass`</ph>が成功し、null 参照として新しいオブジェクトを返します。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if obj cannot be cast to class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> obj はクラスにキャストできない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> クラスが見つからない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) の命令が実行時ではなくネイティブ コードに変換されるときに検出します。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`castclass`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`castclass`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Castclass">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Compares two values.</source>
          <target state="translated">2 つの値を比較します。</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If they are equal, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">2 つの値が等しい場合は、整数 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) が評価スタックにプッシュされます。それ以外の場合は、0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) が評価スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>FE 01</source>
          <target state="translated">FE 01</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>ceq</source>
          <target state="translated">ceq</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> equals <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">場合 1 をプッシュ<ph id="ph1">`value1`</ph>equals<ph id="ph2">`value2`</ph>それ以外、0 をプッシュします。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is compared to <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value1`</ph>と比較<ph id="ph4">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If <ph id="ph1">`value1`</ph> is equal to <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">場合<ph id="ph1">`value1`</ph>と等しい<ph id="ph2">`value2`</ph>1 がスタックにプッシュされます。 それ以外の場合 0 は、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The <ph id="ph1">`ceq`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`ceq`</ph>命令を比較<ph id="ph2">`value1`</ph>と<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>If <ph id="ph1">`value1`</ph> is equal to <ph id="ph2">`value2`</ph>, then 1 (of type <ph id="ph3">`int32`</ph>) is pushed on the stack.</source>
          <target state="translated">場合<ph id="ph1">`value1`</ph>と等しい<ph id="ph2">`value2`</ph>、し、1 (型の<ph id="ph3">`int32`</ph>) が、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>Otherwise 0 (of type <ph id="ph1">`int32`</ph>) is pushed on the stack.</source>
          <target state="translated">それ以外の場合 0 (型の<ph id="ph1">`int32`</ph>) が、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>For floating-point number, <ph id="ph1">`ceq`</ph> will return 0 if the numbers are unordered (either or both are NaN).</source>
          <target state="translated">浮動小数点数の<ph id="ph1">`ceq`</ph>数値は順序付けられていない場合に 0 を返します (いずれかまたは両方が NaN)。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The infinite values are equal to themselves.</source>
          <target state="translated">無限値では、それ自体と同じです。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ceq`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ceq`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ceq">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Compares two values.</source>
          <target state="translated">2 つの値を比較します。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If the first value is greater than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">最初の値が 2 番目の値を超える場合は、整数 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) が評価スタックにプッシュされます。それ以外の場合は、0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) が評価スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>FE 02</source>
          <target state="translated">FE 02</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>cgt</source>
          <target state="translated">cgt</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">場合 1 をプッシュ<ph id="ph1">`value1`</ph>がより大きい<ph id="ph2">`value2`</ph>それ以外、0 をプッシュします。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`cgt`</ph> tests if <ph id="ph4">`value1`</ph> is greater than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`cgt`</ph>かどうか<ph id="ph4">`value1`</ph>がより大きい<ph id="ph5">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">場合<ph id="ph1">`value1`</ph>がより大きい<ph id="ph2">`value2`</ph>1 がスタックにプッシュされます。 それ以外の場合 0 は、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The <ph id="ph1">`cgt`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`cgt`</ph>命令を比較<ph id="ph2">`value1`</ph>と<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>If <ph id="ph1">`value1`</ph> is strictly greater than <ph id="ph2">`value2`</ph>, then an <ph id="ph3">`int32`</ph> value of 1 is pushed on the stack.</source>
          <target state="translated">場合<ph id="ph1">`value1`</ph>がより厳密に大きい<ph id="ph2">`value2`</ph>、<ph id="ph3">`int32`</ph>値 1 がスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">それ以外の場合、 <ph id="ph1">`int32`</ph> 0 の値が、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>For floating-point numbers, <ph id="ph1">`cgt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</source>
          <target state="translated">浮動小数点数の<ph id="ph1">`cgt`</ph>(1 つまたは両方の引数が NaN) の場合は、数値は順序付けられていない場合は 0 を返します。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cgt`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`cgt`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Compares two unsigned or unordered values.</source>
          <target state="translated">2 つの符号なしの値または順序なしの値を比較します。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>If the first value is greater than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">最初の値が 2 番目の値を超える場合は、整数 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) が評価スタックにプッシュされます。それ以外の場合は、0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) が評価スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>FE 03</source>
          <target state="translated">FE 03</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>cgt.un</source>
          <target state="translated">cgt.un</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>; else pushes 0 (unsigned values).</source>
          <target state="translated">場合 1 をプッシュ<ph id="ph1">`value1`</ph>がより大きい<ph id="ph2">`value2`</ph>それ以外、0 (符号なしの値) をプッシュします。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`cgt.un`</ph> tests if <ph id="ph4">`value1`</ph> is greater than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`cgt.un`</ph>かどうか<ph id="ph4">`value1`</ph>がより大きい<ph id="ph5">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>If <ph id="ph1">`value1`</ph> is greater than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">場合<ph id="ph1">`value1`</ph>がより大きい<ph id="ph2">`value2`</ph>1 がスタックにプッシュされます。 それ以外の場合 0 は、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>An <ph id="ph1">`int32`</ph> value of 1 is pushed on the stack if any of the following is <ph id="ph2">`true`</ph> :</source>
          <target state="translated"><ph id="ph1">`int32`</ph>場合は、次のいずれかが値 1 がスタックにプッシュされる<ph id="ph2">`true`</ph>:</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>For floating-point numbers, <ph id="ph1">`value1`</ph> is not ordered with respect to <ph id="ph2">`value2`</ph>.</source>
          <target state="translated">浮動小数点数の<ph id="ph1">`value1`</ph>に関連する順序付けされていない<ph id="ph2">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>For integer values, <ph id="ph1">`value1`</ph> is strictly greater than <ph id="ph2">`value2`</ph> when considered as unsigned numbers.</source>
          <target state="translated">整数値の場合は、<ph id="ph1">`value1`</ph>がより厳密に大きい<ph id="ph2">`value2`</ph>符号なし数値と見なされた場合。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>Otherwise an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">それ以外の場合、 <ph id="ph1">`int32`</ph> 0 の値が、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cgt.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`cgt.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cgt_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Throws <ph id="ph1">&lt;see cref="T:System.ArithmeticException" /&gt;</ph> if value is not a finite number.</source>
          <target state="translated">値が有限数ではない場合は、<ph id="ph1">&lt;see cref="T:System.ArithmeticException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>C3</source>
          <target state="translated">C3</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>ckfinite</source>
          <target state="translated">ckfinite</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>throw <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> if value is not a finite number.</source>
          <target state="translated">スロー<ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph>値が有限数ではない場合。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack..</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the <ph id="ph2">`ckfinite`</ph> instruction is performed on it.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックからポップされ、<ph id="ph2">`ckfinite`</ph>命令は、その上で実行します。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`value`</ph> is pushed back onto the stack if no exception is thrown.</source>
          <target state="translated"><ph id="ph1">`value`</ph> プッシュ バック スタックに例外がスローされない場合。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The <ph id="ph1">`ckfinite instruction`</ph> throws <ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph> if <ph id="ph3">`value`</ph> (a floating-point number) is either a "not a number" value (NaN) or a <ph id="ph4">`+-`</ph> infinity value.</source>
          <target state="translated"><ph id="ph1">`ckfinite instruction`</ph>スロー<ph id="ph2">&lt;xref:System.ArithmeticException&gt;</ph>場合<ph id="ph3">`value`</ph>(浮動小数点数) は、いずれか、「非数」の値 (NaN) または<ph id="ph4">`+-`</ph>無限大の値。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">`Ckfinite`</ph> leaves the value on the stack if no exception is thrown.</source>
          <target state="translated"><ph id="ph1">`Ckfinite`</ph> 例外がスローされない場合、スタック上の値のままです。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Execution is unspecified if <ph id="ph1">`value`</ph> is not a floating-point number.</source>
          <target state="translated">実行は指定されていない場合は<ph id="ph1">`value`</ph>浮動小数点数値ではありません。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source><ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> is thrown if <ph id="ph2">`value`</ph> is not a 'normal' number.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> 場合にスローされる<ph id="ph2">`value`</ph>'normal' 数値ではありません。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>Note that a special exception or a derived class of <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> may be more appropriate, passing the incorrect value to the exception handler.</source>
          <target state="translated">なお、特別な例外、またはの派生クラス<ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph>より適切な例外ハンドラーに正しくない値を渡すことがあります。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ckfinite`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ckfinite`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ckfinite">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Compares two values.</source>
          <target state="translated">2 つの値を比較します。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If the first value is less than the second, the integer value 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated">最初の値が 2 番目の値より小さい場合は、整数 1 <ph id="ph1">&lt;see langword="(int32" /&gt;</ph>) が評価スタックにプッシュされます。それ以外の場合は、0 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph>) が評価スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>FE 04</source>
          <target state="translated">FE 04</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>clt</source>
          <target state="translated">clt</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>; else pushes 0.</source>
          <target state="translated">場合 1 をプッシュ<ph id="ph1">`value1`</ph>はより小さい<ph id="ph2">`value2`</ph>それ以外、0 をプッシュします。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The stack transitional behavior, in sequential order, is: <ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">シーケンシャルな順序でスタックの遷移動作:<ph id="ph1">`value1`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`clt`</ph> tests if <ph id="ph4">`value1`</ph> is less than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`clt`</ph>かどうか<ph id="ph4">`value1`</ph>はより小さい<ph id="ph5">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">場合<ph id="ph1">`value1`</ph>はより小さい<ph id="ph2">`value2`</ph>1 がスタックにプッシュされます。 それ以外の場合 0 は、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The <ph id="ph1">`clt`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`clt`</ph>命令を比較<ph id="ph2">`value1`</ph>と<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>If <ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph>, then an <ph id="ph3">`int32`</ph> value of 1 is pushed on the stack.</source>
          <target state="translated">場合<ph id="ph1">`value1`</ph>がより厳密に小さい<ph id="ph2">`value2`</ph>、<ph id="ph3">`int32`</ph>値 1 がスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">それ以外の場合、 <ph id="ph1">`int32`</ph> 0 の値が、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>For floating-point numbers, <ph id="ph1">`clt`</ph> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</source>
          <target state="translated">浮動小数点数の<ph id="ph1">`clt`</ph>(1 つまたは両方の引数が NaN) の場合は、数値は順序付けられていない場合は 0 を返します。</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`clt`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`clt`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Compares the unsigned or unordered values <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> and <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>.</source>
          <target state="translated">符号なしの値または順序なしの値である <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> と <ph id="ph2">&lt;paramref name="value2" /&gt;</ph> を比較します。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>If <ph id="ph1">&lt;paramref name="value1" /&gt;</ph> is less than <ph id="ph2">&lt;paramref name="value2" /&gt;</ph>, then the integer value 1 <ph id="ph3">&lt;see langword="(int32" /&gt;</ph>) is pushed onto the evaluation stack; otherwise 0 (<ph id="ph4">&lt;see langword="int32" /&gt;</ph>) is pushed onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value1" /&gt;</ph> が <ph id="ph2">&lt;paramref name="value2" /&gt;</ph> より小さい場合は、整数 1 <ph id="ph3">&lt;see langword="(int32" /&gt;</ph>) が評価スタックにプッシュされます。それ以外の場合は、0 (<ph id="ph4">&lt;see langword="int32" /&gt;</ph>) が評価スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>FE 05</source>
          <target state="translated">FE 05</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>clt.un</source>
          <target state="translated">clt.un</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Pushes 1 if <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>; else pushes 0 (unsigned values).</source>
          <target state="translated">場合 1 をプッシュ<ph id="ph1">`value1`</ph>はより小さい<ph id="ph2">`value2`</ph>それ以外、0 (符号なしの値) をプッシュします。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`clt.un`</ph> tests if <ph id="ph4">`value1`</ph> is less than <ph id="ph5">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`clt.un`</ph>かどうか<ph id="ph4">`value1`</ph>はより小さい<ph id="ph5">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>If <ph id="ph1">`value1`</ph> is less than <ph id="ph2">`value2`</ph>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</source>
          <target state="translated">場合<ph id="ph1">`value1`</ph>はより小さい<ph id="ph2">`value2`</ph>1 がスタックにプッシュされます。 それ以外の場合 0 は、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The <ph id="ph1">`clt.un`</ph> instruction compares <ph id="ph2">`value1`</ph> and <ph id="ph3">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`clt.un`</ph>命令を比較<ph id="ph2">`value1`</ph>と<ph id="ph3">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>An <ph id="ph1">`int32`</ph> value of 1 is pushed on the stack if any of the following is true:</source>
          <target state="translated"><ph id="ph1">`int32`</ph> 1 の値が、次のいずれかが当てはまる場合に、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source><ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph> (as for <ph id="ph3">`clt`</ph>).</source>
          <target state="translated"><ph id="ph1">`value1`</ph> より厳密に小さい<ph id="ph2">`value2`</ph>(の場合と同様<ph id="ph3">`clt`</ph>)。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>For floating-point numbers, <ph id="ph1">`value1`</ph> is not ordered with respect to <ph id="ph2">`value2`</ph>.</source>
          <target state="translated">浮動小数点数の<ph id="ph1">`value1`</ph>に関連する順序付けされていない<ph id="ph2">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>For integer values, <ph id="ph1">`value1`</ph> is strictly less than <ph id="ph2">`value2`</ph> when considered as unsigned numbers.</source>
          <target state="translated">整数値の場合は、<ph id="ph1">`value1`</ph>がより厳密に小さい<ph id="ph2">`value2`</ph>符号なし数値と見なされた場合。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>Otherwise, an <ph id="ph1">`int32`</ph> value of 0 is pushed on the stack.</source>
          <target state="translated">それ以外の場合、 <ph id="ph1">`int32`</ph> 0 の値が、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`clt.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`clt.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Clt_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Constrains the type on which a virtual method call is made.</source>
          <target state="translated">仮想メソッド呼び出しをする対象の型を制約します。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>FE 16 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 16 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>constrained.</source>
          <target state="translated">制約を受けます。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Call a virtual method on a type constrained to be type <ph id="ph1">`T`</ph>.</source>
          <target state="translated">型の仮想メソッドの型に制約付き呼び出し<ph id="ph1">`T`</ph>です。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix is permitted only on a <ph id="ph2">`callvirt`</ph> instruction.</source>
          <target state="translated"><ph id="ph1">`constrained`</ph>プレフィックスがでのみ許可されて、<ph id="ph2">`callvirt`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The state of the MSIL stack at this point must be as follows:</source>
          <target state="translated">MSIL スタックをこの時点の状態は、次のようにする必要があります。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>A managed pointer, <ph id="ph1">`ptr`</ph>, is pushed onto the stack.</source>
          <target state="translated">マネージ ポインター<ph id="ph1">`ptr`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The type of <ph id="ph1">`ptr`</ph> must be a managed pointer (<ph id="ph2">`&amp;`</ph>) to <ph id="ph3">`thisType`</ph>.</source>
          <target state="translated">型<ph id="ph1">`ptr`</ph>マネージ ポインターである必要があります (<ph id="ph2">`&amp;`</ph>) に<ph id="ph3">`thisType`</ph>です。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Note that this is different from the case of an unprefixed <ph id="ph1">`callvirt`</ph> instruction, which expects a reference of <ph id="ph2">`thisType`</ph>.</source>
          <target state="translated">これは、プレフィックスなしの大文字と小文字を異なることに注意してください<ph id="ph1">`callvirt`</ph>命令の参照が必要ですが<ph id="ph2">`thisType`</ph>です。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Method arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argN`</ph> are pushed onto the stack, just as with an unprefixed <ph id="ph3">`callvirt`</ph> instruction.</source>
          <target state="translated">メソッドの引数<ph id="ph1">`arg1`</ph>を通じて<ph id="ph2">`argN`</ph>と同様に、プレフィックスなし、スタックにプッシュ<ph id="ph3">`callvirt`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix is designed to allow <ph id="ph2">`callvirt`</ph> instructions to be made in a uniform way independent of whether <ph id="ph3">`thisType`</ph> is a value type or a reference type.</source>
          <target state="translated"><ph id="ph1">`constrained`</ph>プレフィックスは、許可するように設計された<ph id="ph2">`callvirt`</ph>独立に作成された一貫した方法かどうかを指示<ph id="ph3">`thisType`</ph>が値型または参照型です。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>When a <ph id="ph1">`callvirt`</ph> <ph id="ph2">`method`</ph> instruction has been prefixed by <ph id="ph3">`constrained`</ph> <ph id="ph4">`thisType`</ph>, the instruction is executed as follows:</source>
          <target state="translated">ときに、 <ph id="ph1">`callvirt`</ph> <ph id="ph2">`method`</ph>命令がプレフィックスとして<ph id="ph3">`constrained`</ph><ph id="ph4">`thisType`</ph>命令の実行は、次のようにします。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a reference type (as opposed to a value type) then <ph id="ph2">`ptr`</ph> is dereferenced and passed as the 'this' pointer to the <ph id="ph3">`callvirt`</ph> of <ph id="ph4">`method`</ph>.</source>
          <target state="translated">場合<ph id="ph1">`thisType`</ph>(値型) ではなく、参照型が<ph id="ph2">`ptr`</ph>が逆参照で 'this' へのポインターとして渡され、<ph id="ph3">`callvirt`</ph>の<ph id="ph4">`method`</ph>します。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a value type and <ph id="ph2">`thisType`</ph> implements <ph id="ph3">`method`</ph> then <ph id="ph4">`ptr`</ph> is passed unmodified as the 'this' pointer to a <ph id="ph5">`call`</ph> <ph id="ph6">`method`</ph> instruction, for the implementation of <ph id="ph7">`method`</ph> by <ph id="ph8">`thisType`</ph>.</source>
          <target state="translated">場合<ph id="ph1">`thisType`</ph>値の型と<ph id="ph2">`thisType`</ph>を実装する<ph id="ph3">`method`</ph>し<ph id="ph4">`ptr`</ph>未変更へ 'this' ポインターとして渡される、 <ph id="ph5">`call`</ph> <ph id="ph6">`method`</ph>の実装のための命令<ph id="ph7">`method`</ph>によって<ph id="ph8">`thisType`</ph>です。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If <ph id="ph1">`thisType`</ph> is a value type and <ph id="ph2">`thisType`</ph> does not implement <ph id="ph3">`method`</ph> then <ph id="ph4">`ptr`</ph> is dereferenced, boxed, and passed as the 'this' pointer to the <ph id="ph5">`callvirt`</ph> <ph id="ph6">`method`</ph> instruction.</source>
          <target state="translated">場合<ph id="ph1">`thisType`</ph>値の型と<ph id="ph2">`thisType`</ph>を実装していません<ph id="ph3">`method`</ph>し<ph id="ph4">`ptr`</ph>が逆参照、ボックス化、およびを 'this' ポインターとしてやり取りされる、 <ph id="ph5">`callvirt`</ph> <ph id="ph6">`method`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>This last case can occur only when <ph id="ph1">`method`</ph> was defined on <ph id="ph2">&lt;xref:System.Object&gt;</ph>, <ph id="ph3">&lt;xref:System.ValueType&gt;</ph>, or <ph id="ph4">&lt;xref:System.Enum&gt;</ph> and not overridden by <ph id="ph5">`thisType`</ph>.</source>
          <target state="translated">この場合は最後に発生する可能性がされる場合にのみ<ph id="ph1">`method`</ph>で定義されていた<ph id="ph2">&lt;xref:System.Object&gt;</ph>、 <ph id="ph3">&lt;xref:System.ValueType&gt;</ph>、または<ph id="ph4">&lt;xref:System.Enum&gt;</ph>によってオーバーライドされていないと<ph id="ph5">`thisType`</ph>です。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>In this case, the boxing causes a copy of the original object to be made.</source>
          <target state="translated">ここでは、ボックス化できるように、元のオブジェクトのコピーをさせます。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>However, because none of the methods of <ph id="ph1">&lt;xref:System.Object&gt;</ph>, <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Enum&gt;</ph> modify the state of the object, this fact cannot be detected.</source>
          <target state="translated">ただし、ためのメソッドのいずれも<ph id="ph1">&lt;xref:System.Object&gt;</ph>、 <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>、および<ph id="ph3">&lt;xref:System.Enum&gt;</ph>状態を変更、オブジェクトのこのファクトを検出できません。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix supports IL generators that create generic code.</source>
          <target state="translated"><ph id="ph1">`constrained`</ph>プレフィックスは、汎用的なコードを作成する IL ジェネレーターをサポートしています。</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Normally the <ph id="ph1">`callvirt`</ph> instruction is not valid on value types.</source>
          <target state="translated">通常、<ph id="ph1">`callvirt`</ph>命令は値型では無効です。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of <ph id="ph1">`ptr`</ph> and the method being called.</source>
          <target state="translated">必須では代わりに IL コンパイラが、'this' の種類によっては、コンパイル時に上記で説明した変換を効率的に実行すること<ph id="ph1">`ptr`</ph>と呼び出されるメソッド。</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>However, when <ph id="ph1">`ptr`</ph> is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</source>
          <target state="translated">ただし、<ph id="ph1">`ptr`</ph>コンパイル時に不明なジェネリック型は、コンパイル時にこの変換を行うことはできません。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether <ph id="ph2">`ptr`</ph> is a value type or a reference type.</source>
          <target state="translated"><ph id="ph1">`constrained`</ph>オペコード IL コンパイラかどうかの方法に依存しない一貫した仮想関数への呼び出しを行うには、<ph id="ph2">`ptr`</ph>が値型または参照型です。</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Although it is intended for the case where <ph id="ph1">`thisType`</ph> is a generic type variable, the <ph id="ph2">`constrained`</ph> prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types.</source>
          <target state="translated">場合、対象としていますが、<ph id="ph1">`thisType`</ph>ジェネリック型の変数は、<ph id="ph2">`constrained`</ph>プレフィックスも非ジェネリック型のしくみと、値型と参照型の違いを非表示にする言語で仮想呼び出しの生成の複雑さを軽減できます。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Using the <ph id="ph1">`constrained`</ph> prefix also avoids potential versioning problems with value types.</source>
          <target state="translated">使用して、<ph id="ph1">`constrained`</ph>プレフィックス値型で、バージョン管理の潜在的な問題を回避できます。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If the <ph id="ph1">`constrained`</ph> prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object.</source>
          <target state="translated">場合、<ph id="ph1">`constrained`</ph>プレフィックスが使用しない場合、値の型が System.Object のメソッドをオーバーライドするかどうかに応じて異なる IL を生成する必要があります。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>For example, if a value type <ph id="ph1">`V`</ph> overrides the Object.ToString() method, a <ph id="ph2">`call`</ph> <ph id="ph3">`V.ToString()`</ph> instruction is emitted; if it does not, a <ph id="ph4">`box`</ph> instruction and a <ph id="ph5">`callvirt`</ph> <ph id="ph6">`Object.ToString()`</ph> instruction are emitted.</source>
          <target state="translated">たとえば、値型の場合<ph id="ph1">`V`</ph>Object.ToString() メソッドをオーバーライドし、 <ph id="ph2">`call`</ph> <ph id="ph3">`V.ToString()`</ph>命令が生成されます。 その場合は、、<ph id="ph4">`box`</ph>命令と<ph id="ph5">`callvirt`</ph><ph id="ph6">`Object.ToString()`</ph>命令が生成されます。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added.</source>
          <target state="translated">バージョン管理の問題が生じる場合は、上書きが後で削除されると、前者の場合、および後者の場合、上書きが後から追加された場合です。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The <ph id="ph1">`constrained`</ph> prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a <ph id="ph2">`MethodImpl`</ph>.</source>
          <target state="translated"><ph id="ph1">`constrained`</ph>プレフィックスこともできます、値の型に対するインターフェイスのメソッドの呼び出しを使用してインターフェイス メソッドを実装する値の型のメソッドを変更できるため、<ph id="ph2">`MethodImpl`</ph>です。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>If the <ph id="ph1">`constrained`</ph> prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time.</source>
          <target state="translated">場合、<ph id="ph1">`constrained`</ph>プレフィックスが使用しない場合、コンパイラがコンパイル時にバインドする型のメソッドの選択となる値を求められます。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>Using the <ph id="ph1">`constrained`</ph> prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</source>
          <target state="translated">使用して、<ph id="ph1">`constrained`</ph>プレフィックスは、コンパイル時ではなく、実行時に、インターフェイス メソッドを実装するメソッドにバインドする MSIL を使用します。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`constrained`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`constrained`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Constrained">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="native int" /&gt;</ph> に変換します。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>D3</source>
          <target state="translated">D3</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>conv.i</source>
          <target state="translated">conv.i</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Convert to <ph id="ph1">`native int`</ph>, pushing <ph id="ph2">`native int`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`native int`</ph>プッシュ、<ph id="ph2">`native int`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The <ph id="ph1">`conv.i`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.i`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.i`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int8" /&gt;</ph>, then extends (pads) it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="int8" /&gt;</ph> に変換し、<ph id="ph2">&lt;see langword="int32" /&gt;</ph> への拡張 (埋め込み) を行います。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>67</source>
          <target state="translated">67</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>conv.i1</source>
          <target state="translated">conv.i1</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Convert to <ph id="ph1">`int8`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`int8`</ph>プッシュ、<ph id="ph2">`int32`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The <ph id="ph1">`conv.i1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.i1`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.i1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int16" /&gt;</ph>, then extends (pads) it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="int16" /&gt;</ph> に変換し、<ph id="ph2">&lt;see langword="int32" /&gt;</ph> への拡張 (埋め込み) を行います。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>68</source>
          <target state="translated">68</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>conv.i2</source>
          <target state="translated">conv.i2</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Convert to <ph id="ph1">`int16`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`int16`</ph>プッシュ、<ph id="ph2">`int32`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The <ph id="ph1">`conv.i2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.i2`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.i2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> に変換します。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>69</source>
          <target state="translated">69</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>conv.i4</source>
          <target state="translated">conv.i4</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Convert to <ph id="ph1">`int32`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`int32`</ph>プッシュ、<ph id="ph2">`int32`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The <ph id="ph1">`conv.i4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.i4`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.i4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="int64" /&gt;</ph> に変換します。</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>6A</source>
          <target state="translated">6A</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>conv.i8</source>
          <target state="translated">conv.i8</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Convert to <ph id="ph1">`int64`</ph>, pushing <ph id="ph2">`int64`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`int64`</ph>プッシュ、<ph id="ph2">`int64`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The <ph id="ph1">`conv.i8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.i8`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.i8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.i8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号付きの値を符号付き <ph id="ph1">&lt;see langword="native int" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>D4</source>
          <target state="translated">D4</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>conv.ovf.i</source>
          <target state="translated">conv.ovf.i</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Convert to a <ph id="ph1">`native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">変換、 <ph id="ph1">`native int`</ph> (スタック上でとして<ph id="ph2">`native int`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The <ph id="ph1">`conv.ovf.i`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.i`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号なしの値を符号付き <ph id="ph1">&lt;see langword="native int" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>8A</source>
          <target state="translated">8A</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>conv.ovf.i.un</source>
          <target state="translated">conv.ovf.i.un</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Converts an unsigned value to a <ph id="ph1">`native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">符号なしの値を変換、 <ph id="ph1">`native int`</ph> (スタック上でとして<ph id="ph2">`native int`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The <ph id="ph1">`conv.ovf.i.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.i.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号付きの値を符号付き <ph id="ph1">&lt;see langword="int8" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張し、オーバーフローについては <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>B3</source>
          <target state="translated">B3</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>conv.ovf.i1</source>
          <target state="translated">conv.ovf.i1</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Convert to an <ph id="ph1">`int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">変換、 <ph id="ph1">`int8`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The <ph id="ph1">`conv.ovf.i1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i1`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.i1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号なしの値を符号付き <ph id="ph1">&lt;see langword="int8" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張し、オーバーフローについては <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>82</source>
          <target state="translated">82</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>conv.ovf.i1.un</source>
          <target state="translated">conv.ovf.i1.un</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">符号なしの値を変換、 <ph id="ph1">`int8`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The <ph id="ph1">`conv.ovf.i1.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i1.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i1.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.i1.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int16" /&gt;</ph> and extending it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号付きの値を符号付き <ph id="ph1">&lt;see langword="int16" /&gt;</ph> に変換し、変換した値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張し、オーバーフローについては <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>B5</source>
          <target state="translated">B5</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>conv.ovf.i2</source>
          <target state="translated">conv.ovf.i2</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Convert to an <ph id="ph1">`int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">変換、 <ph id="ph1">`int16`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The <ph id="ph1">`conv.ovf.i2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i2`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.i2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号なしの値を符号付き <ph id="ph1">&lt;see langword="int16" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張し、オーバーフローについては <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>83</source>
          <target state="translated">83</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>conv.ovf.i2.un</source>
          <target state="translated">conv.ovf.i2.un</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">符号なしの値を変換、 <ph id="ph1">`int16`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The <ph id="ph1">`conv.ovf.i2.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i2.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i2.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.i2.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号付きの値を符号付き <ph id="ph1">&lt;see langword="int32" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>B7</source>
          <target state="translated">B7</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>conv.ovf.i4</source>
          <target state="translated">conv.ovf.i4</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Convert to an <ph id="ph1">`int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">変換、 <ph id="ph1">`int32`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The <ph id="ph1">`conv.ovf.i4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i4`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.i4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号なしの値を符号付き <ph id="ph1">&lt;see langword="int32" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>84</source>
          <target state="translated">84</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>conv.ovf.i4.un</source>
          <target state="translated">conv.ovf.i4.un</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">符号なしの値を変換、 <ph id="ph1">`int32`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The <ph id="ph1">`conv.ovf.i4.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i4.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i4.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.i4.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Converts the signed value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号付きの値を符号付き <ph id="ph1">&lt;see langword="int64" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>B9</source>
          <target state="translated">B9</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>conv.ovf.i8</source>
          <target state="translated">conv.ovf.i8</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Convert to an <ph id="ph1">`int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">変換、 <ph id="ph1">`int64`</ph> (スタック上でとして<ph id="ph2">`int64`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The <ph id="ph1">`conv.ovf.i8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i8`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.i8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Converts the unsigned value on top of the evaluation stack to signed <ph id="ph1">&lt;see langword="int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号なしの値を符号付き <ph id="ph1">&lt;see langword="int64" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>85</source>
          <target state="translated">85</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>conv.ovf.i8.un</source>
          <target state="translated">conv.ovf.i8.un</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">符号なしの値を変換、 <ph id="ph1">`int64`</ph> (スタック上でとして<ph id="ph2">`int64`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The <ph id="ph1">`conv.ovf.i8.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.i8.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.i8.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.i8.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号付きの値を <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>D5</source>
          <target state="translated">D5</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>conv.ovf.u</source>
          <target state="translated">conv.ovf.u</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Convert to an <ph id="ph1">`unsigned native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">変換、 <ph id="ph1">`unsigned native int`</ph> (スタック上でとして<ph id="ph2">`native int`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The <ph id="ph1">`conv.ovf.u`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.u`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号なしの値を <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>8B</source>
          <target state="translated">8B</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>conv.ovf.u.un</source>
          <target state="translated">conv.ovf.u.un</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Converts un unsigned value to an <ph id="ph1">`unsigned native int`</ph> (on the stack as <ph id="ph2">`native int`</ph>) and throw an exception on overflow.</source>
          <target state="translated">値を符号、 <ph id="ph1">`unsigned native int`</ph> (スタック上でとして<ph id="ph2">`native int`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The <ph id="ph1">`conv.ovf.u.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.uvf.u.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.uvf.u.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号付きの値を <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張し、オーバーフローについては <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>B4</source>
          <target state="translated">B4</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>conv.ovf.u1</source>
          <target state="translated">conv.ovf.u1</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Convert to an <ph id="ph1">`unsigned int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">変換、 <ph id="ph1">`unsigned int8`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The <ph id="ph1">`conv.ovf.u1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u1`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.u1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号なしの値を <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張し、オーバーフローについては <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>86</source>
          <target state="translated">86</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>conv.ovf.u1.un</source>
          <target state="translated">conv.ovf.u1.un</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int8`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">符号なしの値を変換、 <ph id="ph1">`unsigned int8`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The <ph id="ph1">`conv.ovf.u1.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u1.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u1.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.u1.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号付きの値を <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張し、オーバーフローについては <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>B6</source>
          <target state="translated">B6</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>conv.ovf.u2</source>
          <target state="translated">conv.ovf.u2</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Convert to an <ph id="ph1">`unsigned int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">変換、 <ph id="ph1">`unsigned int16`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The <ph id="ph1">`conv.ovf.u2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u2`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.u2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, throwing <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号なしの値を <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張し、オーバーフローについては <ph id="ph3">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>87</source>
          <target state="translated">87</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>conv.ovf.u2.un</source>
          <target state="translated">conv.ovf.u2.un</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int16`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">符号なしの値を変換、 <ph id="ph1">`unsigned int16`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The <ph id="ph1">`conv.ovf.u2.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u2.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u2.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.u2.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号付きの値を <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>B8</source>
          <target state="translated">B8</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>conv.ovf.u4</source>
          <target state="translated">conv.ovf.u4</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Convert to an <ph id="ph1">`unsigned int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">変換、 <ph id="ph1">`unsigned int32`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The <ph id="ph1">`conv.ovf.u4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u4`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.u4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号なしの値を <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>88</source>
          <target state="translated">88</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>conv.ovf.u4.un</source>
          <target state="translated">conv.ovf.u4.un</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int32`</ph> (on the stack as <ph id="ph2">`int32`</ph>) and throw an exception on overflow.</source>
          <target state="translated">符号なしの値を変換、 <ph id="ph1">`unsigned int32`</ph> (スタック上でとして<ph id="ph2">`int32`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The <ph id="ph1">`conv.ovf.u4.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u4.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u4.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.u4.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Converts the signed value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号付きの値を <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>BA</source>
          <target state="translated">BA</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>conv.ovf.u8</source>
          <target state="translated">conv.ovf.u8</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Convert to an <ph id="ph1">`unsigned int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">変換、 <ph id="ph1">`unsigned int64`</ph> (スタック上でとして<ph id="ph2">`int64`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The <ph id="ph1">`conv.ovf.u8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u8`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.u8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Converts the unsigned value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, throwing <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> on overflow.</source>
          <target state="translated">評価スタックの一番上にある符号なしの値を <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph> に変換し、オーバーフローについては <ph id="ph2">&lt;see cref="T:System.OverflowException" /&gt;</ph> をスローします。</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>89</source>
          <target state="translated">89</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>conv.ovf.u8.un</source>
          <target state="translated">conv.ovf.u8.un</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Converts an unsigned value to an <ph id="ph1">`unsigned int64`</ph> (on the stack as <ph id="ph2">`int64`</ph>) and throw an exception on overflow.</source>
          <target state="translated">符号なしの値を変換、 <ph id="ph1">`unsigned int64`</ph> (スタック上でとして<ph id="ph2">`int64`</ph>)、オーバーフロー例外をスローします。</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If overflow occurs, an exception is thrown.</source>
          <target state="translated">オーバーフローが発生した場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The <ph id="ph1">`conv.ovf.u8.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.ovf.u8.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上の場所で指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>If the value is too large or too small to be represented by the target type, an exception is thrown.</source>
          <target state="translated">値が大きすぎる、または対象の型で表現するのには小さすぎる場合、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Conversions from floating-point numbers to integer values truncate the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.ovf.i`</ph> or <ph id="ph3">`conv.ovf.u`</ph> are used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.ovf.i`</ph>または<ph id="ph3">`conv.ovf.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.ovf.u8.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.ovf.u8.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Converts the unsigned integer value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の符号なし整数値を <ph id="ph1">&lt;see langword="float32" /&gt;</ph> に変換します。</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>76</source>
          <target state="translated">76</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>conv.r.un</source>
          <target state="translated">conv.r.un</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Convert unsigned integer to floating-point, pushing <ph id="ph1">`F`</ph> on stack.</source>
          <target state="translated">変換する符号なし整数、浮動小数点のプッシュ<ph id="ph1">`F`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The <ph id="ph1">`conv.r.un`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.r.un`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>When converting from a <ph id="ph1">`float64`</ph> to a <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>If overflow occurs converting a floating-point type to an integer the <ph id="ph1">`result`</ph> returned is unspecified.</source>
          <target state="translated">浮動小数点型を整数に変換するオーバーフローが発生した場合、<ph id="ph1">`result`</ph>返されるは指定されていません。</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The <ph id="ph1">`conv.r.un`</ph> operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a <ph id="ph2">`float32`</ph>, if this is wide enough to represent the integer without loss of precision, or else a <ph id="ph3">`float64`</ph>.</source>
          <target state="translated"><ph id="ph1">`conv.r.un`</ph>操作整数スタックでは、署名されていないとして解釈および整数を表す浮動小数点数に置き換えられます: いずれか、<ph id="ph2">`float32`</ph>これは、精度の損失のない整数を表すの十分な場合、またはしない場合、<ph id="ph3">`float64`</ph>です。</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.r.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float32" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="float32" /&gt;</ph> に変換します。</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>6B</source>
          <target state="translated">6B</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>conv.r4</source>
          <target state="translated">conv.r4</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Convert to <ph id="ph1">`float32`</ph>, pushing <ph id="ph2">`F`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`float32`</ph>プッシュ、<ph id="ph2">`F`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The <ph id="ph1">`conv.r4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.r4`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.r4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="float64" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="float64" /&gt;</ph> に変換します。</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>6C</source>
          <target state="translated">6C</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>conv.r8</source>
          <target state="translated">conv.r8</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Convert to <ph id="ph1">`float64`</ph>, pushing <ph id="ph2">`F`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`float64`</ph>プッシュ、<ph id="ph2">`F`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The <ph id="ph1">`conv.r8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.r8`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.r8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.r8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="unsigned native int" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="native int" /&gt;</ph> に拡張します。</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>E0</source>
          <target state="translated">E0</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>conv.u</source>
          <target state="translated">conv.u</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Convert to <ph id="ph1">`unsigned native int`</ph>, pushing <ph id="ph2">`native int`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`unsigned native int`</ph>プッシュ、<ph id="ph2">`native int`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The <ph id="ph1">`conv.u`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.u`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un&gt;</ph>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.u`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張します。</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>D2</source>
          <target state="translated">D2</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>conv.u1</source>
          <target state="translated">conv.u1</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Convert to <ph id="ph1">`int8`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`int8`</ph>プッシュ、<ph id="ph2">`int32`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The <ph id="ph1">`conv.u1`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.u1`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un&gt;</ph>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.u1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張します。</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>D1</source>
          <target state="translated">D1</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>conv.u2</source>
          <target state="translated">conv.u2</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Convert to <ph id="ph1">`int16`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`int16`</ph>プッシュ、<ph id="ph2">`int32`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The <ph id="ph1">`conv.u2`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.u2`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un&gt;</ph>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.u2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> に拡張します。</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>6D</source>
          <target state="translated">6D</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>conv.u4</source>
          <target state="translated">conv.u4</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Convert to <ph id="ph1">`unsigned int32`</ph>, pushing <ph id="ph2">`int32`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`unsigned int32`</ph>プッシュ、<ph id="ph2">`int32`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The <ph id="ph1">`conv.u4`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.u4`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un&gt;</ph>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.u4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Converts the value on top of the evaluation stack to <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph>, and extends it to <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">評価スタックの一番上の値を <ph id="ph1">&lt;see langword="unsigned int64" /&gt;</ph> に変換し、その値を <ph id="ph2">&lt;see langword="int64" /&gt;</ph> に拡張します。</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>6E</source>
          <target state="translated">6E</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>conv.u8</source>
          <target state="translated">conv.u8</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Convert to <ph id="ph1">`int64`</ph>, pushing <ph id="ph2">`int64`</ph> on stack.</source>
          <target state="translated">変換<ph id="ph1">`int64`</ph>プッシュ、<ph id="ph2">`int64`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source><ph id="ph1">`value`</ph> is popped from the stack and the conversion operation is attempted.</source>
          <target state="translated"><ph id="ph1">`value`</ph> ポップされ、スタックとの変換から、操作が試行されました。</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If the conversion is successful, the resulting value is pushed onto the stack.</source>
          <target state="translated">変換が成功した場合は、結果の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The <ph id="ph1">`conv.u8`</ph> opcode converts the <ph id="ph2">`value`</ph> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`conv.u8`</ph>オペコードの変換、<ph id="ph2">`value`</ph>履歴オペコード、および変換した値をスタックの一番上のままにして指定された型を上にします。</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> when they are loaded onto the evaluation stack (unless <ph id="ph2">`conv.i`</ph> or <ph id="ph3">`conv.u`</ph> is used, in which case the result is also <ph id="ph4">`native int`</ph>).</source>
          <target state="translated">4 バイト未満の整数値に拡張されます<ph id="ph1">`int32`</ph>を評価スタックに読み込まれるとき (しない限り、<ph id="ph2">`conv.i`</ph>または<ph id="ph3">`conv.u`</ph>を使用する結果がいる場合も<ph id="ph4">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Floating-point values are converted to the <ph id="ph1">`F`</ph> type.</source>
          <target state="translated">浮動小数点値に変換する、<ph id="ph1">`F`</ph>型です。</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>Conversion from floating-point numbers to integer values truncates the number toward zero.</source>
          <target state="translated">浮動小数点数から整数値への変換では、数値 0 方向に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>When converting from an <ph id="ph1">`float64`</ph> to an <ph id="ph2">`float32`</ph>, precision can be lost.</source>
          <target state="translated">変換するときに、<ph id="ph1">`float64`</ph>を<ph id="ph2">`float32`</ph>精度が失われることができます。</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If <ph id="ph1">`value`</ph> is too large to fit in a <ph id="ph2">`float32 (F)`</ph>, positive infinity (if <ph id="ph3">`value`</ph> is positive) or negative infinity (if <ph id="ph4">`value`</ph> is negative) is returned.</source>
          <target state="translated">場合<ph id="ph1">`value`</ph>が大きすぎますに収まるように、 <ph id="ph2">`float32 (F)`</ph>、正の無限大 (場合<ph id="ph3">`value`</ph>が正の値) または負の無限大 (場合<ph id="ph4">`value`</ph>が負の値) が返されます。</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If overflow occurs converting one integer type to another, the high order bits are truncated.</source>
          <target state="translated">変換する際の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If the result is smaller than an <ph id="ph1">`int32`</ph>, the value is sign-extended to fill the slot.</source>
          <target state="translated">結果がより小さい場合、<ph id="ph1">`int32`</ph>値は符号拡張スロットにします。</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</source>
          <target state="translated">オーバーフローが発生した場合は、返される値を整数、浮動小数点型の変換指定されていません。</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>No exceptions are ever thrown when using this field.</source>
          <target state="translated">このフィールドを使用する場合は、例外はこれまでスローされません。</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un&gt;</ph>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については等価です。</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`conv.u8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`conv.u8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Conv_U8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Copies a specified number bytes from a source address to a destination address.</source>
          <target state="translated">ソース アドレスから指定した数のバイトを宛先アドレスにコピーします。</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>FE 17</source>
          <target state="translated">FE 17</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>cpblk</source>
          <target state="translated">cpblk</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>Copy data from one memory block to another.</source>
          <target state="translated">データを別の 1 つのメモリ ブロックにコピーします。</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The destination address is pushed onto the stack.</source>
          <target state="translated">送信先アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The source address is pushed onto the stack.</source>
          <target state="translated">送信元アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The number of bytes to copy is pushed onto the stack.</source>
          <target state="translated">コピーするバイト数は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</source>
          <target state="translated">バイト、発信元アドレスおよび宛先アドレスの数がスタックからポップされます。指定したバイト数は、宛先アドレスに送信元アドレスからコピーされます。</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The <ph id="ph1">`cpblk`</ph> instruction copies a number (type <ph id="ph2">`unsigned int32`</ph>) of bytes from a source address (of type <ph id="ph3">`*`</ph>, <ph id="ph4">`native int`</ph>, or <ph id="ph5">`&amp;`</ph>) to a destination address (of type <ph id="ph6">`*`</ph>, <ph id="ph7">`native int`</ph>, or <ph id="ph8">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`cpblk`</ph>命令数のコピー (型<ph id="ph2">`unsigned int32`</ph>) ソース アドレスからのバイトの (型の<ph id="ph3">`*`</ph>、 <ph id="ph4">`native int`</ph>、または<ph id="ph5">`&amp;`</ph>) を移行先のアドレス (型の<ph id="ph6">`*`</ph>、 <ph id="ph7">`native int`</ph>、または<ph id="ph8">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The behavior of <ph id="ph1">`cpblk`</ph> is unspecified if the source and destination areas overlap.</source>
          <target state="translated">動作<ph id="ph1">`cpblk`</ph>元とコピー先の領域が重なっている場合は指定されていません。</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source><ph id="ph1">`cpblk`</ph> assumes that both the source and destination addressed are aligned to the natural size of the machine.</source>
          <target state="translated"><ph id="ph1">`cpblk`</ph> ソースと宛先のアドレス指定の両方が、マシンの自然なサイズに合わせて配置されると仮定します。</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The <ph id="ph1">`cpblk`</ph> instruction can be immediately preceded by the <ph id="ph2">`unaligned.&lt;prefix&gt;`</ph> instruction to indicate that either the source or the destination is unaligned.</source>
          <target state="translated"><ph id="ph1">`cpblk`</ph>命令のすぐ前に、<ph id="ph2">`unaligned.&lt;prefix&gt;`</ph>元または転送先にアラインされたがないことを示す命令します。</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The operation of the <ph id="ph1">`cpblk`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`cpblk`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローされる可能性がします。</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cpblk`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`cpblk`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpblk">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Copies the value type located at the address of an object (type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph2">&lt;see langword="*" /&gt;</ph> or <ph id="ph3">&lt;see langword="native int" /&gt;</ph>) to the address of the destination object (type <ph id="ph4">&lt;see langword="&amp;amp;" /&gt;</ph>, <ph id="ph5">&lt;see langword="*" /&gt;</ph> or <ph id="ph6">&lt;see langword="native int" /&gt;</ph>).</source>
          <target state="translated">オブジェクトのアドレス (<ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>、<ph id="ph2">&lt;see langword="*" /&gt;</ph>、または <ph id="ph3">&lt;see langword="native int" /&gt;</ph> の各型) にある値型をコピー先のオブジェクトのアドレス (<ph id="ph4">&lt;see langword="&amp;amp;" /&gt;</ph>、<ph id="ph5">&lt;see langword="*" /&gt;</ph>、または <ph id="ph6">&lt;see langword="native int" /&gt;</ph> の各型) にコピーします。</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>70 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">70 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>cpobj <ph id="ph1">`classTok`</ph></source>
          <target state="translated">cpobj <ph id="ph1">`classTok`</ph></target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>Copies a value type from a source object to a destination object.</source>
          <target state="translated">値のコピーをソース オブジェクトから変換先オブジェクトに入力します。</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The destination object reference is pushed onto the stack.</source>
          <target state="translated">移行先のオブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The source object reference is pushed onto the stack.</source>
          <target state="translated">ソース オブジェクトの参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</source>
          <target state="translated">2 つのオブジェクト参照がスタックからポップされます。ソース オブジェクトのアドレスの値の型は、対象オブジェクトのアドレスにコピーされます。</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The behavior of <ph id="ph1">`cpobj`</ph> is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token <ph id="ph2">`classTok`</ph> (a <ph id="ph3">`typeref`</ph> or <ph id="ph4">`typedef`</ph>), or if <ph id="ph5">`classTok`</ph> does not represent a value type.</source>
          <target state="translated">動作<ph id="ph1">`cpobj`</ph>元と移行先のオブジェクトの参照がクラス トークンによって表されるクラスのインスタンスへのポインターでない場合に指定されていない<ph id="ph2">`classTok`</ph>(、<ph id="ph3">`typeref`</ph>または<ph id="ph4">`typedef`</ph>)、または<ph id="ph5">`classTok`</ph>値の型を表していません。</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローされる可能性がします。</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`cpobj`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`cpobj`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Cpobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Divides two values and pushes the result as a floating-point (type <ph id="ph1">&lt;see langword="F" /&gt;</ph>) or quotient (type <ph id="ph2">&lt;see langword="int32" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">2 つの値の除算を実行し、結果を浮動小数点値 (<ph id="ph1">&lt;see langword="F" /&gt;</ph> 型) または商 (<ph id="ph2">&lt;see langword="int32" /&gt;</ph> 型) として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>5B</source>
          <target state="translated">5B</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>div</source>
          <target state="translated">div</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Divides two values to return a quotient or floating-point result.</source>
          <target state="translated">商または浮動小数点の結果を返す 2 つの値を除算します。</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is divided by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value1`</ph>で割った値<ph id="ph4">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> div value2 satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> div value2 は、次の条件を満たします。</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>&amp;#124; <ph id="ph1">`result`</ph> &amp;#124; = &amp;#124; <ph id="ph2">`value1`</ph> &amp;#124; / &amp;#124; <ph id="ph3">`value2`</ph> &amp;#124;, and:</source>
          <target state="translated">&amp;#124; <ph id="ph1">`result`</ph> &amp;#124; = &amp;#124; <ph id="ph2">`value1`</ph> &amp;#124; / &amp;#124; <ph id="ph3">`value2`</ph> &amp;#124;, and:</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>sign(<ph id="ph1">`result`</ph>) = +, if sign(<ph id="ph2">`value1`</ph>) = sign(<ph id="ph3">`value2`</ph>), or -, if sign(<ph id="ph4">`value1`</ph>) ~= sign(<ph id="ph5">`value2`</ph>)</source>
          <target state="translated">sign(<ph id="ph1">`result`</ph>) = +, if sign(<ph id="ph2">`value1`</ph>) = sign(<ph id="ph3">`value2`</ph>), or -, if sign(<ph id="ph4">`value1`</ph>) ~= sign(<ph id="ph5">`value2`</ph>)</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The <ph id="ph1">`div`</ph> instruction computes the result and pushes it on the stack.</source>
          <target state="translated"><ph id="ph1">`div`</ph>命令は、結果を計算し、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integer division truncates towards zero.</source>
          <target state="translated">整数の除算はゼロに向かって切り捨てられます。</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Division of a finite number by zero produces the correctly signed infinite value.</source>
          <target state="translated">有限数 0 による除算では、正しく署名された無限値が生成されます。</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value.</source>
          <target state="translated">0 を 0 または無限無限大 NaN (Not A Number) 値で除算します。</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Any number divided by infinity will produce a zero value.</source>
          <target state="translated">任意の数が無限大で割った値ゼロの値が生成されます。</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph> if the result cannot be represented in the result type.</source>
          <target state="translated">整数演算でスロー<ph id="ph1">&lt;xref:System.ArithmeticException&gt;</ph>場合は、結果を結果の型で表すことはできません。</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>This can happen if <ph id="ph1">`value1`</ph> is the maximum negative value, and <ph id="ph2">`value2`</ph> is -1.</source>
          <target state="translated">これは、場合に発生<ph id="ph1">`value1`</ph>最大負の値と<ph id="ph2">`value2`</ph>-1 です。</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">整数演算でスロー<ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph>場合<ph id="ph2">`value2`</ph>ゼロです。</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Note that on Intel-based platforms an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint div -1).</source>
          <target state="translated">Intel ベース プラットフォームなお、 <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> (minint div-1) を計算するときにスローされます。</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>Floating-point operations never throw an exception (they produce NaNs or infinities instead).</source>
          <target state="translated">浮動小数点演算では、(されるので、nans 値や無限大代わりに)、例外がスローされません。</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`div`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`div`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Divides two unsigned integer values and pushes the result (<ph id="ph1">&lt;see langword="int32" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">2 つの符号なし整数値を除算し、結果 (<ph id="ph1">&lt;see langword="int32" /&gt;</ph>) を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>5C</source>
          <target state="translated">5C</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>div.un</source>
          <target state="translated">div.un</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>Divides two values, unsigned, returning a quotient.</source>
          <target state="translated">2 つの値を除算、署名なし、し、商を返します。</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is divided by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value1`</ph>で割った値<ph id="ph4">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The <ph id="ph1">`div.un`</ph> instruction computes <ph id="ph2">`value1`</ph> divided by <ph id="ph3">`value2`</ph>, both taken as unsigned integers, and pushes the <ph id="ph4">`result`</ph> on the stack.</source>
          <target state="translated"><ph id="ph1">`div.un`</ph>命令計算<ph id="ph2">`value1`</ph>で割った値<ph id="ph3">`value2`</ph>、どちらも、符号なし整数とプッシュとして実行される、<ph id="ph4">`result`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`div.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`div.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Div_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</source>
          <target state="translated">現在評価スタックの一番上にある値をコピーし、そのコピーを評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>25</source>
          <target state="translated">25</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>dup</source>
          <target state="translated">dup</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>Duplicates the value on the top of the stack.</source>
          <target state="translated">スタックの一番上の値を複製します。</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is popped off of the stack for duplication.</source>
          <target state="translated"><ph id="ph1">`value`</ph> 複製用スタックからポップされます。</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source><ph id="ph1">`value`</ph> is pushed back onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> プッシュ バック スタックにします。</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>A duplicate value is pushed onto the stack.</source>
          <target state="translated">重複する値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The <ph id="ph1">`dup`</ph> instruction duplicates the top element of the stack, and leaves two identical values atop it.</source>
          <target state="translated"><ph id="ph1">`dup`</ph>命令がスタックの最上位の要素を複製し、2 つの同一の値のままにします。</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`dup`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`dup`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Dup">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Transfers control from the <ph id="ph1">&lt;see langword="filter" /&gt;</ph> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</source>
          <target state="translated">例外の <ph id="ph1">&lt;see langword="filter" /&gt;</ph> 句から共通言語基盤 (CLI) 例外ハンドラーに制御を転送します。</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>FE 11</source>
          <target state="translated">FE 11</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>endfilter</source>
          <target state="translated">endfilter</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>End filter clause of SEH exception handling.</source>
          <target state="translated">SEH 例外処理のフィルター句を終了します。</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`value`</ph> is popped from the stack; <ph id="ph2">`endfilter`</ph> is executed and control is transferred to the exception handler.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックからポップされます。<ph id="ph2">`endfilter`</ph>が実行されると、例外ハンドラーに制御が移ります。</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`Value`</ph> (which must be of type <ph id="ph2">`int32`</ph> and is one of a specific set of values) is returned from the filter clause.</source>
          <target state="translated"><ph id="ph1">`Value`</ph> (型でなければならない<ph id="ph2">`int32`</ph>特定の値セットの 1 つ) がフィルター句から返されます。</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>It should be one of:</source>
          <target state="translated">いずれかを指定する必要があります。</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`exception_continue_search`</ph> (<ph id="ph2">`value`</ph> = 0) to continue searching for an exception handler</source>
          <target state="translated"><ph id="ph1">`exception_continue_search`</ph> (<ph id="ph2">`value`</ph> = 0)、例外ハンドラーの検索を続行するには</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source><ph id="ph1">`exception_execute_handler`</ph> (<ph id="ph2">`value`</ph> = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located.</source>
          <target state="translated"><ph id="ph1">`exception_execute_handler`</ph> (<ph id="ph2">`value`</ph> = 1) を 2 つ目の開始場所 finally ブロックはまで実行ハンドラーは、このフィルター句に関連付けられている例外処理のフェーズが配置されています。</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Upon discovery, the handler is executed.</source>
          <target state="translated">探索時に、ハンドラーが実行されます。</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Other integer values will produce unspecified results.</source>
          <target state="translated">その他の整数値を指定されていない結果となります。</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block.</source>
          <target state="translated">フィルターのエントリ ポイント メソッドの例外の表に示すようにするとフィルターのコード ブロックの最初の命令がある必要があります。</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The <ph id="ph1">`endfilter`</ph> instruction must be the last instruction in the filter's code block (hence there can only be one <ph id="ph2">`endfilter`</ph> for any single filter block).</source>
          <target state="translated"><ph id="ph1">`endfilter`</ph>命令は、フィルターのコード ブロックの最後の命令である必要があります (したがってのみ存在できますいずれかの<ph id="ph2">`endfilter`</ph>の任意の 1 つのフィルター ブロック) します。</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>After executing the <ph id="ph1">`endfilter`</ph> instruction, control logically flows back to the CLI exception handling mechanism.</source>
          <target state="translated">実行した後、<ph id="ph1">`endfilter`</ph>命令の制御に論理的にフロー CLI の例外処理機構にします。</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Control cannot be transferred into a filter block except through the exception mechanism.</source>
          <target state="translated">例外処理機構を通じてを除くフィルター ブロックに制御を転送できません。</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>Control cannot be transferred out of a filter block except through the use of a <ph id="ph1">`throw`</ph> instruction or by executing the final <ph id="ph2">`endfilter`</ph> instruction.</source>
          <target state="translated">コントロールは、以外を使用すると、フィルター ブロック外へ転送することはできません、<ph id="ph1">`throw`</ph>命令または最終的なを実行することによって<ph id="ph2">`endfilter`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>You cannot embed a <ph id="ph1">`try`</ph> block within a <ph id="ph2">`filter`</ph> block.</source>
          <target state="translated">埋め込むことはできません、<ph id="ph1">`try`</ph>ブロック内で、<ph id="ph2">`filter`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>If an exception is thrown inside the <ph id="ph1">`filter`</ph> block, it is intercepted and a value of 0 (<ph id="ph2">`exception_continue_search`</ph>) is returned.</source>
          <target state="translated">内部例外がスローされた場合、<ph id="ph1">`filter`</ph>ブロックが傍受と 0 の値 (<ph id="ph2">`exception_continue_search`</ph>) が返されます。</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`endfilter`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`endfilter`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfilter">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Transfers control from the <ph id="ph1">&lt;see langword="fault" /&gt;</ph> or <ph id="ph2">&lt;see langword="finally" /&gt;</ph> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</source>
          <target state="translated">例外ブロックの <ph id="ph1">&lt;see langword="fault" /&gt;</ph> 句または <ph id="ph2">&lt;see langword="finally" /&gt;</ph> 句から共通言語基盤 (CLI) 例外ハンドラーに制御を転送します。</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>DC</source>
          <target state="translated">DC</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>endfinally</source>
          <target state="translated">endfinally</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>endfault</source>
          <target state="translated">endfault</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Ends the <ph id="ph1">`finally`</ph> or <ph id="ph2">`fault`</ph> clause of an exception block.</source>
          <target state="translated">終了、<ph id="ph1">`finally`</ph>または<ph id="ph2">`fault`</ph>例外ブロックの句。</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>There are no stack transition behaviors for this instruction.</source>
          <target state="translated">スタックこの命令の遷移の動作はありません。</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source><ph id="ph1">`Endfinally`</ph> and <ph id="ph2">`endfault`</ph> signal the end of the <ph id="ph3">`finally`</ph> or <ph id="ph4">`fault`</ph> clause so that stack unwinding can continue until the exception handler is invoked.</source>
          <target state="translated"><ph id="ph1">`Endfinally`</ph> および<ph id="ph2">`endfault`</ph>の終わり、<ph id="ph3">`finally`</ph>または<ph id="ph4">`fault`</ph>例外ハンドラーが呼び出されるまでそのスタック アンワインドを継続できるように句。</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The <ph id="ph1">`endfinally`</ph> or <ph id="ph2">`endfault`</ph> instruction transfers control back to the CLI exception mechanism.</source>
          <target state="translated"><ph id="ph1">`endfinally`</ph>または<ph id="ph2">`endfault`</ph>命令は、CLI 例外処理機構に制御を転送します。</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The mechanism then searches for the next <ph id="ph1">`finally`</ph> clause in the chain if the protected block was exited with a leave instruction.</source>
          <target state="translated">次の検索され、メカニズム<ph id="ph1">`finally`</ph>leave 命令で保護されたブロックが終了した場合、チェーン内の句。</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>If the protected block was exited with an exception, the CLI will search for the next <ph id="ph1">`finally`</ph> or <ph id="ph2">`fault`</ph>, or enter the exception handler chosen during the first pass of exception handling.</source>
          <target state="translated">保護されたブロックは例外で終了しましたが場合、CLI、次を検索<ph id="ph1">`finally`</ph>または<ph id="ph2">`fault`</ph>、または例外処理の最初のパスの中に、選択した例外ハンドラーを入力します。</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>An <ph id="ph1">`endfinally`</ph> instruction might only appear lexically within a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated"><ph id="ph1">`endfinally`</ph>命令が構文的に内に表示されるのみ、<ph id="ph2">`finally`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Unlike the <ph id="ph1">`endfilter`</ph> instruction, there is no requirement that the block end with an <ph id="ph2">`endfinally`</ph> instruction, and there can be as many <ph id="ph3">`endfinally`</ph> instructions within the block as required.</source>
          <target state="translated">異なり、<ph id="ph1">`endfilter`</ph>命令でブロックが終了する必要はありません、<ph id="ph2">`endfinally`</ph>命令、およびが多くあります<ph id="ph3">`endfinally`</ph>必要に応じてブロック内の指示します。</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>These same restrictions apply to the <ph id="ph1">`endfault`</ph> instruction and the <ph id="ph2">`fault`</ph> block.</source>
          <target state="translated">これらの同じ制限が適用、<ph id="ph1">`endfault`</ph>命令と<ph id="ph2">`fault`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Control cannot be transferred into a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block except through the exception mechanism.</source>
          <target state="translated">コントロールに転送できません、 <ph id="ph1">`finally`</ph> (または<ph id="ph2">`fault`</ph>) を除く例外処理機構を通じてをブロックします。</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Control cannot be transferred out of a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block except through the use of a <ph id="ph3">`throw`</ph> instruction or executing the <ph id="ph4">`endfinally`</ph> (or <ph id="ph5">`endfault`</ph>) instruction.</source>
          <target state="translated">制御を転送できません、 <ph id="ph1">`finally`</ph> (または<ph id="ph2">`fault`</ph>) の使用によりのブロックを除く、<ph id="ph3">`throw`</ph>命令またはを実行する、 <ph id="ph4">`endfinally`</ph> (または<ph id="ph5">`endfault`</ph>) 命令します。</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>In particular, you cannot "fall out" of a <ph id="ph1">`finally`</ph> (or <ph id="ph2">`fault`</ph>) block or to execute a <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph> or <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction within a <ph id="ph5">`finally`</ph> (or <ph id="ph6">`fault`</ph>) block.</source>
          <target state="translated">具体的には、する落ちることはできません"out"の<ph id="ph1">`finally`</ph>(または<ph id="ph2">`fault`</ph>) ブロックまたは実行する、<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>または<ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph>内の命令、 <ph id="ph5">`finally`</ph> (または<ph id="ph6">`fault`</ph>) ブロックされます。</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>Note that the <ph id="ph1">`endfault`</ph> and <ph id="ph2">`endfinally`</ph> instructions are aliases - they correspond to the same opcode.</source>
          <target state="translated">なお、<ph id="ph1">`endfault`</ph>と<ph id="ph2">`endfinally`</ph>手順については、別名 - 同一の opcode に対応します。</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`endfinally`</ph> (<ph id="ph3">`endfault`</ph>) opcode, as well as the <ph id="ph4">`ILGenerator`</ph> method <ph id="ph5">&lt;xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A&gt;</ph>.</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、 <ph id="ph2">`endfinally`</ph> (<ph id="ph3">`endfault`</ph>) オペコード、だけでなく<ph id="ph4">`ILGenerator`</ph>メソッド<ph id="ph5">&lt;xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Endfinally">
          <source>ILGenerator.EndExceptionBlock()</source>
          <target state="translated">ILGenerator.EndExceptionBlock()</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Initializes a specified block of memory at a specific address to a given size and initial value.</source>
          <target state="translated">特定のアドレスの指定したメモリ ブロックを、指定のサイズと初期値に初期化します。</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>FE 18</source>
          <target state="translated">FE 18</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>initblk</source>
          <target state="translated">initblk</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>Set each location in a block of memory to a given value.</source>
          <target state="translated">指定した値にメモリ ブロックのそれぞれの場所を設定します。</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>A starting address is pushed onto the stack.</source>
          <target state="translated">開始アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>An initialization value is pushed onto the stack.</source>
          <target state="translated">初期値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The number of bytes to initialize is pushed onto the stack.</source>
          <target state="translated">初期化するためにバイトの数は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</source>
          <target state="translated">バイトの数、初期値、開始アドレスは、スタックからポップされます。 され、それらの値に従って、初期化が行われます。</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The <ph id="ph1">`initblk`</ph> instruction sets the number (<ph id="ph2">`unsigned int32`</ph>) of bytes starting at the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or <ph id="ph5">`*`</ph>) to the initialization value (of type <ph id="ph6">`unsigned int8`</ph>).</source>
          <target state="translated"><ph id="ph1">`initblk`</ph>命令数を設定します (<ph id="ph2">`unsigned int32`</ph>) 指定したアドレスで始まるバイト (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または<ph id="ph5">`*`</ph>) の初期化の値に (型の<ph id="ph6">`unsigned int8`</ph>)。</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source><ph id="ph1">`initblk`</ph> assumes that the starting address is aligned to the natural size of the machine.</source>
          <target state="translated"><ph id="ph1">`initblk`</ph> 開始アドレスがマシンの自然なサイズに合わせて配置されると仮定します。</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The operation of the <ph id="ph1">`initblk`</ph> instructions can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`initblk`</ph>手順については、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> may be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローされる可能性がします。</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`initblk`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`initblk`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initblk">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</source>
          <target state="translated">指定したアドレスにある値型の各フィールドを null 参照または適切なプリミティブ型の 0 に初期化します。</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>FE 15 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 15 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source><ph id="ph1">`initobj`</ph> <ph id="ph2">`typeTok`</ph></source>
          <target state="translated"><ph id="ph1">`initobj`</ph> <ph id="ph2">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Initializes a value type.</source>
          <target state="translated">値の型を初期化します。</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The address of the value type to initialize is pushed onto the stack.</source>
          <target state="translated">初期化するために、値型のアドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The address is popped from the stack; the value type at the specified address is initialized as type <ph id="ph1">`typeTok`</ph>.</source>
          <target state="translated">アドレスがスタックからポップされます。指定したアドレスに値の型は型として初期化<ph id="ph1">`typeTok`</ph>です。</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The <ph id="ph1">`initobj`</ph> instruction initializes each field of the value type specified by the pushed address (of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, or <ph id="ph4">`*`</ph>) to a null reference or a 0 of the appropriate primitive type.</source>
          <target state="translated"><ph id="ph1">`initobj`</ph>命令がプッシュされたアドレスで指定された値型の各フィールドを初期化します (型の<ph id="ph2">`native int`</ph>、 <ph id="ph3">`&amp;`</ph>、または<ph id="ph4">`*`</ph>) の参照を null または適切なプリミティブ型の 0 にします。</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>After this method is called, the instance is ready for a constructor method to be called.</source>
          <target state="translated">このメソッドが呼び出された後、インスタンスが呼び出されるコンス トラクター メソッドの準備ができてです。</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>If <ph id="ph1">`typeTok`</ph> is a reference type, this instruction has the same effect as <ph id="ph2">`ldnull`</ph> followed by <ph id="ph3">`stind.ref`</ph>.</source>
          <target state="translated">場合<ph id="ph1">`typeTok`</ph>、参照型では、この命令と同じ効果<ph id="ph2">`ldnull`</ph>続く<ph id="ph3">`stind.ref`</ph>です。</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>Unlike <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>, <ph id="ph2">`initobj`</ph> does not call the constructor method.</source>
          <target state="translated">異なり<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>、<ph id="ph2">`initobj`</ph>コンス トラクター メソッドを呼び出しません。</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source><ph id="ph1">`Initobj`</ph> is intended for initializing value types, while <ph id="ph2">`newobj`</ph> is used to allocate and initialize objects.</source>
          <target state="translated"><ph id="ph1">`Initobj`</ph> 値型の初期化のためのもので、中に<ph id="ph2">`newobj`</ph>の割り当てし、オブジェクトの初期化に使用します。</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`initobj`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`initobj`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Initobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Tests whether an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) is an instance of a particular class.</source>
          <target state="translated">オブジェクト参照 (<ph id="ph1">&lt;see langword="O" /&gt;</ph> 型) が特定のクラスのインスタンスかどうかをテストします。</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>75 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">75 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>isinst <ph id="ph1">`class`</ph></source>
          <target state="translated">isinst <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Tests if an object reference is an instance of <ph id="ph1">`class`</ph>, returning either a null reference or an instance of that class or interface.</source>
          <target state="translated">オブジェクト参照がのインスタンスであるかどうか<ph id="ph1">`class`</ph>null 参照またはそのクラスのインスタンスのいずれかを返すこと、またはインターフェイスします。</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The object reference is popped from the stack and tested to see if it is an instance of the class passed in <ph id="ph1">`class`</ph>.</source>
          <target state="translated">オブジェクト参照がスタックからポップされ、テストするかどうかは渡されたクラスのインスタンスを参照してください<ph id="ph1">`class`</ph>です。</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The result (either an object reference or a null reference) is pushed onto the stack.</source>
          <target state="translated">結果 (オブジェクト参照または null 参照) は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source><ph id="ph1">`Class`</ph> is a metadata token indicating the desired class.</source>
          <target state="translated"><ph id="ph1">`Class`</ph> メタデータ トークンは、希望のクラスを示すです。</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>If the class of the object on the top of the stack implements <ph id="ph1">`class`</ph> (if <ph id="ph2">`class`</ph> is an interface) or is a derived class of <ph id="ph3">`class`</ph> (if <ph id="ph4">`class`</ph> is a regular class) then it is cast to type <ph id="ph5">`class`</ph> and the result is pushed on the stack, exactly as though <ph id="ph6">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph> had been called.</source>
          <target state="translated">スタックの一番上のオブジェクトのクラスを実装するかどうか<ph id="ph1">`class`</ph>(場合<ph id="ph2">`class`</ph>インターフェイス) の派生クラスまたは<ph id="ph3">`class`</ph>(場合<ph id="ph4">`class`</ph>通常のクラス) 型にキャストし、<ph id="ph5">`class`</ph>し、結果は、スタックにプッシュ、正確かのよう<ph id="ph6">&lt;xref:System.Reflection.Emit.OpCodes.Castclass&gt;</ph>が呼び出されました。</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>Otherwise, a null reference is pushed on the stack.</source>
          <target state="translated">それ以外の場合は null 参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>If the object reference itself is a null reference, then <ph id="ph1">`isinst`</ph> likewise returns a null reference.</source>
          <target state="translated">オブジェクト参照自体が null 参照し、<ph id="ph1">`isinst`</ph>同様に null 参照を返します。</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> クラスが見つからない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) の手順が実行時ではなくネイティブ コードに変換された場合に検出します。</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`isinst`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`isinst`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Isinst">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Exits current method and jumps to specified method.</source>
          <target state="translated">現在のメソッドを終了し、指定したメソッドにジャンプします。</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>27 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">27 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>jmp <ph id="ph1">`method`</ph></source>
          <target state="translated">jmp <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>Exit current method and jump to specified method.</source>
          <target state="translated">現在のメソッドを終了し、指定したメソッドにジャンプします。</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>There are no stack transition behaviors for this instruction.</source>
          <target state="translated">スタックこの命令の遷移の動作はありません。</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The <ph id="ph1">`jmp`</ph> (jump) instruction transfers control to the method specified by <ph id="ph2">`method`</ph>, which is a metadata token for a method reference.</source>
          <target state="translated"><ph id="ph1">`jmp`</ph> (移動) の命令は、によって指定されたメソッドに制御を転送<ph id="ph2">`method`</ph>、これは、メソッドの参照のメタデータ トークン。</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The current arguments are transferred to the destination method.</source>
          <target state="translated">現在の引数は、先のメソッドに転送されます。</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The evaluation stack must be empty when this instruction is executed.</source>
          <target state="translated">この命令を実行すると、評価スタックに空にする必要があります。</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The calling convention, number and type of arguments at the destination address must match that of the current method.</source>
          <target state="translated">呼び出し規約、数、および宛先アドレスで引数の型は、現在のメソッドで一致しなければなりません。</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The <ph id="ph1">`jmp`</ph> instruction cannot be used to transferred control out of a <ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, or <ph id="ph5">`finally`</ph> block.</source>
          <target state="translated"><ph id="ph1">`jmp`</ph>命令は、転送の制御を使用することはできません、 <ph id="ph2">`try`</ph>、 <ph id="ph3">`filter`</ph>、 <ph id="ph4">`catch`</ph>、または<ph id="ph5">`finally`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`jmp`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`jmp`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Jmp">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、MethodInfo)</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Loads an argument (referenced by a specified index value) onto the stack.</source>
          <target state="translated">指定したインデックス値によって参照される引数をスタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>FE 09 &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 09 &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>ldarg <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarg <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Load argument at <ph id="ph1">`index`</ph> onto stack.</source>
          <target state="translated">引数を読み込み<ph id="ph1">`index`</ph>をスタックにします。</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The argument value at <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">引数値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The <ph id="ph1">`ldarg`</ph> instruction pushes the argument indexed at <ph id="ph2">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg`</ph>命令がインデックスの引数にプッシュ<ph id="ph2">`index`</ph>場所引数インデックスは 0 から以降、評価スタックに、します。</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The <ph id="ph1">`ldarg`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg`</ph>命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).</source>
          <target state="translated">可変長の引数リストを取得する手順については、<ph id="ph1">`ldarg`</ph>命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph>詳細命令)。</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長より小さい整数値を保持している引数を型に拡張されます<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldarg`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (オペコード、short)</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Loads the argument at index 0 onto the evaluation stack.</source>
          <target state="translated">インデックス 0 の引数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>02</source>
          <target state="translated">02</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>ldarg.0</source>
          <target state="translated">ldarg.0</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Load argument 0 onto stack</source>
          <target state="translated">引数 0 をスタックに読み込みます</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The argument value at index 0 is pushed onto the stack.</source>
          <target state="translated">インデックス 0 の引数の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction is an efficient encoding for loading the argument value at index 0.</source>
          <target state="translated"><ph id="ph1">`ldarg.0`</ph>命令はインデックス 0 の引数の値を読み込むための効率的なエンコーディングします。</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction pushes the argument indexed at 0 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg.0`</ph>命令は引数のインデックスが 0 を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The <ph id="ph1">`ldarg.0`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg.0`</ph>命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長より小さい整数値を保持している引数を型に拡張されます<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.0`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldarg.0`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Loads the argument at index 1 onto the evaluation stack.</source>
          <target state="translated">インデックス 1 の引数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>03</source>
          <target state="translated">03</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>ldarg.1</source>
          <target state="translated">ldarg.1</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Load argument 1 onto stack.</source>
          <target state="translated">引数 1 をスタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The argument value at index 1 is pushed onto the stack.</source>
          <target state="translated">インデックス 1 の引数の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction is an efficient encoding for loading the argument value at index 1.</source>
          <target state="translated"><ph id="ph1">`ldarg.1`</ph>命令はインデックス 1 の引数の値を読み込むための効率的なエンコーディングします。</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction pushes the argument indexed at 1 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg.1`</ph>命令は引数のインデックスが 1 を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The <ph id="ph1">`ldarg.1`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg.1`</ph>命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長より小さい整数値を保持している引数を型に拡張されます<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldarg.1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Loads the argument at index 2 onto the evaluation stack.</source>
          <target state="translated">インデックス 2 の引数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>04</source>
          <target state="translated">04</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>ldarg.2</source>
          <target state="translated">ldarg.2</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Load argument 2 onto stack.</source>
          <target state="translated">引数 2 をスタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The argument value at index 2 is pushed onto the stack.</source>
          <target state="translated">インデックス 2 の引数の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction is an efficient encoding for loading the argument value at index 2.</source>
          <target state="translated"><ph id="ph1">`ldarg.2`</ph>命令はインデックス 2 の引数の値を読み込むための効率的なエンコーディングします。</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction pushes the argument indexed at 2 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg.2`</ph>命令は引数のインデックスが 2 を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The <ph id="ph1">`ldarg.2`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg.2`</ph>命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長より小さい整数値を保持している引数を型に拡張されます<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldarg.2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Loads the argument at index 3 onto the evaluation stack.</source>
          <target state="translated">インデックス 3 の引数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>05</source>
          <target state="translated">05</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>ldarg.3</source>
          <target state="translated">ldarg.3</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Load argument 3 onto stack.</source>
          <target state="translated">引数 3 をスタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The argument value at index 3 is pushed onto the stack.</source>
          <target state="translated">インデックス 3 の引数の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction is an efficient encoding for loading the argument value at index 3.</source>
          <target state="translated"><ph id="ph1">`ldarg.3`</ph>命令はインデックス 3 の引数の値を読み込むための効率的なエンコーディングします。</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction pushes the argument indexed at 3 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg.3`</ph>命令は引数のインデックスが 3 を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The <ph id="ph1">`ldarg.3`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg.3`</ph>命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長より小さい整数値を保持している引数を型に拡張されます<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.3`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldarg.3`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Loads the argument (referenced by a specified short form index) onto the evaluation stack.</source>
          <target state="translated">指定した短い形式のインデックスによって参照される引数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>0E &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">0E &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>ldarg.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarg.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Load argument at <ph id="ph1">`index`</ph> onto stack, short form.</source>
          <target state="translated">引数を読み込み<ph id="ph1">`index`</ph>スタックに短縮形です。</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The argument value at <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">引数値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction is an efficient encoding for loading arguments indexed from 4 through 255.</source>
          <target state="translated"><ph id="ph1">`ldarg.s`</ph>命令はインデックスの引数を読み込む 4 ~ 255 の効率的なエンコーディングします。</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction pushes the argument indexed at <ph id="ph2">`index`</ph>, where arguments are indexed from 0 onwards, onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldarg.s`</ph>命令がインデックスの引数にプッシュ<ph id="ph2">`index`</ph>場所引数インデックスは 0 から以降、評価スタックに、します。</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The <ph id="ph1">`ldarg.s`</ph> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument.</source>
          <target state="translated"><ph id="ph1">`ldarg.s`</ph>命令は、受信の引数からコピーする値型またはプリミティブ値をスタックを読み込みを使用することができます。</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</source>
          <target state="translated">引数の値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph> instruction for more details).</source>
          <target state="translated">可変長の引数リストを取得する手順については、<ph id="ph1">`ldarg.s`</ph>命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Arglist&gt;</ph>詳細命令)。</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長より小さい整数値を保持している引数を型に拡張されます<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarg.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldarg.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarg_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (オペコード, byte)</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Load an argument address onto the evaluation stack.</source>
          <target state="translated">引数アドレスを評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>FE 0A &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0A &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>ldarga <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarga <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>Fetch the address of argument indexed by <ph id="ph1">`index`</ph>.</source>
          <target state="translated">インデックスが引数のアドレスをフェッチ<ph id="ph1">`index`</ph>です。</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The address <ph id="ph1">`addr`</ph> of the argument indexed by <ph id="ph2">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">アドレス<ph id="ph1">`addr`</ph>によってインデックスの引数の<ph id="ph2">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The <ph id="ph1">`ldarga`</ph> instruction fetches the address (of type <ph id="ph2">`*`</ph>) of the argument indexed by <ph id="ph3">`index`</ph>, where arguments are indexed from 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldarga`</ph>命令アドレスがフェッチされます (型の<ph id="ph2">`*`</ph>) インデックスが引数の<ph id="ph3">`index`</ph>場所引数のインデックスは 0 以降から、します。</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The address <ph id="ph1">`addr`</ph> is always aligned to a natural boundary on the target machine.</source>
          <target state="translated">アドレス<ph id="ph1">`addr`</ph>は、常に対象のコンピューターで自然な境界に配置します。</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarga`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">可変長の引数リストを取得する手順については、<ph id="ph1">`ldarga`</ph>命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます。</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source><ph id="ph1">`ldarga`</ph> is used for by-ref parameter passing.</source>
          <target state="translated"><ph id="ph1">`ldarga`</ph> 参照渡しによるパラメーターの引き渡しに使用されます。</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>For other cases, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg&gt;</ph> should be used.</source>
          <target state="translated">それ以外の場合の<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg&gt;</ph>使用する必要があります。</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarga`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldarga`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (オペコード、short)</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Load an argument address, in short form, onto the evaluation stack.</source>
          <target state="translated">引数アドレス (短い形式) を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>0F &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">0F &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>ldarga.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldarga.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>Fetch the address of argument indexed by <ph id="ph1">`index`</ph>, short form.</source>
          <target state="translated">インデックスが引数のアドレスをフェッチ<ph id="ph1">`index`</ph>、短縮形です。</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The address <ph id="ph1">`addr`</ph> of the argument indexed by <ph id="ph2">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">アドレス<ph id="ph1">`addr`</ph>によってインデックスの引数の<ph id="ph2">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source><ph id="ph1">`ldarga.s`</ph> (the short form of <ph id="ph2">`ldarga`</ph>) should be used for argument numbers 0 through 255, and is a more efficient encoding.</source>
          <target state="translated"><ph id="ph1">`ldarga.s`</ph> (短い形式の<ph id="ph2">`ldarga`</ph>) 0 ~ 255 の数値の引数を使用し、効率的なエンコーディングがします。</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The <ph id="ph1">`ldarga.s`</ph> instruction fetches the address (of type<ph id="ph2">`*`</ph>) of the argument indexed by <ph id="ph3">`index`</ph>, where arguments are indexed from 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldarga.s`</ph>命令アドレスがフェッチされます (型の<ph id="ph2">`*`</ph>) インデックスが引数の<ph id="ph3">`index`</ph>場所引数のインデックスは 0 以降から、します。</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The address <ph id="ph1">`addr`</ph> is always aligned to a natural boundary on the target machine.</source>
          <target state="translated">アドレス<ph id="ph1">`addr`</ph>は、常に対象のコンピューターで自然な境界に配置します。</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>For procedures that take a variable-length argument list, the <ph id="ph1">`ldarga.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">可変長の引数リストを取得する手順については、<ph id="ph1">`ldarga.s`</ph>命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます。</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source><ph id="ph1">`ldarga.s`</ph> is used for by-ref parameter passing.</source>
          <target state="translated"><ph id="ph1">`ldarga.s`</ph> 参照渡しによるパラメーターの引き渡しに使用されます。</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>For other cases, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg_S&gt;</ph> should be used.</source>
          <target state="translated">それ以外の場合の<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldarg_S&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Starg_S&gt;</ph>使用する必要があります。</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldarga.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldarga.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldarga_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (オペコード, byte)</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">提供された <ph id="ph1">&lt;see langword="int32" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>20 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">20 &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>ldc.i4 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.i4 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Pushes the value <ph id="ph1">`num`</ph> onto the stack.</source>
          <target state="translated">値をプッシュ<ph id="ph1">`num`</ph>をスタックにします。</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">値<ph id="ph1">`num`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8.</source>
          <target state="translated">整数-128 ~-1 ~ 8 の 127 と特に短いエンコーディングの短い (とそのためより効率的な) の特殊なエンコードがあることに注意してください。</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>All short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms.</source>
          <target state="translated">8 バイト整数 4、8 バイト浮動小数点数と短い形式に適合しない 4 バイト値の長いエンコーディングが使用されます。</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>There are three ways to push an 8 byte integer constant onto the stack</source>
          <target state="translated">8 バイト整数定数をスタックにプッシュする 3 つの方法します。</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I8&gt;</ph> instruction for constants that must be expressed in more than 32 bits.</source>
          <target state="translated">使用して、 <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I8&gt;</ph> 32 ビット以上で表現する必要がある定数の命令。</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4&gt;</ph> instruction followed by a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that require 9 to 32 bits.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4&gt;</ph>命令を実行して、 <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> 9 を 32 ビットを必要とする定数をします。</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>Use a short form instruction followed by a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> for constants that can be expressed in 8 or fewer bits.</source>
          <target state="translated">続けて、短い形式の命令を使用して、 <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Conv_I8&gt;</ph> 8 個以下のビット単位で表すことができる定数。</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4">
          <source>ILGenerator.Emit(OpCode, int)</source>
          <target state="translated">ILGenerator.Emit (オペコード、int)</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Pushes the integer value of 0 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">整数値 0 を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>16</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>ldc.i4.0</source>
          <target state="translated">ldc.i4.0</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>Pushes 0 onto the stack.</source>
          <target state="translated">0、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The value 0 is pushed onto the stack.</source>
          <target state="translated">値 0 は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">これは、特殊な短いエンコードを整数値 0 のプッシュです。</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.0`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.0`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Pushes the integer value of 1 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">整数値 1 を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>17</source>
          <target state="translated">17</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>ldc.i4.1</source>
          <target state="translated">ldc.i4.1</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>Pushes 1 onto the stack.</source>
          <target state="translated">1 をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The value 1 is pushed onto the stack.</source>
          <target state="translated">値 1 は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">これは、特殊な短いエンコードを整数値 0 のプッシュです。</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Pushes the integer value of 2 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">整数値 2 を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>18</source>
          <target state="translated">18</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>ldc.i4.2</source>
          <target state="translated">ldc.i4.2</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>Pushes 2 onto the stack.</source>
          <target state="translated">2 をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The value 2 is pushed onto the stack.</source>
          <target state="translated">2 という値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">これは、特殊な短いエンコードを整数値 0 のプッシュです。</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Pushes the integer value of 3 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">整数値 3 を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>19</source>
          <target state="translated">19</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>ldc.i4.3</source>
          <target state="translated">ldc.i4.3</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>Pushes 3 onto the stack.</source>
          <target state="translated">3 をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The value 3 is pushed onto the stack.</source>
          <target state="translated">値 3 は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">これは、特殊な短いエンコードを整数値 0 のプッシュです。</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.3`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.3`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Pushes the integer value of 4 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">整数値 4 を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>1A</source>
          <target state="translated">1A</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>ldc.i4.4</source>
          <target state="translated">ldc.i4.4</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>Pushes 4 onto the stack.</source>
          <target state="translated">4 をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The value 4 is pushed onto the stack.</source>
          <target state="translated">4 という値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">これは、特殊な短いエンコードを整数値 0 のプッシュです。</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Pushes the integer value of 5 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">整数値 5 を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>1B</source>
          <target state="translated">1B</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>ldc.i4.5</source>
          <target state="translated">ldc.i4.5</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>Pushes 5 onto the stack.</source>
          <target state="translated">5 をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The value 5 is pushed onto the stack.</source>
          <target state="translated">値 5 は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">これは、特殊な短いエンコードを整数値 0 のプッシュです。</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.5`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.5`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_5">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Pushes the integer value of 6 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">整数値 6 を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>1C</source>
          <target state="translated">1C</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>ldc.i4.6</source>
          <target state="translated">ldc.i4.6</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>Pushes 6 onto the stack.</source>
          <target state="translated">6 をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The value 6 is pushed onto the stack.</source>
          <target state="translated">値 6 は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">これは、特殊な短いエンコードを整数値 0 のプッシュです。</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.6`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.6`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_6">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Pushes the integer value of 7 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">整数値 7 を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>1D</source>
          <target state="translated">1D</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>ldc.i4.7</source>
          <target state="translated">ldc.i4.7</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>Pushes 7 onto the stack.</source>
          <target state="translated">7 をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The value 7 is pushed onto the stack.</source>
          <target state="translated">7 の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">これは、特殊な短いエンコードを整数値 0 のプッシュです。</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.7`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.7`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_7">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Pushes the integer value of 8 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">整数値 8 を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>1E</source>
          <target state="translated">1E</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>ldc.i4.8</source>
          <target state="translated">ldc.i4.8</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>Pushes 8 onto the stack.</source>
          <target state="translated">8 をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The value 8 is pushed onto the stack.</source>
          <target state="translated">8 の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">これは、特殊な短いエンコードを整数値 0 のプッシュです。</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Pushes the integer value of -1 onto the evaluation stack as an <ph id="ph1">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">整数値 -1 を <ph id="ph1">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>15</source>
          <target state="translated">16</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>ldc.i4.m1</source>
          <target state="translated">ldc.i4.m1</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>Pushes -1 onto the stack.</source>
          <target state="translated">-1 をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The value -1 is pushed onto the stack.</source>
          <target state="translated">値-1 は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>This is a special short encoding for the push of the integer value 0.</source>
          <target state="translated">これは、特殊な短いエンコードを整数値 0 のプッシュです。</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>All special short encodings push 4 byte integers on the stack.</source>
          <target state="translated">すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.m1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.m1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Pushes the supplied <ph id="ph1">&lt;see langword="int8" /&gt;</ph> value onto the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>, short form.</source>
          <target state="translated">提供された <ph id="ph1">&lt;see langword="int8" /&gt;</ph> 値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックにプッシュします (短い形式)。</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>1F &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">1F &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>ldc.i4.s <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.i4.s <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`int32`</ph>, short form.</source>
          <target state="translated">プッシュ<ph id="ph1">`num`</ph>としてスタック<ph id="ph2">`int32`</ph>、短縮形です。</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">値<ph id="ph1">`num`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source><ph id="ph1">`ldc.i4.s`</ph> is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</source>
          <target state="translated"><ph id="ph1">`ldc.i4.s`</ph> -128 から 127 の整数を評価スタックにプッシュのエンコードをより効率的です。</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i4.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i4.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I4_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (オペコード, byte)</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> onto the evaluation stack as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">提供された <ph id="ph1">&lt;see langword="int64" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="int64" /&gt;</ph> として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>21 &lt; <ph id="ph1">`int64`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">21 &lt; <ph id="ph1">`int64`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>ldc.i8 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.i8 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`int64`</ph>.</source>
          <target state="translated">プッシュ<ph id="ph1">`num`</ph>としてスタック<ph id="ph2">`int64`</ph>です。</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">値<ph id="ph1">`num`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>This encoding pushes an <ph id="ph1">`int64`</ph> value onto the stack.</source>
          <target state="translated">このエンコーディング、<ph id="ph1">`int64`</ph>の値をスタックします。</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.i8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.i8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_I8">
          <source>ILGenerator.Emit(OpCode, long)</source>
          <target state="translated">ILGenerator.Emit (オペコード、長い)</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> onto the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">提供された <ph id="ph1">&lt;see langword="float32" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) 型として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>22 &lt; <ph id="ph1">`float32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">22 &lt; <ph id="ph1">`float32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>ldc.r4 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.r4 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`F`</ph>.</source>
          <target state="translated">プッシュ<ph id="ph1">`num`</ph>としてスタック<ph id="ph2">`F`</ph>です。</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">値<ph id="ph1">`num`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>This encoding pushes a <ph id="ph1">`float32`</ph> value onto the stack.</source>
          <target state="translated">このエンコーディング、<ph id="ph1">`float32`</ph>の値をスタックします。</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.r4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.r4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R4">
          <source>ILGenerator.Emit(OpCode, single)</source>
          <target state="translated">ILGenerator.Emit (オペコード、1 つ)</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Pushes a supplied value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> onto the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">提供された <ph id="ph1">&lt;see langword="float64" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) 型として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>23 &lt; <ph id="ph1">`float64`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">23 &lt; <ph id="ph1">`float64`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>ldc.r8 <ph id="ph1">`num`</ph></source>
          <target state="translated">ldc.r8 <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>Pushes <ph id="ph1">`num`</ph> onto the stack as <ph id="ph2">`F`</ph>.</source>
          <target state="translated">プッシュ<ph id="ph1">`num`</ph>としてスタック<ph id="ph2">`F`</ph>です。</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The value <ph id="ph1">`num`</ph> is pushed onto the stack.</source>
          <target state="translated">値<ph id="ph1">`num`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>This encoding pushes a <ph id="ph1">`float64`</ph> value onto the stack.</source>
          <target state="translated">このエンコーディング、<ph id="ph1">`float64`</ph>の値をスタックします。</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldc.r8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldc.r8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldc_R8">
          <source>ILGenerator.Emit(OpCode, double)</source>
          <target state="translated">ILGenerator.Emit (オペコード、double)</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction.</source>
          <target state="translated">指定した配列インデックスの要素を命令で指定された型として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>A3 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A3 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>ldelem <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">ldelem <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Loads the element at <ph id="ph1">`index`</ph> onto the top of the stack as type <ph id="ph2">`typeTok`</ph>.</source>
          <target state="translated">位置にある要素を読み込みます<ph id="ph1">`index`</ph>型としてのスタックの一番上に<ph id="ph2">`typeTok`</ph>です。</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The <ph id="ph1">`ldelem`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>Arrays are objects, and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列は、オブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The type of the return value is specified by the token <ph id="ph1">`typeTok`</ph> in the instruction.</source>
          <target state="translated">戻り値の型が、トークンで指定された<ph id="ph1">`typeTok`</ph>命令でします。</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the upper bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値の上限よりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> at a specified array index onto the top of the evaluation stack as a <ph id="ph2">&lt;see langword="native int" /&gt;</ph>.</source>
          <target state="translated">指定した配列インデックスの <ph id="ph1">&lt;see langword="native int" /&gt;</ph> 型の要素を <ph id="ph2">&lt;see langword="native int" /&gt;</ph> として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>97</source>
          <target state="translated">97</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>ldelem.i</source>
          <target state="translated">ldelem.i</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Loads the element with type <ph id="ph1">`native int`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as a <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">型を持つ要素を読み込みます<ph id="ph1">`native int`</ph>で<ph id="ph2">`index`</ph>としてスタックの一番上、<ph id="ph3">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The <ph id="ph1">`ldelem.i`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.i`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The return value for <ph id="ph1">`ldelem.i`</ph> is <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.i`</ph>は<ph id="ph2">`native int`</ph>します。</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.i`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">指定した配列インデックスの <ph id="ph1">&lt;see langword="int8" /&gt;</ph> 型の要素を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>90</source>
          <target state="translated">90</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>ldelem.i1</source>
          <target state="translated">ldelem.i1</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Loads the element with type <ph id="ph1">`int8`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">型を持つ要素を読み込みます<ph id="ph1">`int8`</ph>で<ph id="ph2">`index`</ph>としてスタックの一番上、<ph id="ph3">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The <ph id="ph1">`ldelem.i1`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.i1`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The return value for <ph id="ph1">`ldelem.i1`</ph> is <ph id="ph2">`int8`</ph>.</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.i1`</ph>は<ph id="ph2">`int8`</ph>します。</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.i1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">指定した配列インデックスの <ph id="ph1">&lt;see langword="int16" /&gt;</ph> 型の要素を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>92</source>
          <target state="translated">92</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>ldelem.i2</source>
          <target state="translated">ldelem.i2</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Loads the element with type <ph id="ph1">`int16`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">型を持つ要素を読み込みます<ph id="ph1">`int16`</ph>で<ph id="ph2">`index`</ph>としてスタックの一番上、<ph id="ph3">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The <ph id="ph1">`ldelem.i2`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.i2`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The return value for <ph id="ph1">`ldelem.i2`</ph> is <ph id="ph2">`int16`</ph>.</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.i2`</ph>は<ph id="ph2">`int16`</ph>します。</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.i2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">指定した配列インデックスの <ph id="ph1">&lt;see langword="int32" /&gt;</ph> 型の要素を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>94</source>
          <target state="translated">94</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>ldelem.i4</source>
          <target state="translated">ldelem.i4</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Loads the element with type <ph id="ph1">`int32`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">型を持つ要素を読み込みます<ph id="ph1">`int32`</ph>で<ph id="ph2">`index`</ph>としてスタックの一番上、<ph id="ph3">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The <ph id="ph1">`ldelem.i4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.i4`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The return value for <ph id="ph1">`ldelem.i4`</ph> is <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.i4`</ph>は<ph id="ph2">`int32`</ph>します。</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.i4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph>.</source>
          <target state="translated">指定した配列インデックスの <ph id="ph1">&lt;see langword="int64" /&gt;</ph> 型の要素を <ph id="ph2">&lt;see langword="int64" /&gt;</ph> として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>96</source>
          <target state="translated">96</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>ldelem.i8</source>
          <target state="translated">ldelem.i8</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Loads the element with type <ph id="ph1">`int64`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int64`</ph>.</source>
          <target state="translated">型を持つ要素を読み込みます<ph id="ph1">`int64`</ph>で<ph id="ph2">`index`</ph>としてスタックの一番上、<ph id="ph3">`int64`</ph>です。</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The <ph id="ph1">`ldelem.i8`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.i8`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The return value for <ph id="ph1">`ldelem.i8`</ph> is <ph id="ph2">`int64`</ph>.</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.i8`</ph>は<ph id="ph2">`int64`</ph>します。</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.i8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.i8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">指定した配列インデックスの <ph id="ph1">&lt;see langword="float32" /&gt;</ph> 型の要素を <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) 型として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>98</source>
          <target state="translated">98</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>ldelem.r4</source>
          <target state="translated">ldelem.r4</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Loads the element with type <ph id="ph1">`float32`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">型を持つ要素を読み込みます<ph id="ph1">`float32`</ph>で<ph id="ph2">`index`</ph>型としてのスタックの一番上に<ph id="ph3">`F`</ph>です。</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The <ph id="ph1">`ldelem.r4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.r4`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The return value for <ph id="ph1">`ldelem.r4`</ph> is <ph id="ph2">`float32`</ph>.</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.r4`</ph>は<ph id="ph2">`float32`</ph>します。</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>Floating-point values are converted to type <ph id="ph1">`F`</ph> when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値が型に変換されます<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときにします。</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.r4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.r4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> at a specified array index onto the top of the evaluation stack as type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float).</source>
          <target state="translated">指定した配列インデックスの <ph id="ph1">&lt;see langword="float64" /&gt;</ph> 型の要素を <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) 型として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>99</source>
          <target state="translated">99</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>ldelem.r8</source>
          <target state="translated">ldelem.r8</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Loads the element with type <ph id="ph1">`float64`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">型を持つ要素を読み込みます<ph id="ph1">`float64`</ph>で<ph id="ph2">`index`</ph>型としてのスタックの一番上に<ph id="ph3">`F`</ph>です。</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The <ph id="ph1">`ldelem.r8`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.r8`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The return value for <ph id="ph1">`ldelem.r8`</ph> is <ph id="ph2">`float64`</ph>.</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.r8`</ph>は<ph id="ph2">`float64`</ph>します。</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>Floating-point values are converted to type <ph id="ph1">`F`</ph> when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値が型に変換されます<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときにします。</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.r8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.r8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <ph id="ph1">&lt;see langword="O" /&gt;</ph> (object reference).</source>
          <target state="translated">指定した配列インデックスのオブジェクト参照を格納している要素を <ph id="ph1">&lt;see langword="O" /&gt;</ph> 型 (オブジェクト参照) として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>9A</source>
          <target state="translated">9A</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>ldelem.ref</source>
          <target state="translated">ldelem.ref</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Loads the element with an object reference at <ph id="ph1">`index`</ph> onto the top of the stack as type <ph id="ph2">`O`</ph>.</source>
          <target state="translated">オブジェクト参照を持つ要素を読み込みます<ph id="ph1">`index`</ph>型としてのスタックの一番上に<ph id="ph2">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The <ph id="ph1">`ldelem.ref`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.ref`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The return value for <ph id="ph1">`ldelem.ref`</ph> is type <ph id="ph2">`O`</ph> (object reference).</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.ref`</ph>は型です。 <ph id="ph2">`O`</ph> (オブジェクト参照)。</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.ref`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.ref`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">指定した配列インデックスの <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> 型の要素を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>91</source>
          <target state="translated">91</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>ldelem.u1</source>
          <target state="translated">ldelem.u1</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Loads the element with type <ph id="ph1">`unsigned int8`</ph> at <ph id="ph2">`index`</ph> onto the top of the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">型を持つ要素を読み込みます<ph id="ph1">`unsigned int8`</ph>で<ph id="ph2">`index`</ph>としてスタックの一番上、<ph id="ph3">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The <ph id="ph1">`ldelem.u1`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.u1`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The return value for <ph id="ph1">`ldelem.u1`</ph> is <ph id="ph2">`int8`</ph>.</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.u1`</ph>は<ph id="ph2">`int8`</ph>します。</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.u1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">指定した配列インデックスの <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> 型の要素を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>93</source>
          <target state="translated">93</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>ldelem.u2</source>
          <target state="translated">ldelem.u2</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Loads the element with type <ph id="ph1">`unsigned int16`</ph> at index onto the top of the stack as an <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">型を持つ要素を読み込みます<ph id="ph1">`unsigned int16`</ph>としてスタックの一番上のインデックスにある、<ph id="ph2">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The <ph id="ph1">`ldelem.u2`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.u2`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The return value for <ph id="ph1">`ldelem.u2`</ph> is <ph id="ph2">`int16`</ph>.</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.u2`</ph>は<ph id="ph2">`int16`</ph>します。</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.u2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Loads the element with type <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> at a specified array index onto the top of the evaluation stack as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph>.</source>
          <target state="translated">指定した配列インデックスの <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> 型の要素を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>95</source>
          <target state="translated">95</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>ldelem.u4</source>
          <target state="translated">ldelem.u4</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Loads the element with type <ph id="ph1">`unsigned int32`</ph> at index onto the top of the stack as an <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">型を持つ要素を読み込みます<ph id="ph1">`unsigned int32`</ph>としてスタックの一番上のインデックスにある、<ph id="ph2">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the value stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されている値<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The <ph id="ph1">`ldelem.u4`</ph> instruction loads the value of the element with index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelem.u4`</ph>命令は、インデックスを持つ要素の値を読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The return value for <ph id="ph1">`ldelem.u4`</ph> is <ph id="ph2">`int32`</ph>.</source>
          <target state="translated">戻り値<ph id="ph1">`ldelem.u4`</ph>は<ph id="ph2">`int32`</ph>します。</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if array does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 配列が必要な型の要素を保持していない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelem.u4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelem.u4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelem_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph> (managed pointer).</source>
          <target state="translated">指定した配列インデックスにある配列要素のアドレスを <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph> 型 (マネージ ポインター) として評価スタックの一番上に読み込みます。</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>8F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>ldelema <ph id="ph1">`class`</ph></source>
          <target state="translated">ldelema <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Loads the address of the array element at <ph id="ph1">`index`</ph> onto the top of the evaluation stack as type <ph id="ph2">`&amp;`</ph> (managed pointer).</source>
          <target state="translated">ある配列要素のアドレスをロード<ph id="ph1">`index`</ph>型として評価スタックの一番上<ph id="ph2">`&amp;`</ph>(マネージ ポインター)。</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>An object reference <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>An index value <ph id="ph1">`index`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値<ph id="ph1">`index`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">`index`</ph> and <ph id="ph2">`array`</ph> are popped from the stack; the address stored at position <ph id="ph3">`index`</ph> in <ph id="ph4">`array`</ph> is looked up.</source>
          <target state="translated"><ph id="ph1">`index`</ph> および<ph id="ph2">`array`</ph>スタックからポップされます。 位置に格納されているアドレス<ph id="ph3">`index`</ph>で<ph id="ph4">`array`</ph>が検索されます。</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The <ph id="ph1">`ldelema`</ph> is used to retrieve the address of an object at a particular index in an array of objects (of type <ph id="ph2">`class`</ph>).</source>
          <target state="translated"><ph id="ph1">`ldelema`</ph>オブジェクトの配列内の特定のインデックスにあるオブジェクトのアドレスを取得するために使用 (型の<ph id="ph2">`class`</ph>)。</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The <ph id="ph1">`ldelema`</ph> instruction loads the address of the value at index <ph id="ph2">`index`</ph> (type <ph id="ph3">`native int`</ph>) in the zero-based one-dimensional array <ph id="ph4">`array`</ph> and places it on the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldelema`</ph>命令は、インデックスの値のアドレスを読み込みます<ph id="ph2">`index`</ph>(型<ph id="ph3">`native int`</ph>)、0 から始まる 1 次元の配列<ph id="ph4">`array`</ph>し、スタックの一番上に配置します。</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The value must be of type <ph id="ph1">`class`</ph> passed with the instruction.</source>
          <target state="translated">値型でなければなりません<ph id="ph1">`class`</ph>命令で渡されます。</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The return value for <ph id="ph1">`ldelema`</ph> is a managed pointer (type <ph id="ph2">`&amp;`</ph>).</source>
          <target state="translated">戻り値<ph id="ph1">`ldelema`</ph>マネージ ポインター (型<ph id="ph2">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldelema`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldelema`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldelema">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Finds the value of a field in the object whose reference is currently on the evaluation stack.</source>
          <target state="translated">参照が現在評価スタック上にあるオブジェクト内のフィールドの値を検索します。</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>7B &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7B &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>ldfld <ph id="ph1">`field`</ph></source>
          <target state="translated">ldfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>Pushes the value of a field in a specified object onto the stack.</source>
          <target state="translated">指定したオブジェクトをスタック内のフィールドの値をプッシュします。</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>An object reference (or pointer) is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照 (またはポインター) は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</source>
          <target state="translated">オブジェクト参照 (またはポインター) が、スタックからポップされます。オブジェクトの指定されたフィールドの値が見つかりました。</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The value stored in the field is pushed onto the stack.</source>
          <target state="translated">フィールドに格納されている値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The <ph id="ph1">`ldfld`</ph> instruction pushes the value of a field located in an object onto the stack.</source>
          <target state="translated"><ph id="ph1">`ldfld`</ph>命令がスタックにオブジェクトにあるフィールドの値にプッシュします。</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object must be on the stack as an object reference (type <ph id="ph1">`O`</ph>), a managed pointer (type <ph id="ph2">`&amp;`</ph>), an unmanaged pointer (type <ph id="ph3">`native int`</ph>), a transient pointer (type <ph id="ph4">`*`</ph>), or an instance of a value type.</source>
          <target state="translated">オブジェクトはスタック上でのオブジェクト参照としてする必要があります (型<ph id="ph1">`O`</ph>)、マネージ ポインター (型<ph id="ph2">`&amp;`</ph>)、アンマネージ ポインター (型<ph id="ph3">`native int`</ph>)、一時的なポインター (型<ph id="ph4">`*`</ph>)、または値型のインスタンス。</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The use of an unmanaged pointer is not permitted in verifiable code.</source>
          <target state="translated">検証可能なコードでは、アンマネージ ポインターは使用できません。</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The object's field is specified by a metadata token that must refer to a field member.</source>
          <target state="translated">オブジェクトのフィールドは、フィールドのメンバーを参照する必要があるメタデータ トークンによって指定されます。</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The return type is the same as the one associated with the field.</source>
          <target state="translated">戻り値の型は、フィールドに関連付けられているものと同じです。</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The field may be either an instance field (in which case the object must not be a null reference) or a static field.</source>
          <target state="translated">フィールドは、インスタンス フィールド (その場合は、オブジェクトすることはできません、null 参照) または静的フィールドのいずれかである可能性があります。</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The <ph id="ph1">`ldfld`</ph> instruction can be preceded by either or both of the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.</source>
          <target state="translated"><ph id="ph1">`ldfld`</ph>命令の前に、いずれかまたは両方の<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>と<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>プレフィックス。</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> オブジェクトが null と、フィールドは静的でない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> 指定したフィールドは、メタデータ内で見つからない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) の手順については、実行時ではなく、ネイティブ コードに変換する場合にチェックします。</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldfld`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldfld`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、FieldInfo)</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Finds the address of a field in the object whose reference is currently on the evaluation stack.</source>
          <target state="translated">参照が現在評価スタック上にあるオブジェクト内のフィールドのアドレスを検索します。</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>7C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>ldflda <ph id="ph1">`field`</ph></source>
          <target state="translated">ldflda <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>Pushes the address of <ph id="ph1">`field`</ph> in a specified object onto the stack.</source>
          <target state="translated">アドレス プッシュ<ph id="ph1">`field`</ph>をスタックに指定されたオブジェクト。</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>An object reference (or pointer) is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照 (またはポインター) は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</source>
          <target state="translated">オブジェクト参照 (またはポインター) が、スタックからポップされます。オブジェクト内の指定したフィールドのアドレスが検出されます。</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The address of the specified field is pushed onto the stack.</source>
          <target state="translated">指定したフィールドのアドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The <ph id="ph1">`ldflda`</ph> instruction pushes the address of a field located in an object onto the stack.</source>
          <target state="translated"><ph id="ph1">`ldflda`</ph>命令がスタックにオブジェクトにあるフィールドのアドレスにプッシュします。</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object must be on the stack as an object reference (type <ph id="ph1">`O`</ph>), a managed pointer (type <ph id="ph2">`&amp;`</ph>), an unmanaged pointer (type <ph id="ph3">`native int`</ph>), a transient pointer (type <ph id="ph4">`*`</ph>), or an instance of a value type.</source>
          <target state="translated">オブジェクトはスタック上でのオブジェクト参照としてする必要があります (型<ph id="ph1">`O`</ph>)、マネージ ポインター (型<ph id="ph2">`&amp;`</ph>)、アンマネージ ポインター (型<ph id="ph3">`native int`</ph>)、一時的なポインター (型<ph id="ph4">`*`</ph>)、または値型のインスタンス。</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The use of an unmanaged pointer is not permitted in verifiable code.</source>
          <target state="translated">検証可能なコードでは、アンマネージ ポインターは使用できません。</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The object's field is specified by a metadata token that must refer to a field member.</source>
          <target state="translated">オブジェクトのフィールドは、フィールドのメンバーを参照する必要があるメタデータ トークンによって指定されます。</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The value returned by <ph id="ph1">`ldflda`</ph> is a managed pointer (type <ph id="ph2">`&amp;`</ph>) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type <ph id="ph3">`native int`</ph>).</source>
          <target state="translated">によって返される値<ph id="ph1">`ldflda`</ph>マネージ ポインター (型<ph id="ph2">`&amp;`</ph>) オブジェクトを指すアンマネージ ポインターとしてのスタックにプッシュ、しない限り、その場合は、差出人住所もアンマネージ ポインター (型<ph id="ph3">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The <ph id="ph1">`ldflda`</ph> instruction can be preceded by either or both of the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefixes.</source>
          <target state="translated"><ph id="ph1">`ldflda`</ph>命令の前に、いずれかまたは両方の<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>と<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>プレフィックス。</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown if the object is not within the application domain from which it is being accessed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidOperationException&gt;</ph> アクセス元のアプリケーション ドメイン内のオブジェクトがない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The address of a field that is not inside the accessing application domain cannot be loaded.</source>
          <target state="translated">アクセスのアプリケーション ドメイン内ではないフィールドのアドレスを読み込むことができません。</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object is null and the field is not static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> オブジェクトが null と、フィールドは静的でない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if the specified field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> 指定したフィールドは、メタデータ内で見つからない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) の手順については、実行時ではなく、ネイティブ コードに変換する場合にチェックします。</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldflda`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldflda`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldflda">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、FieldInfo)</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Pushes an unmanaged pointer (type <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) to the native code implementing a specific method onto the evaluation stack.</source>
          <target state="translated">特定のメソッドを実装しているネイディブ コードへのアンマネージ ポインター (<ph id="ph1">&lt;see langword="native int" /&gt;</ph> 型) を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>FE 06 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 06 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>ldftn <ph id="ph1">`method`</ph></source>
          <target state="translated">ldftn <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>Pushes a pointer to a method referenced by <ph id="ph1">`method`</ph> on the stack.</source>
          <target state="translated">によって参照されるメソッドへのポインターをプッシュ<ph id="ph1">`method`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The unmanaged pointer to a specific method is pushed onto the stack.</source>
          <target state="translated">特定のメソッドへのアンマネージ ポインターは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The specific method (<ph id="ph1">`method`</ph>) can be called using the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</source>
          <target state="translated">特定のメソッド (<ph id="ph1">`method`</ph>) を使用して呼び出すことができます、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>命令マネージ メソッド (またはアンマネージ コードにマネージ コードから遷移をスタブ) を参照する場合。</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The value returned points to native code using the CLR calling convention.</source>
          <target state="translated">値には、CLR 呼び出し規約を使用してネイティブ コードにポイントが返されます。</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>This method pointer should not be passed to unmanaged native code as a callback routine.</source>
          <target state="translated">このメソッドのポインターは、コールバック ルーチンとしてアンマネージ ネイティブ コードに渡すことはできません。</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldftn`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldftn`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldftn">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、MethodInfo)</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> as a <ph id="ph2">&lt;see langword="native int" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="native int" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="native int" /&gt;</ph> として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>4D</source>
          <target state="translated">4D</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>ldind.i</source>
          <target state="translated">ldind.i</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Loads the <ph id="ph1">`native int`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">読み込み、<ph id="ph1">`native int`</ph>アドレスに<ph id="ph2">`addr`</ph>としてスタック、<ph id="ph3">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにある値を取得します。</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">フェッチされた値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The <ph id="ph1">`ldind.i`</ph> instruction indirectly loads a <ph id="ph2">`native int`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a <ph id="ph5">`native int`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.i`</ph>いない命令は直接読み込みます、<ph id="ph2">`native int`</ph>指定されたアドレスからの値 (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または *)、スタックとして、<ph id="ph5">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.i`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="int8" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>46</source>
          <target state="translated">46</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>ldind.i1</source>
          <target state="translated">ldind.i1</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Loads the <ph id="ph1">`int8`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">読み込み、<ph id="ph1">`int8`</ph>アドレスに<ph id="ph2">`addr`</ph>としてスタック、<ph id="ph3">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにある値を取得します。</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The fetched value is pushed onto the stack..</source>
          <target state="translated">取得した値は、スタックにプッシュされます.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The <ph id="ph1">`ldind.i1`</ph> instruction indirectly loads an <ph id="ph2">`int8`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.i1`</ph>いない命令は直接読み込みます、<ph id="ph2">`int8`</ph>指定されたアドレスからの値 (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または *)、スタックとして、<ph id="ph5">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.i1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="int16" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>48</source>
          <target state="translated">48</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>ldind.i2</source>
          <target state="translated">ldind.i2</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Loads the <ph id="ph1">`int16`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">読み込み、<ph id="ph1">`int16`</ph>アドレスに<ph id="ph2">`addr`</ph>としてスタック、<ph id="ph3">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにある値を取得します。</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">フェッチされた値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The <ph id="ph1">`ldind.i2`</ph> instruction indirectly loads an <ph id="ph2">`int16`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.i2`</ph>いない命令は直接読み込みます、<ph id="ph2">`int16`</ph>指定されたアドレスからの値 (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または *)、スタックとして、<ph id="ph5">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.i2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="int32" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>4A</source>
          <target state="translated">4A</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>ldind.i4</source>
          <target state="translated">ldind.i4</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Loads the <ph id="ph1">`int32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">読み込み、<ph id="ph1">`int32`</ph>アドレスに<ph id="ph2">`addr`</ph>としてスタック、<ph id="ph3">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにある値を取得します。</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">フェッチされた値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The <ph id="ph1">`ldind.i4`</ph> instruction indirectly loads an <ph id="ph2">`int32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.i4`</ph>いない命令は直接読み込みます、<ph id="ph2">`int32`</ph>指定されたアドレスからの値 (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または *)、スタックとして、<ph id="ph5">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.i4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int64" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="int64" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="int64" /&gt;</ph> として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>4C</source>
          <target state="translated">4C</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>ldind.i8</source>
          <target state="translated">ldind.i8</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Loads the <ph id="ph1">`int64`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int64`</ph>.</source>
          <target state="translated">読み込み、<ph id="ph1">`int64`</ph>アドレスに<ph id="ph2">`addr`</ph>としてスタック、<ph id="ph3">`int64`</ph>です。</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにある値を取得します。</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">フェッチされた値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The <ph id="ph1">`ldind.i8`</ph> instruction indirectly loads an <ph id="ph2">`int64`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int64`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.i8`</ph>いない命令は直接読み込みます、<ph id="ph2">`int64`</ph>指定されたアドレスからの値 (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または *)、スタックとして、<ph id="ph5">`int64`</ph>です。</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.i8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.i8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> as a type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) onto the evaluation stack indirectly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="float32" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) 型として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>4E</source>
          <target state="translated">4E</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>ldind.r4</source>
          <target state="translated">ldind.r4</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Loads the <ph id="ph1">`float32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">読み込み、<ph id="ph1">`float32`</ph>アドレスに<ph id="ph2">`addr`</ph>型としてのスタックに<ph id="ph3">`F`</ph>です。</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにある値を取得します。</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">フェッチされた値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The <ph id="ph1">`ldind.r4`</ph> instruction indirectly loads a <ph id="ph2">`float32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a type <ph id="ph5">`F`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.r4`</ph>いない命令は直接読み込みます、<ph id="ph2">`float32`</ph>指定されたアドレスからの値 (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または *) を型としてのスタックに<ph id="ph5">`F`</ph>です。</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.r4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.r4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> as a type <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) onto the evaluation stack indirectly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="float64" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="F" /&gt;</ph> (float) 型として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>4F</source>
          <target state="translated">4F</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>ldind.r8</source>
          <target state="translated">ldind.r8</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Loads the <ph id="ph1">`float64`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as a type <ph id="ph3">`F`</ph>.</source>
          <target state="translated">読み込み、<ph id="ph1">`float64`</ph>アドレスに<ph id="ph2">`addr`</ph>型としてのスタックに<ph id="ph3">`F`</ph>です。</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにある値を取得します。</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">フェッチされた値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The <ph id="ph1">`ldind.r8`</ph> instruction indirectly loads a <ph id="ph2">`float64`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as a <ph id="ph5">`float64`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.r8`</ph>いない命令は直接読み込みます、<ph id="ph2">`float64`</ph>指定されたアドレスからの値 (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または *)、スタックとして、<ph id="ph5">`float64`</ph>です。</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.r8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.r8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Loads an object reference as a type <ph id="ph1">&lt;see langword="O" /&gt;</ph> (object reference) onto the evaluation stack indirectly.</source>
          <target state="translated">オブジェクト参照を <ph id="ph1">&lt;see langword="O" /&gt;</ph> 型 (オブジェクト参照) として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>50</source>
          <target state="translated">50</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>ldind.ref</source>
          <target state="translated">ldind.ref</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Loads the object reference at address <ph id="ph1">`addr`</ph> onto the stack as a type <ph id="ph2">`O`</ph></source>
          <target state="translated">アドレスでのオブジェクト参照を読み込む<ph id="ph1">`addr`</ph>型としてスタック <ph id="ph2">`O`</ph></target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The address is popped from the stack; the object reference located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにあるオブジェクトの参照を取得します。</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The fetched reference is pushed onto the stack.</source>
          <target state="translated">フェッチされた参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The <ph id="ph1">`ldind.ref`</ph> instruction indirectly loads the object reference the specified address (of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`&amp;`</ph>, or *) onto the stack as type <ph id="ph4">`O`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.ref`</ph>命令が指定されたアドレスのオブジェクト参照を直接読み込みます (型の<ph id="ph2">`native int`</ph>、 <ph id="ph3">`&amp;`</ph>、または *)、スタックの種類として<ph id="ph4">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.ref`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.ref`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="unsigned int8" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>47</source>
          <target state="translated">47</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>ldind.u1</source>
          <target state="translated">ldind.u1</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Loads the <ph id="ph1">`unsigned int8`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">読み込み、<ph id="ph1">`unsigned int8`</ph>アドレスに<ph id="ph2">`addr`</ph>としてスタック、<ph id="ph3">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにある値を取得します。</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">フェッチされた値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The <ph id="ph1">`ldind.u1`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int8`</ph> value from the specified address (of type<ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.u1`</ph>いない命令は直接読み込みます、<ph id="ph2">`unsigned int8`</ph>指定されたアドレスからの値 (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または *)、スタックとして、<ph id="ph5">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.u1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="unsigned int16" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>49</source>
          <target state="translated">49</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>ldind.u2</source>
          <target state="translated">ldind.u2</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Loads the <ph id="ph1">`unsigned int16`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">読み込み、<ph id="ph1">`unsigned int16`</ph>アドレスに<ph id="ph2">`addr`</ph>としてスタック、<ph id="ph3">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにある値を取得します。</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">フェッチされた値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The <ph id="ph1">`ldind.u2`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int16`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.u2`</ph>いない命令は直接読み込みます、<ph id="ph2">`unsigned int16`</ph>指定されたアドレスからの値 (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または *)、スタックとして、<ph id="ph5">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.u2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Loads a value of type <ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> as an <ph id="ph2">&lt;see langword="int32" /&gt;</ph> onto the evaluation stack indirectly.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="unsigned int32" /&gt;</ph> 型の値を <ph id="ph2">&lt;see langword="int32" /&gt;</ph> として評価スタックに間接的に読み込みます。</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>4B</source>
          <target state="translated">4B</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>ldind.u4</source>
          <target state="translated">ldind.u4</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Loads the <ph id="ph1">`unsigned int32`</ph> value at address <ph id="ph2">`addr`</ph> onto the stack as an <ph id="ph3">`int32`</ph>.</source>
          <target state="translated">読み込み、<ph id="ph1">`unsigned int32`</ph>アドレスに<ph id="ph2">`addr`</ph>としてスタック、<ph id="ph3">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The address is popped from the stack; the value located at the address is fetched.</source>
          <target state="translated">アドレスがスタックからポップされます。アドレスにある値を取得します。</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The fetched value is pushed onto the stack.</source>
          <target state="translated">フェッチされた値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The <ph id="ph1">`ldind.u4`</ph> instruction indirectly loads an <ph id="ph2">`unsigned int32`</ph> value from the specified address (of type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or *) onto the stack as an <ph id="ph5">`int32`</ph>.</source>
          <target state="translated"><ph id="ph1">`ldind.u4`</ph>いない命令は直接読み込みます、<ph id="ph2">`unsigned int32`</ph>指定されたアドレスからの値 (型の<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または *)、スタックとして、<ph id="ph5">`int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>All of the <ph id="ph1">`ldind`</ph> instructions are shortcuts for a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph> instruction that specifies the corresponding built-in value class.</source>
          <target state="translated">すべての<ph id="ph1">`ldind`</ph>手順については、ショートカット、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldobj&gt;</ph>組み込みの値の対応するクラスを指定する命令です。</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Note that integer values of less than 4 bytes are extended to <ph id="ph1">`int32`</ph> (not <ph id="ph2">`native int`</ph>) when they are loaded onto the evaluation stack.</source>
          <target state="translated">4 バイト未満の整数値に拡張されたことに注意してください<ph id="ph1">`int32`</ph>(いない<ph id="ph2">`native int`</ph>) を評価スタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Floating-point values are converted to <ph id="ph1">`F`</ph> type when loaded onto the evaluation stack.</source>
          <target state="translated">浮動小数点値に変換する<ph id="ph1">`F`</ph>を評価スタックに読み込まれるときに入力します。</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <ph id="ph1">`ldind`</ph> instructions are used in a manner consistent with the type of the pointer.</source>
          <target state="translated">形式が正しい Microsoft Intermediate Language (MSIL) により、<ph id="ph1">`ldind`</ph>命令は、ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can occur (see the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction for preventative measures).</source>
          <target state="translated">最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの自然なサイズに合わせて配置する必要がありますまたは<ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>発生することができます (を参照してください、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>予防策の命令をプレフィックス)。</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The results of all MSIL instructions that return addresses (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) are safely aligned.</source>
          <target state="translated">アドレスを返す MSIL 命令がすべての結果 (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloca&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldarga&gt;</ph>) が安全に配置されています。</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.</source>
          <target state="translated">1 バイトを超えるデータ型、バイトの順序付けはターゲット CPU に依存します。</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>Code that depends on byte ordering might not run on all platforms.</source>
          <target state="translated">バイトの順序付けに依存するコードは、すべてのプラットフォームでは実行されません。</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> can be thrown if an invalid address is detected.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 無効なアドレスが検出された場合にスローできます。</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldind.u4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldind.u4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldind_U4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</source>
          <target state="translated">インデックス番号が 0 から始まる 1 次元配列の要素数を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>8E</source>
          <target state="translated">8E</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>ldlen</source>
          <target state="translated">ldlen</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Pushes the length (of type <ph id="ph1">`natural unsigned int`</ph>) of an array on the stack.</source>
          <target state="translated">長さをプッシュ (型の<ph id="ph1">`natural unsigned int`</ph>) スタックで配列のです。</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>An object reference to an array is pushed onto the stack.</source>
          <target state="translated">配列へのオブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The array reference is popped from the stack and the length is computed.</source>
          <target state="translated">配列参照がスタックからポップされ、長さが計算されます。</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The length is pushed onto the stack.</source>
          <target state="translated">長さは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The length is returned as a <ph id="ph1">`natural unsigned int`</ph>.</source>
          <target state="translated">長さとして返されます、<ph id="ph1">`natural unsigned int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the array reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 配列の参照が null 参照である場合にスローされます。</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldlen`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldlen`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldlen">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Loads the local variable at a specific index onto the evaluation stack.</source>
          <target state="translated">特定のインデックスのローカル変数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>FE 0C &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0C &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ldloc <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloc <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Loads the local variable at index <ph id="ph1">`index`</ph> onto stack.</source>
          <target state="translated">ローカル変数をインデックスに読み込みます<ph id="ph1">`index`</ph>をスタックにします。</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The local variable value at the specified index is pushed onto the stack.</source>
          <target state="translated">指定したインデックスにあるローカル変数の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The <ph id="ph1">`ldloc`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldloc`</ph>命令は、ローカル変数は、番号 0 以降の渡されたインデックスを評価スタックにローカル変数の数の内容をプッシュします。</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true.</source>
          <target state="translated">ローカル変数は、メソッドの初期化フラグが true の場合にのみ、メソッドを入力する前に 0 に初期化されます。</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>There are 65,535 (2^16-1) local variables possible (0-65,534).</source>
          <target state="translated">65,535 がある (2 ^16-1) 使用できるローカル変数 (0 ~ 65,534)。</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method.</source>
          <target state="translated">可能性の高い実装は、特定のメソッドのローカル変数の合計数と共に、ローカルの両方のインデックスを追跡するために、2 バイトの整数を使用して、ので、インデックス 65,535 は有効ではありません。</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</source>
          <target state="translated">65535 のインデックスが行われた有効な場合、このようなメソッドでのローカルの数を追跡するために広く整数が必要になります。</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The <ph id="ph1">`ldloc.0`</ph>, <ph id="ph2">`ldloc.1`</ph>, <ph id="ph3">`ldloc.2`</ph>, and <ph id="ph4">`ldloc.3`</ph> instructions provide an efficient encoding for accessing the first four local variables.</source>
          <target state="translated"><ph id="ph1">`ldloc.0`</ph>、 <ph id="ph2">`ldloc.1`</ph>、 <ph id="ph3">`ldloc.2`</ph>、および<ph id="ph4">`ldloc.3`</ph>手順については、最初の 4 つのローカル変数にアクセスするため、効率的なエンコーディングを提供します。</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長が型に拡張されますよりも小さいをパーティション I. ローカル変数を参照してください<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldloc`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードを使用できる、<ph id="ph2">`ldloc`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit (オペコード、LocalBuilder)</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (オペコード、short)</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Loads the local variable at index 0 onto the evaluation stack.</source>
          <target state="translated">インデックス 0 のローカル変数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>06</source>
          <target state="translated">06</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>ldloc.0</source>
          <target state="translated">ldloc.0</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Loads the local variable at index 0 onto the evaluation stack.</source>
          <target state="translated">インデックス 0 のローカル変数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The local variable value at the index 0 is pushed onto the stack.</source>
          <target state="translated">インデックス 0 のローカル変数の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source><ph id="ph1">`ldloc.0`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 0.</source>
          <target state="translated"><ph id="ph1">`ldloc.0`</ph> 特に効率的なエンコーディングを<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>インデックス 0 のローカル変数へのアクセスを許可します。</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長よりも小さいをローカル変数は、型に拡張されます<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.0`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldloc.0`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Loads the local variable at index 1 onto the evaluation stack.</source>
          <target state="translated">インデックス 1 のローカル変数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>07</source>
          <target state="translated">07</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>ldloc.1</source>
          <target state="translated">ldloc.1</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Loads the local variable at index 1 onto the evaluation stack.</source>
          <target state="translated">インデックス 1 のローカル変数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The local variable value at the index 1 is pushed onto the stack.</source>
          <target state="translated">インデックス 1 のローカル変数の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source><ph id="ph1">`ldloc.1`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 1.</source>
          <target state="translated"><ph id="ph1">`ldloc.1`</ph> 特に効率的なエンコーディングを<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>インデックス 1 のローカル変数へのアクセスを許可します。</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長よりも小さいをローカル変数は、型に拡張されます<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldloc.1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Loads the local variable at index 2 onto the evaluation stack.</source>
          <target state="translated">インデックス 2 のローカル変数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>08</source>
          <target state="translated">08</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>ldloc.2</source>
          <target state="translated">ldloc.2</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Loads the local variable at index 2 onto the evaluation stack.</source>
          <target state="translated">インデックス 2 のローカル変数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The local variable value at the index 2 is pushed onto the stack.</source>
          <target state="translated">インデックス 2 のローカル変数の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source><ph id="ph1">`ldloc.2`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 2.</source>
          <target state="translated"><ph id="ph1">`ldloc.2`</ph> 特に効率的なエンコーディングを<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>インデックス 2 のローカル変数へのアクセスを許可します。</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長よりも小さいをローカル変数は、型に拡張されます<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldloc.2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Loads the local variable at index 3 onto the evaluation stack.</source>
          <target state="translated">インデックス 3 のローカル変数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>09</source>
          <target state="translated">09</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>ldloc.3</source>
          <target state="translated">ldloc.3</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Loads the local variable at index 3 onto the evaluation stack.</source>
          <target state="translated">インデックス 3 のローカル変数を評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The local variable value at the index 3 is pushed onto the stack.</source>
          <target state="translated">インデックス 3 のローカル変数の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source><ph id="ph1">`ldloc.3`</ph> is an especially efficient encoding for <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>, allowing access to the local variable at index 3.</source>
          <target state="translated"><ph id="ph1">`ldloc.3`</ph> 特に効率的なエンコーディングを<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc&gt;</ph>インデックス 3 のローカル変数へのアクセスを許可します。</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長よりも小さいをローカル変数は、型に拡張されます<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloc.3`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldloc.3`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Loads the local variable at a specific index onto the evaluation stack, short form.</source>
          <target state="translated">特定のインデックスのローカル変数を評価スタックに読み込みます (短い形式)。</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>11 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">11 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ldloc.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloc.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Loads the local variable at index <ph id="ph1">`index`</ph> onto stack, short form.</source>
          <target state="translated">ローカル変数をインデックスに読み込みます<ph id="ph1">`index`</ph>スタックに短縮形です。</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The local variable value at the specified index is pushed onto the stack.</source>
          <target state="translated">指定したインデックスにあるローカル変数の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The <ph id="ph1">`ldloc.s`</ph> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldloc.s`</ph>命令は、ローカル変数は、番号 0 以降の渡されたインデックスを評価スタックにローカル変数の数の内容をプッシュします。</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Local variables are initialized to 0 before entering the method if the initialize flag on the method is true.</source>
          <target state="translated">ローカル変数は、メソッドの初期化フラグが true の場合、メソッドを入力する前に 0 に初期化されます。</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than <ph id="ph1">`ldloc`</ph>.</source>
          <target state="translated">256 がある (2 ^8) ローカルで使用できる変数 (0 ~ 255)、短い形式はより効率的なエンコーディング<ph id="ph1">`ldloc`</ph>です。</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The type of the value is the same as the type of the local variable, which is specified in the method header.</source>
          <target state="translated">値の型は、メソッドのヘッダーで指定されているローカル変数の型と同じです。</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <ph id="ph1">`int32`</ph> when they are loaded onto the stack.</source>
          <target state="translated">4 バイト長が型に拡張されますよりも小さいをパーティション I. ローカル変数を参照してください<ph id="ph1">`int32`</ph>をスタックに読み込まれるときです。</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>Floating-point values are expanded to their native size (type <ph id="ph1">`F`</ph>).</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズに拡張されます (型<ph id="ph1">`F`</ph>)。</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldloc.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードを使用できる、<ph id="ph2">`ldloc.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit (オペコード、LocalBuilder)</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloc_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (オペコード, byte)</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Loads the address of the local variable at a specific index onto the evaluation stack.</source>
          <target state="translated">特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます。</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>FE OD &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE OD &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>ldloca <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloca <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>Loads the address of the local variable at <ph id="ph1">`index`</ph> onto the evaluation stack.</source>
          <target state="translated">ローカル変数のアドレスをロード<ph id="ph1">`index`</ph>を評価スタックにします。</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The address stored in the local variable at the specified index is pushed onto the stack.</source>
          <target state="translated">指定したインデックス位置のローカル変数に格納されているアドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The <ph id="ph1">`ldloca`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldloca`</ph>命令は、ローカル変数は、番号 0 以降のスタックに渡されたインデックス ローカル変数の数のアドレスをプッシュします。</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The value pushed on the stack is already aligned correctly for use with instructions like <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</source>
          <target state="translated">スタックにプッシュされた値が既に正しく整列して使用するように指示と共に<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The result is a transient pointer (type <ph id="ph1">`*`</ph>).</source>
          <target state="translated">結果は、一時的なポインター (型<ph id="ph1">`*`</ph>)。</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloca`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldloca`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (オペコード、short)</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Loads the address of the local variable at a specific index onto the evaluation stack, short form.</source>
          <target state="translated">特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます (短い形式)。</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>ldloca.s <ph id="ph1">`index`</ph></source>
          <target state="translated">ldloca.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>Loads the address of the local variable at <ph id="ph1">`index`</ph> onto the evaluation stack, short form.</source>
          <target state="translated">ローカル変数のアドレスをロード<ph id="ph1">`index`</ph>を評価スタックに短縮形です。</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The address stored in the local variable at the specified index is pushed onto the stack.</source>
          <target state="translated">指定したインデックス位置のローカル変数に格納されているアドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The <ph id="ph1">`ldloca.s`</ph> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`ldloca.s`</ph>命令は、ローカル変数は、番号 0 以降のスタックに渡されたインデックス ローカル変数の数のアドレスをプッシュします。</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The value pushed on the stack is already aligned correctly for use with instructions like <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>.</source>
          <target state="translated">スタックにプッシュされた値が既に正しく整列して使用するように指示と共に<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The result is a transient pointer (type <ph id="ph1">`*`</ph>).</source>
          <target state="translated">結果は、一時的なポインター (型<ph id="ph1">`*`</ph>)。</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The <ph id="ph1">`ldloca.s`</ph> instruction provides an efficient encoding for use with the local variables 0 through 255.</source>
          <target state="translated"><ph id="ph1">`ldloca.s`</ph>命令は 0 ~ 255 のローカル変数で使用するための効率的なエンコーディングします。</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldloca.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldloca.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldloca_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (オペコード, byte)</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Pushes a null reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">null 参照 (<ph id="ph1">&lt;see langword="O" /&gt;</ph> 型) を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>14</source>
          <target state="translated">14</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>ldnull</source>
          <target state="translated">ldnull</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>push a null reference onto the stack</source>
          <target state="translated">null 参照をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>A null object reference is pushed onto the stack.</source>
          <target state="translated">Null オブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source><ph id="ph1">`ldnull`</ph> pushes a null reference (type <ph id="ph2">`O`</ph>) on the stack.</source>
          <target state="translated"><ph id="ph1">`ldnull`</ph> null 参照をプッシュ (型<ph id="ph2">`O`</ph>)、スタックにします。</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>This is used to initialize locations before they are populated with data, or when they become deprecated.</source>
          <target state="translated">これは、データが入力されている前に、または禁止になったときに、場所を初期化するために使用されます。</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source><ph id="ph1">`ldnull`</ph> provides a null reference that is size-independent.</source>
          <target state="translated"><ph id="ph1">`ldnull`</ph> サイズに依存しない null 参照を提供します。</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldnull`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldnull`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldnull">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Copies the value type object pointed to by an address to the top of the evaluation stack.</source>
          <target state="translated">アドレスが指す値型オブジェクトを評価スタックの一番上にコピーします。</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>71 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">71 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>ldobj <ph id="ph1">`class`</ph></source>
          <target state="translated">ldobj <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>Copy instance of value type <ph id="ph1">`class`</ph> to the stack.</source>
          <target state="translated">値型のインスタンスのコピー<ph id="ph1">`class`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The address of a value type object is pushed onto the stack.</source>
          <target state="translated">値型のオブジェクトのアドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The address is popped from the stack and the instance at that particular address is looked up.</source>
          <target state="translated">アドレスが、スタックからポップされ、その特定のアドレスで、インスタンスが検索されます。</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The value of the object stored at that address is pushed onto the stack.</source>
          <target state="translated">そのアドレスに格納されているオブジェクトの値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`ldobj`</ph> instruction is used to pass a value type as a parameter.</source>
          <target state="translated"><ph id="ph1">`ldobj`</ph>値の型をパラメーターとして渡す命令を使用します。</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`ldobj`</ph> instruction copies the value pointed to by <ph id="ph2">`addrOfValObj`</ph> (of type <ph id="ph3">`&amp;`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`native int`</ph>) to the top of the stack.</source>
          <target state="translated"><ph id="ph1">`ldobj`</ph>命令が指す値をコピー <ph id="ph2">`addrOfValObj`</ph> (型の<ph id="ph3">`&amp;`</ph>、 <ph id="ph4">`*`</ph>、または<ph id="ph5">`native int`</ph>)、スタックの一番上にします。</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The number of bytes copied depends on the size of the class (as specified by the <ph id="ph1">`class`</ph> parameter).</source>
          <target state="translated">コピーされたバイト数は、クラスのサイズによって異なります (で指定されたとおり、<ph id="ph1">`class`</ph>パラメーター)。</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The <ph id="ph1">`class`</ph> parameter is a metadata token representing the value type.</source>
          <target state="translated"><ph id="ph1">`class`</ph>パラメーターが値型を表すメタデータ トークン。</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The operation of the <ph id="ph1">`ldobj`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`ldobj`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> クラスが見つからない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) の命令が実行時ではなくネイティブ コードに変換されるときに検出します。</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldobj`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldobj`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Pushes the value of a static field onto the evaluation stack.</source>
          <target state="translated">静的フィールドの値を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>7E &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7E &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>ldsfld <ph id="ph1">`field`</ph></source>
          <target state="translated">ldsfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>Push the value of <ph id="ph1">`field`</ph> on the stack.</source>
          <target state="translated">値をプッシュ<ph id="ph1">`field`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The value of the specific field is pushed onto the stack.</source>
          <target state="translated">特定のフィールドの値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The <ph id="ph1">`ldsfld`</ph> instruction pushes the value of a static (shared among all instances of a class) field on the stack.</source>
          <target state="translated"><ph id="ph1">`ldsfld`</ph>命令は、静的 (クラスのすべてのインスタンスで共有) の値をプッシュ、スタックのフィールドです。</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The return type is that associated with the passed metadata token <ph id="ph1">`field`</ph>.</source>
          <target state="translated">戻り値の型は、渡されたメタデータ トークンに関連付けられた<ph id="ph1">`field`</ph>です。</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The <ph id="ph1">`ldsfld`</ph> instruction can have a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.</source>
          <target state="translated"><ph id="ph1">`ldsfld`</ph>命令が持つことができます、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>プレフィックス。</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldsfld`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldsfld`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、FieldInfo)</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Pushes the address of a static field onto the evaluation stack.</source>
          <target state="translated">静的フィールドのアドレスを評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>7F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7F &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>ldsflda <ph id="ph1">`field`</ph></source>
          <target state="translated">ldsflda <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Push the address of <ph id="ph1">`field`</ph> on the stack</source>
          <target state="translated">アドレスをプッシュ<ph id="ph1">`field`</ph>スタック上</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The address of a specific field is pushed onto the stack.</source>
          <target state="translated">特定のフィールドのアドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The <ph id="ph1">`ldsflda`</ph> instruction pushes the address of a static (shared among all instances of a class) field on the stack.</source>
          <target state="translated"><ph id="ph1">`ldsflda`</ph>命令は、静的 (クラスのすべてのインスタンスで共有) のアドレス、プッシュ、スタックのフィールドです。</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The address may be represented as a transient pointer (type <ph id="ph1">`*`</ph>) if the metadata token <ph id="ph2">`field`</ph> refers to a type whose memory is managed.</source>
          <target state="translated">アドレスは、一時的なポインターとして表すことができます (型<ph id="ph1">`*`</ph>) 場合、メタデータ トークン<ph id="ph2">`field`</ph>メモリがマネージ型を参照します。</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Otherwise, it corresponds to an unmanaged pointer (type <ph id="ph1">`native int`</ph>).</source>
          <target state="translated">それ以外の場合、そのアンマネージ ポインターに対応しています (型<ph id="ph1">`native int`</ph>)。</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>Note that <ph id="ph1">`field`</ph> may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</source>
          <target state="translated">なお<ph id="ph1">`field`</ph>場合があります、静的な割り当ての相対仮想アドレス (そのを含む PE ファイルが現在メモリに読み込まれる場合は、ベース アドレスからのフィールドのオフセット) を持つグローバル メモリは管理されません。</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The <ph id="ph1">`ldsflda`</ph> instruction can have a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix.</source>
          <target state="translated"><ph id="ph1">`ldsflda`</ph>命令が持つことができます、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>プレフィックス。</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> フィールドは、メタデータ内で見つからない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) の手順については、ランタイムではなく、ネイティブ コードに変換する場合にチェックします。</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldsflda`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldsflda`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldsflda">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、FieldInfo)</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Pushes a new object reference to a string literal stored in the metadata.</source>
          <target state="translated">メタデータに格納されているリテラル文字列への新しいオブジェクト参照をプッシュします。</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>72 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">72 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>ldstr <ph id="ph1">`mdToken`</ph></source>
          <target state="translated">ldstr <ph id="ph1">`mdToken`</ph></target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>Pushes a string object for the metadata string token <ph id="ph1">`mdToken`</ph>.</source>
          <target state="translated">メタデータの文字列トークンの文字列オブジェクトをプッシュ<ph id="ph1">`mdToken`</ph>です。</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>An object reference to a string is pushed onto the stack.</source>
          <target state="translated">文字列へのオブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The <ph id="ph1">`ldstr`</ph> instruction pushes an object reference (type <ph id="ph2">`O`</ph>) to a new string object representing the specific string literal stored in the metadata.</source>
          <target state="translated"><ph id="ph1">`ldstr`</ph>命令がオブジェクト参照にプッシュ (型<ph id="ph2">`O`</ph>)、特定の文字列を表すリテラルのメタデータに格納されている新しい文字列オブジェクトにします。</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The <ph id="ph1">`ldstr`</ph> instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</source>
          <target state="translated"><ph id="ph1">`ldstr`</ph>命令が必要なメモリを割り当ててし、実行時に必要な文字列形式のファイルで使用される形式からは、リテラル文字列を変換するために必要な任意の形式変換を実行します。</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The Common Language Infrastructure (CLI) guarantees that the result of two <ph id="ph1">`ldstr`</ph> instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as "string interning").</source>
          <target state="translated">共通言語基盤 (CLI) からの 2 つの結果を保証する<ph id="ph1">`ldstr`</ph>を同じ文字のシーケンスを持つ 2 つのメタデータ トークンを参照しているオブジェクトを返す厳密に同じ文字列 (「文字列インターンの使用」と呼ばれるプロセス)。</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldstr`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldstr`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldstr">
          <source>ILGenerator.Emit(OpCode, string)</source>
          <target state="translated">ILGenerator.Emit (オペコード、文字列)</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</source>
          <target state="translated">メタデータ トークンをそのランタイム表現に変換し、評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>D0 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">D0 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ldtoken <ph id="ph1">`token`</ph></source>
          <target state="translated">ldtoken <ph id="ph1">`token`</ph></target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>Converts a metadata token to its runtime representation.</source>
          <target state="translated">メタデータ トークンをそのランタイム表現に変換します。</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The passed token is converted to a <ph id="ph1">`RuntimeHandle`</ph> and pushed onto the stack.</source>
          <target state="translated">渡されたトークンを変換、<ph id="ph1">`RuntimeHandle`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The <ph id="ph1">`ldtoken`</ph> instruction pushes a <ph id="ph2">`RuntimeHandle`</ph> for the specified metadata token.</source>
          <target state="translated"><ph id="ph1">`ldtoken`</ph>命令プッシュ、<ph id="ph2">`RuntimeHandle`</ph>の指定したメタデータ トークン。</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>A <ph id="ph1">`RuntimeHandle`</ph> can be a <ph id="ph2">`fieldref/fielddef`</ph>, a <ph id="ph3">`methodref/methoddef`</ph>, or a <ph id="ph4">`typeref/typedef`</ph>.</source>
          <target state="translated">A<ph id="ph1">`RuntimeHandle`</ph>できます、 <ph id="ph2">`fieldref/fielddef`</ph>、 <ph id="ph3">`methodref/methoddef`</ph>、または<ph id="ph4">`typeref/typedef`</ph>です。</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The value pushed on the stack can be used in calls to <ph id="ph1">`Reflection`</ph> methods in the system class library.</source>
          <target state="translated">呼び出しでスタックにプッシュされた値を使用できます<ph id="ph1">`Reflection`</ph>システム クラス ライブラリのメソッドです。</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>For information on runtime handles, see the following classes: <ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph>, <ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph>, and <ph id="ph3">&lt;xref:System.RuntimeMethodHandle&gt;</ph>.</source>
          <target state="translated">ランタイム ハンドルのについては、次のクラスを参照してください: <ph id="ph1">&lt;xref:System.RuntimeFieldHandle&gt;</ph>、 <ph id="ph2">&lt;xref:System.RuntimeTypeHandle&gt;</ph>、および<ph id="ph3">&lt;xref:System.RuntimeMethodHandle&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`ldtoken`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードを使用できる、<ph id="ph2">`ldtoken`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、MethodInfo)</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、FieldInfo)</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldtoken">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Pushes an unmanaged pointer (type <ph id="ph1">&lt;see langword="native int" /&gt;</ph>) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</source>
          <target state="translated">指定したオブジェクトに関連付けられた特定の仮想メソッドを実装しているネイティブ コードへのアンマネージ ポインター (<ph id="ph1">&lt;see langword="native int" /&gt;</ph> 型) を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>FE 07 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 07 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>ldvirtftn <ph id="ph1">`method`</ph></source>
          <target state="translated">ldvirtftn <ph id="ph1">`method`</ph></target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>Pushes the pointer to an object's virtual method <ph id="ph1">`method`</ph> on the stack.</source>
          <target state="translated">オブジェクトの仮想メソッドへのポインターをプッシュ<ph id="ph1">`method`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token <ph id="ph1">`method`</ph>) is looked up.</source>
          <target state="translated">メソッドにオブジェクト参照がスタックと、エントリ ポイントのアドレスからポップされます。 (メタデータ トークンによって指定されたとおり<ph id="ph1">`method`</ph>) が検索されます。</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The pointer to <ph id="ph1">`method`</ph> is pushed onto the stack.</source>
          <target state="translated">ポインター<ph id="ph1">`method`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The resulting unmanaged pointer pushed onto the stack by the <ph id="ph1">`ldvirtftn`</ph> instruction can be called using the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</source>
          <target state="translated">結果のアンマネージ ポインター、スタックにプッシュして、<ph id="ph1">`ldvirtftn`</ph>命令を使用して呼び出すことができます、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>命令マネージ メソッド (またはアンマネージ コードにマネージ コードから遷移をスタブ) を参照する場合。</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The unmanaged pointer points to native code using the CLR calling convention.</source>
          <target state="translated">アンマネージ ポインターは、CLR 呼び出し規約を使用してネイティブ コードを指します。</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>This method pointer should not be passed to unmanaged native code as a callback routine.</source>
          <target state="translated">このメソッドのポインターは、コールバック ルーチンとしてアンマネージ ネイティブ コードに渡すことはできません。</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ldvirtftn`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ldvirtftn`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ldvirtftn">
          <source>ILGenerator.Emit(OpCode, MethodInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、MethodInfo)</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Exits a protected region of code, unconditionally transferring control to a specific target instruction.</source>
          <target state="translated">コードの保護領域を終了し、制御を特定のターゲット命令に無条件で転送します。</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>DD &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">DD &lt; <ph id="ph1">`int32`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>leave <ph id="ph1">`target`</ph></source>
          <target state="translated">ままにして <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>Exits a protected region of code.</source>
          <target state="translated">コードの保護領域を終了します。</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>There is no stack transition behavior specified for this instruction.</source>
          <target state="translated">この命令に指定された履歴の移行の動作はありません。</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated"><ph id="ph1">`leave`</ph>命令が現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表され、特定のターゲット命令に無条件に制御を転送します。</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction is similar to the <ph id="ph2">`br`</ph> instruction, but it can be used to exit a <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, or <ph id="ph5">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</source>
          <target state="translated"><ph id="ph1">`leave`</ph>命令がに似ていますが、 <ph id="ph2">`br`</ph> 、命令が、これを使用して、終了、 <ph id="ph3">`try`</ph>、 <ph id="ph4">`filter`</ph>、または<ph id="ph5">`catch`</ph>通常分岐命令のみ使用できますでこのようなブロック内に制御を転送する一方をブロックします。</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The <ph id="ph1">`leave`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id="ph2">`finally`</ph> blocks are executed.</source>
          <target state="translated"><ph id="ph1">`leave`</ph>命令を評価スタックを空にして確実に適切な周囲<ph id="ph2">`finally`</ph>ブロックは実行されます。</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>You cannot use a <ph id="ph1">`leave`</ph> instruction to exit a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated">使用することはできません、<ph id="ph1">`leave`</ph>を終了する命令を<ph id="ph2">`finally`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>To ease code generation for exception handlers it is valid from within a catch block to use a <ph id="ph1">`leave`</ph> instruction to transfer control to any instruction within the associated <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">使用する catch ブロック内から有効な例外ハンドラーのコード生成を容易にする、 <ph id="ph1">`leave`</ph> 、関連付けられている任意の命令に制御を転送命令<ph id="ph2">`try`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`leave`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードを使用できる、<ph id="ph2">`leave`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</source>
          <target state="translated">コードの保護領域を終了し、制御をターゲット命令に無条件で転送します (短い形式)。</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>DE &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">DE &lt; <ph id="ph1">`int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>leave.s <ph id="ph1">`target`</ph></source>
          <target state="translated">leave.s <ph id="ph1">`target`</ph></target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>Exit a protected region of code, short form.</source>
          <target state="translated">コード、短い形式の保護領域を終了します。</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>There is no stack transition behavior specified for this instruction.</source>
          <target state="translated">この命令に指定された履歴の移行の動作はありません。</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</source>
          <target state="translated"><ph id="ph1">`leave.s`</ph>命令が現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表され、渡されたターゲット命令に無条件に制御を転送します。</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction is similar to the <ph id="ph2">`br`</ph> instruction, but it can be used to exit a <ph id="ph3">`try`</ph>, <ph id="ph4">`filter`</ph>, or <ph id="ph5">`catch`</ph> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it.</source>
          <target state="translated"><ph id="ph1">`leave.s`</ph>命令がに似ていますが、 <ph id="ph2">`br`</ph> 、命令が、これを使用して、終了、 <ph id="ph3">`try`</ph>、 <ph id="ph4">`filter`</ph>、または<ph id="ph5">`catch`</ph>通常分岐命令のみ使用できますでこのようなブロック内に制御を転送する一方をブロックします。</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The <ph id="ph1">`leave.s`</ph> instruction empties the evaluation stack and ensures that the appropriate surrounding <ph id="ph2">`finally`</ph> blocks are executed.</source>
          <target state="translated"><ph id="ph1">`leave.s`</ph>命令を評価スタックを空にして確実に適切な周囲<ph id="ph2">`finally`</ph>ブロックは実行されます。</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>You cannot use a <ph id="ph1">`leave.s`</ph> instruction to exit a <ph id="ph2">`finally`</ph> block.</source>
          <target state="translated">使用することはできません、<ph id="ph1">`leave.s`</ph>を終了する命令を<ph id="ph2">`finally`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>To ease code generation for exception handlers it is valid from within a catch block to use a <ph id="ph1">`leave.s`</ph> instruction to transfer control to any instruction within the associated <ph id="ph2">`try`</ph> block.</source>
          <target state="translated">使用する catch ブロック内から有効な例外ハンドラーのコード生成を容易にする、 <ph id="ph1">`leave.s`</ph> 、関連付けられている任意の命令に制御を転送命令<ph id="ph2">`try`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`leave.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`leave.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Leave_S">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <ph id="ph1">&lt;see langword="*" /&gt;</ph>) of the first allocated byte onto the evaluation stack.</source>
          <target state="translated">ローカル動的メモリ プールから特定のバイト数を割り当て、最初に割り当てたバイトのアドレス (遷移ポインター、<ph id="ph1">&lt;see langword="*" /&gt;</ph> 型) を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>FE 0F</source>
          <target state="translated">FE 0F</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>localloc</source>
          <target state="translated">localloc</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>Allocate space from the local heap.</source>
          <target state="translated">ローカル ヒープの領域を割り当てます。</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The number of bytes to be allocated is pushed onto the stack.</source>
          <target state="translated">割り当てるバイトの数は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</source>
          <target state="translated">バイト数が、スタックからポップされます。サイズに対応するメモリ容量は、ローカル ヒープから割り当てられます。</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>A pointer to the first byte of the allocated memory is pushed onto the stack.</source>
          <target state="translated">割り当てられたメモリの最初のバイトへのポインターは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The <ph id="ph1">`localloc`</ph> instruction allocates <ph id="ph2">`size`</ph> (type <ph id="ph3">`natural unsigned int`</ph>) bytes from the local dynamic memory pool and returns the address (a transient pointer, type <ph id="ph4">`*`</ph>) of the first allocated byte.</source>
          <target state="translated"><ph id="ph1">`localloc`</ph>命令を割り当てます<ph id="ph2">`size`</ph>(型<ph id="ph3">`natural unsigned int`</ph>) ローカルの動的メモリからのバイトのプールし、アドレスを返します (一時的なポインター、型<ph id="ph4">`*`</ph>)、最初の割り当てられたバイトです。</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The block of memory returned is initialized to 0 only if the initialize flag on the method is <ph id="ph1">`true`</ph>.</source>
          <target state="translated">返されるメモリのブロックは場合にのみ、メソッドの初期化フラグは、0 に初期化<ph id="ph1">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>When the current method executes a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>, the local memory pool is made available for reuse.</source>
          <target state="translated">現在のメソッドを実行すると、 <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>、ローカル メモリ プールは再利用するために使用可能になります。</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The resulting address is aligned so that any primitive data type can be stored there using the <ph id="ph1">`stind`</ph> instructions (such as <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I4&gt;</ph>) and loaded using the <ph id="ph3">`ldind`</ph> instructions (such as <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>).</source>
          <target state="translated">結果として得られるアドレスは、任意のプリミティブ データ型を格納するため存在を使用して、<ph id="ph1">`stind`</ph>命令 (など<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stind_I4&gt;</ph>) を使用して読み込まれると、<ph id="ph3">`ldind`</ph>命令 (など<ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The <ph id="ph1">`localloc`</ph> instruction cannot occur within a <ph id="ph2">`filter`</ph>, <ph id="ph3">`catch`</ph>, <ph id="ph4">`finally`</ph>, or <ph id="ph5">`fault`</ph> block.</source>
          <target state="translated"><ph id="ph1">`localloc`</ph>命令が内で発生することはできません、 <ph id="ph2">`filter`</ph>、 <ph id="ph3">`catch`</ph>、 <ph id="ph4">`finally`</ph>、または<ph id="ph5">`fault`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source><ph id="ph1">&lt;xref:System.StackOverflowException&gt;</ph> is thrown if there is insufficient memory to service the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.StackOverflowException&gt;</ph> メモリ不足のため、要求の処理がある場合にスローされます。</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`localloc`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`localloc`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Localloc">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Pushes a typed reference to an instance of a specific type onto the evaluation stack.</source>
          <target state="translated">特定の型のインスタンスへの型指定された参照を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>C6 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">C6 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>mkrefany <ph id="ph1">`class`</ph></source>
          <target state="translated">mkrefany <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>Pushes a typed reference of type <ph id="ph1">`class`</ph> onto the stack.</source>
          <target state="translated">型の参照を型指定されたプッシュ<ph id="ph1">`class`</ph>をスタックにします。</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>A pointer to piece of data is pushed onto the stack.</source>
          <target state="translated">ポインターのデータがスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The pointer is popped and converted to a typed reference of type <ph id="ph1">`class`</ph>.</source>
          <target state="translated">ポインターがポップされ、型の型指定された参照に変換<ph id="ph1">`class`</ph>です。</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The typed reference is pushed onto the stack.</source>
          <target state="translated">型指定された参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The <ph id="ph1">`mkrefany`</ph> instruction supports the passing of dynamically typed references.</source>
          <target state="translated"><ph id="ph1">`mkrefany`</ph>命令には、動的に型指定された参照を渡すことがサポートしています。</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The pointer must be of type <ph id="ph1">`&amp;`</ph>, <ph id="ph2">`*`</ph>, or <ph id="ph3">`native int`</ph>, and hold the valid address of a piece of data.</source>
          <target state="translated">ポインター型でなければなりません<ph id="ph1">`&amp;`</ph>、 <ph id="ph2">`*`</ph>、または<ph id="ph3">`native int`</ph>、し、一部のデータの有効なアドレスを保持します。</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">`Class`</ph> is the class token describing the type of the data referenced by the pointer.</source>
          <target state="translated"><ph id="ph1">`Class`</ph> ポインターによって参照されるデータの種類を記述するクラスのトークン。</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">`Mkrefany`</ph> pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type <ph id="ph2">`class`</ph>.</source>
          <target state="translated"><ph id="ph1">`Mkrefany`</ph> 型指定された参照のポインターと型の非透過の説明を提供する、スタックにプッシュ<ph id="ph2">`class`</ph>です。</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter.</source>
          <target state="translated">型指定された参照時に許可されている唯一の有効な操作では、パラメーターとして型指定された参照を必要とするメソッドに渡すことです。</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The callee can then use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Refanytype&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Refanyval&gt;</ph> instructions to retrieve the type (class) and the address respectively.</source>
          <target state="translated">呼び出し先を使用してできます、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Refanytype&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Refanyval&gt;</ph>それぞれ型 (クラス) とアドレスを取得する手順。</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id="ph2">`class`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> 場合にスローされる<ph id="ph2">`class`</ph>が見つかりません。</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mkrefany`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`mkrefany`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mkrefany">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Multiplies two values and pushes the result on the evaluation stack.</source>
          <target state="translated">2 つの値を乗算し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>5A</source>
          <target state="translated">5A</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>mul</source>
          <target state="translated">mul</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Multiplies two values on the stack.</source>
          <target state="translated">スタック上の 2 つの値を乗算します。</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value1`</ph>が乗算<ph id="ph4">`value2`</ph>です。</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The <ph id="ph1">`mul`</ph> instruction multiplies <ph id="ph2">`value1`</ph> by <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated"><ph id="ph1">`mul`</ph>命令乗算<ph id="ph2">`value1`</ph>によって<ph id="ph3">`value2`</ph>し、結果をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>Integer operations silently truncate the upper bits on overflow.</source>
          <target state="translated">整数演算では、オーバーフローについては、上位ビットが自動的に切り捨てられます。</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mul_Ovf&gt;</ph> for an integer-specific multiply operation with overflow handling.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mul_Ovf&gt;</ph>整数固有のオーバーフロー処理で操作を乗算します。</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>For floating-point types, 0 * infinity = NaN.</source>
          <target state="translated">浮動小数点型の場合は、0 * 無限大 NaN を = です。</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`mul`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">2 つの整数値を乗算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>D8</source>
          <target state="translated">D8</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>mul.ovf</source>
          <target state="translated">mul.ovf</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>Multiplies two integer values on the stack with an overflow check.</source>
          <target state="translated">オーバーフロー チェックでスタック上の 2 つの整数値を乗算します。</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>, with an overflow check.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value1`</ph>が乗算<ph id="ph4">`value2`</ph>、オーバーフロー チェックを使用します。</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The <ph id="ph1">`mul.ovf`</ph> instruction multiplies integer <ph id="ph2">`value1`</ph> by integer <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated"><ph id="ph1">`mul.ovf`</ph>命令は、整数を乗算<ph id="ph2">`value1`</ph>整数<ph id="ph3">`value2`</ph>し、結果をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>An exception is thrown if the result will not fit in the result type.</source>
          <target state="translated">結果は結果の型に収まらない場合は、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul.ovf`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`mul.ovf`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">2 つの符号なし整数値を乗算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>D9</source>
          <target state="translated">D9</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>mul.ovf.un</source>
          <target state="translated">mul.ovf.un</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>Multiplies two unsigned values on the stack with an overflow check.</source>
          <target state="translated">オーバーフロー チェックでスタック上の 2 つの符号なし値を乗算します。</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value1`</ph> is multiplied by <ph id="ph4">`value2`</ph>, with an overflow check.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value1`</ph>が乗算<ph id="ph4">`value2`</ph>、オーバーフロー チェックを使用します。</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The <ph id="ph1">`mul.ovf.un`</ph> instruction multiplies unsigned integer <ph id="ph2">`value1`</ph> by unsigned integer <ph id="ph3">`value2`</ph> and pushes the result on the stack.</source>
          <target state="translated"><ph id="ph1">`mul.ovf.un`</ph>命令が符号なし整数を乗算<ph id="ph2">`value1`</ph>符号なし整数で<ph id="ph3">`value2`</ph>し、結果をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>An exception is thrown if the result will not fit in the result type.</source>
          <target state="translated">結果は結果の型に収まらない場合は、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`mul.ovf.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`mul.ovf.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negates a value and pushes the result onto the evaluation stack.</source>
          <target state="translated">値を無効にし、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>65</source>
          <target state="translated">65</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>neg</source>
          <target state="translated">負</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negates the value currently on top of the stack.</source>
          <target state="translated">スタック上に現在の値を否定します。</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>A value is popped from the stack and negated.</source>
          <target state="translated">値がスタックからポップされ、符号を反転します。</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The <ph id="ph1">`neg`</ph> instruction negates value and pushes the result on top of the stack.</source>
          <target state="translated"><ph id="ph1">`neg`</ph>命令の値を無効にし、結果をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The return type is the same as the operand type.</source>
          <target state="translated">戻り値の型は、オペランドの型と同じです。</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negation of integral values is standard two's complement negation.</source>
          <target state="translated">整数値の否定は、標準的な 2 の補数の否定。</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number.</source>
          <target state="translated">具体的には、否定、最も負の数 (正の対応するものはありません) には、負の数が生成されます。</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>To detect this overflow use the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph> instruction instead (that is, subtract from 0).</source>
          <target state="translated">このオーバーフローの使用を検出するために、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>命令代わりに (つまり、0 から減算)。</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>Negating a floating-point number cannot overflow, and negating NaN returns NaN.</source>
          <target state="translated">浮動小数点数を否定すると、オーバーフローが発生することはできませんと NaN が否定は NaN を返します。</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`neg`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`neg`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Neg">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</source>
          <target state="translated">特定の型の要素を持つ、インデックス番号が 0 から始まる新しい 1 次元配列へのオブジェクト参照を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>8D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">8D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>newarr <ph id="ph1">`etype`</ph></source>
          <target state="translated">newarr <ph id="ph1">`etype`</ph></target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Creates a new array with elements of type <ph id="ph1">`etype`</ph>.</source>
          <target state="translated">型の要素を持つ新しい配列を作成<ph id="ph1">`etype`</ph>です。</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements in the array is pushed onto the stack.</source>
          <target state="translated">配列内の要素の数は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements is popped from the stack and the array is created.</source>
          <target state="translated">要素の数が、スタックからポップされ、配列が作成されます。</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>An object reference to the new array is pushed onto the stack.</source>
          <target state="translated">新しい配列にオブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The <ph id="ph1">`newarr`</ph> instruction pushes an object reference (type <ph id="ph2">`O`</ph>) to a new zero-based, one-dimensional array whose elements are of type <ph id="ph3">`etype`</ph> (a metadata token describing the type).</source>
          <target state="translated"><ph id="ph1">`newarr`</ph>命令がオブジェクト参照にプッシュ (型<ph id="ph2">`O`</ph>) に、新しい 0 から始まる 1 次元配列の要素の型は<ph id="ph3">`etype`</ph>(型を記述するメタデータ トークン)。</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The number of elements in the new array should be specified as a <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">として新しい配列の要素の数を指定する必要があります、<ph id="ph1">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Valid array indexes range from zero to the maximum number of elements minus one.</source>
          <target state="translated">有効な配列のインデックス範囲は 0 から 1 を引いた要素の最大数です。</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The elements of an array can be any type, including value types.</source>
          <target state="translated">配列の要素には、値型を含む、任意の型を使用できます。</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<ph id="ph1">&lt;xref:System.Int32&gt;</ph>, and so on).</source>
          <target state="translated">数値の 0 から始まる、1 次元の配列は、適切な値の型を参照するメタデータ トークンを使用して作成されます (<ph id="ph1">&lt;xref:System.Int32&gt;</ph>など)。</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Elements of the array are initialized to 0 of the appropriate type.</source>
          <target state="translated">配列の要素は、適切な型の 0 に初期化されます。</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>Nonzero-based one-dimensional arrays and multidimensional arrays are created using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph> rather than <ph id="ph2">`newarr`</ph>.</source>
          <target state="translated">始まる 1 次元配列と多次元配列を使用して作成<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newobj&gt;</ph>なく<ph id="ph2">`newarr`</ph>です。</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>More commonly, they are created using the methods of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class in the .NET Framework.</source>
          <target state="translated">一般的には、作成されたのメソッドを使用して、 <ph id="ph1">&lt;xref:System.Array&gt;</ph> .NET Framework のクラスです。</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> メモリ不足のため、要求を満たす場合にスローされます。</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if <ph id="ph2">`numElems`</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 場合にスローされる<ph id="ph2">`numElems`</ph>が 0 未満です。</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`newarr`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`newarr`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newarr">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Creates a new object or a new instance of a value type, pushing an object reference (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) onto the evaluation stack.</source>
          <target state="translated">新しいオブジェクトまたは値型の新しいインスタンスを作成し、オブジェクト参照 (<ph id="ph1">&lt;see langword="O" /&gt;</ph> 型) を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>73 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">73 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>newobj <ph id="ph1">`ctor`</ph></source>
          <target state="translated">newobj <ph id="ph1">`ctor`</ph></target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Allocates an uninitialized object or value type and calls the constructor method <ph id="ph1">`ctor`</ph>.</source>
          <target state="translated">初期化されていないオブジェクトまたは値型の割り当てし、コンス トラクター メソッドを呼び出して<ph id="ph1">`ctor`</ph>です。</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Arguments <ph id="ph1">`arg1`</ph> through <ph id="ph2">`argn`</ph> are pushed on the stack in sequence.</source>
          <target state="translated">引数<ph id="ph1">`arg1`</ph>を通じて<ph id="ph2">`argn`</ph>順序でスタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Arguments <ph id="ph1">`argn`</ph> through <ph id="ph2">`arg1`</ph> are popped from the stack and passed to <ph id="ph3">`ctor`</ph> for object creation.</source>
          <target state="translated">引数<ph id="ph1">`argn`</ph>を通じて<ph id="ph2">`arg1`</ph>スタックからポップされに渡される<ph id="ph3">`ctor`</ph>オブジェクトを作成します。</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>A reference to the new object is pushed onto the stack.</source>
          <target state="translated">新しいオブジェクトへの参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The <ph id="ph1">`newobj`</ph> instruction creates a new object or a new instance of a value type.</source>
          <target state="translated"><ph id="ph1">`newobj`</ph>命令は、新しいオブジェクトまたは値型の新しいインスタンスを作成します。</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">`Ctor`</ph> is a metadata token (a <ph id="ph2">`methodref`</ph> or <ph id="ph3">`methoddef`</ph> that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</source>
          <target state="translated"><ph id="ph1">`Ctor`</ph> メタデータ トークンは、(、<ph id="ph2">`methodref`</ph>または<ph id="ph3">`methoddef`</ph>コンス トラクターとしてマークする必要があります) を示す名前とクラスを呼び出すコンス トラクターのシグネチャ。</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The <ph id="ph1">`newobj`</ph> instruction allocates a new instance of the class associated with <ph id="ph2">`ctor`</ph> and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate.</source>
          <target state="translated"><ph id="ph1">`newobj`</ph>命令に関連付けられているクラスの新しいインスタンスを割り当てる<ph id="ph2">`ctor`</ph>し、新しいインスタンスを適切な型の 0 または適切な null 参照のすべてのフィールドを初期化します。</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>It then calls the constructor <ph id="ph1">`ctor`</ph> with the given arguments along with the newly created instance.</source>
          <target state="translated">コンス トラクターを呼び出して<ph id="ph1">`ctor`</ph>と、新しく作成されたインスタンスと共に、指定された引数を使用します。</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>After the constructor has been called, the now initialized object reference (type <ph id="ph1">`O`</ph>) is pushed on the stack.</source>
          <target state="translated">ここがオブジェクト参照を初期化するコンス トラクターが呼び出された後 (型<ph id="ph1">`O`</ph>) が、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</source>
          <target state="translated">コンス トラクターの観点から初期化されていないオブジェクトは引数 0 であり、newobj に渡されるその他の引数が順番に従います。</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>All zero-based, one-dimensional arrays are created using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newarr&gt;</ph>, not <ph id="ph2">`newobj`</ph>.</source>
          <target state="translated">使用してすべての 0 から始まる 1 次元配列が作成された<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Newarr&gt;</ph>ではなく、<ph id="ph2">`newobj`</ph>です。</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using <ph id="ph1">`newobj`</ph>.</source>
          <target state="translated">これに対し、他のすべての配列 (1 つの次元数よりもまたは 1 次元が、0 以上) を使用してを作成する、<ph id="ph1">`newobj`</ph>です。</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Value types are not usually created using <ph id="ph1">`newobj`</ph>.</source>
          <target state="translated">値の型は、通常使用して作成されなかった<ph id="ph1">`newobj`</ph>です。</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>They are usually allocated either as arguments or local variables, using <ph id="ph1">`newarr`</ph> (for zero-based, one-dimensional arrays), or as fields of objects.</source>
          <target state="translated">引数またはを使用して、ローカル変数として通常割り当てられる<ph id="ph1">`newarr`</ph>(0 から始まる、1 次元配列の)、またはオブジェクトのフィールドとして。</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>Once allocated, they are initialized using <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Initobj&gt;</ph>.</source>
          <target state="translated">使用して初期化される、いったん割り当てられる<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Initobj&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>However, the <ph id="ph1">`newobj`</ph> instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</source>
          <target state="translated">ただし、<ph id="ph1">`newobj`</ph>とに、ローカルに格納、引数として渡すことができると、スタックに値型の新しいインスタンスを作成する命令を使用することができます。</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> is thrown if there is insufficient memory to satisfy the request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> メモリ不足のため、要求を満たす場合にスローされます。</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> is thrown if a constructor method <ph id="ph2">`ctor`</ph> with the indicated name, class and signature could not be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingMethodException&gt;</ph> コンス トラクター メソッドの場合にスローされる<ph id="ph2">`ctor`</ph>指定された名前を持つクラスと署名で見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) 命令が実行時ではなく、ネイティブ コードに変換されるときに検出します。</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`newobj`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`newobj`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Newobj">
          <source>ILGenerator.Emit(OpCode, ConstructorInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ConstructorInfo)</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Fills space if opcodes are patched.</source>
          <target state="translated">オペコードがパッチされている場合は、領域を補完します。</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>No meaningful operation is performed although a processing cycle can be consumed.</source>
          <target state="translated">循環参照の処理を利用することはできますが、意味のある演算は実行されません。</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>00</source>
          <target state="translated">00</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>nop</source>
          <target state="translated">nop</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>Performs an operation without behavior.</source>
          <target state="translated">動作せず、操作を実行します。</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>There is no stack transitional behavior defined for this instruction.</source>
          <target state="translated">この命令に対して定義されているスタック過渡期の動作はありません。</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The <ph id="ph1">`nop`</ph> operation does nothing.</source>
          <target state="translated"><ph id="ph1">`nop`</ph>操作は、何も行われません。</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>It is intended to fill in space if opcodes are patched.</source>
          <target state="translated">オペコードがパッチされている場合は、スペースを埋めるためにしています。</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`nop`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`nop`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Nop">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</source>
          <target state="translated">スタックの一番上にある整数値のビットごとの補数を計算し、結果を同じ型として評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>66</source>
          <target state="translated">66</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>not</source>
          <target state="translated">not</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>Computes the bitwise complement of a value.</source>
          <target state="translated">値のビットごとの補数を計算します。</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source><ph id="ph1">`value`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source><ph id="ph1">`value`</ph> is popped from the stack and its bitwise complement computed.</source>
          <target state="translated"><ph id="ph1">`value`</ph> スタックし、そのビットごとのポップ ビットごとの補数を計算します。</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The <ph id="ph1">`not`</ph> instruction computes the bitwise complement of an integer value and pushes the result onto the stack.</source>
          <target state="translated"><ph id="ph1">`not`</ph>命令は整数値のビットごとの補数を計算し、結果をスタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The return type is the same as the operand type.</source>
          <target state="translated">戻り値の型は、オペランドの型と同じです。</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`not`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`not`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Not">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</source>
          <target state="translated">スタックの一番上にある 2 つの整数値のビットごとの補数を計算し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>60</source>
          <target state="translated">60</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>or</source>
          <target state="translated">または</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>Computes the bitwise OR of two integer values, returns an integer.</source>
          <target state="translated">ビットごとの計算または 2 つの整数値の整数を返します。</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and their bitwise OR computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックと、ビットごとの OR からポップされます。 計算します。</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The <ph id="ph1">`or`</ph> instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</source>
          <target state="translated"><ph id="ph1">`or`</ph>命令は、結果をスタックにプッシュ、スタックの一番上の 2 つの値のビットごとの OR を計算します。</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source><ph id="ph1">`Or`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`Or`</ph> 整数固有操作です。</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`or`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`or`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Or">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Removes the value currently on top of the evaluation stack.</source>
          <target state="translated">現在評価スタックの一番上にある値を削除します。</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>26</source>
          <target state="translated">26</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>pop</source>
          <target state="translated">pop</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>Pops the top value from the stack.</source>
          <target state="translated">スタックから上位の値をポップします。</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The top value is popped from the stack.</source>
          <target state="translated">上位の値は、スタックからポップされます。</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The <ph id="ph1">`pop`</ph> instruction removes the top element from the stack.</source>
          <target state="translated"><ph id="ph1">`pop`</ph>命令がスタックから先頭の要素を削除します。</target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`pop`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`pop`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Pop">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix1">
          <source>This is a reserved instruction.</source>
          <target state="translated">これは予約済みの命令です。</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix2">
          <source>This is a reserved instruction.</source>
          <target state="translated">これは予約済みの命令です。</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix3">
          <source>This is a reserved instruction.</source>
          <target state="translated">これは予約済みの命令です。</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix4">
          <source>This is a reserved instruction.</source>
          <target state="translated">これは予約済みの命令です。</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix5">
          <source>This is a reserved instruction.</source>
          <target state="translated">これは予約済みの命令です。</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix6">
          <source>This is a reserved instruction.</source>
          <target state="translated">これは予約済みの命令です。</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefix7">
          <source>This is a reserved instruction.</source>
          <target state="translated">これは予約済みの命令です。</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Prefixref">
          <source>This is a reserved instruction.</source>
          <target state="translated">これは予約済みの命令です。</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</source>
          <target state="translated">以降の配列アドレス演算で、実行時に型チェックを実行しないこと、および変更可能性が制限されたマネージ ポインターを返すことを指定します。</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>FE 1E</source>
          <target state="translated">FE 1E</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>readonly.</source>
          <target state="translated">読み取り専用です。</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Specify that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer with restricted mutability.</source>
          <target state="translated">以降の配列アドレス演算では、実行時型チェックは実行しないと、制限された変更可能性とマネージ ポインターが返されることを指定します。</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>This prefix can only appear immediately preceding the <ph id="ph1">`ldelema`</ph> instruction and calls to the special <ph id="ph2">`Address`</ph> method on arrays.</source>
          <target state="translated">このプレフィックスがすぐ前でのみ使用できます、<ph id="ph1">`ldelema`</ph>命令および特別なへの呼び出し<ph id="ph2">`Address`</ph>メソッドの配列。</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Its effect on the subsequent operation is twofold:</source>
          <target state="translated">後続の操作に対するその効果は、2 つを示します。</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>At run time, no type check operation is performed.</source>
          <target state="translated">実行時に、型チェックの操作は実行されません。</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Note that there is normally an implicit type check for the <ph id="ph1">`ldelema`</ph> and <ph id="ph2">`stelem`</ph> instructions when used on reference type arrays.</source>
          <target state="translated">暗黙的な型チェックは通常、<ph id="ph1">`ldelema`</ph>と<ph id="ph2">`stelem`</ph>参照で使用する入力配列。</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>There is never a run-time type check for value classes, so <ph id="ph1">`readonly`</ph> is a no-op in that case.</source>
          <target state="translated">ないため、値クラス、実行時の型チェックのため<ph id="ph1">`readonly`</ph>no-op をその場合は。</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The verifier treats the result of the address-of operation as a managed pointer with restricted mutability.</source>
          <target state="translated">検証は、マネージ ポインターとして変更可能性が制限にアドレスの操作の結果を扱います。</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated.</source>
          <target state="translated">ポインターは、定義する型が値を変更できるかどうかを制御するために可変性が制限と呼ばれます。</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix).</source>
          <target state="translated">ポインターは読み取り専用のパブリック フィールドまたは場所の値を更新するメソッドを公開しない値クラス、(そのため、プレフィックスの名前)。</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only.</source>
          <target state="translated">具体的には、プリミティブ型 (たとえば、System.Int32) を表すクラスは、ミューテーターを公開しないと、そのため、読み取り専用です。</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>A managed pointer restricted in this fashion can be used only in the following ways:</source>
          <target state="translated">この方法で制限されたマネージ ポインターは、次の方法でのみ使用できます。</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`object`</ph> parameter for the <ph id="ph2">`ldfld`</ph>, <ph id="ph3">`ldflda`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`call`</ph>, or<ph id="ph6">`constrained callvirt`</ph> instructions.</source>
          <target state="translated">として、<ph id="ph1">`object`</ph>のパラメーター、 <ph id="ph2">`ldfld`</ph>、 <ph id="ph3">`ldflda`</ph>、 <ph id="ph4">`stfld`</ph>、 <ph id="ph5">`call`</ph>、または<ph id="ph6">`constrained callvirt`</ph>指示します。</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`pointer`</ph> parameter to the <ph id="ph2">`ldobj`</ph> instruction or to one of the <ph id="ph3">`ldind`</ph> instructions.</source>
          <target state="translated">として、<ph id="ph1">`pointer`</ph>パラメーターを<ph id="ph2">`ldobj`</ph>命令またはのいずれかに、<ph id="ph3">`ldind`</ph>指示します。</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>As the <ph id="ph1">`source`</ph> parameter to the <ph id="ph2">`cpobj`</ph> instruction.</source>
          <target state="translated">として、<ph id="ph1">`source`</ph>パラメーターを<ph id="ph2">`cpobj`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>All other operations disallowed, including the <ph id="ph1">`stobj`</ph>, <ph id="ph2">`initobj`</ph>, or <ph id="ph3">`mkrefany`</ph> operations, or any of the <ph id="ph4">`stind`</ph> instructions.</source>
          <target state="translated">他のなどすべての操作が許可されていない、 <ph id="ph1">`stobj`</ph>、 <ph id="ph2">`initobj`</ph>、または<ph id="ph3">`mkrefany`</ph>操作、またはのいずれか、<ph id="ph4">`stind`</ph>指示します。</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The purpose of the <ph id="ph1">`readonly`</ph> prefix is to avoid a type check when fetching an element from an array in generic code.</source>
          <target state="translated">目的、<ph id="ph1">`readonly`</ph>をジェネリック コードの配列から要素をフェッチするときに、型チェックを回避するのには、プレフィックス。</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>For example, the expression <ph id="ph1">`arr[i].m()`</ph>, where the element type of the array <ph id="ph2">`arr`</ph> is a generic type that has been constrained to have an interface with method <ph id="ph3">`m`</ph>, might compile to the following MSIL.</source>
          <target state="translated">たとえば、式<ph id="ph1">`arr[i].m()`</ph>, 配列の要素型が、<ph id="ph2">`arr`</ph>はジェネリック型のメソッドを使用してインターフェイスが存在するが制約されていること<ph id="ph3">`m`</ph>、次の MSIL にコンパイルする場合があります。</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Without the <ph id="ph1">`readonly`</ph> prefix, the <ph id="ph2">`ldelema`</ph> instruction would perform a type check in the case where !0 was a reference type.</source>
          <target state="translated">なし、<ph id="ph1">`readonly`</ph>プレフィックス、<ph id="ph2">`ldelema`</ph>命令は大文字と小文字で型チェックを実行する場所です。 0 は、参照型です。</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>Not only is this type check inefficient, but it is semantically incorrect.</source>
          <target state="translated">効率的なこの種類のチェックはありませんできるだけでなく、意味的に正しいはありません。</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The type check for <ph id="ph1">`ldelema`</ph> is an exact match, which is too strong.</source>
          <target state="translated">型チェック<ph id="ph1">`ldelema`</ph>すぎます強力なは、完全に一致します。</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>If the array held subclasses of type !0, the code above would fail the type check.</source>
          <target state="translated">配列には、型のサブクラスが保持されている場合です。 0 で、上記のコードには、型チェックが失敗します。</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The address of the array element is fetched, instead of the element itself, in order to have a handle for <ph id="ph1">`arr[i]`</ph> that works for both value types and reference types, and thus can be passed to the <ph id="ph2">`constrained callvirt`</ph> instruction.</source>
          <target state="translated">配列要素のアドレスをフェッチされると、要素自体ではなくをハンドルするために<ph id="ph1">`arr[i]`</ph>両方の動作が値の型と参照型の場合と、そのために渡されることができます、<ph id="ph2">`constrained callvirt`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>In general it would be unsafe to skip the run-time check if the array held elements of a reference type.</source>
          <target state="translated">一般にできなくなる、配列には、参照型の要素が保持されている場合、ランタイム チェックをスキップしても安全です。</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>To be safe, it is necessary to ensure that no modifications to the array are made through this pointer.</source>
          <target state="translated">念のためには、このポインターから配列への変更が行われていないことを確認する必要があります。</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The verifier rules ensure this.</source>
          <target state="translated">検証規則では、これを確認します。</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</source>
          <target state="translated">厳密に言うと、値の型の読み取り専用ですが値型の型の安全性の問題はありません、インスタンス メソッドの呼び出しのオブジェクトとして制限されたマネージ ポインターを渡すことができます。</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`readonly`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`readonly`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Readonly">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Retrieves the type token embedded in a typed reference.</source>
          <target state="translated">型指定された参照に埋め込まれている型トークンを取得します。</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>FE 1D</source>
          <target state="translated">FE 1D</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>refanytype</source>
          <target state="translated">refanytype</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>Pushes the type token stored in a typed reference.</source>
          <target state="translated">型指定された参照に格納されている型トークンをプッシュします。</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>A value type reference is pushed onto the stack.</source>
          <target state="translated">値の型参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The typed reference is popped from the stack and its corresponding type token retrieved.</source>
          <target state="translated">型指定された参照がスタックからポップされ、その対応する型トークンを取得します。</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The type token is pushed onto the stack.</source>
          <target state="translated">型トークンは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>A typed reference contains a type token and an address to an object instance.</source>
          <target state="translated">型指定された参照には、型のトークンとオブジェクト インスタンスにアドレスが含まれています。</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The <ph id="ph1">`refanytype`</ph> instruction retrieves the type token embedded in the typed reference.</source>
          <target state="translated"><ph id="ph1">`refanytype`</ph>命令は、型指定された参照に埋め込まれている型トークンを取得します。</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for information on creating typed references.</source>
          <target state="translated">参照してください、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph>命令を作成する方法についての参照を入力します。</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`refanytype`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`refanytype`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanytype">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Retrieves the address (type <ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph>) embedded in a typed reference.</source>
          <target state="translated">型指定された参照に埋め込まれているアドレス (<ph id="ph1">&lt;see langword="&amp;amp;" /&gt;</ph> 型) を取得します。</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>C2 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">C2 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>refanyval <ph id="ph1">`type`</ph></source>
          <target state="translated">refanyval <ph id="ph1">`type`</ph></target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>Pushes the address stored in a typed reference.</source>
          <target state="translated">型指定された参照に格納されているアドレスにプッシュします。</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>A value type reference is pushed onto the stack.</source>
          <target state="translated">値の型参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The typed reference is popped from the stack and the corresponding address retrieved.</source>
          <target state="translated">型指定された参照がスタックからポップされし、対応するアドレスを取得します。</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>A typed reference contains a type token and an address to an object instance.</source>
          <target state="translated">型指定された参照には、型のトークンとオブジェクト インスタンスにアドレスが含まれています。</target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The <ph id="ph1">`refanyval`</ph> instruction retrieves the address embedded in the a typed reference.</source>
          <target state="translated"><ph id="ph1">`refanyval`</ph>命令アドレスを取得しますに埋め込まれている、型指定された参照です。</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The type embedded in the typed reference supplied on the stack must match the type specified by <ph id="ph1">`type`</ph> (a metadata token, either a <ph id="ph2">`typedef`</ph> or a <ph id="ph3">`typeref`</ph>).</source>
          <target state="translated">スタックで提供される型指定された参照に埋め込まれている型がで指定された型と一致する必要があります<ph id="ph1">`type`</ph>(いずれかのメタデータ トークン、<ph id="ph2">`typedef`</ph>または<ph id="ph3">`typeref`</ph>)。</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction for related content.</source>
          <target state="translated">参照してください、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph>関連コンテンツの命令。</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id="ph2">`type`</ph> is not identical to the type stored in the type reference (in this case, <ph id="ph3">`type`</ph> is the class supplied to the <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph> instruction that constructed said typed reference).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> 場合にスローされる<ph id="ph2">`type`</ph>型参照に格納されている型と同一には (この場合、<ph id="ph3">`type`</ph>にクラスが用意されて、<ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Mkrefany&gt;</ph>構築命令が型指定された参照と呼ばれます)。</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if <ph id="ph2">`type`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> 場合にスローされる<ph id="ph2">`type`</ph>が見つかりません。</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`refanyval`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`refanyval`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Refanyval">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Divides two values and pushes the remainder onto the evaluation stack.</source>
          <target state="translated">2 つの値を除算し、剰余を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>5D</source>
          <target state="translated">5D</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>rem</source>
          <target state="translated">rem</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Pushes the remainder of dividing <ph id="ph1">`value1`</ph> by <ph id="ph2">`value2`</ph> onto the stack.</source>
          <target state="translated">除算の剰余プッシュ<ph id="ph1">`value1`</ph>によって<ph id="ph2">`value2`</ph>をスタックにします。</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>ReplaceThisText</source>
          <target state="translated">ReplaceThisText</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>A <ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">A<ph id="ph1">`value1`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and the remainder of <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックとの残りの部分からポップされます。 <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph>計算します。</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem`</ph> <ph id="ph5">`value2`</ph> satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem`</ph> <ph id="ph5">`value2`</ph> 次の条件を満たします。</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> <ph id="ph6">`×`</ph> (<ph id="ph7">`value1`</ph> <ph id="ph8">`div`</ph> <ph id="ph9">`value2`</ph>), and:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> <ph id="ph6">`×`</ph> (<ph id="ph7">`value1`</ph> <ph id="ph8">`div`</ph> <ph id="ph9">`value2`</ph>)、および。</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>0 = &amp;#124; <ph id="ph1">`result`</ph> &amp;#124; &lt; &amp;#124; <ph id="ph2">`value2`</ph> &amp;#124;, sign(<ph id="ph3">`result`</ph>) = sign(<ph id="ph4">`value1`</ph>), where <ph id="ph5">`div`</ph> is the division instruction that truncates towards zero.</source>
          <target state="translated">0 = &amp;#124; <ph id="ph1">`result`</ph> &amp;#124; &lt; &amp;#124; <ph id="ph2">`value2`</ph> &amp;#124;、記号 (<ph id="ph3">`result`</ph>) 記号の = (<ph id="ph4">`value1`</ph>) ここで、<ph id="ph5">`div`</ph>は 0 方向に切り捨てられます除算命令します。</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>If <ph id="ph1">`value2`</ph> is zero or <ph id="ph2">`value1`</ph> is infinity the result is NaN.</source>
          <target state="translated">場合<ph id="ph1">`value2`</ph>ゼロまたは<ph id="ph2">`value1`</ph>無限大 NaN になります。</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>If <ph id="ph1">`value2`</ph> is infinity, the result is <ph id="ph2">`value1`</ph> (negated for <ph id="ph3">`-infinity`</ph>).</source>
          <target state="translated">場合<ph id="ph1">`value2`</ph>無限大の場合は、結果は<ph id="ph2">`value1`</ph>(の否定<ph id="ph3">`-infinity`</ph>)。</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">整数演算でスロー<ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph>場合<ph id="ph2">`value2`</ph>ゼロです。</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>Note that on the Intel-based platforms an <ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown when computing (minint <ph id="ph2">`rem`</ph> -1).</source>
          <target state="translated">Intel ベースのプラットフォームで、なお、<ph id="ph1">&lt;xref:System.OverflowException&gt;</ph>を計算するときにスローされる (minint <ph id="ph2">`rem`</ph> -1)。</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rem`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`rem`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Divides two unsigned values and pushes the remainder onto the evaluation stack.</source>
          <target state="translated">2 つの符号なしの値を除算し、剰余を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>5E</source>
          <target state="translated">5E</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>rem.un</source>
          <target state="translated">rem.un</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Pushes the remainder of dividing unsigned <ph id="ph1">`value1`</ph> by unsigned <ph id="ph2">`value2`</ph> onto the stack.</source>
          <target state="translated">符号なしに除算した剰余をプッシュ<ph id="ph1">`value1`</ph>符号なしで<ph id="ph2">`value2`</ph>をスタックにします。</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and the remainder of <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph> computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックとの残りの部分からポップされます。 <ph id="ph3">`value1`</ph> <ph id="ph4">`div`</ph> <ph id="ph5">`value2`</ph>計算します。</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem.un`</ph> <ph id="ph5">`value2`</ph> satisfies the following conditions:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph> <ph id="ph4">`rem.un`</ph> <ph id="ph5">`value2`</ph> 次の条件を満たします。</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> x(<ph id="ph6">`value1`</ph> <ph id="ph7">`div.un`</ph> <ph id="ph8">`value2`</ph>), and:</source>
          <target state="translated"><ph id="ph1">`result`</ph><ph id="ph2"> = </ph><ph id="ph3">`value1`</ph><ph id="ph4"> - </ph><ph id="ph5">`value2`</ph> x (<ph id="ph6">`value1`</ph> <ph id="ph7">`div.un`</ph> <ph id="ph8">`value2`</ph>)、および。</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>0 = <ph id="ph1">`result`</ph><ph id="ph2"> &lt; </ph><ph id="ph3">`value2`</ph>, where <ph id="ph4">`div.un`</ph> is the unsigned division instruction.</source>
          <target state="translated">0 = <ph id="ph1">`result`</ph> <ph id="ph2"> &lt; </ph><ph id="ph3">`value2`</ph>ここで、<ph id="ph4">`div.un`</ph>は符号なしの除算命令します。</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The <ph id="ph1">`rem.un`</ph> instruction computes <ph id="ph2">`result`</ph> and pushes it on the stack.</source>
          <target state="translated"><ph id="ph1">`rem.un`</ph>命令計算<ph id="ph2">`result`</ph>し、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`Rem.un`</ph> treats its arguments as unsigned integers, while <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Rem&gt;</ph> treats them as signed integers.</source>
          <target state="translated"><ph id="ph1">`Rem.un`</ph> 符号なし整数としてその引数を処理中に<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Rem&gt;</ph>はこれらを扱い、符号付き整数。</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source><ph id="ph1">`Rem.un`</ph> is unspecified for floating-point numbers.</source>
          <target state="translated"><ph id="ph1">`Rem.un`</ph> 浮動小数点数に指定されていません。</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>Integral operations throw <ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph> if <ph id="ph2">`value2`</ph> is zero.</source>
          <target state="translated">整数演算でスロー<ph id="ph1">&lt;xref:System.DivideByZeroException&gt;</ph>場合<ph id="ph2">`value2`</ph>ゼロです。</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rem.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`rem.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rem_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</source>
          <target state="translated">現在のメソッドから戻り、呼び出し先の評価スタックから呼び出し元の評価スタックに戻り値 (存在する場合) をプッシュします。</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>2A</source>
          <target state="translated">2A</target>       </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>ret</source>
          <target state="translated">ret</target>       </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Returns from method, possibly returning a value.</source>
          <target state="translated">可能性のある値を返すメソッドから返されます。</target>       </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The return value is popped from the callee evaluation stack.</source>
          <target state="translated">戻り値は、呼び出し先の評価スタックからポップされます。</target>       </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The return value obtained in step 1 is pushed onto the caller evaluation stack.</source>
          <target state="translated">手順 1. で得た戻り値は、呼び出し元の評価スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</source>
          <target state="translated">戻り値が呼び出し先の評価スタックに存在しない場合は、値なしに (スタック遷移の動作、呼び出し先または呼び出し元のメソッド) が返されません。</target>       </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method.</source>
          <target state="translated">戻り値の型存在する場合、現在のメソッドの決定、スタックの最上位と、現在のメソッドを呼び出したメソッドのスタックにコピーしたからフェッチする値の型します。</target>       </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The evaluation stack for the current method must be empty except for the value to be returned.</source>
          <target state="translated">現在のメソッドの評価スタックは、返される値を除く空にする必要があります。</target>       </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The <ph id="ph1">`ret`</ph> instruction cannot be used to transfer control out of a<ph id="ph2">`try`</ph>, <ph id="ph3">`filter`</ph>, <ph id="ph4">`catch`</ph>, or <ph id="ph5">`finally`</ph> block.</source>
          <target state="translated"><ph id="ph1">`ret`</ph> Out の制御を転送する命令を使用することはできません、<ph id="ph2">`try`</ph>、 <ph id="ph3">`filter`</ph>、 <ph id="ph4">`catch`</ph>、または<ph id="ph5">`finally`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>From within a <ph id="ph1">`try`</ph> or <ph id="ph2">`catch`</ph>, use the <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph> instruction with a destination of a <ph id="ph4">`ret`</ph> instruction that is outside all enclosing exception blocks.</source>
          <target state="translated">内から、<ph id="ph1">`try`</ph>または<ph id="ph2">`catch`</ph>を使用して、<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Leave&gt;</ph>命令の対象、<ph id="ph4">`ret`</ph>命令が外側のすべての例外ブロックの範囲外です。</target>       </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>Because the <ph id="ph1">`filter`</ph> and <ph id="ph2">`finally`</ph> blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a <ph id="ph3">`filter`</ph> or <ph id="ph4">`finally`</ph>.</source>
          <target state="translated"><ph id="ph1">`filter`</ph>と<ph id="ph2">`finally`</ph>ブロックは論理的には一部の例外処理と、コードが埋め込まれているメソッドではなく、正しく生成された Microsoft Intermediate Language (MSIL) 命令がメソッド内からの戻り値を実行しないで、<ph id="ph3">`filter`</ph>または<ph id="ph4">`finally`</ph>です。</target>       </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`ret`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`ret`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Ret">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Rethrows the current exception.</source>
          <target state="translated">現在の例外を再スローします。</target>       </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>FE 1A</source>
          <target state="translated">FE 1A</target>       </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>rethrow</source>
          <target state="translated">rethrow</target>       </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>Rethrows the current exception</source>
          <target state="translated">現在の例外を再スローします。</target>       </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>No stack transition behavior is defined for this instruction.</source>
          <target state="translated">この命令の履歴の移行の動作が定義されていません。</target>       </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The <ph id="ph1">`rethrow`</ph> instruction is only permitted within the body of a <ph id="ph2">`catch`</ph> handler.</source>
          <target state="translated"><ph id="ph1">`rethrow`</ph>命令がの本体内でのみ許可されている、<ph id="ph2">`catch`</ph>ハンドラー。</target>       </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>It throws the same exception that was caught by this handler.</source>
          <target state="translated">このハンドラーによってキャッチされた例外と同じ例外がスローされます。</target>       </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`rethrow`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`rethrow`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Rethrow">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">整数値を指定したビット数だけ、0 を使用して左にシフトし、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>62</source>
          <target state="translated">62</target>       </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>shl</source>
          <target state="translated">shl</target>       </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>Shifts an integer to the left (shifting in zeros).</source>
          <target state="translated">整数が (0 でシフト) 左にシフトします。</target>       </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">シフトするビットの量は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</source>
          <target state="translated">シフトするビットの数と、値がスタックからポップされます。値は指定されたビット数だけ左にシフトします。</target>       </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The <ph id="ph1">`shl`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) left by the specified number of bits.</source>
          <target state="translated"><ph id="ph1">`shl`</ph>命令シフト値 (型<ph id="ph2">`int32`</ph>、<ph id="ph3">`int64`</ph>または<ph id="ph4">`native int`</ph>) 指定されたビット数だけ左します。</target>       </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph> or <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">ビットの数は、型の値を<ph id="ph1">`int32`</ph>または<ph id="ph2">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">シフトするビット数が (bits) の幅指定された値以上である場合、戻り値は指定されません。</target>       </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source><ph id="ph1">`Shl`</ph> inserts a zero bit in the lowest position on each shift.</source>
          <target state="translated"><ph id="ph1">`Shl`</ph> 0 のビットをシフトごとの最下位の位置に挿入します。</target>       </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shl`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`shl`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shl">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">整数値を指定したビット数だけ、符号を付けて右にシフトし、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>63</source>
          <target state="translated">63</target>       </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>shr</source>
          <target state="translated">shr</target>       </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>Shifts an integer to the right (shifting in sign).</source>
          <target state="translated">整数を (符号でシフト) 右にシフトします。</target>       </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">シフトするビットの量は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</source>
          <target state="translated">シフトするビットの数と、値がスタックからポップされます。値は指定されたビット数だけ右にシフトします。</target>       </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The <ph id="ph1">`shr.un`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) right by the specified number of bits.</source>
          <target state="translated"><ph id="ph1">`shr.un`</ph>命令シフト値 (型<ph id="ph2">`int32`</ph>、<ph id="ph3">`int64`</ph>または<ph id="ph4">`native int`</ph>) 指定されたビット数だけ右。</target>       </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph> or <ph id="ph2">`native int`</ph>.</source>
          <target state="translated">ビットの数は、型の値を<ph id="ph1">`int32`</ph>または<ph id="ph2">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">シフトするビット数が (bits) の幅指定された値以上である場合、戻り値は指定されません。</target>       </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source><ph id="ph1">`Shr`</ph> replicates the high order bit on each shift, preserving the sign of the original value in the <ph id="ph2">`result`</ph>.</source>
          <target state="translated"><ph id="ph1">`Shr`</ph> 上位の元の値の符号を保持し、シフトごとのビットを複製、<ph id="ph2">`result`</ph>です。</target>       </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shr`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`shr`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</source>
          <target state="translated">符号なし整数値を指定したビット数だけ、0 を使用して右にシフトし、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>64</source>
          <target state="translated">64</target>       </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>shr.un</source>
          <target state="translated">shr.un</target>       </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>Shifts an integer to the right (shifting in zeroes).</source>
          <target state="translated">整数を (0 でシフト) 右にシフトします。</target>       </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The amount of bits to be shifted is pushed onto the stack.</source>
          <target state="translated">シフトするビットの量は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</source>
          <target state="translated">シフトするビットの数と、値がスタックからポップされます。値は指定されたビット数だけ右にシフトします。</target>       </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The <ph id="ph1">`shr.un`</ph> instruction shifts the value (type <ph id="ph2">`int32`</ph>, <ph id="ph3">`int64`</ph> or <ph id="ph4">`native int`</ph>) right by the specified number of bits.</source>
          <target state="translated"><ph id="ph1">`shr.un`</ph>命令シフト値 (型<ph id="ph2">`int32`</ph>、<ph id="ph3">`int64`</ph>または<ph id="ph4">`native int`</ph>) 指定されたビット数だけ右。</target>       </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The number of bits is a value of type <ph id="ph1">`int32`</ph>, <ph id="ph2">`int64`</ph> or <ph id="ph3">`native int`</ph>.</source>
          <target state="translated">ビットの数は、型の値を<ph id="ph1">`int32`</ph>、<ph id="ph2">`int64`</ph>または<ph id="ph3">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</source>
          <target state="translated">シフトするビット数が (bits) の幅指定された値以上である場合、戻り値は指定されません。</target>       </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source><ph id="ph1">`Shr.un`</ph> inserts a zero bit in the highest position on each shift.</source>
          <target state="translated"><ph id="ph1">`Shr.un`</ph> 0 のビットをシフトごとの最も高い位置に挿入します。</target>       </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`shr.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`shr.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Shr_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</source>
          <target state="translated">提供された値型のサイズ (バイト単位) を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>FE 1C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 1C &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>sizeof <ph id="ph1">`valType`</ph></source>
          <target state="translated">sizeof <ph id="ph1">`valType`</ph></target>       </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>Push the size, in bytes, of a value type as an <ph id="ph1">`unsigned int32`</ph>.</source>
          <target state="translated">(バイト単位) として値型のサイズをプッシュする<ph id="ph1">`unsigned int32`</ph>です。</target>       </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The size (in bytes) of the supplied value type (<ph id="ph1">`valType`</ph>) is pushed onto the stack.</source>
          <target state="translated">サイズ (バイト単位)、指定された値の型 (<ph id="ph1">`valType`</ph>)、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source><ph id="ph1">`valType`</ph> must be a metadata token (a <ph id="ph2">`typeref`</ph> or <ph id="ph3">`typedef`</ph>) that specifies a value type, reference type, or generic type parameter.</source>
          <target state="translated"><ph id="ph1">`valType`</ph> メタデータ トークンにする必要があります (、<ph id="ph2">`typeref`</ph>または<ph id="ph3">`typedef`</ph>) 値の型、参照型またはジェネリック型パラメーターを指定します。</target>       </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value.</source>
          <target state="translated">参照型で返されるサイズはの対応する参照値のサイズは参照値によって参照されるオブジェクトに格納されたデータのサイズではなく (32 ビット システムでは 4 バイト) を入力します。</target>       </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>A generic type parameter can be used only in the body of the type or method that defines it.</source>
          <target state="translated">ジェネリック型パラメーターは、型またはそれを定義するメソッドの本体でのみ使用できます。</target>       </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</source>
          <target state="translated">その型またはメソッドがインスタンス化されるときに、ジェネリック型パラメーターが値型または参照型によって置き換えられます。</target>       </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sizeof`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`sizeof`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sizeof">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Stores the value on top of the evaluation stack in the argument slot at a specified index.</source>
          <target state="translated">評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します。</target>       </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>FE 0B &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0B &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>starg <ph id="ph1">`num`</ph></source>
          <target state="translated">starg <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Pops the top value from the stack and stores it in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">スタックから上位の値をポップし、引数スロットに格納<ph id="ph1">`num`</ph>です。</target>       </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The value currently on top of the stack is popped and placed in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">スタック上に現在の値がポップされ、引数スロットに配置<ph id="ph1">`num`</ph>です。</target>       </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The <ph id="ph1">`starg`</ph> instruction pops a value from the stack and places it in argument slot <ph id="ph2">`num`</ph>.</source>
          <target state="translated"><ph id="ph1">`starg`</ph>命令がスタックからの値をポップし、引数スロットに配置<ph id="ph2">`num`</ph>です。</target>       </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The type of the value must match the type of the argument, as specified in the current method's signature.</source>
          <target state="translated">値の型は、現在のメソッドのシグネチャで指定されている引数の型と一致する必要があります。</target>       </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>For procedures that take a variable argument list, the <ph id="ph1">`starg`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">可変個引数リストを取得する手順については、<ph id="ph1">`starg`</ph>命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます。</target>       </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</source>
          <target state="translated">4 バイト長より小さい整数値を保持している引数に格納を実行すると、スタックから引数に移動するときに、値が切り捨てられます。</target>       </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズから丸められます (型<ph id="ph1">`F`</ph>) を引数に関連付けられているサイズにします。</target>       </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`starg`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`starg`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (オペコード、short)</target>       </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</source>
          <target state="translated">評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します (短い形式)。</target>       </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>10 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">10 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>starg.s <ph id="ph1">`num`</ph></source>
          <target state="translated">starg.s <ph id="ph1">`num`</ph></target>       </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Pops the top value from the stack and stores it in argument slot <ph id="ph1">`num`</ph>, short form.</source>
          <target state="translated">スタックから上位の値をポップし、引数スロットに格納<ph id="ph1">`num`</ph>、短縮形です。</target>       </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The value currently on top of the stack is popped and placed in argument slot <ph id="ph1">`num`</ph>.</source>
          <target state="translated">スタック上に現在の値がポップされ、引数スロットに配置<ph id="ph1">`num`</ph>です。</target>       </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The <ph id="ph1">`starg.s`</ph> instruction pops a value from the stack and places it in argument slot <ph id="ph2">`num`</ph>.</source>
          <target state="translated"><ph id="ph1">`starg.s`</ph>命令がスタックからの値をポップし、引数スロットに配置<ph id="ph2">`num`</ph>です。</target>       </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The type of the value must match the type of the argument, as specified in the current method's signature.</source>
          <target state="translated">値の型は、現在のメソッドのシグネチャで指定されている引数の型と一致する必要があります。</target>       </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The <ph id="ph1">`starg.s`</ph> instruction provides an efficient encoding for use with the first 256 arguments.</source>
          <target state="translated"><ph id="ph1">`starg.s`</ph>命令は最初の 256 個の引数で使用するための効率的なエンコーディングします。</target>       </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>For procedures that take a variable argument list, the <ph id="ph1">`starg.s`</ph> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</source>
          <target state="translated">可変個引数リストを取得する手順については、<ph id="ph1">`starg.s`</ph>命令は、最初の署名の可変部分でなく、その引数を固定にのみ使用できます。</target>       </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument.</source>
          <target state="translated">4 バイト長より小さい整数値を保持している引数に格納を実行すると、スタックから引数に移動するときに、値が切り捨てられます。</target>       </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズから丸められます (型<ph id="ph1">`F`</ph>) を引数に関連付けられているサイズにします。</target>       </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`starg.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`starg.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Starg_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (オペコード, byte)</target>       </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</source>
          <target state="translated">指定のインデックス位置にある配列要素を評価スタックの、命令で指定された型の値に置き換えます。</target>       </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>A4 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A4 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>stelem <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">stelem <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Replaces the array element at the supplied index with a value of type <ph id="ph1">`typeTok`</ph> on the stack.</source>
          <target state="translated">指定したインデックスにある配列要素を型の値に置き換えます<ph id="ph1">`typeTok`</ph>スタックにします。</target>       </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照、配列に<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>An index value, <ph id="ph1">`index`</ph>, to an element in <ph id="ph2">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">インデックス値、 <ph id="ph1">`index`</ph>、内の要素へ<ph id="ph2">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>A value of the type specified in the instruction is pushed onto the stack.</source>
          <target state="translated">命令で指定された型の値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。</target>       </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The <ph id="ph1">`stelem`</ph> instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array <ph id="ph2">`array`</ph> with the value.</source>
          <target state="translated"><ph id="ph1">`stelem`</ph>命令が 1 次元配列で指定された 0 から始まるインデックス位置にある要素の値を置き換えます<ph id="ph2">`array`</ph>値を使用します。</target>       </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The value has the type specified by the token <ph id="ph1">`typeTok`</ph> in the instruction.</source>
          <target state="translated">トークンで指定された型は、値が<ph id="ph1">`typeTok`</ph>命令でします。</target>       </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>Arrays are objects, and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列は、オブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">インデックスの種類は、<ph id="ph1">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stelem`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="native int" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">指定のインデックス位置にある配列要素を評価スタックの <ph id="ph1">&lt;see langword="native int" /&gt;</ph> 値に置き換えます。</target>       </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>9B</source>
          <target state="translated">9B</target>       </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>stelem.i</source>
          <target state="translated">stelem.i</target>       </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`native int`</ph> value on the stack.</source>
          <target state="translated">指定されたインデックス位置にある配列要素が置き換えられます、<ph id="ph1">`native int`</ph>スタックの値にします。</target>       </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照、配列に<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">内の要素への有効なインデックス<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。</target>       </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The <ph id="ph1">`stelem.i`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`native int`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.i`</ph>命令、要素の値で置き換え<ph id="ph2">`index`</ph>1 次元配列で<ph id="ph3">`array`</ph>で、<ph id="ph4">`native int`</ph>値、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">インデックスの種類は、<ph id="ph1">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stelem.i`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int8" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">指定のインデックス位置にある配列要素を評価スタックの <ph id="ph1">&lt;see langword="int8" /&gt;</ph> 値に置き換えます。</target>       </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>9C</source>
          <target state="translated">9C</target>       </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>stelem.i1</source>
          <target state="translated">stelem.i1</target>       </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int8`</ph> value on the stack.</source>
          <target state="translated">指定されたインデックス位置にある配列要素が置き換えられます、<ph id="ph1">`int8`</ph>スタックの値にします。</target>       </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照、配列に<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">内の要素への有効なインデックス<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。</target>       </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The <ph id="ph1">`stelem.i1`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int8`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.i1`</ph>命令、要素の値で置き換え<ph id="ph2">`index`</ph>1 次元配列で<ph id="ph3">`array`</ph>で、<ph id="ph4">`int8`</ph>値、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">インデックスの種類は、<ph id="ph1">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stelem.i1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int16" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">指定のインデックス位置にある配列要素を評価スタックの <ph id="ph1">&lt;see langword="int16" /&gt;</ph> 値に置き換えます。</target>       </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>9D</source>
          <target state="translated">9D</target>       </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>stelem.i2</source>
          <target state="translated">stelem.i2</target>       </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int16`</ph> value on the stack.</source>
          <target state="translated">指定されたインデックス位置にある配列要素が置き換えられます、<ph id="ph1">`int16`</ph>スタックの値にします。</target>       </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照、配列に<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">内の要素への有効なインデックス<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。</target>       </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The <ph id="ph1">`stelem.i2`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int16`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.i2`</ph>命令、要素の値で置き換え<ph id="ph2">`index`</ph>1 次元配列で<ph id="ph3">`array`</ph>で、<ph id="ph4">`int16`</ph>値、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">インデックスの種類は、<ph id="ph1">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stelem.i2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int32" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">指定のインデックス位置にある配列要素を評価スタックの <ph id="ph1">&lt;see langword="int32" /&gt;</ph> 値に置き換えます。</target>       </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>9E</source>
          <target state="translated">9E</target>       </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>stelem.i4</source>
          <target state="translated">stelem.i4</target>       </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int32`</ph> value on the stack.</source>
          <target state="translated">指定されたインデックス位置にある配列要素が置き換えられます、<ph id="ph1">`int32`</ph>スタックの値にします。</target>       </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照、配列に<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">内の要素への有効なインデックス<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。</target>       </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The <ph id="ph1">`stelem.i4`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int32`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.i4`</ph>命令、要素の値で置き換え<ph id="ph2">`index`</ph>1 次元配列で<ph id="ph3">`array`</ph>で、<ph id="ph4">`int32`</ph>値、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">インデックスの種類は、<ph id="ph1">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stelem.i4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="int64" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">指定のインデックス位置にある配列要素を評価スタックの <ph id="ph1">&lt;see langword="int64" /&gt;</ph> 値に置き換えます。</target>       </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>9F</source>
          <target state="translated">9F</target>       </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>stelem.i8</source>
          <target state="translated">stelem.i8</target>       </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`int64`</ph> value on the stack.</source>
          <target state="translated">指定されたインデックス位置にある配列要素が置き換えられます、<ph id="ph1">`int64`</ph>スタックの値にします。</target>       </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照、配列に<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">内の要素への有効なインデックス<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。</target>       </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The <ph id="ph1">`stelem.i8`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`int64`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.i8`</ph>命令、要素の値で置き換え<ph id="ph2">`index`</ph>1 次元配列で<ph id="ph3">`array`</ph>で、<ph id="ph4">`int64`</ph>値、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">インデックスの種類は、<ph id="ph1">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.i8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stelem.i8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="float32" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">指定のインデックス位置にある配列要素を評価スタックの <ph id="ph1">&lt;see langword="float32" /&gt;</ph> 値に置き換えます。</target>       </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A0</source>
          <target state="translated">A0</target>       </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>stelem.r4</source>
          <target state="translated">stelem.r4</target>       </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`float32`</ph> value on the stack.</source>
          <target state="translated">指定されたインデックス位置にある配列要素が置き換えられます、<ph id="ph1">`float32`</ph>スタックの値にします。</target>       </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照、配列に<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">内の要素への有効なインデックス<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。</target>       </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The <ph id="ph1">`stelem.r4`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`float32`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.r4`</ph>命令、要素の値で置き換え<ph id="ph2">`index`</ph>1 次元配列で<ph id="ph3">`array`</ph>で、<ph id="ph4">`float32`</ph>値、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">インデックスの種類は、<ph id="ph1">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.r4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stelem.r4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Replaces the array element at a given index with the <ph id="ph1">&lt;see langword="float64" /&gt;</ph> value on the evaluation stack.</source>
          <target state="translated">指定のインデックス位置にある配列要素を評価スタックの <ph id="ph1">&lt;see langword="float64" /&gt;</ph> 値に置き換えます。</target>       </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A1</source>
          <target state="translated">A1</target>       </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>stelem.r8</source>
          <target state="translated">stelem.r8</target>       </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`float64`</ph> value on the stack.</source>
          <target state="translated">指定されたインデックス位置にある配列要素が置き換えられます、<ph id="ph1">`float64`</ph>スタックの値にします。</target>       </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照、配列に<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">内の要素への有効なインデックス<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。</target>       </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The <ph id="ph1">`stelem.r8`</ph> instruction replaces the value of the element <ph id="ph2">`index`</ph> in the one-dimensional array <ph id="ph3">`array`</ph> with the <ph id="ph4">`float64`</ph> value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.r8`</ph>命令、要素の値で置き換え<ph id="ph2">`index`</ph>1 次元配列で<ph id="ph3">`array`</ph>で、<ph id="ph4">`float64`</ph>値、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">インデックスの種類は、<ph id="ph1">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.r8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stelem.r8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Replaces the array element at a given index with the object ref value (type <ph id="ph1">&lt;see langword="O" /&gt;</ph>) on the evaluation stack.</source>
          <target state="translated">指定のインデックス位置にある配列要素をオブジェクト参照値 (<ph id="ph1">&lt;see langword="O" /&gt;</ph> 型) に置き換えます。</target>       </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A2</source>
          <target state="translated">A2</target>       </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>stelem.ref</source>
          <target state="translated">stelem.ref</target>       </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Replaces an array element at the supplied index with the <ph id="ph1">`ref`</ph> value (type <ph id="ph2">`O`</ph>) on the stack.</source>
          <target state="translated">指定されたインデックス位置にある配列要素が置き換えられます、<ph id="ph1">`ref`</ph>値 (型<ph id="ph2">`O`</ph>)、スタックにします。</target>       </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>An object reference to an array, <ph id="ph1">`array`</ph>, is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照、配列に<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A valid index to an element in <ph id="ph1">`array`</ph> is pushed onto the stack.</source>
          <target state="translated">内の要素への有効なインデックス<ph id="ph1">`array`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</source>
          <target state="translated">値、インデックス、および配列参照がスタックからポップされます。値は、指定したインデックスにある配列要素に配置されます。</target>       </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The <ph id="ph1">`stelem.ref`</ph> instruction replaces the value of the element at the supplied index in the one-dimensional array <ph id="ph2">`array`</ph> with the <ph id="ph3">`ref`</ph> (type <ph id="ph4">`O`</ph>) value pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`stelem.ref`</ph>命令が 1 次元配列で指定されたインデックス位置にある要素の値を置き換えます<ph id="ph2">`array`</ph>で、 <ph id="ph3">`ref`</ph> (型<ph id="ph4">`O`</ph>) 値、スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Arrays are objects and hence represented by a value of type <ph id="ph1">`O`</ph>.</source>
          <target state="translated">配列はオブジェクト型の値によって表されるため、<ph id="ph1">`O`</ph>です。</target>       </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The index is type <ph id="ph1">`native int`</ph>.</source>
          <target state="translated">インデックスの種類は、<ph id="ph1">`native int`</ph>です。</target>       </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Note that <ph id="ph1">`stelem.ref`</ph> implicitly casts the supplied value to the element type of <ph id="ph2">`array`</ph> before assigning the value to the array element.</source>
          <target state="translated">なお<ph id="ph1">`stelem.ref`</ph>の要素の型に指定された値を暗黙的にキャスト<ph id="ph2">`array`</ph>配列の要素に値を割り当てる前にします。</target>       </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>This cast can fail, even for verified code.</source>
          <target state="translated">検証済みのコードであっても、このキャストが失敗することができます。</target>       </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>Thus the <ph id="ph1">`stelem.ref`</ph> instruction can throw <ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>.</source>
          <target state="translated">したがって、<ph id="ph1">`stelem.ref`</ph>命令をスローできます<ph id="ph2">&lt;xref:System.InvalidCastException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class provides a <ph id="ph2">&lt;xref:System.Array.SetValue%2A&gt;</ph> method.</source>
          <target state="translated">以外で始まる 1 次元の配列および多次元配列の場合、<ph id="ph1">&lt;xref:System.Array&gt;</ph>クラスを提供する<ph id="ph2">&lt;xref:System.Array.SetValue%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> is thrown if <ph id="ph2">`index`</ph> is negative, or larger than the bound of <ph id="ph3">`array`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IndexOutOfRangeException&gt;</ph> 場合にスローされる<ph id="ph2">`index`</ph>が負の値のバインドよりも大きい<ph id="ph3">`array`</ph>です。</target>       </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> is thrown if <ph id="ph2">`array`</ph> does not hold elements of the required type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ArrayTypeMismatchException&gt;</ph> 場合にスローされる<ph id="ph2">`array`</ph>が必要な型の要素を保持しません。</target>       </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stelem.ref`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stelem.ref`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stelem_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Replaces the value stored in the field of an object reference or pointer with a new value.</source>
          <target state="translated">オブジェクト参照またはポインターのフィールドに格納された値を新しい値に置き換えます。</target>       </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>7D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">7D &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>stfld <ph id="ph1">`field`</ph></source>
          <target state="translated">stfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>Replaces the value of <ph id="ph1">`field`</ph> of the object with a new value.</source>
          <target state="translated">値を置き換えます<ph id="ph1">`field`</ph>の新しい値を持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>An object reference or pointer is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照またはポインターは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The value and the object reference/pointer are popped from the stack; the value of <ph id="ph1">`field`</ph> in the object is replaced with the supplied value.</source>
          <target state="translated">値とオブジェクトの参照/ポインターがスタックからポップされます。値<ph id="ph1">`field`</ph>オブジェクトで指定された値に置き換えられます。</target>       </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The <ph id="ph1">`stfld`</ph> instruction replaces the value of a field of an object (type <ph id="ph2">`O`</ph>) or via a pointer (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`&amp;`</ph>, or <ph id="ph5">`*`</ph>) with a given value.</source>
          <target state="translated"><ph id="ph1">`stfld`</ph>命令は、オブジェクトのフィールドの値を置き換えます (型<ph id="ph2">`O`</ph>) またはポインター経由で (型<ph id="ph3">`native int`</ph>、 <ph id="ph4">`&amp;`</ph>、または<ph id="ph5">`*`</ph>) に特定の値。</target>       </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">`Field`</ph> is a metadata token that refers to a field member reference.</source>
          <target state="translated"><ph id="ph1">`Field`</ph> フィールドのメンバーの参照を表すメタデータ トークンです。</target>       </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The <ph id="ph1">`stfld`</ph> instruction can have a prefix of either or both of <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`stfld`</ph>命令は、のいずれかまたは両方のプレフィックスを持つことができます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>と<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference or pointer is a null reference and the field isn't static.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> オブジェクト参照またはポインターが null 参照と、フィールドが静的でない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if <ph id="ph2">`field`</ph> is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> 場合にスローされる<ph id="ph2">`field`</ph>はメタデータに存在しません。</target>       </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) の命令がランタイムではなく、ネイティブ コードに変換されるときにチェックします。</target>       </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stfld`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stfld`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、FieldInfo)</target>       </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="native int" /&gt;</ph> at a supplied address.</source>
          <target state="translated">提供されたアドレスに <ph id="ph1">&lt;see langword="native int" /&gt;</ph> 型の値を格納します。</target>       </trans-unit>
        <trans-unit id="4004" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4005" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4006" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4007" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4008" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>DF</source>
          <target state="translated">DF</target>       </trans-unit>
        <trans-unit id="4009" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>stind.i</source>
          <target state="translated">stind.i</target>       </trans-unit>
        <trans-unit id="4010" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Stores a <ph id="ph1">`native int`</ph> value at a given address.</source>
          <target state="translated">ストア、<ph id="ph1">`native int`</ph>指定したアドレスにある値。</target>       </trans-unit>
        <trans-unit id="4011" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4012" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4013" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4014" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。</target>       </trans-unit>
        <trans-unit id="4015" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The <ph id="ph1">`stind.i`</ph> instruction stores a <ph id="ph2">`native int`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.i`</ph>命令ストア、<ph id="ph2">`native int`</ph>指定されたアドレスにある値 (型<ph id="ph3">`native int`</ph>、 <ph id="ph4">`*`</ph>、または<ph id="ph5">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="4016" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">タイプ セーフな演算では、する必要があります、<ph id="ph1">`stind.i`</ph>命令ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="4017" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The operation of the <ph id="ph1">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`stind.i`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="4018" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`addr`</ph>命令のサフィックスが含まれる引数の型が自然に配置できません。</target>       </trans-unit>
        <trans-unit id="4019" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stind.i`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4020" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4021" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int8" /&gt;</ph> at a supplied address.</source>
          <target state="translated">提供されたアドレスに <ph id="ph1">&lt;see langword="int8" /&gt;</ph> 型の値を格納します。</target>       </trans-unit>
        <trans-unit id="4022" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4023" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4024" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4025" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4026" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>52</source>
          <target state="translated">52</target>       </trans-unit>
        <trans-unit id="4027" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>stind.i1</source>
          <target state="translated">stind.i1</target>       </trans-unit>
        <trans-unit id="4028" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Stores an <ph id="ph1">`int8`</ph> value at a given address.</source>
          <target state="translated">ストア、<ph id="ph1">`int8`</ph>指定したアドレスにある値。</target>       </trans-unit>
        <trans-unit id="4029" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4030" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4031" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4032" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。</target>       </trans-unit>
        <trans-unit id="4033" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The <ph id="ph1">`stind.i1`</ph> instruction stores an <ph id="ph2">`int8`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.i1`</ph>命令ストア、<ph id="ph2">`int8`</ph>指定されたアドレスにある値 (型<ph id="ph3">`native int`</ph>、 <ph id="ph4">`*`</ph>、または<ph id="ph5">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="4034" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i1`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">タイプ セーフな演算では、する必要があります、<ph id="ph1">`stind.i1`</ph>命令ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="4035" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The operation of the <ph id="ph1">`stind.i1`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`stind.i1`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="4036" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`addr`</ph>命令のサフィックスが含まれる引数の型が自然に配置できません。</target>       </trans-unit>
        <trans-unit id="4037" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stind.i1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4038" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4039" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int16" /&gt;</ph> at a supplied address.</source>
          <target state="translated">提供されたアドレスに <ph id="ph1">&lt;see langword="int16" /&gt;</ph> 型の値を格納します。</target>       </trans-unit>
        <trans-unit id="4040" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4041" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4042" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4043" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4044" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>53</source>
          <target state="translated">53</target>       </trans-unit>
        <trans-unit id="4045" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>stind.i2</source>
          <target state="translated">stind.i2</target>       </trans-unit>
        <trans-unit id="4046" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Stores an <ph id="ph1">`int16`</ph> value at a given address.</source>
          <target state="translated">ストア、<ph id="ph1">`int16`</ph>指定したアドレスにある値。</target>       </trans-unit>
        <trans-unit id="4047" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4048" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4049" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4050" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。</target>       </trans-unit>
        <trans-unit id="4051" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The <ph id="ph1">`stind.i2`</ph> instruction stores an <ph id="ph2">`int16`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.i2`</ph>命令ストア、<ph id="ph2">`int16`</ph>指定されたアドレスにある値 (型<ph id="ph3">`native int`</ph>、 <ph id="ph4">`*`</ph>、または<ph id="ph5">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="4052" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>Type safe operation requires that the <ph id="ph1">`stind.2i`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">タイプ セーフな演算では、する必要があります、<ph id="ph1">`stind.2i`</ph>命令ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="4053" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The operation of the <ph id="ph1">`stind.i2`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`stind.i2`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="4054" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`addr`</ph>命令のサフィックスが含まれる引数の型が自然に配置できません。</target>       </trans-unit>
        <trans-unit id="4055" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stind.i2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4056" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4057" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int32" /&gt;</ph> at a supplied address.</source>
          <target state="translated">提供されたアドレスに <ph id="ph1">&lt;see langword="int32" /&gt;</ph> 型の値を格納します。</target>       </trans-unit>
        <trans-unit id="4058" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4059" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4060" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4061" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4062" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>54</source>
          <target state="translated">54</target>       </trans-unit>
        <trans-unit id="4063" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>stind.i4</source>
          <target state="translated">stind.i4</target>       </trans-unit>
        <trans-unit id="4064" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Stores an <ph id="ph1">`int32`</ph> value at a given address.</source>
          <target state="translated">ストア、<ph id="ph1">`int32`</ph>指定したアドレスにある値。</target>       </trans-unit>
        <trans-unit id="4065" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4066" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4067" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4068" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。</target>       </trans-unit>
        <trans-unit id="4069" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The <ph id="ph1">`stind.i4`</ph> instruction stores an <ph id="ph2">`int32`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.i4`</ph>命令ストア、<ph id="ph2">`int32`</ph>指定されたアドレスにある値 (型<ph id="ph3">`native int`</ph>、 <ph id="ph4">`*`</ph>、または<ph id="ph5">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="4070" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i4`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">タイプ セーフな演算では、する必要があります、<ph id="ph1">`stind.i4`</ph>命令ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="4071" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The operation of the <ph id="ph1">`stind.i4`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`stind.i4`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="4072" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`addr`</ph>命令のサフィックスが含まれる引数の型が自然に配置できません。</target>       </trans-unit>
        <trans-unit id="4073" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stind.i4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4074" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4075" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="int64" /&gt;</ph> at a supplied address.</source>
          <target state="translated">提供されたアドレスに <ph id="ph1">&lt;see langword="int64" /&gt;</ph> 型の値を格納します。</target>       </trans-unit>
        <trans-unit id="4076" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4077" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4078" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4079" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4080" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>55</source>
          <target state="translated">55</target>       </trans-unit>
        <trans-unit id="4081" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>stind.i8</source>
          <target state="translated">stind.i8</target>       </trans-unit>
        <trans-unit id="4082" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Stores an <ph id="ph1">`int64`</ph> value at a given address.</source>
          <target state="translated">ストア、<ph id="ph1">`int64`</ph>指定したアドレスにある値。</target>       </trans-unit>
        <trans-unit id="4083" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4084" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4085" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4086" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。</target>       </trans-unit>
        <trans-unit id="4087" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The <ph id="ph1">`stind.i8`</ph> instruction stores an <ph id="ph2">`int64`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.i8`</ph>命令ストア、<ph id="ph2">`int64`</ph>指定されたアドレスにある値 (型<ph id="ph3">`native int`</ph>、 <ph id="ph4">`*`</ph>、または<ph id="ph5">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="4088" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>Type safe operation requires that the <ph id="ph1">`stind.i8`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">タイプ セーフな演算では、する必要があります、<ph id="ph1">`stind.i8`</ph>命令ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="4089" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The operation of the <ph id="ph1">`stind.i`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`stind.i`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="4090" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`addr`</ph>命令のサフィックスが含まれる引数の型が自然に配置できません。</target>       </trans-unit>
        <trans-unit id="4091" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.i8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stind.i8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4092" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_I8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4093" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="float32" /&gt;</ph> at a supplied address.</source>
          <target state="translated">提供されたアドレスに <ph id="ph1">&lt;see langword="float32" /&gt;</ph> 型の値を格納します。</target>       </trans-unit>
        <trans-unit id="4094" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4095" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4096" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4097" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4098" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>56</source>
          <target state="translated">56</target>       </trans-unit>
        <trans-unit id="4099" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>stind.r4</source>
          <target state="translated">stind.r4</target>       </trans-unit>
        <trans-unit id="4100" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Stores a <ph id="ph1">`float32`</ph> value at a given address.</source>
          <target state="translated">ストア、<ph id="ph1">`float32`</ph>指定したアドレスにある値。</target>       </trans-unit>
        <trans-unit id="4101" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4102" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4103" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4104" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。</target>       </trans-unit>
        <trans-unit id="4105" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The <ph id="ph1">`stind.r4`</ph> instruction stores a <ph id="ph2">`float32`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.r4`</ph>命令ストア、<ph id="ph2">`float32`</ph>指定されたアドレスにある値 (型<ph id="ph3">`native int`</ph>、 <ph id="ph4">`*`</ph>、または<ph id="ph5">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="4106" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>Type safe operation requires that the <ph id="ph1">`stind.r4`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">タイプ セーフな演算では、する必要があります、<ph id="ph1">`stind.r4`</ph>命令ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="4107" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The operation of the <ph id="ph1">`stind.r4`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`stind.r4`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="4108" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`addr`</ph>命令のサフィックスが含まれる引数の型が自然に配置できません。</target>       </trans-unit>
        <trans-unit id="4109" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.r4`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stind.r4`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4110" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R4">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4111" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Stores a value of type <ph id="ph1">&lt;see langword="float64" /&gt;</ph> at a supplied address.</source>
          <target state="translated">提供されたアドレスに <ph id="ph1">&lt;see langword="float64" /&gt;</ph> 型の値を格納します。</target>       </trans-unit>
        <trans-unit id="4112" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4113" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4114" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4115" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4116" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>57</source>
          <target state="translated">57</target>       </trans-unit>
        <trans-unit id="4117" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>stind.r8</source>
          <target state="translated">stind.r8</target>       </trans-unit>
        <trans-unit id="4118" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Stores a <ph id="ph1">`float64`</ph> value at a given address.</source>
          <target state="translated">ストア、<ph id="ph1">`float64`</ph>指定したアドレスにある値。</target>       </trans-unit>
        <trans-unit id="4119" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4120" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4121" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4122" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。</target>       </trans-unit>
        <trans-unit id="4123" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The <ph id="ph1">`stind.r8`</ph> instruction stores a <ph id="ph2">`float64`</ph> value at the supplied address (type <ph id="ph3">`native int`</ph>, <ph id="ph4">`*`</ph>, or <ph id="ph5">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.r8`</ph>命令ストア、<ph id="ph2">`float64`</ph>指定されたアドレスにある値 (型<ph id="ph3">`native int`</ph>、 <ph id="ph4">`*`</ph>、または<ph id="ph5">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="4124" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>Type safe operation requires that the <ph id="ph1">`stind.r8`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">タイプ セーフな演算では、する必要があります、<ph id="ph1">`stind.r8`</ph>命令ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="4125" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The operation of the <ph id="ph1">`stind.r8`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`stind.r8`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="4126" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`addr`</ph>命令のサフィックスが含まれる引数の型が自然に配置できません。</target>       </trans-unit>
        <trans-unit id="4127" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.r8`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stind.r8`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4128" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_R8">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4129" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Stores a object reference value at a supplied address.</source>
          <target state="translated">提供されたアドレスにオブジェクト参照値を格納します。</target>       </trans-unit>
        <trans-unit id="4130" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4131" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4132" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4133" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4134" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>51</source>
          <target state="translated">51</target>       </trans-unit>
        <trans-unit id="4135" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>stind.ref</source>
          <target state="translated">stind.ref</target>       </trans-unit>
        <trans-unit id="4136" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Stores an object reference (type <ph id="ph1">`O`</ph>) value at a given address.</source>
          <target state="translated">オブジェクト参照を保存 (型<ph id="ph1">`O`</ph>) 指定したアドレスにある値。</target>       </trans-unit>
        <trans-unit id="4137" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4138" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4139" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4140" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The value and the address are popped from the stack; the value is stored at the address.</source>
          <target state="translated">値と、アドレスがスタックからポップされます。値は、アドレスに格納されます。</target>       </trans-unit>
        <trans-unit id="4141" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The <ph id="ph1">`stind.ref`</ph> instruction stores an object reference value at the supplied address (type <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, or <ph id="ph4">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stind.ref`</ph>命令は、指定されたアドレスにオブジェクト参照値を格納 (型<ph id="ph2">`native int`</ph>、 <ph id="ph3">`*`</ph>、または<ph id="ph4">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="4142" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>Type safe operation requires that the <ph id="ph1">`stind.ref`</ph> instruction be used in a manner consistent with the type of the pointer.</source>
          <target state="translated">タイプ セーフな演算では、する必要があります、<ph id="ph1">`stind.ref`</ph>命令ポインターの型と一致する方法で使用します。</target>       </trans-unit>
        <trans-unit id="4143" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The operation of the <ph id="ph1">`stind.ref`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`stind.ref`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="4144" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`addr`</ph> is not naturally aligned for the argument type implied by the instruction suffix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`addr`</ph>命令のサフィックスが含まれる引数の型が自然に配置できません。</target>       </trans-unit>
        <trans-unit id="4145" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stind.ref`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stind.ref`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4146" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stind_Ref">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4147" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</source>
          <target state="translated">評価スタックの一番上から現在の値をポップし、指定したインデックスのローカル変数リストに格納します。</target>       </trans-unit>
        <trans-unit id="4148" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4149" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4150" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4151" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4152" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>FE 0E &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 0E &lt; <ph id="ph1">`unsigned int16`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4153" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>stloc <ph id="ph1">`index`</ph></source>
          <target state="translated">stloc <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="4154" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Pops a value from the stack and stores it in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">スタックから値をポップし、ローカル変数に格納<ph id="ph1">`index`</ph>です。</target>       </trans-unit>
        <trans-unit id="4155" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4156" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>A value is popped off of the stack and placed in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">値がスタックからポップされ、ローカル変数に格納<ph id="ph1">`index`</ph>です。</target>       </trans-unit>
        <trans-unit id="4157" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The <ph id="ph1">`stloc`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id="ph2">`index`</ph>, where local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`stloc`</ph>命令は、評価スタックの最上位の値をポップし、ローカル変数の数に移さ<ph id="ph2">`index`</ph>では、ローカル変数は番号 0 以降。</target>       </trans-unit>
        <trans-unit id="4158" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。</target>       </trans-unit>
        <trans-unit id="4159" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。</target>       </trans-unit>
        <trans-unit id="4160" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズから丸められます (型<ph id="ph1">`F`</ph>) を引数に関連付けられているサイズにします。</target>       </trans-unit>
        <trans-unit id="4161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>Correct Microsoft Intermediate Language (MSIL) instructions require that <ph id="ph1">`index`</ph> be a valid local index.</source>
          <target state="translated">正しい Microsoft Intermediate Language (MSIL) の手順を必要とする<ph id="ph1">`index`</ph>ローカル インデックスを有効にします。</target>       </trans-unit>
        <trans-unit id="4162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>For the <ph id="ph1">`stloc`</ph> instruction, <ph id="ph2">`index`</ph> must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid).</source>
          <target state="translated"><ph id="ph1">`stloc`</ph>命令、<ph id="ph2">`index`</ph>包括 0 を 65534 の範囲内である必要があります (具体的には、65535 が正しくありません)。</target>       </trans-unit>
        <trans-unit id="4163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method.</source>
          <target state="translated">65535 を除くための実用的な: 可能性の高い実装は、2 バイト整数を使用して特定のメソッドのローカル変数の合計数だけでなく、ローカルのインデックスを追跡するためには。</target>       </trans-unit>
        <trans-unit id="4164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</source>
          <target state="translated">65535 のインデックスが行われた有効な場合、このようなメソッドでのローカルの数を追跡するために広く整数が必要になります。</target>       </trans-unit>
        <trans-unit id="4165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`stloc`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードを使用できる、<ph id="ph2">`stloc`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit (オペコード、LocalBuilder)</target>       </trans-unit>
        <trans-unit id="4167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc">
          <source>ILGenerator.Emit(OpCode, short)</source>
          <target state="translated">ILGenerator.Emit (オペコード、short)</target>       </trans-unit>
        <trans-unit id="4168" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</source>
          <target state="translated">評価スタックの一番上から現在の値をポップし、インデックス 0 のローカル変数リストに格納します。</target>       </trans-unit>
        <trans-unit id="4169" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4170" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4171" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4172" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4173" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>0A</source>
          <target state="translated">0A</target>       </trans-unit>
        <trans-unit id="4174" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>stloc.0</source>
          <target state="translated">stloc.0</target>       </trans-unit>
        <trans-unit id="4175" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Pops a value from the stack into local variable 0.</source>
          <target state="translated">0 のローカル変数には、スタックから値をポップします。</target>       </trans-unit>
        <trans-unit id="4176" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4177" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>A value is popped off of the stack and placed in the local variable indexed by 0.</source>
          <target state="translated">値がスタックからポップされ、インデックスが 0 でローカル変数に格納されます。</target>       </trans-unit>
        <trans-unit id="4178" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The <ph id="ph1">`stloc.0`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0.</source>
          <target state="translated"><ph id="ph1">`stloc.0`</ph>命令は、評価スタックの最上位の値をポップし、インデックスが 0 であるローカル変数に移動します。</target>       </trans-unit>
        <trans-unit id="4179" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。</target>       </trans-unit>
        <trans-unit id="4180" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source><ph id="ph1">`stloc.0`</ph> is an especially efficient encoding for storing values in local variable 0.</source>
          <target state="translated"><ph id="ph1">`stloc.0`</ph> 0 のローカル変数の値を格納するため、特に効率的なエンコードです。</target>       </trans-unit>
        <trans-unit id="4181" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。</target>       </trans-unit>
        <trans-unit id="4182" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズから丸められます (型<ph id="ph1">`F`</ph>) を引数に関連付けられているサイズにします。</target>       </trans-unit>
        <trans-unit id="4183" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.0`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stloc.0`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4184" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_0">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4185" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</source>
          <target state="translated">評価スタックの一番上から現在の値をポップし、インデックス 1 のローカル変数リストに格納します。</target>       </trans-unit>
        <trans-unit id="4186" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4187" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4188" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4189" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4190" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>0B</source>
          <target state="translated">0B</target>       </trans-unit>
        <trans-unit id="4191" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>stloc.1</source>
          <target state="translated">stloc.1</target>       </trans-unit>
        <trans-unit id="4192" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Pops a value from the stack into local variable 1.</source>
          <target state="translated">1 のローカル変数には、スタックから値をポップします。</target>       </trans-unit>
        <trans-unit id="4193" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4194" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>A value is popped off of the stack and placed in the local variable indexed by 1.</source>
          <target state="translated">値がスタックからポップされ、インデックスが 1 でローカル変数に格納されます。</target>       </trans-unit>
        <trans-unit id="4195" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The <ph id="ph1">`stloc.1`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1.</source>
          <target state="translated"><ph id="ph1">`stloc.1`</ph>命令は、評価スタックの最上位の値をポップし、インデックスが 1 でローカル変数に移動します。</target>       </trans-unit>
        <trans-unit id="4196" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。</target>       </trans-unit>
        <trans-unit id="4197" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source><ph id="ph1">`stloc.1`</ph> is an especially efficient encoding for storing values in local variable 1.</source>
          <target state="translated"><ph id="ph1">`stloc.1`</ph> 1 のローカル変数の値を格納するため、特に効率的なエンコードです。</target>       </trans-unit>
        <trans-unit id="4198" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。</target>       </trans-unit>
        <trans-unit id="4199" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズから丸められます (型<ph id="ph1">`F`</ph>) を引数に関連付けられているサイズにします。</target>       </trans-unit>
        <trans-unit id="4200" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.1`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stloc.1`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4201" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_1">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4202" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</source>
          <target state="translated">評価スタックの一番上から現在の値をポップし、インデックス 2 のローカル変数リストに格納します。</target>       </trans-unit>
        <trans-unit id="4203" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4204" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4205" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>0C</source>
          <target state="translated">0C</target>       </trans-unit>
        <trans-unit id="4208" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>stloc.2</source>
          <target state="translated">stloc.2</target>       </trans-unit>
        <trans-unit id="4209" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Pops a value from the stack into local variable 2</source>
          <target state="translated">2 のローカル変数に、スタックから値をポップします。</target>       </trans-unit>
        <trans-unit id="4210" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4211" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>A value is popped off of the stack and placed in the local variable indexed by 2.</source>
          <target state="translated">値がスタックからポップされ、インデックスが 2 でローカル変数に格納します。</target>       </trans-unit>
        <trans-unit id="4212" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The <ph id="ph1">`stloc.2`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2.</source>
          <target state="translated"><ph id="ph1">`stloc.2`</ph>命令は、評価スタックの最上位の値をポップし、インデックスが 2 でローカル変数に移動します。</target>       </trans-unit>
        <trans-unit id="4213" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。</target>       </trans-unit>
        <trans-unit id="4214" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source><ph id="ph1">`stloc.2`</ph> is an especially efficient encoding for storing values in local variable 2.</source>
          <target state="translated"><ph id="ph1">`stloc.2`</ph> 2 のローカル変数の値を格納するため、特に効率的なエンコードです。</target>       </trans-unit>
        <trans-unit id="4215" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。</target>       </trans-unit>
        <trans-unit id="4216" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズから丸められます (型<ph id="ph1">`F`</ph>) を引数に関連付けられているサイズにします。</target>       </trans-unit>
        <trans-unit id="4217" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.2`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stloc.2`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4218" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_2">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4219" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</source>
          <target state="translated">評価スタックの一番上から現在の値をポップし、インデックス 3 のローカル変数リストに格納します。</target>       </trans-unit>
        <trans-unit id="4220" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4221" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4222" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4223" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>0D</source>
          <target state="translated">0D</target>       </trans-unit>
        <trans-unit id="4225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>stloc.3</source>
          <target state="translated">stloc.3</target>       </trans-unit>
        <trans-unit id="4226" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Pops a value from the stack into local variable 3</source>
          <target state="translated">3 のローカル変数に、スタックから値をポップします。</target>       </trans-unit>
        <trans-unit id="4227" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4228" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>A value is popped off of the stack and placed in the local variable indexed by 3.</source>
          <target state="translated">値がスタックからポップされ、3 でインデックス付けされたローカル変数に格納されます。</target>       </trans-unit>
        <trans-unit id="4229" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The <ph id="ph1">`stloc.3`</ph> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3.</source>
          <target state="translated"><ph id="ph1">`stloc.3`</ph>命令は、評価スタックの最上位の値をポップし、インデックスが 3 でローカル変数に移動します。</target>       </trans-unit>
        <trans-unit id="4230" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。</target>       </trans-unit>
        <trans-unit id="4231" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source><ph id="ph1">`stloc.3`</ph> is an especially efficient encoding for storing values in local variable 3.</source>
          <target state="translated"><ph id="ph1">`stloc.3`</ph> 3 のローカル変数の値を格納するため、特に効率的なエンコードです。</target>       </trans-unit>
        <trans-unit id="4232" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。</target>       </trans-unit>
        <trans-unit id="4233" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズから丸められます (型<ph id="ph1">`F`</ph>) を引数に関連付けられているサイズにします。</target>       </trans-unit>
        <trans-unit id="4234" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stloc.3`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stloc.3`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4235" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_3">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4236" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <ph id="ph1">&lt;paramref name="index" /&gt;</ph> (short form).</source>
          <target state="translated">評価スタックの一番上から現在の値をポップし、<ph id="ph1">&lt;paramref name="index" /&gt;</ph> のローカル変数リストに格納します (短い形式)。</target>       </trans-unit>
        <trans-unit id="4237" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4238" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4239" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4240" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4241" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>13 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">13 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4242" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>stloc.s <ph id="ph1">`index`</ph></source>
          <target state="translated">stloc.s <ph id="ph1">`index`</ph></target>       </trans-unit>
        <trans-unit id="4243" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Pops a value from the stack and stores it in local variable <ph id="ph1">`index`</ph>, short form.</source>
          <target state="translated">スタックから値をポップし、ローカル変数に格納<ph id="ph1">`index`</ph>、短縮形です。</target>       </trans-unit>
        <trans-unit id="4244" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4245" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>A value is popped off of the stack and placed in local variable <ph id="ph1">`index`</ph>.</source>
          <target state="translated">値がスタックからポップされ、ローカル変数に格納<ph id="ph1">`index`</ph>です。</target>       </trans-unit>
        <trans-unit id="4246" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The <ph id="ph1">`stloc.s`</ph> instruction pops the top value off the evaluation stack and moves it into local variable number <ph id="ph2">`index`</ph>, where local variables are numbered 0 onwards.</source>
          <target state="translated"><ph id="ph1">`stloc.s`</ph>命令は、評価スタックの最上位の値をポップし、ローカル変数の数に移さ<ph id="ph2">`index`</ph>では、ローカル変数は番号 0 以降。</target>       </trans-unit>
        <trans-unit id="4247" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The type of the value must match the type of the local variable as specified in the current method's local signature.</source>
          <target state="translated">値の型は、現在のメソッドのローカル シグネチャで指定されたローカル変数の型と一致する必要があります。</target>       </trans-unit>
        <trans-unit id="4248" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The <ph id="ph1">`stloc.s`</ph> instruction provides an efficient encoding for local variables 0 through 255.</source>
          <target state="translated"><ph id="ph1">`stloc.s`</ph>命令は、0 255 までからのローカル変数の効率的なエンコーディングを提供します。</target>       </trans-unit>
        <trans-unit id="4249" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable.</source>
          <target state="translated">4 バイト長より小さい整数値を保持しているローカルに格納すると、スタックから、ローカル変数に移動するときに値が切り詰められます。</target>       </trans-unit>
        <trans-unit id="4250" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>Floating-point values are rounded from their native size (type <ph id="ph1">`F`</ph>) to the size associated with the argument.</source>
          <target state="translated">浮動小数点値は、ネイティブのサイズから丸められます (型<ph id="ph1">`F`</ph>) を引数に関連付けられているサイズにします。</target>       </trans-unit>
        <trans-unit id="4251" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`stloc.s`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードを使用できる、<ph id="ph2">`stloc.s`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4252" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>ILGenerator.Emit(OpCode, LocalBuilder)</source>
          <target state="translated">ILGenerator.Emit (オペコード、LocalBuilder)</target>       </trans-unit>
        <trans-unit id="4253" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stloc_S">
          <source>ILGenerator.Emit(OpCode, byte)</source>
          <target state="translated">ILGenerator.Emit (オペコード, byte)</target>       </trans-unit>
        <trans-unit id="4254" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Copies a value of a specified type from the evaluation stack into a supplied memory address.</source>
          <target state="translated">評価スタックから提供されたメモリ アドレスに、指定した型の値をコピーします。</target>       </trans-unit>
        <trans-unit id="4255" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4256" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4257" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4258" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4259" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>81 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">81 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4260" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>stobj <ph id="ph1">`class`</ph></source>
          <target state="translated">stobj <ph id="ph1">`class`</ph></target>       </trans-unit>
        <trans-unit id="4261" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>Stores a value of type <ph id="ph1">`class`</ph> from the stack into memory.</source>
          <target state="translated">型の値が格納<ph id="ph1">`class`</ph>メモリにスタックからです。</target>       </trans-unit>
        <trans-unit id="4262" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4263" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4264" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>A value type object of type <ph id="ph1">`class`</ph> is pushed onto the stack.</source>
          <target state="translated">型の値型のオブジェクト<ph id="ph1">`class`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4265" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The object and the address are popped from the stack; the value type object is stored at the address.</source>
          <target state="translated">オブジェクトとアドレスがスタックからポップされます。値型のオブジェクトは、アドレスに格納されます。</target>       </trans-unit>
        <trans-unit id="4266" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The <ph id="ph1">`stobj`</ph> instruction copies the value type object into the address specified by the address (a pointer of type <ph id="ph2">`native int`</ph>, <ph id="ph3">`*`</ph>, or <ph id="ph4">`&amp;`</ph>).</source>
          <target state="translated"><ph id="ph1">`stobj`</ph>命令アドレスで指定されたアドレスに値型のオブジェクトをコピーする (型のポインター <ph id="ph2">`native int`</ph>、 <ph id="ph3">`*`</ph>、または<ph id="ph4">`&amp;`</ph>)。</target>       </trans-unit>
        <trans-unit id="4267" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The number of bytes copied depends on the size of the class represented by <ph id="ph1">`class`</ph>, a metadata token representing a value type.</source>
          <target state="translated">コピーされたバイト数で表されるクラスのサイズによって異なります<ph id="ph1">`class`</ph>値型を表すメタデータ トークン。</target>       </trans-unit>
        <trans-unit id="4268" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The operation of the <ph id="ph1">`stobj`</ph> instruction can be altered by an immediately preceding <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> prefix instruction.</source>
          <target state="translated">操作、<ph id="ph1">`stobj`</ph>命令は、の直前で変更できます<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>または<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>命令をプレフィックスします。</target>       </trans-unit>
        <trans-unit id="4269" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if class cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> クラスが見つからない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="4270" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。</target>       </trans-unit>
        <trans-unit id="4271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stobj`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stobj`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stobj">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="4273" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Replaces the value of a static field with a value from the evaluation stack.</source>
          <target state="translated">静的フィールドの値を評価スタックの値に置き換えます。</target>       </trans-unit>
        <trans-unit id="4274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4276" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4277" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4278" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>80 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">80 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4279" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>stsfld <ph id="ph1">`field`</ph></source>
          <target state="translated">stsfld <ph id="ph1">`field`</ph></target>       </trans-unit>
        <trans-unit id="4280" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>Replaces the value in <ph id="ph1">`field`</ph> with a supplied value.</source>
          <target state="translated">値を置き換えます<ph id="ph1">`field`</ph>指定された値を使用します。</target>       </trans-unit>
        <trans-unit id="4281" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4282" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4283" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>A value is popped from the stack and stored in <ph id="ph1">`field`</ph>.</source>
          <target state="translated">値が、スタックからポップされに格納されている<ph id="ph1">`field`</ph>です。</target>       </trans-unit>
        <trans-unit id="4284" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The <ph id="ph1">`stsfld`</ph> instruction replaces the value of a static field with a value from the stack.</source>
          <target state="translated"><ph id="ph1">`stsfld`</ph>命令がスタックから値を持つ静的フィールドの値を置き換えます。</target>       </trans-unit>
        <trans-unit id="4285" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source><ph id="ph1">`field`</ph> is a metadata token that must refer to a static field member.</source>
          <target state="translated"><ph id="ph1">`field`</ph> 静的フィールド メンバーを参照する必要があるメタデータ トークンです。</target>       </trans-unit>
        <trans-unit id="4286" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The <ph id="ph1">`stsfld`</ph> instruction may be prefixed by <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`stsfld`</ph>命令をプレフィックスとして付けることがあります<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4287" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> is thrown if field is not found in the metadata.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.MissingFieldException&gt;</ph> フィールドは、メタデータ内で見つからない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="4288" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) の手順については、実行時ではなく、ネイティブ コードに変換する場合にチェックします。</target>       </trans-unit>
        <trans-unit id="4289" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`stsfld`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`stsfld`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4290" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Stsfld">
          <source>ILGenerator.Emit(OpCode, FieldInfo)</source>
          <target state="translated">ILGenerator.Emit (オペコード、FieldInfo)</target>       </trans-unit>
        <trans-unit id="4291" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Subtracts one value from another and pushes the result onto the evaluation stack.</source>
          <target state="translated">ある値から別の値を減算し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="4292" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4293" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4294" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4295" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4296" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>59</source>
          <target state="translated">59</target>       </trans-unit>
        <trans-unit id="4297" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>sub</source>
          <target state="translated">sub</target>       </trans-unit>
        <trans-unit id="4298" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Subtracts one value from another, returning a new numeric value.</source>
          <target state="translated">新しい数値を返す別の 1 つの値を減算します。</target>       </trans-unit>
        <trans-unit id="4299" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4300" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4301" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4302" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph>.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value2`</ph>から差し引かれます<ph id="ph4">`value1`</ph>です。</target>       </trans-unit>
        <trans-unit id="4303" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4304" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Overflow is not detected for integer operations (for proper overflow handling, see <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>).</source>
          <target state="translated">整数演算のオーバーフローが検出されない (適切なオーバーフロー処理では、次を参照してください。 <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub_Ovf&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="4305" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Integer subtraction wraps, rather than saturates.</source>
          <target state="translated">整数の減算飽和するのではなく、ラップします。</target>       </trans-unit>
        <trans-unit id="4306" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>For example: assuming 8-bit integers, where <ph id="ph1">`value1`</ph> is set to 0 and <ph id="ph2">`value2`</ph> is set to 1, the "wrapped" result will be 255.</source>
          <target state="translated">例: 8 ビット整数場所<ph id="ph1">`value1`</ph>0 に設定されていると<ph id="ph2">`value2`</ph>が設定を 1 に「ラップされた」の結果は 255 になります。</target>       </trans-unit>
        <trans-unit id="4307" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>Floating-point overflow returns <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) or <ph id="ph3">`-inf`</ph> (<ph id="ph4">`NegativeInfinity`</ph>).</source>
          <target state="translated">浮動小数点オーバーフロー <ph id="ph1">`+inf`</ph> (<ph id="ph2">`PositiveInfinity`</ph>) または<ph id="ph3">`-inf`</ph>(<ph id="ph4">`NegativeInfinity`</ph>)。</target>       </trans-unit>
        <trans-unit id="4308" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`sub`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4309" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4310" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">ある整数値を別の整数値から減算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="4311" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4312" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4313" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4314" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4315" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>DA</source>
          <target state="translated">DA</target>       </trans-unit>
        <trans-unit id="4316" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>sub.ovf</source>
          <target state="translated">sub.ovf</target>       </trans-unit>
        <trans-unit id="4317" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>Subtracts one integer value from another with an overflow check.</source>
          <target state="translated">オーバーフロー チェックを別の 1 つの整数値を減算します。</target>       </trans-unit>
        <trans-unit id="4318" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4319" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4320" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4321" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value2`</ph>から差し引かれます<ph id="ph4">`value1`</ph>オーバーフローをチェックします。</target>       </trans-unit>
        <trans-unit id="4322" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4323" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="4324" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>This operation is performed on signed integers; for floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</source>
          <target state="translated">符号付き整数では、この操作を実行してください。浮動小数点の値を使用して<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4325" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub.ovf`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`sub.ovf`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4326" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4327" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</source>
          <target state="translated">ある符号なし整数値を別の符号なし整数値から減算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="4328" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4329" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4330" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4331" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>DB</source>
          <target state="translated">DB</target>       </trans-unit>
        <trans-unit id="4333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>sub.ovf.un</source>
          <target state="translated">sub.ovf.un</target>       </trans-unit>
        <trans-unit id="4334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>Subtracts one unsigned integer value from another with an overflow check.</source>
          <target state="translated">オーバーフロー チェックを別の 1 つの符号なし整数値を減算します。</target>       </trans-unit>
        <trans-unit id="4335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4337" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack; <ph id="ph3">`value2`</ph> is subtracted from <ph id="ph4">`value1`</ph> with a check for overflow.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックからポップされます。<ph id="ph3">`value2`</ph>から差し引かれます<ph id="ph4">`value1`</ph>オーバーフローをチェックします。</target>       </trans-unit>
        <trans-unit id="4339" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The result is pushed onto the stack.</source>
          <target state="translated">結果は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4340" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> is thrown if the result can not be represented in the result type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.OverflowException&gt;</ph> 結果は、結果の型では表されない場合にスローされます。</target>       </trans-unit>
        <trans-unit id="4341" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>This operation is performed on signed integers; for floating-point values, use <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>.</source>
          <target state="translated">符号付き整数では、この操作を実行してください。浮動小数点の値を使用して<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Sub&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4342" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`sub.ovf.un`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`sub.ovf.un`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4343" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4344" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Implements a jump table.</source>
          <target state="translated">ジャンプ テーブルを実装します。</target>       </trans-unit>
        <trans-unit id="4345" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4346" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4347" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4348" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4349" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>45 &lt; <ph id="ph1">`unsigned int32`</ph> &gt; &lt; <ph id="ph2">`int32`</ph> &gt;... &lt; <ph id="ph3">`int32`</ph><ph id="ph4"> &gt;</ph></source>
          <target state="translated">45 &lt; <ph id="ph1">`unsigned int32`</ph> &gt; &lt; <ph id="ph2">`int32`</ph> &gt;... &lt; <ph id="ph3">`int32`</ph><ph id="ph4"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4350" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>switch (<ph id="ph1">`N`</ph>, <ph id="ph2">`t1`</ph>, <ph id="ph3">`t2`</ph>... <ph id="ph4">`tN`</ph>)</source>
          <target state="translated">switch (<ph id="ph1">`N`</ph>, <ph id="ph2">`t1`</ph>, <ph id="ph3">`t2`</ph>...<ph id="ph4">`tN`</ph>)</target>       </trans-unit>
        <trans-unit id="4351" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Jumps to one of <ph id="ph1">`N`</ph> values.</source>
          <target state="translated">いずれかにジャンプ<ph id="ph1">`N`</ph>値。</target>       </trans-unit>
        <trans-unit id="4352" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4353" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>A value is pushed onto the stack.</source>
          <target state="translated">値は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4354" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than <ph id="ph1">`N`</ph>.</source>
          <target state="translated">値は、スタックからポップし、実行は、値が、命令のインデックスを指定されたオフセット位置に転送より小さい<ph id="ph1">`N`</ph>です。</target>       </trans-unit>
        <trans-unit id="4355" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`switch`</ph> instruction implements a jump table.</source>
          <target state="translated"><ph id="ph1">`switch`</ph>命令がジャンプ テーブルを実装します。</target>       </trans-unit>
        <trans-unit id="4356" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The format of the instruction is an <ph id="ph1">`unsigned int32`</ph> representing the number of targets <ph id="ph2">`N`</ph>, followed by <ph id="ph3">`N`</ph> int32 values specifying jump targets.</source>
          <target state="translated">命令の形式は、<ph id="ph1">`unsigned int32`</ph>ターゲットの数を表す<ph id="ph2">`N`</ph>、その後に<ph id="ph3">`N`</ph>int32 値を指定することは、ターゲットを移動します。</target>       </trans-unit>
        <trans-unit id="4357" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>These targets are represented as offsets (positive or negative) from the beginning of the instruction following this <ph id="ph1">`switch`</ph> instruction.</source>
          <target state="translated">これらのターゲットは、これを次の命令の先頭からのオフセット (正または負の値) として表されます<ph id="ph1">`switch`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="4358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`switch`</ph> instruction pops a value off the stack and compares it, as an unsigned integer, to <ph id="ph2">`N`</ph>.</source>
          <target state="translated"><ph id="ph1">`switch`</ph>命令がスタックからの値をポップし、符号なし整数として比較し、<ph id="ph2">`N`</ph>です。</target>       </trans-unit>
        <trans-unit id="4359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If value is less than <ph id="ph1">`N`</ph>, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on).</source>
          <target state="translated">値の場合より小さい<ph id="ph1">`N`</ph>、0 からターゲットの番号と位置のインデックス値をターゲットに実行が転送される (たとえば、0 の値は、最初のターゲットを取得、1 の値と 2 つ目のターゲットを取得する)。</target>       </trans-unit>
        <trans-unit id="4360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If the value is greater than or equal to <ph id="ph1">`N`</ph>, execution continues at the next instruction (fall through).</source>
          <target state="translated">値がより大きいか等しい場合<ph id="ph1">`N`</ph>、次の命令 (フォール スルー) で実行が続行します。</target>       </trans-unit>
        <trans-unit id="4361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</source>
          <target state="translated">最初に制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。</target>       </trans-unit>
        <trans-unit id="4362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>Control transfers into and out of <ph id="ph1">`try`</ph>, <ph id="ph2">`catch`</ph>, <ph id="ph3">`filter`</ph>, and <ph id="ph4">`finally`</ph> blocks cannot be performed by this instruction.</source>
          <target state="translated">制御が移りますアウトや<ph id="ph1">`try`</ph>、 <ph id="ph2">`catch`</ph>、 <ph id="ph3">`filter`</ph>、および<ph id="ph4">`finally`</ph>この命令でブロックは実行できません。</target>       </trans-unit>
        <trans-unit id="4363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>(Such transfers are severely restricted and must use the leave instruction instead).</source>
          <target state="translated">(このような移動は厳しく制限されるはおよび leave 命令を代わりに使用する必要があります。)</target>       </trans-unit>
        <trans-unit id="4364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`switch`</ph> opcode.</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、 <ph id="ph2">`switch`</ph> opcode です。</target>       </trans-unit>
        <trans-unit id="4365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The <ph id="ph1">`Label[]`</ph> argument is an array of Labels representing 32-bit offsets.</source>
          <target state="translated"><ph id="ph1">`Label[]`</ph>引数は、32 ビットのオフセットを表すラベルの配列。</target>       </trans-unit>
        <trans-unit id="4366" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>ILGenerator.Emit(OpCode, Label[])</source>
          <target state="translated">ILGenerator.Emit (オペコード、Label[])</target>       </trans-unit>
        <trans-unit id="4367" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Switch">
          <source>The following code sample illustrates the use of the <ph id="ph1">`Switch`</ph> opcode to generate a jump table using an array of <ph id="ph2">&lt;xref:System.Reflection.Emit.Label&gt;</ph>.</source>
          <target state="translated">次のコード サンプルの使用を示しています、<ph id="ph1">`Switch`</ph>の配列を使用してジャンプ テーブルを生成するオペコード<ph id="ph2">&lt;xref:System.Reflection.Emit.Label&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4368" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</source>
          <target state="translated">実際の呼び出し命令が実行される前に、現在のメソッドのスタック フレームが削除されるように、後置のメソッド呼び出し命令を実行します。</target>       </trans-unit>
        <trans-unit id="4369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>FE 14</source>
          <target state="translated">FE 14</target>       </trans-unit>
        <trans-unit id="4374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>tail.</source>
          <target state="translated">末尾。</target>       </trans-unit>
        <trans-unit id="4375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Subsequent call terminates current methods</source>
          <target state="translated">後続の呼び出しでは、現在のメソッドを終了します。</target>       </trans-unit>
        <trans-unit id="4376" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>There is no stack transition behavior defined for this instruction.</source>
          <target state="translated">この命令に対して定義されている履歴の移行の動作はありません。</target>       </trans-unit>
        <trans-unit id="4377" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The <ph id="ph1">`tail`</ph> prefix instruction must immediately precede a <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph> instruction.</source>
          <target state="translated"><ph id="ph1">`tail`</ph>プレフィックス命令の直前にある必要があります、 <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>、 <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Calli&gt;</ph>、または<ph id="ph4">&lt;xref:System.Reflection.Emit.OpCodes.Callvirt&gt;</ph>命令します。</target>       </trans-unit>
        <trans-unit id="4378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>It indicates that the current method's stack frame should be removed before the call instruction is executed.</source>
          <target state="translated">これは、呼び出し命令を実行する前に、現在のメソッドのスタック フレームが削除されることを示します。</target>       </trans-unit>
        <trans-unit id="4379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</source>
          <target state="translated">また、後続の呼び出しから返される値も、現在のメソッドによって返される値と、呼び出しはクロス メソッド ジャンプにしたがって変換することを意味します。</target>       </trans-unit>
        <trans-unit id="4380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The stack must be empty except for the arguments being transferred by the following call.</source>
          <target state="translated">スタックは、次の呼び出しによって転送される引数を除く空にする必要があります。</target>       </trans-unit>
        <trans-unit id="4381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The instruction following the call instruction must be a ret. Thus the only valid code sequence is <ph id="ph1">`tail. call`</ph> (or <ph id="ph2">`calli`</ph> or <ph id="ph3">`callvirt`</ph>).</source>
          <target state="translated">呼び出し命令を次の命令は、ret をする必要があります。したがって、唯一の有効なコード シーケンスは<ph id="ph1">`tail. call`</ph>(または<ph id="ph2">`calli`</ph>または<ph id="ph3">`callvirt`</ph>)。</target>       </trans-unit>
        <trans-unit id="4382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the <ph id="ph1">`call`</ph> instruction, but they may branch to the subsequent <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>.</source>
          <target state="translated">Microsoft Intermediate Language (MSIL) の正しい指示する必要がありますに分岐できません、 <ph id="ph1">`call`</ph> 、それ以降に分岐可能性がある、命令が<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ret&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="4383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security.</source>
          <target state="translated">コントロールが転送されるときに信頼されていないコードから、信頼されるコードを id のセキュリティをコードから、現在のフレームを破棄できません。</target>       </trans-unit>
        <trans-unit id="4384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The .NET Framework security checks can therefore cause the <ph id="ph1">`tail`</ph> to be ignored, leaving a standard <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph> instruction.</source>
          <target state="translated">.NET Framework セキュリティ チェックの可能性がありますので、<ph id="ph1">`tail`</ph>は無視され、標準のまま<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Call&gt;</ph>命令します。</target>       </trans-unit>
        <trans-unit id="4385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the <ph id="ph1">`tail`</ph> prefix is ignored when used to exit a method that is marked synchronized.</source>
          <target state="translated">同様の順序、呼び出しが戻った後に同期の領域を終了できるようにする場合、<ph id="ph1">`tail`</ph>同期済みとマークされているメソッドを終了に使用する場合、プレフィックスは無視されます。</target>       </trans-unit>
        <trans-unit id="4386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`tail`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`tail`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4387" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Tailcall">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4388" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>An instance of an Opcode object.</source>
          <target state="translated">Opcode オブジェクトのインスタンス。</target>       </trans-unit>
        <trans-unit id="4389" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>Returns true or false if the supplied opcode takes a single byte argument.</source>
          <target state="translated">提供されたオペコードが 1 バイト引数をとる場合は、true または false を返します。</target>       </trans-unit>
        <trans-unit id="4390" translate="yes" xml:space="preserve" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source><ph id="ph1">&lt;see langword="True" /&gt;</ph> or <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="True" /&gt;</ph> または <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="4391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>This method can be used to find which MSIL opcodes are "short form", for use in optimized code.</source>
          <target state="translated">このメソッドは、どの MSIL オペコードが、最適化されたコードの"short"、使用する形式の検索に使用できます。</target>       </trans-unit>
        <trans-unit id="4392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source><ph id="ph1">`TakesSingleByteArgument`</ph> returns <ph id="ph2">`true`</ph> if the <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCode&gt;</ph> instance takes a single byte argument in the following cases:</source>
          <target state="translated"><ph id="ph1">`TakesSingleByteArgument`</ph> 返します<ph id="ph2">`true`</ph>場合、<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCode&gt;</ph>インスタンスでは、1 バイト引数を受け取り、次の場合。</target>       </trans-unit>
        <trans-unit id="4393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode performs a branch instruction to a byte-sized address (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Br_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Bgt_S&gt;</ph>).</source>
          <target state="translated">オペコード サイズのバイトのアドレスにブランチ命令を実行する (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Br_S&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Bgt_S&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="4394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode pushes a byte value onto the stack (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4_S&gt;</ph>).</source>
          <target state="translated">オペコード プッシュ、スタックのバイト値 (たとえば、 <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldc_I4_S&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="4395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The opcode references a variable or argument via the byte-sized "short form" (for example, <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc_S&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stloc_S&gt;</ph>).</source>
          <target state="translated">オペコード参照変数または引数のバイト サイズ「短縮形」を使用して (たとえば、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldloc_S&gt;</ph>と<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Stloc_S&gt;</ph>)。</target>       </trans-unit>
        <trans-unit id="4396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>Otherwise, it returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">それ以外の場合は、<ph id="ph1">`false`</ph> を返します。</target>       </trans-unit>
        <trans-unit id="4397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)">
          <source>The example below demonstrates the use of <ph id="ph1">`TakesSingleByteArgument`</ph> by reflecting on to the <ph id="ph2">`OpCodes`</ph> class and testing to see whether each <ph id="ph3">`OpCode`</ph> field takes a single-byte argument.</source>
          <target state="translated">使用を次の例に示します<ph id="ph1">`TakesSingleByteArgument`</ph>に反映して、<ph id="ph2">`OpCodes`</ph>クラスとテストを表示するかどうか各<ph id="ph3">`OpCode`</ph>フィールドは 1 バイト引数を受け取ります。</target>       </trans-unit>
        <trans-unit id="4398" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Throws the exception object currently on the evaluation stack.</source>
          <target state="translated">現在評価スタックにある例外オブジェクトをスローします。</target>       </trans-unit>
        <trans-unit id="4399" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4400" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4401" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>7A</source>
          <target state="translated">7A</target>       </trans-unit>
        <trans-unit id="4404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>throw</source>
          <target state="translated">throw</target>       </trans-unit>
        <trans-unit id="4405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>Throws an exception.</source>
          <target state="translated">例外をスローします。</target>       </trans-unit>
        <trans-unit id="4406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4407" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>An object reference (to an exception) is pushed onto the stack.</source>
          <target state="translated">(例外) へのオブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4408" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The object reference is popped from the stack and the exception thrown.</source>
          <target state="translated">オブジェクト参照がスタックし、スローされた例外からポップされます。</target>       </trans-unit>
        <trans-unit id="4409" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The <ph id="ph1">`throw`</ph> instruction throws the exception object (type <ph id="ph2">`O`</ph>) currently on the stack.</source>
          <target state="translated"><ph id="ph1">`throw`</ph>命令は、例外オブジェクトをスロー (型<ph id="ph2">`O`</ph>) 現在のスタックにします。</target>       </trans-unit>
        <trans-unit id="4410" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> オブジェクト参照が null 参照である場合にスローされます。</target>       </trans-unit>
        <trans-unit id="4411" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`throw`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`throw`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4412" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Throw">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4413" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <ph id="ph1">&lt;see langword="ldind" /&gt;</ph>, <ph id="ph2">&lt;see langword="stind" /&gt;</ph>, <ph id="ph3">&lt;see langword="ldfld" /&gt;</ph>, <ph id="ph4">&lt;see langword="stfld" /&gt;</ph>, <ph id="ph5">&lt;see langword="ldobj" /&gt;</ph>, <ph id="ph6">&lt;see langword="stobj" /&gt;</ph>, <ph id="ph7">&lt;see langword="initblk" /&gt;</ph>, or <ph id="ph8">&lt;see langword="cpblk" /&gt;</ph> instruction.</source>
          <target state="translated">現在評価スタックの一番上にあるアドレスが、直後の <ph id="ph1">&lt;see langword="ldind" /&gt;</ph>、<ph id="ph2">&lt;see langword="stind" /&gt;</ph>、<ph id="ph3">&lt;see langword="ldfld" /&gt;</ph>、<ph id="ph4">&lt;see langword="stfld" /&gt;</ph>、<ph id="ph5">&lt;see langword="ldobj" /&gt;</ph>、<ph id="ph6">&lt;see langword="stobj" /&gt;</ph>、<ph id="ph7">&lt;see langword="initblk" /&gt;</ph> または <ph id="ph8">&lt;see langword="cpblk" /&gt;</ph> の各命令の通常サイズに合わせて配置されていない可能性があることを示します。</target>       </trans-unit>
        <trans-unit id="4414" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4415" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4416" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4417" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4418" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>FE 12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">FE 12 &lt; <ph id="ph1">`unsigned int8`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4419" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>unaligned.</source>
          <target state="translated">アライメントされていません。</target>       </trans-unit>
        <trans-unit id="4420" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Indicates that the subsequent pointer instruction may be unaligned.</source>
          <target state="translated">後続のポインターの命令が固定である可能性を示します。</target>       </trans-unit>
        <trans-unit id="4421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4423" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source><ph id="ph1">`Unaligned`</ph> specifies that the address (an unmanaged pointer, <ph id="ph2">`native int`</ph>) on the stack might not be aligned to the natural size of the immediately following <ph id="ph3">`ldind`</ph>, <ph id="ph4">`stind`</ph>, <ph id="ph5">`ldfld`</ph>, <ph id="ph6">`stfld`</ph>, <ph id="ph7">`ldobj`</ph>, <ph id="ph8">`stobj`</ph>, <ph id="ph9">`initblk`</ph>, or <ph id="ph10">`cpblk`</ph> instruction.</source>
          <target state="translated"><ph id="ph1">`Unaligned`</ph> 指定するアドレス (アンマネージ ポインター、 <ph id="ph2">`native int`</ph>)、スタックに適さないことがあります、直後の自然なサイズに<ph id="ph3">`ldind`</ph>、 <ph id="ph4">`stind`</ph>、 <ph id="ph5">`ldfld`</ph>、 <ph id="ph6">`stfld`</ph>、 <ph id="ph7">`ldobj`</ph>、 <ph id="ph8">`stobj`</ph>、<ph id="ph9">`initblk`</ph>、または<ph id="ph10">`cpblk`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="4424" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>That is, for a <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph> instruction the alignment of the address may not be to a 4-byte boundary.</source>
          <target state="translated">つまり、用、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Ldind_I4&gt;</ph>命令アドレスのアラインメントは 4 バイト境界にできない可能性があります。</target>       </trans-unit>
        <trans-unit id="4425" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>For <ph id="ph1">`initblk`</ph> and <ph id="ph2">`cpblk`</ph> the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs).</source>
          <target state="translated"><ph id="ph1">`initblk`</ph>と<ph id="ph2">`cpblk`</ph>の既定のアラインメントは依存のアーキテクチャ (32 ビットの Cpu、64 ビット Cpu で 8 バイトでは 4 バイト)。</target>       </trans-unit>
        <trans-unit id="4426" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Code generators that do not restrict their output to a 32-bit word size must use <ph id="ph1">`unaligned`</ph> if the alignment is not known at compile time to be 8-byte.</source>
          <target state="translated">32 ビット ワード サイズには、出力を制限しないコード ジェネレーターを使用する必要があります<ph id="ph1">`unaligned`</ph>不明の場合、配置はコンパイル時に 8 バイトであります。</target>       </trans-unit>
        <trans-unit id="4427" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively.</source>
          <target state="translated">配置の値は、1、2、または 4 および生成されたコードでは、アドレスは、バイト、2 バイト、またはクアッド バイトでアライン、それぞれのことを想定してくださいことを意味する必要があります。</target>       </trans-unit>
        <trans-unit id="4428" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Note that transient pointers (type <ph id="ph1">`*`</ph>) are always aligned.</source>
          <target state="translated">その一時的なものに注意してくださいポインター (型<ph id="ph1">`*`</ph>)、常に配置します。</target>       </trans-unit>
        <trans-unit id="4429" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>While the alignment for a <ph id="ph1">`cpblk`</ph> instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</source>
          <target state="translated">配置中に、<ph id="ph1">`cpblk`</ph>命令は 2 つの数値 (1 つは、ソース) と、変換先のいずれかが必要に論理的に、影響はありません顕著なパフォーマンスの低い数値が指定されている場合のみです。</target>       </trans-unit>
        <trans-unit id="4430" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The <ph id="ph1">`unaligned`</ph> and <ph id="ph2">`volatile`</ph> prefixes can be combined in either order.</source>
          <target state="translated"><ph id="ph1">`unaligned`</ph>と<ph id="ph2">`volatile`</ph>プレフィックスは、いずれかの順序で組み合わせることができます。</target>       </trans-unit>
        <trans-unit id="4431" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>They must immediately precede a <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
          <target state="translated">直前に入れなければなりませんが、 <ph id="ph1">`ldind`</ph>、 <ph id="ph2">`stind`</ph>、 <ph id="ph3">`ldfld`</ph>、 <ph id="ph4">`stfld`</ph>、 <ph id="ph5">`ldobj`</ph>、 <ph id="ph6">`stobj`</ph>、 <ph id="ph7">`initblk`</ph>、または<ph id="ph8">`cpblk`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="4432" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>Only the <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph> prefix is allowed for the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.</source>
          <target state="translated">のみ、<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Volatile&gt;</ph>のプレフィックスは許可されて、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph>と<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph>指示します。</target>       </trans-unit>
        <trans-unit id="4433" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overloads can use the <ph id="ph2">`unaligned`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードを使用できる、<ph id="ph2">`unaligned`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4434" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>ILGenerator.Emit(OpCode, Label)</source>
          <target state="translated">ILGenerator.Emit (オペコード、ラベル)</target>       </trans-unit>
        <trans-unit id="4435" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unaligned">
          <source>ILGenerator.Emit(Opcode, Byte)</source>
          <target state="translated">ILGenerator.Emit (オペコード, Byte)</target>       </trans-unit>
        <trans-unit id="4436" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Converts the boxed representation of a value type to its unboxed form.</source>
          <target state="translated">値型のボックス化変換された形式をボックス化が解除された形式に変換します。</target>       </trans-unit>
        <trans-unit id="4437" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4438" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4439" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4440" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4441" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>79 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">79 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4442" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>unbox <ph id="ph1">`valType`</ph></source>
          <target state="translated">ボックス化解除します。 <ph id="ph1">`valType`</ph></target>       </trans-unit>
        <trans-unit id="4443" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Extracts the value type data from <ph id="ph1">`obj`</ph>, its boxed representation.</source>
          <target state="translated">値型のデータを抽出<ph id="ph1">`obj`</ph>、その表現をボックス化します。</target>       </trans-unit>
        <trans-unit id="4444" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4445" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>An object reference is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4446" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The object reference is popped from the stack and unboxed to a value type pointer.</source>
          <target state="translated">オブジェクト参照がスタックからポップされ、値のポインター型をボックス化解除します。</target>       </trans-unit>
        <trans-unit id="4447" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The value type pointer is pushed onto the stack.</source>
          <target state="translated">値型のポインターは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4448" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A value type has two separate representations within the Common Language Infrastructure (CLI):</source>
          <target state="translated">値型は、2 つの独立した表現内で共通言語基盤 (CLI) には。</target>       </trans-unit>
        <trans-unit id="4449" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A 'raw' form used when a value type is embedded within another object.</source>
          <target state="translated">値の型が別のオブジェクトに埋め込まれたときに使用される '生' のフォームです。</target>       </trans-unit>
        <trans-unit id="4450" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</source>
          <target state="translated">ここで値の型のデータがラップされる (のボックス化された) オブジェクトのため、個別のエンティティとして存在する可能性が 'ボックス化' の形式です。</target>       </trans-unit>
        <trans-unit id="4451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The <ph id="ph1">`unbox`</ph> instruction converts the object reference (type <ph id="ph2">`O`</ph>), the boxed representation of a value type, to a value type pointer (a managed pointer, type <ph id="ph3">`&amp;`</ph>), its unboxed form.</source>
          <target state="translated"><ph id="ph1">`unbox`</ph>命令がオブジェクト参照に変換 (型<ph id="ph2">`O`</ph>) では、値型のポインターに値の型の表現をボックス化 (マネージ ポインター型<ph id="ph3">`&amp;`</ph>)、そのフォームをボックス化解除します。</target>       </trans-unit>
        <trans-unit id="4452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The supplied value type (<ph id="ph1">`valType`</ph>) is a metadata token indicating the type of value type contained within the boxed object.</source>
          <target state="translated">指定された値の型 (<ph id="ph1">`valType`</ph>) は、ボックス化されたオブジェクト内に含まれる値の型の型を示すメタデータ トークン。</target>       </trans-unit>
        <trans-unit id="4453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Unlike <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Box&gt;</ph>, which is required to make a copy of a value type for use in the object, <ph id="ph2">`unbox`</ph> is not required to copy the value type from the object.</source>
          <target state="translated">異なり<ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Box&gt;</ph>、オブジェクトで使用する値型のコピーを作成する必要となる<ph id="ph2">`unbox`</ph>オブジェクトから値の型をコピーする必要はありません。</target>       </trans-unit>
        <trans-unit id="4454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>Typically it simply computes the address of the value type that is already present inside of the boxed object.</source>
          <target state="translated">通常、ボックス化されたオブジェクトの内部で存在する値の型のアドレスを計算するだけです。</target>       </trans-unit>
        <trans-unit id="4455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if the object is not boxed as <ph id="ph2">`valType`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> オブジェクトがないとしてボックス化された場合にスローされる<ph id="ph2">`valType`</ph>です。</target>       </trans-unit>
        <trans-unit id="4456" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if the object reference is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> オブジェクト参照が null 参照である場合にスローされます。</target>       </trans-unit>
        <trans-unit id="4457" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown if the value type <ph id="ph2">`valType`</ph> cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> 値を入力する場合にスローされる<ph id="ph2">`valType`</ph>が見つかりません。</target>       </trans-unit>
        <trans-unit id="4458" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</source>
          <target state="translated">これは、通常、Microsoft Intermediate Language (MSIL) 命令が実行時ではなく、ネイティブ コードに変換されるときに検出します。</target>       </trans-unit>
        <trans-unit id="4459" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`unbox`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`unbox`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4460" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="4461" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Converts the boxed representation of a type specified in the instruction to its unboxed form.</source>
          <target state="translated">命令で指定された型のボックス化変換された形式を、ボックス化が解除された形式に変換します。</target>       </trans-unit>
        <trans-unit id="4462" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4463" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4464" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4465" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4466" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>A5 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></source>
          <target state="translated">A5 &lt; <ph id="ph1">`T`</ph><ph id="ph2"> &gt;</ph></target>       </trans-unit>
        <trans-unit id="4467" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>unbox.any <ph id="ph1">`typeTok`</ph></source>
          <target state="translated">unbox.any <ph id="ph1">`typeTok`</ph></target>       </trans-unit>
        <trans-unit id="4468" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>Extract the data from <ph id="ph1">`obj`</ph>, its boxed representation.</source>
          <target state="translated">データの抽出<ph id="ph1">`obj`</ph>、その表現をボックス化します。</target>       </trans-unit>
        <trans-unit id="4469" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4470" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>An object reference <ph id="ph1">`obj`</ph> is pushed onto the stack.</source>
          <target state="translated">オブジェクト参照<ph id="ph1">`obj`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4471" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The object reference is popped from the stack and unboxed to the type specified in the instruction.</source>
          <target state="translated">オブジェクト参照がスタックからポップされ、命令で指定された型をボックス化解除します。</target>       </trans-unit>
        <trans-unit id="4472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The resulting object reference or value type is pushed onto the stack.</source>
          <target state="translated">結果として得られるオブジェクトの参照または値の型は、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>When applied to the boxed form of a value type, the <ph id="ph1">`unbox.any`</ph> instruction extracts the value contained within <ph id="ph2">`obj`</ph> (of type <ph id="ph3">`O`</ph>), and is therefore equivalent to <ph id="ph4">`unbox`</ph> followed by <ph id="ph5">`ldobj`</ph>.</source>
          <target state="translated">値の型のボックス化された形式に適用すると、<ph id="ph1">`unbox.any`</ph>命令に含まれる値を抽出する<ph id="ph2">`obj`</ph>(型の<ph id="ph3">`O`</ph>) と同じであるため、<ph id="ph4">`unbox`</ph>続く<ph id="ph5">`ldobj`</ph>です。</target>       </trans-unit>
        <trans-unit id="4474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>When applied to a reference type, the <ph id="ph1">`unbox.any`</ph> instruction has the same effect as <ph id="ph2">`castclass`</ph> <ph id="ph3">`typeTok`</ph>.</source>
          <target state="translated">参照型に適用すると、<ph id="ph1">`unbox.any`</ph>命令と同じ効果を持つ<ph id="ph2">`castclass`</ph><ph id="ph3">`typeTok`</ph>です。</target>       </trans-unit>
        <trans-unit id="4475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>If the operand <ph id="ph1">`typeTok`</ph> is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</source>
          <target state="translated">場合、オペランド<ph id="ph1">`typeTok`</ph>がジェネリック型パラメーターでは、実行時の動作は、そのジェネリック型パラメーターに対して指定されている型によって決定されます。</target>       </trans-unit>
        <trans-unit id="4476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> is thrown if <ph id="ph2">`obj`</ph> is not a boxed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> 場合にスローされる<ph id="ph2">`obj`</ph>ボックス化された型ではありません。</target>       </trans-unit>
        <trans-unit id="4477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> is thrown if <ph id="ph2">`obj`</ph> is a null reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> 場合にスローされる<ph id="ph2">`obj`</ph>null 参照です。</target>       </trans-unit>
        <trans-unit id="4478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`unbox.any`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`unbox.any`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Unbox_Any">
          <source>ILGenerator.Emit(OpCode, Type)</source>
          <target state="translated">ILGenerator.Emit (オペコード、型)</target>       </trans-unit>
        <trans-unit id="4480" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</source>
          <target state="translated">現在評価スタックの一番上にあるアドレスが揮発性である可能性があるため、この位置の読み取り結果をキャッシュできないこと、またはこの位置への複数の格納を中止できないことを指定します。</target>       </trans-unit>
        <trans-unit id="4481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4485" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>FE 13</source>
          <target state="translated">FE 13</target>       </trans-unit>
        <trans-unit id="4486" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>volatile.</source>
          <target state="translated">揮発性です。</target>       </trans-unit>
        <trans-unit id="4487" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Indicates that the subsequent pointer reference is volatile.</source>
          <target state="translated">後続のポインターの参照が揮発性であることを示します。</target>       </trans-unit>
        <trans-unit id="4488" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4489" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>An address is pushed onto the stack.</source>
          <target state="translated">アドレスは、スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source><ph id="ph1">`volatile`</ph>.</source>
          <target state="translated"><ph id="ph1">`volatile`</ph>。</target>       </trans-unit>
        <trans-unit id="4491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</source>
          <target state="translated">アドレスが揮発性のアドレスを指定します (つまり、参照できる外部で実行の現在のスレッドに) と、結果の読み取り位置をキャッシュすることはできませんまたはその場所に複数の店舗を抑制することはできません。</target>       </trans-unit>
        <trans-unit id="4492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Marking an access as <ph id="ph1">`volatile`</ph> affects only that single access; other accesses to the same location must be marked separately.</source>
          <target state="translated">あるアクセス<ph id="ph1">`volatile`</ph>単一のアクセスを示すだけに影響を同じ場所にその他のアクセスを個別にマークする必要があります。</target>       </trans-unit>
        <trans-unit id="4493" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Access to volatile locations need not be performed atomically.</source>
          <target state="translated">揮発性の場所へのアクセスをアトミックに実行する必要はありません。</target>       </trans-unit>
        <trans-unit id="4494" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph> and <ph id="ph2">`volatile`</ph> prefixes can be combined in either order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Emit.OpCodes.Unaligned&gt;</ph>と<ph id="ph2">`volatile`</ph>プレフィックスは、いずれかの順序で組み合わせることができます。</target>       </trans-unit>
        <trans-unit id="4495" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>They must immediately precede a <ph id="ph1">`ldind`</ph>, <ph id="ph2">`stind`</ph>, <ph id="ph3">`ldfld`</ph>, <ph id="ph4">`stfld`</ph>, <ph id="ph5">`ldobj`</ph>, <ph id="ph6">`stobj`</ph>, <ph id="ph7">`initblk`</ph>, or <ph id="ph8">`cpblk`</ph> instruction.</source>
          <target state="translated">直前に入れなければなりませんが、 <ph id="ph1">`ldind`</ph>、 <ph id="ph2">`stind`</ph>、 <ph id="ph3">`ldfld`</ph>、 <ph id="ph4">`stfld`</ph>、 <ph id="ph5">`ldobj`</ph>、 <ph id="ph6">`stobj`</ph>、 <ph id="ph7">`initblk`</ph>、または<ph id="ph8">`cpblk`</ph>命令します。</target>       </trans-unit>
        <trans-unit id="4496" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>Only the <ph id="ph1">`volatile`</ph> prefix is allowed for the <ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph> instructions.</source>
          <target state="translated">のみ、<ph id="ph1">`volatile`</ph>のプレフィックスは許可されて、<ph id="ph2">&lt;xref:System.Reflection.Emit.OpCodes.Ldsfld&gt;</ph>と<ph id="ph3">&lt;xref:System.Reflection.Emit.OpCodes.Stsfld&gt;</ph>指示します。</target>       </trans-unit>
        <trans-unit id="4497" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`volatile`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`volatile`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4498" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Volatile">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
        <trans-unit id="4499" translate="yes" xml:space="preserve" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</source>
          <target state="translated">評価スタックの一番上にある 2 つの値のビットごとの XOR を計算し、結果を評価スタックにプッシュします。</target>       </trans-unit>
        <trans-unit id="4500" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</source>
          <target state="translated">次の表に、命令の 16 進数および簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) のアセンブリの形式を示します。</target>       </trans-unit>
        <trans-unit id="4501" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Format</source>
          <target state="translated">形式</target>       </trans-unit>
        <trans-unit id="4502" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Assembly Format</source>
          <target state="translated">アセンブリの形式</target>       </trans-unit>
        <trans-unit id="4503" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="4504" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>61</source>
          <target state="translated">61</target>       </trans-unit>
        <trans-unit id="4505" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>xor</source>
          <target state="translated">xor</target>       </trans-unit>
        <trans-unit id="4506" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>Computes the bitwise XOR of two integer values and returns an integer.</source>
          <target state="translated">2 つの整数値のビットごとの XOR を計算し、整数を返します。</target>       </trans-unit>
        <trans-unit id="4507" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The stack transitional behavior, in sequential order, is:</source>
          <target state="translated">履歴の移行動作では、順番には。</target>       </trans-unit>
        <trans-unit id="4508" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value1`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4509" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value2`</ph> is pushed onto the stack.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4510" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> are popped from the stack and their bitwise XOR computed.</source>
          <target state="translated"><ph id="ph1">`value2`</ph> および<ph id="ph2">`value1`</ph>スタックと、ビット単位からポップされます。 XOR を計算します。</target>       </trans-unit>
        <trans-unit id="4511" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The bitwise XOR of <ph id="ph1">`value2`</ph> and <ph id="ph2">`value1`</ph> is pushed onto the stack.</source>
          <target state="translated">ビットごとの XOR<ph id="ph1">`value2`</ph>と<ph id="ph2">`value1`</ph>スタックにプッシュされます。</target>       </trans-unit>
        <trans-unit id="4512" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The <ph id="ph1">`xor`</ph> instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</source>
          <target state="translated"><ph id="ph1">`xor`</ph>命令は、最上位の 2 つのビットごとの XOR、スタックに値をスタックに、結果を残しますを計算します。</target>       </trans-unit>
        <trans-unit id="4513" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source><ph id="ph1">`Xor`</ph> is an integer-specific operation.</source>
          <target state="translated"><ph id="ph1">`Xor`</ph> 整数固有操作です。</target>       </trans-unit>
        <trans-unit id="4514" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph> method overload can use the <ph id="ph2">`xor`</ph> opcode:</source>
          <target state="translated">次<ph id="ph1">&lt;xref:System.Reflection.Emit.ILGenerator.Emit%2A&gt;</ph>メソッドのオーバー ロードが使用できる、<ph id="ph2">`xor`</ph>オペコード。</target>       </trans-unit>
        <trans-unit id="4515" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Reflection.Emit.OpCodes.Xor">
          <source>ILGenerator.Emit(OpCode)</source>
          <target state="translated">ILGenerator.Emit(OpCode)</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>