<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3d83d76933977f09396d3785edac9c15d9fd4cf6" /><Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/05/2018" /><Meta Name="ms.locfileid" Value="52919047" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Reflection.Emit.ILGenerator" /> クラス メンバー (<see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" /> など) による出力に対する MSIL (Microsoft Intermediate Language) 命令のフィールド表現を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メンバーのオペコードの詳細については、特に「Partition III: CIL Instruction Set"と"Partition II:: Metadata Definition and Semantics"は、共通言語基盤 (CLI) ドキュメントを参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
   
  
## Examples  
 次の例では、動的メソッドを使用して、構築<xref:System.Reflection.Emit.ILGenerator>を出力する`OpCodes`に、<xref:System.Reflection.Emit.MethodBuilder>します。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を加算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|58|追加|2 つの数値があり、新しい数値を返すことを追加します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value1`に追加されます`value2`します。  
  
4.  結果は、スタックにプッシュされます。  
  
 整数演算のオーバーフローが検出されない (適切なオーバーフロー処理では、次を参照してください。 <xref:System.Reflection.Emit.OpCodes.Add_Ovf>)。  
  
 整数の加算飽和よりも、ラップします。 たとえば、8 ビット整数と仮定すると、 `value1` 255 に設定されていると`value2`設定されている 256 ではなく 0 を 1 に、ラップされた結果は、します。  
  
 浮動小数点オーバーフロー `+inf` (`PositiveInfinity`) または`-inf`(`NegativeInfinity`)。  
  
 許容されるオペランドの型とその対応する結果のデータ型は、次の表に表示されます。 特定の種類の組み合わせのエントリがないかどうか (たとえば、`int32`と`float`;`int32`と`int64`)、無効な Microsoft 中間言語 (MSIL) であり、エラーが発生します。  
  
|オペランド|value1 型|value2 型|結果の型|  
|-------------|-----------------|-----------------|-----------------|  
|追加|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|追加|`*`|`native int`|`*`|  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `add` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの整数値を加算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D6|add.ovf のトピック|オーバーフロー チェックを 2 つの符号付き整数値を追加します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value1`に追加されます`value2`オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException> 結果は結果の型では表されない場合にスローされます。  
  
 符号付き整数でこの操作を実行することができます。 浮動小数点の値を使用して<xref:System.Reflection.Emit.OpCodes.Add>します。  
  
 許容されるオペランドの型とその対応する結果のデータ型は、次の表に表示されます。 特定の種類の組み合わせのエントリがないかどうか (たとえば、`int32`と`float`;`int32`と`int64`)、Microsoft Intermediate Language (MSIL) の無効な命令であり、エラーが発生します。  
  
|オペランド|value1 型|value2 型|結果の型|  
|-------------|-----------------|-----------------|-----------------|  
|追加|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|追加|`*`|`native int`|`*`|  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `add.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を加算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|オーバーフロー チェックを 2 つの符号なし整数値を追加します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value1`に追加されます`value2`オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException> 結果は結果の型では表されない場合にスローされます。  
  
 符号付き整数でこの操作を実行することができます。 浮動小数点の値を使用して<xref:System.Reflection.Emit.OpCodes.Add>します。  
  
 許容されるオペランドの型とその対応する結果のデータ型は、次の表に表示されます。 特定の種類の組み合わせのエントリがないかどうか (たとえば、`int32`と`float`;`int32`と`int64`)、Microsoft Intermediate Language (MSIL) の無効な命令であり、エラーが発生します。  
  
|オペランド|value1 型|value2 型|結果の型|  
|-------------|-----------------|-----------------|-----------------|  
|追加|`int32`|`int32`|`int32`|  
|追加|`int32`|`native int`|`native int`|  
|追加|`int32`|`&`|`&`|  
|追加|`int32`|`*`|`*`|  
|追加|`int64`|`int64`|`int64`|  
|追加|`native int`|`int32`|`native int`|  
|追加|`native int`|`native int`|`native int`|  
|追加|`native int`|`&`|`&`|  
|追加|`native int`|`*`|`*`|  
|追加|`F`|`F`|`F`|  
|追加|`&`|`int32`|`&`|  
|追加|`&`|`native int`|`&`|  
|追加|`*`|`int32`|`*`|  
|追加|`*`|`native int`|`*`|  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `add.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値のビットごとの AND を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|命令|説明|  
|------------|-----------------|-----------------|  
|5 F|と、呼び出し|2 つの整数値のビットごとの AND を決定します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value1` `value2`スタックからポップされます。 2 つの値のビットごとの AND を計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `and`命令がスタックの上位 2 つの値のビットごとの AND を計算し、結果をスタックに残します。  
  
 `And` 整数に固有の操作です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `and` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドの引数リストへのアンマネージ ポインターを返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 00|arglist|現在のメソッドの引数リストのハンドルを返します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `arglist`命令が不透明なハンドルを返します (型のアンマネージ ポインターを`native int`) 現在のメソッドの引数リストを表します。 このハンドルは、現在のメソッドの有効期間中にのみ有効です。 ただし、現在のメソッドがコントロールのスレッドである限り、ハンドルを他のメソッドに渡すことができます。 のみを実行することができます、`arglist`を可変個の引数を受け取るメソッド内の命令。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `arglist` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値が等しい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq `target`|オフセットでターゲット命令に分岐`target`2 つの値が等しい場合。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`と等しい`value2`、分岐操作を実行します。  
  
 `beq`命令が場合に、指定したターゲット命令に制御を転送`value1`と等しい`value2`します。 効果を実行すると同じ、`ceq`命令を`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 以下は、許容されるオペランドの型がカプセル化します。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません (このような転送が厳しく制限されていると、使用する必要があります、<xref:System.Reflection.Emit.OpCodes.Leave>命令代わりに)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `beq` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値が等しい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq.s `target`|オフセットでターゲット命令に分岐`target`の場合、短い形式|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`と等しい`value2`、分岐操作を実行します。  
  
 `beq.s`命令が場合に、指定したターゲット命令に制御を転送`value1`と等しい`value2`します。 効果を実行すると同じ、`ceq`命令を`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 以下は、許容されるオペランドの型がカプセル化します。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません (このような転送が厳しく制限されていると、使用する必要があります、<xref:System.Reflection.Emit.OpCodes.Leave>命令代わりに)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `beq.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以上の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge `target`|最初の値が 2 番目の値以上の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより大きいまたは等しい`value2`、分岐操作を実行します。  
  
 `bge`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きいまたは等しい`value2`します。 この効果を実行するのには、`clt.un`命令を`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `bge` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以上の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2 F `<int8>`|bge.s `target`|最初の値がより大きいまたは短い形式として、2 番目の値と等しい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより大きいまたは等しい`value2`、分岐操作を実行します。  
  
 `bge.s`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きいまたは等しい`value2`します。 この効果を実行するのには、`clt.un`命令を`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `bge.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.un `target`|最初の値が 2 番目の値 (符号なしの値) 以上の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより大きいまたは等しい`value2`、分岐操作を実行します。  
  
 `bge.un`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きいまたは等しい`value2`符号なし整数値または順序なし float 値を使用して比較した場合に、します。 この効果を実行するのには、`clt`命令を`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `bge.un` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s `target`|最初の値が 2 番目の値 (符号なしの値)、短い形式以上の場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより大きいまたは等しい`value2`、分岐操作を実行します。  
  
 `bge.un.s`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きいまたは等しい`value2`符号なし整数値または順序なし float 値を使用して比較した場合に、します。 この効果を実行するのには、`clt`命令を`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `bge.un.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3D < `int32` >|[サービス] `target`|最初の値が 2 番目の値より大きい場合、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより大きい`value2`、分岐操作を実行します。  
  
 `bgt`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きい`value2`します。 この効果を実行するのには、`cgt`命令を`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `bgt` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s `target`|最初の値が 2 番目の値では、短い形式よりも大きい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより大きい`value2`、分岐操作を実行します。  
  
 `bgt.s`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きい`value2`します。 この効果を実行するのには、`cgt`命令を`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `bgt.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.un `target`|最初の値が 2 番目の値 (符号なしの値) より大きい場合、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより大きい`value2`、分岐操作を実行します。  
  
 `bgt.un`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きい`value2`符号なし整数値または順序なし float 値を使用して比較した場合に、します。 この効果を実行するのには、`cgt.un`命令を`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `bgt.un` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値を超える場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s `target`|最初の値が 2 番目の値 (符号なしの値)、短い形式よりも大きい場合は、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより大きい`value2`、分岐操作を実行します。  
  
 `bgt.un.s`命令が場合に、指定したターゲット命令に制御を転送`value1`がより大きい`value2`符号なし整数値または順序なし float 値を使用して比較した場合に、します。 この効果を実行するのには、`cgt.un`命令を`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `bgt.un.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3 E `<int32>`|ble `target`|最初の値が 2 番目の値に等しいまたはそれよりも小さい場合、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`に等しいまたはそれよりも小さい`value2`、分岐操作を実行します。  
  
 `ble`命令が場合に、指定したターゲット命令に制御を転送`value1`に等しいまたはそれよりも小さい`value2`します。 効果を実行するのには、`cgt`命令 (`cgt.un`浮動小数点値の) 後に、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ble` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s `target`|最初の値が短い形式として、2 番目の値と等しいかそれよりも小さい場合、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`に等しいまたはそれよりも小さい`value2`、分岐操作を実行します。  
  
 `ble.s`命令が場合に、指定したターゲット命令に制御を転送`value1`に等しいまたはそれよりも小さい`value2`します。 効果を実行するのには、`cgt`命令 (`cgt.un`浮動小数点値の) 命令を`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ble.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.un `target`|最初の値が (符号なしの値) の 2 番目の値に等しいまたはそれよりも小さい場合、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`に等しいまたはそれよりも小さい`value2`、分岐操作を実行します。  
  
 `ble.un`命令が場合に、指定したターゲット命令に制御を転送`value1`に等しいまたはそれよりも小さい`value2`符号なし整数値または順序なし float 値を使用して比較した場合に、します。 効果を実行するのには、`cgt.un`命令 (`cgt`浮動小数点値の) 後に、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ble.un` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値以下の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un `target`|最初の値が 2 番目の値 (符号なしの値)、短い形式の場合、指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`に等しいまたはそれよりも小さい`value2`、分岐操作を実行します。  
  
 `ble.un.s`命令が場合に、指定したターゲット命令に制御を転送`value1`に等しいまたはそれよりも小さい`value2`符号なし整数値または順序なし float 値を使用して比較した場合に、します。 効果を実行するのには、`cgt.un`命令 (`cgt`浮動小数点値の) 後に、`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ble.un.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt `target`|2 番目の値より小さい場合、最初の値が指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより小さい`value2`、分岐操作を実行します。  
  
 `blt`命令が場合に、指定したターゲット命令に制御を転送`value1`に等しいまたはそれよりも小さい`value2`します。 この効果を実行するのには、`clt`命令を`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `blt` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt.s `target`|短い形式として、2 番目の値より小さい場合、最初の値が指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより小さい`value2`、分岐操作を実行します。  
  
 `blt.s`命令が場合に、指定したターゲット命令に制御を転送`value1`がより小さい`value2`します。 この効果を実行するのには、`clt`命令を`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `blt.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.un `target`|(符号なしの値) の 2 番目の値より小さい場合、最初の値が指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより小さい`value2`、分岐操作を実行します。  
  
 `blt.un`命令が場合に、指定したターゲット命令に制御を転送`value1`がより小さい`value2`符号なし整数値または順序なし float 値を使用して比較した場合に、します。 この効果を実行するのには、`clt.un`命令を`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `blt.un` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値または順序なし float 値を比較したとき、最初の値が 2 番目の値より小さい場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s `target`|2 番目の値 (符号なしの値)、短い形式よりも小さい場合、最初の値が指定したオフセットでターゲット命令に分岐します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`がより小さい`value2`、分岐操作を実行します。  
  
 `blt.un`命令が場合に、指定したターゲット命令に制御を転送`value1`がより小さい`value2`符号なし整数値または順序なし float 値を使用して比較した場合に、します。 この効果を実行するのには、`clt.un`命令を`brtrue`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `blt.un.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.un `target`|ブランチ、ターゲット命令は 2 つの符号なし整数値の場合は、指定したオフセットでは (符号なしの値) と等しくありません。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`が等しくない`value2`、分岐操作を実行します。  
  
 `bne.un`命令が場合に、指定したターゲット命令に制御を転送`value1`が等しくない`value2`符号なし整数値または順序なし float 値を使用して比較した場合に、します。 この効果を実行するのには、`ceq`命令を`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `bne.un` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値または順序なし float 値が等しくない場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|33 < `int8` >|続く `target`|ブランチ (符号なしの値) と一致しない場合は、短縮形に 2 つの符号なし整数値の場合は、指定したオフセットで命令が、ターゲットにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`場合に、スタックからポップ`value1`が等しくない`value2`、分岐操作を実行します。  
  
 `bne.un`命令が場合に、指定したターゲット命令に制御を転送`value1`が等しくない`value2`符号なし整数値または順序なし float 値を使用して比較した場合に、します。 この効果を実行するのには、`ceq`命令を`brfalse`特定のターゲット命令に分岐します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `bne.un.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値型をオブジェクト参照 (<see langword="O" /> 型) に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8C < `T` >|ボックス `valTypeToken`|値の型変換 (で指定された型の`valTypeToken`) を真のオブジェクト参照。|  
  
 履歴の移行動作を順番には。  
  
1.  値の型は、スタックにプッシュされます。  
  
2.  値の型がスタックからポップされます。`box`操作を実行します。  
  
3.  結果として得られる「ボックス化された」の値の型へのオブジェクト参照は、スタックにプッシュされます。  
  
 値型では、共通言語基盤 (CLI) 内に 2 つの個別の表現があります。  
  
-   値の型が別のオブジェクト、スタックの上に埋め込まれている場合に使用される '生' のフォームです。  
  
-   場所、値の型のデータにラップされます (手書き) オブジェクトのため、個別のエンティティとして存在する可能性が 'ボックス化' の形式。  
  
 `box`命令は、オブジェクト参照に、'raw' (ボックス化解除された) 値の型を変換します (型`O`)。 これは、新しいオブジェクトを作成し、新しく割り当てられたオブジェクトに値の型からデータをコピーして実行されます。 `valTypeToken` スタックに値型の型をメタデータ トークンを示すです。  
  
 <xref:System.OutOfMemoryException> 要求に対応する十分なメモリがある場合にスローされます。  
  
 <xref:System.TypeLoadException> クラスが見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) がランタイムではなくネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `box` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無条件でターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|指定したオフセット位置に、ターゲット命令に分岐します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `br`命令は無条件でターゲット命令に制御を転送します。 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `br` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無条件でターゲット命令に制御を転送します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br.s `target`|短い形式として、指定されたオフセットには、ターゲット命令に分岐します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `br.s`命令は無条件でターゲット命令に制御を転送します。 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `br.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ブレークポイントがトリップしたことをデバッガーに通知するように、共通言語基盤 (CLI) に通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|01|break|ブレークポイントに達したことをデバッガーに通知します。|  
  
 この操作では、評価スタックの動作は実行されません。  
  
 `break`命令がデバッグのサポートです。 これは、ブレークポイントがトリップしたことをデバッガーに通知するために、CLI を通知します。 インタープリターの状態には、その他の影響を与えません。  
  
 `break`命令は、最小命令サイズ有効にすると中断ポイントを持つ修正プログラムの適用とコード生成、前後のコードを最小限にします。  
  
 `break`命令は、デバッガーをトラップ、何もしない、またはセキュリティ例外が発生します。 正確な動作は、実装定義です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `break` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="false" />、null 参照 (Visual Basic の場合は <see langword="Nothing" />)、または 0 の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse `target`<br /><br /> brnull `target`<br /><br /> brzero `target`|場合は、指定したオフセットでターゲット命令に分岐`false`します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` 前の操作によってスタックにプッシュされます。  
  
2.  `value` スタックからポップされます。場合`value`は`false`、分岐する`target`します。  
  
 `brfalse`命令 (とそのエイリアス`brnull`と`brzero`) 場合は、指定したターゲット命令に制御を転送`value`(型の`int32`、 `int64`、オブジェクト参照`O`、マネージ ポインター`&`、一時的なポインター `*`、 `native int`) は 0 です (`false`)。 場合`value`0 以外の場合 (`true`)、次の命令実行が続行されます。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `brfalse` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="false" />、null 参照または 0 の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s `target`<br /><br /> brnull.s `target`<br /><br /> brzero.s `target`|場合は、指定したオフセットでターゲット命令に分岐`false`、短縮形。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` 前の操作によってスタックにプッシュされます。  
  
2.  `value` スタックからポップされます。場合`value`は`false`、分岐する`target`します。  
  
 `brfalse.s`命令 (とそのエイリアス`brnull`と`brzero`) 場合は、指定したターゲット命令に制御を転送`value`(型の`int32`、 `int64`、オブジェクト参照`O`、マネージ ポインター`&`、一時的なポインター `*`、 `native int`) は 0 です (`false`)。 場合`value`0 以外の場合 (`true`)、次の命令実行が続行されます。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `brfalse.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="true" />、null 以外、または 0 以外の場合は、ターゲット命令に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue `target`<br /><br /> brinst `target`|0 以外の場合は、指定したオフセット位置に、ターゲット命令に分岐 (`true`)。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` 前の操作によってスタックにプッシュされます。  
  
2.  `value` スタックからポップされます。場合`value`は`true`、分岐する`target`します。  
  
 `brtrue`命令が場合に、指定したターゲット命令に制御を転送`value`(型`native int`) が 0 以外 (`true`)。 場合`value`は 0 です (`false`)、次の命令実行が続行されます。  
  
 場合`value`オブジェクト参照 (型`O`) し、 `brinst` (のエイリアス`brtrue`) オブジェクトのインスタンスを表す場合は、制御を転送 (たとえば、null オブジェクト参照ではない場合を参照してください<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `brtrue` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><paramref name="value" /> が <see langword="true" />、null 以外、または 0 以外の場合は、ターゲット命令 (短い形式) に制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue.s `target`<br /><br /> brinst.s `target`|0 以外の場合は、指定したオフセット位置に、ターゲット命令に分岐 (`true`)、短縮形。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` 前の操作によってスタックにプッシュされます。  
  
2.  `value` スタックからポップされます。場合`value`は`true`、分岐する`target`します。  
  
 `brtrue.s`命令が場合に、指定したターゲット命令に制御を転送`value`(型`native int`) が 0 以外 (`true`)。 場合`value`は 0 です (`false`)、次の命令実行が続行されます。  
  
 場合`value`オブジェクト参照 (型`O`) し、 `brinst` (のエイリアス`brtrue`) オブジェクトのインスタンスを表す場合は、制御を転送 (たとえば、null オブジェクト参照ではない場合を参照してください<xref:System.Reflection.Emit.OpCodes.Ldnull>)。  
  
 ターゲット命令は、現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `brtrue.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>渡されたメソッド記述子によって示されているメソッドを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|28 < `T` >|呼び出し `methodDesc`|説明したメソッドを呼び出す`methodDesc`します。|  
  
 履歴の移行動作を順番には。  
  
1.  メソッドの引数`arg1`を通じて`argN`スタックにプッシュされます。  
  
2.  メソッドの引数`arg1`を通じて`argN`スタックからポップされます。 これらの引数でメソッドの呼び出しが実行されると、メソッドの記述子で参照されるメソッドに制御が移ります。 完了すると、戻り値が呼び出し先メソッドによって生成され、呼び出し元に送信します。  
  
3.  戻り値は、スタックにプッシュされます。  
  
 `call`命令は、命令に渡されたメソッド記述子によって示されるメソッドを呼び出します。 メソッドの記述子は、メソッドの呼び出し数、型、および使用する呼び出し規則とそのメソッドに渡されるスタック上に格納された引数の順序を示すメタデータ トークンです。 `call`命令のすぐ前に、 `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) メソッドの現在の状態が制御を転送する前にリリースされることを指定する命令のプレフィックスします。 呼び出し元のメソッドよりも信頼性の高いメソッドに制御を転送、スタック フレームは解放されません。 代わりに、実行が継続として、`tail`が提供されています。 メタデータ トークンには、呼び出しが静的メソッド、インスタンス メソッド、仮想メソッド、またはグローバル関数かどうかを判断するための十分な情報。 送信先アドレスは、メソッドの記述子から判断これらすべてのケース (これと対照的に、<xref:System.Reflection.Emit.OpCodes.Callvirt>命令の仮想メソッドの呼び出しで宛先のアドレスもインスタンスの実行時の型によって異なります。参照がプッシュする前に、 <xref:System.Reflection.Emit.OpCodes.Callvirt>)。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、まで、降順でスタックの一番上のすべての必要な引数がスタックし、2 番目の引数は 3 番目の配置。 次の 3 つの重要な特殊なケースがあります。  
  
 1. 呼び出しインスタンス (または仮想) メソッドが任意のユーザーに表示される引数の前にそのインスタンスの参照をプッシュする必要があります。 インスタンスの参照は null 参照にはできません。 メタデータでシグネチャのパラメーター リスト内のエントリを含まない、`this`ポインターをメソッドに渡すことが必要かどうかを示すために、1 ビットを使用して、代わりに、`this`ポインター。  
  
 2. 使用して、仮想メソッドを呼び出すことは`call`(なく`callvirt`)。 これは、メソッドが呼び出されているオブジェクトから動的に指定ではなく、メソッドによって指定されたクラスを使用して解決することを示します。  
  
 3. なお、デリゲートの`Invoke`いずれかでメソッドを呼び出すことができます、`call`または`callvirt`命令。  
  
 <xref:System.Security.SecurityException> システムのセキュリティは、呼び出されたメソッドを呼び出し元アクセスを許可していない場合にスローされる可能性が。 セキュリティ チェックは、Microsoft Intermediate Language (MSIL) の手順が実行時ではなくネイティブ コードに変換された場合に発生する可能性があります。  
  
> [!NOTE]
>  値の型で System.Object のメソッドを呼び出すときに、使用を検討して、`constrained`プレフィックスを追加、`callvirt`命令の出力ではなく、`call`命令。 これには、潜在的なバージョン管理の問題を回避する値の型がメソッドをオーバーライドするかどうかに応じてさまざまな IL を生成する必要が削除されます。 使用を検討して、`constrained`ため値型のメソッドがインターフェイス メソッドの実装で、値の型のインターフェイス メソッドを呼び出すときにプレフィックスの変更を使用して、 `MethodImpl`。 これらの問題がで詳しく説明されている、 <xref:System.Reflection.Emit.OpCodes.Constrained> opcode です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `call` opcode:  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
-   ILGenerator.EmitCall (オペコード、MethodInfo、Type[])  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A>メソッドが提供`varargs`呼び出し。 使用して、<xref:System.Reflection.Emit.ILGenerator.Emit%2A>通常の呼び出しのメソッド。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し規則によって記述されている引数を使用して、評価スタックで (エントリ ポイントへのポインターとして) 指定されているメソッドを呼び出します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli `callSiteDescr`|呼び出し規則によって記述されている引数を指すメソッドを呼び出します。|  
  
 履歴の移行動作を順番には。  
  
1.  メソッドの引数`arg1`を通じて`argN`スタックにプッシュされます。  
  
2.  メソッドのエントリのポインターがスタックにプッシュされます。  
  
3.  メソッドの引数`arg1`を通じて`argN`とメソッドのエントリのポインターがスタックからポップ; メソッドの呼び出しを実行します。 完了すると、戻り値が呼び出し先メソッドによって生成され、呼び出し元に送信します。  
  
4.  戻り値は、スタックにプッシュされます。  
  
 `calli`命令は、引数を持つメソッドのエントリのポインターを呼び出す`arg1`を通じて`argN`します。 これらの引数の型は、特定の呼び出し規則によって記述されます (`callSiteDesc`)。 `calli`命令ではすぐに付くことがあります、`tail`プレフィックス (<xref:System.Reflection.Emit.OpCodes.Tailcall>) メソッドの現在の状態が制御を転送する前にリリースされることを指定します。 呼び出しが転送される場合、元のメソッドのスタック フレームより信頼性の高いメソッドに制御は解放されません。代わりに、実行が継続される場合と、`tail`が提供されています。  
  
 メソッドのエントリのポインターは、呼び出し規則 (スタンドアロン シグネチャのメタデータ トークン) で説明されている引数で正規に呼び出すことができる (ターゲット コンピューター) のネイティブ コードへの特定のポインターと見なされます。 使用してこのようなポインターを作成することができます、<xref:System.Reflection.Emit.OpCodes.Ldftn>または<xref:System.Reflection.Emit.OpCodes.Ldvirtftn>手順については、ネイティブ コードから渡されたか。  
  
 呼び出し規約が動的にチェックされませんが、これを使用するコードを`calli`変換先が実際には指定した呼び出し規約を使用しない場合、命令が正常に動作しません。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、まで、降順でスタックの一番上のすべての必要な引数がスタックし、2 番目の引数は 3 番目の配置。 インスタンスまたは仮想メソッドの引数構築コード シーケンスでは、任意のユーザーに表示される引数の前に、そのインスタンスの参照 (これは、null 参照をできないようにする必要があります) をプッシュする必要があります。  
  
 <xref:System.Security.SecurityException> システムのセキュリティは、呼び出されたメソッドを呼び出し元アクセスを許可していない場合にスローされる可能性が。 セキュリティ チェックは、実行時ではなくネイティブ コードに、Microsoft Intermediate Language (MSIL) 命令が変換される場合に発生することができます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>メソッドを実行するために使用できる、`calli`スタック上の命令。 なお`calli`を介して呼び出す必要があります、以下を使用するのではなく、メソッド、<xref:System.Reflection.Emit.ILGenerator.Emit%2A>クラス、スタック上で直接、命令を配置します。  
  
-   ILGenerator.EmitCalli (オペコード、CallingConventions、種類は、マネージ呼び出し規則を使用して呼び出し用 Type[]) を入力します。  
  
-   ILGenerator.EmitCalli (オペコード、アンマネージ呼び出し規則を使用して、呼び出しの CallingConvention、型、Type[]) です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト上で遅延バインディング メソッドを呼び出し、戻り値を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt `method`|関連付けられている特定のメソッドを呼び出して`obj`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`obj`がスタックにプッシュされます。  
  
2.  メソッドの引数`arg1`を通じて`argN`スタックにプッシュされます。  
  
3.  メソッドの引数`arg1`を通じて`argN`とオブジェクト参照`obj`スタックからポップされますこれらの引数でメソッドの呼び出しが実行されると、メソッドに制御が移ります`obj`メソッドが参照するには。メタデータ トークン。 完了すると、戻り値が呼び出し先メソッドによって生成され、呼び出し元に送信します。  
  
4.  戻り値は、スタックにプッシュされます。  
  
 `callvirt`命令は、オブジェクトの遅延バインディング メソッドを呼び出します。 つまり、メソッドのランタイム型に基づいて選択`obj`メソッドのポインターに表示される、コンパイル時クラスではなく。 `Callvirt` 仮想両方を呼び出すし、インスタンス メソッドを使用できます。 `callvirt`命令ではすぐに付くことがあります、 `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) プレフィックスを制御を転送する前に、現在のスタック フレームを解放する必要があるかを指定します。 呼び出しが転送される場合、スタック フレームの元のメソッドよりも信頼性の高いメソッドに制御は解放されません。  
  
 メソッドのメタデータ トークンでは、名前とクラスを呼び出すメソッドのシグネチャを提供します。 関連付けられているクラス`obj`は、クラスがインスタンスです。 クラスには、示されたメソッドの名前とシグネチャに一致する非静的メソッドが定義されている場合は、このメソッドが呼び出されます。 それ以外の場合、このクラスの基底クラス チェーン内のすべてのクラスは順番にチェックします。 メソッドが見つからない場合は、エラーです。  
  
 `Callvirt` メソッドを呼び出す前に、オブジェクトと関連付けられている引数を評価スタックをポップします。 メソッドの戻り値の場合は、メソッドの完了時にスタックにプッシュされます。 呼び出し側で、`obj`パラメーターが 0 で、引数としてアクセスされる`arg1`引数 1 という具合にします。  
  
 引数は、左から右の順序でスタックに配置されます。 つまり、最初の引数が計算され、まで、降順でスタックの一番上のすべての必要な引数がスタックし、2 番目の引数は 3 番目の配置。 インスタンス参照`obj`(常に必要な`callvirt`) 任意のユーザーに表示される引数の前にプッシュする必要があります。 署名 (メタデータ トークンに含まれる) 必要があります、このパラメーター リスト内のエントリを含まないポインター。  
  
 仮想メソッドも呼び出すことができますを使用してに注意してください、<xref:System.Reflection.Emit.OpCodes.Call>命令。  
  
 <xref:System.MissingMethodException> 関連付けられているクラスで指定した名前およびシグネチャを持つ非静的メソッドが見つかりませんだった場合にスローされる`obj`またはその基本クラスのいずれか。 これは、通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなく、ネイティブ コードに変換された場合に検出します。  
  
 <xref:System.NullReferenceException> obj が null の場合にスローされます。  
  
 <xref:System.Security.SecurityException> システムのセキュリティは、呼び出されたメソッドを呼び出し元アクセスを許可していない場合にスローされます。 セキュリティ チェックは、実行時ではなくネイティブ コードに CIL を変換するときに発生する可能性があります。  
  
> [!NOTE]
>  値の型で System.Object のメソッドを呼び出すときに、使用を検討して、`constrained`プレフィックスを追加、`callvirt`命令。 これには、潜在的なバージョン管理の問題を回避する値の型がメソッドをオーバーライドするかどうかに応じてさまざまな IL を生成する必要が削除されます。 使用を検討して、`constrained`ため値型のメソッドがインターフェイス メソッドの実装で、値の型のインターフェイス メソッドを呼び出すときにプレフィックスの変更を使用して、 `MethodImpl`。 これらの問題がで詳しく説明されている、 <xref:System.Reflection.Emit.OpCodes.Constrained> opcode です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `callvirt` opcode:  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
-   ILGenerator.EmitCall (オペコード、MethodInfo、Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したクラスへの参照により渡されたオブジェクトをキャストしようとします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass `class`|型の新しいオブジェクトにキャスト`class`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされます。参照先オブジェクトのキャストが指定した`class`します。  
  
3.  成功した場合、新しいオブジェクト参照がスタックにプッシュされます。  
  
 `castclass`命令は、オブジェクト参照をキャストしようとしています (型`O`) を指定したクラスにスタックの一番上。 新しいクラスは、目的のクラスを示すメタデータ トークンによって指定されます。 スタックの上部にあるオブジェクトのクラス (新しいクラスはインターフェイスと仮定)、新しいクラスを実装していませんし、新しいクラスの派生クラスではない場合、<xref:System.InvalidCastException>がスローされます。 オブジェクト参照が null 参照、`castclass`が成功し、null 参照として新しいオブジェクトを返します。  
  
 <xref:System.InvalidCastException> obj はクラスにキャストできない場合にスローされます。  
  
 <xref:System.TypeLoadException> クラスが見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) 命令がランタイムではなくネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `castclass` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 2 つの値が等しい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 01|ceq|場合 1 をプッシュ`value1`equals`value2`それ以外、0 をプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value1`と比較する`value2`します。  
  
4.  場合`value1`と等しい`value2`1 がスタックにプッシュされます。 それ以外の場合 0 がスタックにプッシュされます。  
  
 `ceq`命令比較`value1`と`value2`します。 場合`value1`と等しい`value2`、し、1 (型の`int32`) がスタックにプッシュされます。 それ以外の場合 0 (型の`int32`) がスタックにプッシュされます。  
  
 浮動小数点数の`ceq`数値は順序付けられていない場合に 0 を返します (いずれかまたは両方が NaN)。 無限の値がそれ自体に等しいです。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ceq` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 最初の値が 2 番目の値を超える場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 02|cgt|場合 1 をプッシュ`value1`がより大きい`value2`それ以外、0 をプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`cgt`テスト`value1`がより大きい`value2`します。  
  
4.  場合`value1`がより大きい`value2`1 がスタックにプッシュされます。 それ以外の場合 0 がスタックにプッシュされます。  
  
 `cgt`命令比較`value1`と`value2`します。 場合`value1`より厳密に大きい`value2`、 `int32` 1 の値がスタックにプッシュします。 それ以外の場合、 `int32` 0 の値がスタックにプッシュします。  
  
-   浮動小数点数の`cgt`(1 つまたは両方の引数が NaN) の場合は、数値は順序付けられていない場合は 0 を返します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `cgt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なしの値または順序なしの値を比較します。 最初の値が 2 番目の値を超える場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|場合 1 をプッシュ`value1`がより大きい`value2`それ以外、0 (符号なしの値) をプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`cgt.un`テスト`value1`がより大きい`value2`します。  
  
4.  場合`value1`がより大きい`value2`1 がスタックにプッシュされます。 それ以外の場合 0 がスタックにプッシュされます。  
  
 `int32`場合は、次のいずれかが、値 1 がスタックにプッシュされる`true`:  
  
 浮動小数点数の`value1`を順序付けされていない`value2`します。  
  
 整数値では、`value1`より厳密に大きい`value2`符号なし数値としてと見なされるとします。  
  
 それ以外の場合、 `int32` 0 の値がスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `cgt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値が有限数ではない場合は、<see cref="T:System.ArithmeticException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|C3|ckfinite|スロー<xref:System.ArithmeticException>値が有限数ではない場合。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます.  
  
2.  `value` スタックからポップされ、`ckfinite`命令がその上で実行します。  
  
3.  `value` プッシュ バック スタックに例外がスローされない場合。  
  
 `ckfinite instruction`スロー<xref:System.ArithmeticException>場合`value`(浮動小数点数) が、"not a number"の値 (NaN) または`+-`無限大の値。 `Ckfinite` 例外がスローされない場合、スタック上の値のままです。 実行が指定されていない`value`浮動小数点数ではありません。  
  
 <xref:System.ArithmeticException> 場合にスローされる`value`'normal' の数値ではありません。  
  
 なお、特別な例外または派生クラスの<xref:System.ArithmeticException>より適切な例外ハンドラーに正しくない値を渡すことがあります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ckfinite` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を比較します。 最初の値が 2 番目の値より小さい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 04|clt|場合 1 をプッシュ`value1`がより小さい`value2`それ以外、0 をプッシュします。|  
  
 シーケンシャルな順序でスタックの遷移の動作:`value1`がスタックにプッシュされます。  
  
1.  `value2` スタックにプッシュされます。  
  
2.  `value2` `value1`スタックからポップされます。`clt`テスト`value1`がより小さい`value2`します。  
  
3.  場合`value1`がより小さい`value2`1 がスタックにプッシュされます。 それ以外の場合 0 がスタックにプッシュされます。  
  
 `clt`命令比較`value1`と`value2`します。 場合`value1`がより厳密に小さい`value2`、 `int32` 1 の値がスタックにプッシュします。 それ以外の場合、 `int32` 0 の値がスタックにプッシュします。  
  
-   浮動小数点数の`clt`(1 つまたは両方の引数が NaN) の場合は、数値は順序付けられていない場合は 0 を返します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `clt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なしの値または順序なしの値である <paramref name="value1" /> と <paramref name="value2" /> を比較します。 <paramref name="value1" /> が <paramref name="value2" /> より小さい場合は、整数 1 <see langword="(int32" />) が評価スタックにプッシュされます。それ以外の場合は、0 (<see langword="int32" />) が評価スタックにプッシュされます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|場合 1 をプッシュ`value1`がより小さい`value2`それ以外、0 (符号なしの値) をプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`clt.un`テスト`value1`がより小さい`value2`します。  
  
4.  場合`value1`がより小さい`value2`1 がスタックにプッシュされます。 それ以外の場合 0 がスタックにプッシュされます。  
  
 `clt.un`命令比較`value1`と`value2`します。 `int32` 1 の値がスタックにプッシュは、次のいずれかが true の場合。  
  
-   `value1` より厳密に小さい`value2`(用として`clt`)。  
  
-   浮動小数点数の`value1`を順序付けされていない`value2`します。  
  
-   整数値では、`value1`がより厳密に小さい`value2`符号なし数値としてと見なされるとします。  
  
 それ以外の場合、 `int32` 0 の値がスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `clt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>仮想メソッド呼び出しをする対象の型を制約します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 16 < `T` >|制約を受けます。 `thisType`|型に制約された型の仮想メソッドの呼び出し`T`します。|  
  
 `constrained`プレフィックスは許可されているだけで、`callvirt`命令。  
  
 MSIL スタックをこの時点での状態は、次のようにする必要があります。  
  
1.  マネージ ポインター、`ptr`スタックにプッシュされます。 型`ptr`マネージ ポインターである必要があります (`&`) に`thisType`します。 これは、プレフィックスの付かないの大文字と小文字を異なることに注意してください。`callvirt`の参照が必要ですが、命令`thisType`します。  
  
2.  メソッドの引数`arg1`を通じて`argN`と同様に、プレフィックスのないスタックにプッシュされます`callvirt`命令。  
  
 `constrained`プレフィックスが許可するように設計`callvirt`かどうかの方法に依存しない一貫したで作成する手順について`thisType`が値型または参照型。  
  
 ときに、 `callvirt` `method`で命令をプレフィックスとして`constrained` `thisType`、次のように、命令の実行します。  
  
-   場合`thisType`(値型) ではなく、参照型には`ptr`が逆参照し、を 'this' ポインターとしてやり取りされる、`callvirt`の`method`します。  
  
-   場合`thisType`値の型と`thisType`実装`method`し`ptr`未変更としてへ 'this' ポインターが渡される、 `call` `method`の実装のための命令`method`によって`thisType`.  
  
-   場合`thisType`が値型と`thisType`を実装しません`method`し`ptr`が逆参照、ボックス化、およびを 'this' ポインターとしてやり取りされる、 `callvirt` `method`命令。  
  
 この最後の場合に発生することができる場合にのみ`method`で定義された<xref:System.Object>、 <xref:System.ValueType>、または<xref:System.Enum>によって上書きされないと`thisType`します。 ここでは、ボックス化はによってになる元のオブジェクトのコピー。 ただし、ためのメソッドのいずれも<xref:System.Object>、 <xref:System.ValueType>、および<xref:System.Enum>状態を変更、オブジェクトのこの事実を検出できません。  
  
 `constrained`プレフィックスには、汎用的なコードを作成する IL ジェネレーターがサポートしています。 通常、`callvirt`命令は、値型では無効です。 代わりに必要な IL コンパイラは、'this' の種類に応じて、コンパイル時に上記で説明した変換を効果的に行う`ptr`メソッドが呼び出されるとします。 ただし、`ptr`コンパイル時に不明なジェネリック型は、コンパイル時に、この変換を行うことはできません。  
  
 `constrained`オペコード IL コンパイラかどうかの方法に依存しない一貫した仮想関数への呼び出しを行うには、`ptr`が値型または参照型。 場合に適していますが、`thisType`ジェネリック型の変数には、`constrained`も非ジェネリック型のしくみをプレフィックスし、値の型の違いを非表示にする言語での仮想呼び出しを生成する複雑さを軽減できますと参照型。  
  
 使用して、`constrained`プレフィックス値の型による潜在的なバージョン管理の問題を回避できます。 場合、`constrained`プレフィックスが使用されない値の型が System.Object のメソッドをオーバーライドするかどうかによって別の IL を生成する必要があります場合、。 たとえば、値型の場合`V`Object.ToString() メソッドをオーバーライド、 `call` `V.ToString()`命令が生成していない場合、`box`命令と`callvirt``Object.ToString()`命令が生成されます。 バージョン管理の問題は、上書きが後で追加された場合の場合は、上書きが後で削除されると、前者の場合、後者の場合に発生します。  
  
 `constrained`プレフィックスこともできます、値の型のインターフェイス メソッドの呼び出しを使用してインターフェイス メソッドを実装する値の型のメソッドを変更できるため、`MethodImpl`します。 場合、`constrained`プレフィックスが使用されない場合、コンパイラがコンパイル時にバインドする型のメソッドの選択となる値を強制します。 使用して、`constrained`プリフィックスは、コンパイル時ではなく、実行時に、インターフェイス メソッドを実装するメソッドにバインドする MSIL を使用します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `constrained` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="native int" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D3|conv.i|変換`native int`プッシュ、`native int`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.i`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については同等です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int8" /> に変換し、<see langword="int32" /> への拡張 (埋め込み) を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|67|conv.i1|変換`int8`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.i1`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については同等です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int16" /> に変換し、<see langword="int32" /> への拡張 (埋め込み) を行います。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|68|conv.i2|変換`int16`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.i2`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については同等です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int32" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|69|conv.i4|変換`int32`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.i4`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については同等です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="int64" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6A|conv.i8 を使用|変換`int64`プッシュ、`int64`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.i8`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については同等です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D4|conv.ovf.i|変換、 `native int` (スタック上でとして`native int`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.i`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8A|conv.ovf.i.un|符号なしの値に変換を`native int`(としてスタック上`native int`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.i.un`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.i.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|変換、 `int8` (スタック上でとして`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.i1`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|符号なしの値に変換、 `int8` (としてスタックに`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.i1.un`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.i1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int16" /> に変換し、変換した値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|変換、 `int16` (スタック上でとして`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.i2`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|符号なしの値に変換、 `int16` (としてスタックに`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.i2.un`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.i2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|変換、 `int32` (スタック上でとして`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.i4`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|符号なしの値に変換、 `int32` (としてスタックに`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.i4.un`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.i4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を符号付き <see langword="int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|変換、 `int64` (スタック上でとして`int64`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.i8`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を符号付き <see langword="int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|符号なしの値に変換、 `int64` (としてスタックに`int64`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.i8.un`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.i8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|変換、 `unsigned native int` (スタック上でとして`native int`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.u`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned native int" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|値を符号、 `unsigned native int` (スタック上でとして`native int`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.u.un`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.uvf.u.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|変換、 `unsigned int8` (スタック上でとして`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.u1`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|符号なしの値に変換、 `unsigned int8` (としてスタックに`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.u1.un`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.u1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|変換、 `unsigned int16` (スタック上でとして`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.u2`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|符号なしの値に変換、 `unsigned int16` (としてスタックに`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.u2.un`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.u2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|変換、 `unsigned int32` (スタック上でとして`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.u4`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int32" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|符号なしの値に変換、 `unsigned int32` (としてスタックに`int32`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.u4.un`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.u4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号付きの値を <see langword="unsigned int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|変換、 `unsigned int64` (スタック上でとして`int64`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.u8`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある符号なしの値を <see langword="unsigned int64" /> に変換し、オーバーフローについては <see cref="T:System.OverflowException" /> をスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|符号なしの値に変換、 `unsigned int64` (としてスタックに`int64`) オーバーフローの例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。 オーバーフローが発生した場合、例外がスローされます。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.ovf.u8.un`オペコードの変換、`value`オペレーション コード、およびスタックの上部にある値の変換の場所で指定された種類のスタックの一番上。 値が大きすぎる、またはターゲットの型で表現するのには小さすぎる場合、例外がスローされます。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 4 バイト未満の整数値が拡張されたことに注意してください`int32`を評価スタックに読み込まれるとき (しない限り、`conv.ovf.i`または`conv.ovf.u`を使用している場合、結果も`native int`)。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.ovf.u8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の符号なし整数値を <see langword="float32" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|76|conv.r.un|変換する符号なし整数、浮動小数点プッシュ`F`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.r.un`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 浮動小数点型を整数に変換するオーバーフローが発生した場合、`result`が返されますが指定されていません。 `conv.r.un`操作は、スタックから整数を受け取って、署名されていないと解釈しますおよびを表す、整数の浮動小数点数に置き換えられます。 いずれかを`float32`のに十分な精度の損失のない整数を表すまたは他の場合は、。`float64`します。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.r.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="float32" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6B|conv.r4|変換`float32`プッシュ、`F`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.r4`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="float64" /> に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6C|conv.r8|変換`float64`プッシュ、`F`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.r8`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned native int" /> に変換し、その値を <see langword="native int" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|E0|conv.u|変換`unsigned native int`プッシュ、`native int`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.u`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については同等です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int8" /> に変換し、その値を <see langword="int32" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D2|conv.u1|変換`int8`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.u1`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については同等です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int16" /> に変換し、その値を <see langword="int32" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D1|conv.u2|変換`int16`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.u2`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については同等です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int32" /> に変換し、その値を <see langword="int32" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6D|conv.u4|変換`unsigned int32`プッシュ、`int32`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.u4`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については同等です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上の値を <see langword="unsigned int64" /> に変換し、その値を <see langword="int64" /> に拡張します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|6E|conv.u8|変換`int64`プッシュ、`int64`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックと、変換から操作をしようとします。  
  
3.  変換が成功した場合、結果の値がスタックにプッシュされます。  
  
 `conv.u8`オペコードの変換、`value`オペレーション コード、および変換したスタックの上部にある値のままに指定された型にスタックの一番上。 4 バイト未満の整数値に拡張されます`int32`を評価スタックに読み込まれるとき (しない限り、`conv.i`または`conv.u`を使用する場合、結果も`native int`)。 浮動小数点値に変換されます、`F`型。  
  
 浮動小数点数から整数値への変換では、数値がゼロに向かって切り捨てられます。 変換するときに、`float64`を`float32`、有効桁数が失われることができます。 場合`value`に収まるように大きすぎて、 `float32 (F)`、正の無限大 (場合`value`が正の値) または負の無限大 (場合`value`が負の値) が返されます。 変換の 1 つの整数型間のオーバーフローが発生する場合は、上位ビットが切り捨てられます。 結果がより小さい場合、`int32`値が符号拡張され、スロットを入力します。  
  
 オーバーフローが発生した場合は、返される値を整数の浮動小数点型の変換指定されていません。  
  
 このフィールドを使用する場合は、例外がこれまでスローされません。 参照してください<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>と<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>結果型は、結果の値を正しく表すことができないときに例外をスローする手順については同等です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `conv.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソース アドレスから指定した数のバイトを宛先アドレスにコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|データを別の 1 つのメモリ ブロックにコピーします。|  
  
 履歴の移行動作を順番には。  
  
1.  送信先アドレスは、スタックにプッシュされます。  
  
2.  送信元アドレスは、スタックにプッシュされます。  
  
3.  コピーするバイト数は、スタックにプッシュされます。  
  
4.  バイトの数、送信元アドレス、宛先アドレスがスタックからポップされます。指定したバイト数は、ソース アドレスから宛先アドレスにコピーされます。  
  
 `cpblk`命令数のコピー (型`unsigned int32`) ソース アドレスからのバイトの (型の`*`、 `native int`、または`&`) を移行先のアドレス (型の`*`、 `native int`、または`&`)。 動作`cpblk`元とコピー先の領域が重なっている場合は指定されていません。  
  
 `cpblk` ソースと宛先アドレスの両方がコンピューターの通常サイズに揃っていることを想定しています。 `cpblk`命令のすぐ前に、`unaligned.<prefix>`命令をソースまたは変換先のいずれかに整列されていないかを示します。  
  
 操作、 `cpblk` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされる可能性が。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `cpblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトのアドレス (<see langword="&amp;" />、<see langword="*" />、または <see langword="native int" /> の各型) にある値型をコピー先のオブジェクトのアドレス (<see langword="&amp;" />、<see langword="*" />、または <see langword="native int" /> の各型) にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj `classTok`|値のコピーをソース オブジェクトから変換先オブジェクトに入力します。|  
  
 履歴の移行動作を順番には。  
  
1.  変換先のオブジェクト参照は、スタックにプッシュされます。  
  
2.  ソースのオブジェクト参照は、スタックにプッシュされます。  
  
3.  2 つのオブジェクト参照がスタックからポップされます。ソース オブジェクトのアドレスの値の型は、目的のオブジェクトのアドレスにコピーされます。  
  
 動作`cpobj`場合は、ソースと宛先のオブジェクト参照はクラスのトークンによって表されるクラスのインスタンスへのポインターではありませんが指定されていない`classTok`(、`typeref`または`typedef`)、または`classTok`は表しません、値の型。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされる可能性が。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `cpobj` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値の除算を実行し、結果を浮動小数点値 (<see langword="F" /> 型) または商 (<see langword="int32" /> 型) として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|5B|div|商または浮動小数点の結果を返す 2 つの値を除算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value1`で除算`value2`します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `result` = `value1` div value2 は、次の条件を満たします。  
  
 &#124;`result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124;と。  
  
 サインイン (`result`) = +、サインインする場合 (`value1`) 記号の = (`value2`)、または場合は、記号 (`value1`) ~ = 記号 (`value2`)  
  
 `div`命令は、結果を計算し、スタックにプッシュします。  
  
 整数の除算はゼロに向かって切り捨てられます。  
  
 有限数 0 による除算では、正しく署名された無限の値を生成します。  
  
 0 を 0 か無限無限大 NaN (Not A Number) 値で除算します。 任意の数の無限大で割った値ゼロの値が生成されます。  
  
 整数演算でスロー<xref:System.ArithmeticException>場合は、結果を結果の型で表すことはできません。 これは、場合に発生`value1`が最大の負の値と`value2`は-1 です。  
  
 整数演算でスロー<xref:System.DivideByZeroException>場合`value2`は 0 です。  
  
 Intel ベース プラットフォームに注意してください、 <xref:System.OverflowException> (minint div-1) を計算するときにスローされます。 浮動小数点演算 (生成される小数点代わりに) 例外はスローされません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `div` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を除算し、結果 (<see langword="int32" />) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|5C|div.un|2 つの値、署名なし、商を返すことを分割します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value1`で除算`value2`します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `div.un`命令計算`value1`で割った値`value2`、両方とプッシュ数の符号なし整数として取得、`result`スタックにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `div.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にある値をコピーし、そのコピーを評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|25|dup|スタックの上部にある値を複製します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` 複製のため、スタックからポップされます。  
  
3.  `value` スタックにプッシュ バックします。  
  
4.  重複する値は、スタックにプッシュされます。  
  
 `dup`命令がスタックの最上位の要素を複製し、2 つの同一の値を残します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `dup` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外の <see langword="filter" /> 句から共通言語基盤 (CLI) 例外ハンドラーに制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 11|endfilter|SEH 例外処理のフィルター句を終了します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` スタックからポップされます。`endfilter`が実行されると、例外ハンドラーに制御が移ります。  
  
 `Value` (型でなければならない`int32`特定の値セットの 1 つ) がフィルター句から返されます。 いずれかを指定する必要があります。  
  
-   `exception_continue_search` (`value` = 0) 例外ハンドラーの検索を続行するには  
  
-   `exception_execute_handler` (`value` = 1) の finally ブロックが実行されるまで、このフィルター句に、ハンドラーが関連付けられている例外処理フェーズが配置されている 2 つ目を開始します。 探索時に、ハンドラーが実行されます。  
  
 その他の整数値が指定されていない結果を生成されます。  
  
 フィルターのエントリ ポイント メソッドの例外の表に示すようにすると、フィルターのコード ブロックの最初の命令がある必要があります。 `endfilter`命令は、フィルターのコード ブロックの最後の命令である必要があります (したがってのみ考え`endfilter`任意の 1 つのフィルター ブロックの)。 実行した後、`endfilter`命令、コントロールは論理的に CLI 例外処理機構に戻る送られます。  
  
 例外処理機構を除くフィルター ブロックに制御を転送できません。 コントロールは、以外を使用すると、フィルター ブロック外へ転送することはできません、`throw`命令または最後に実行することによって`endfilter`命令。 埋め込むことはできません、`try`ブロック内で、`filter`ブロックします。 内で例外がスローされた場合、`filter`ブロック、傍受することと、値 0 (`exception_continue_search`) が返されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `endfilter` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外ブロックの <see langword="fault" /> 句または <see langword="finally" /> 句から共通言語基盤 (CLI) 例外ハンドラーに制御を転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DC|endfinally<br /><br /> endfault|終了、`finally`または`fault`例外ブロックの句。|  
  
 スタックのこの手順についての遷移の動作はありません。  
  
 `Endfinally` `endfault`の終了、`finally`または`fault`句例外ハンドラーが呼び出されるまでは引き続きそのスタックのアンワインドできます。 `endfinally`または`endfault`命令は、CLI 例外処理機構に制御を転送します。 次の検索され、メカニズム`finally`leave 命令によって保護されているブロックが終了した場合、チェーン内の句。 保護されているブロックが例外で終了した場合、CLI は、[次へ] 検索`finally`または`fault`、または例外処理の最初のパスの中に選択した例外ハンドラーを入力します。  
  
 `endfinally`命令が構文的に表示されるだけ、`finally`ブロックします。 異なり、`endfilter`命令の場合、ブロックの最後に使用する必要はありません、`endfinally`命令、およびが多くあります`endfinally`手順については、必要に応じてブロック内で。 これらの同じ制限に適用されます、`endfault`命令と`fault`ブロックします。  
  
 コントロールに転送することはできません、 `finally` (または`fault`) を除く例外処理機構を通じてをブロックします。 制御を転送できません、 `finally` (または`fault`) の使用によりのブロックを除く、`throw`命令またはを実行する、 `endfinally` (または`endfault`) 命令。 具体的には、することはできません「の範囲内に」を`finally`(または`fault`) ブロックまたはを実行する、<xref:System.Reflection.Emit.OpCodes.Ret>または<xref:System.Reflection.Emit.OpCodes.Leave>内の命令を`finally`(または`fault`) ブロックします。  
  
 なお、`endfault`と`endfinally`手順については、エイリアスです - 同じオペコードに対応します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `endfinally` (`endfault`) オペコード、だけでなく`ILGenerator`メソッド<xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>します。  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のアドレスの指定したメモリ ブロックを、指定のサイズと初期値に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 18|initblk|特定の値にメモリ ブロックのそれぞれの場所を設定します。|  
  
 履歴の移行動作を順番には。  
  
1.  開始アドレスがスタックにプッシュされます。  
  
2.  初期化の値は、スタックにプッシュされます。  
  
3.  初期化するバイト数は、スタックにプッシュされます。  
  
4.  バイト、初期値、および開始アドレスの数が、スタックからポップし、に従ってその値に初期化が実行します。  
  
 `initblk`命令数を設定する (`unsigned int32`) 指定されたアドレスで始まるバイトの (型の`native int`、 `&`、または`*`) 初期化値 (型の`unsigned int8`)。 `initblk` 開始アドレスが、マシンの自然なサイズに合わせて配置されると仮定します。  
  
 操作、`initblk`すぐに前の手順を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされる可能性が。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `initblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したアドレスにある値型の各フィールドを null 参照または適切なプリミティブ型の 0 に初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 15 < `T` >|`initobj` `typeTok`|値の型を初期化します。|  
  
 履歴の移行動作を順番には。  
  
1.  初期化するために、値型のアドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。種類として、指定したアドレスの値の型が初期化された`typeTok`します。  
  
 `initobj`命令がプッシュされたアドレスで指定された値型の各フィールドを初期化します (型の`native int`、 `&`、または`*`) の参照を null または適切なプリミティブ型の 0 にします。 このメソッドが呼び出された後、インスタンスが呼び出されるコンス トラクター メソッドに対応します。 場合`typeTok`、参照型では、この命令と同じ効果`ldnull`続けて`stind.ref`します。  
  
 異なり<xref:System.Reflection.Emit.OpCodes.Newobj>、`initobj`コンス トラクター メソッドを呼び出しません。 `Initobj` 値型の初期化のためのもので、while`newobj`の割り当てし、オブジェクトを初期化するために使用します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `initobj` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照 (<see langword="O" /> 型) が特定のクラスのインスタンスかどうかをテストします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst `class`|インスタンスで、オブジェクト参照がテスト`class`、null 参照またはそのクラスのインスタンスを返す、またはインターフェイスします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照をスタックからポップされ、それが渡されたクラスのインスタンスであるかどうかをテスト`class`します。  
  
3.  結果 (オブジェクト参照または null 参照) は、スタックにプッシュされます。  
  
 `Class` 目的のクラスをメタデータ トークンを示すです。 スタックの上部にあるオブジェクトのクラスを実装するかどうかは`class`(場合`class`インターフェイス) またはの派生クラスである`class`(場合`class`通常のクラス) 型にキャストし、`class`し、結果が、スタックにプッシュされますまったく同じよう<xref:System.Reflection.Emit.OpCodes.Castclass>が呼び出されました。 それ以外の場合、null 参照がスタックにプッシュされます。 オブジェクト参照自体が null 参照では、し`isinst`同様に null 参照を返します。  
  
 <xref:System.TypeLoadException> クラスが見つからない場合にスローされます。 通常、ランタイムではなくネイティブ コードに、Microsoft Intermediate Language (MSIL) 命令が変換される場合に検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `isinst` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドを終了し、指定したメソッドにジャンプします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp `method`|現在のメソッドを終了し、指定したメソッドにジャンプします。|  
  
 スタックのこの手順についての遷移の動作はありません。  
  
 `jmp` (移動) の命令は、によって指定されたメソッドに制御を転送`method`メソッドの参照のメタデータ トークンであります。 現在の引数は、先のメソッドに転送されます。  
  
 この命令の実行時は、評価スタックが空にする必要があります。 呼び出し元の規則、番号、および変換先のアドレスにある引数の型は、現在のメソッドと一致する必要があります。  
  
 `jmp`命令は、転送の制御を使用することはできません、 `try`、 `filter`、 `catch`、または`finally`ブロックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `jmp` opcode:  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したインデックス値によって参照される引数をスタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg `index`|引数を読み込む`index`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  引数値`index`がスタックにプッシュされます。  
  
 `ldarg`命令がインデックスの引数がプッシュ`index`を評価スタックに引数が 0 以降では、インデックス位置。 `ldarg`命令は、受信の引数からコピーすることで、値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 可変長引数リストでは、手順については、`ldarg`命令は、最初の可変部分の署名のある引数を固定にのみ使用できます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Arglist>命令の詳細)。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldarg` opcode:  
  
-   ILGenerator.Emit (オペコード、短い)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 0 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|02|ldarg.0|引数 0 をスタックに読み込みます|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 0 位置にある引数の値は、スタックにプッシュされます。  
  
 `ldarg.0`命令は、インデックス 0 位置にある引数の値を読み込むための効率的なエンコーディングします。  
  
 `ldarg.0`命令は引数のインデックスが 0 を評価スタックにプッシュします。 `ldarg.0`命令は、受信の引数からコピーすることで、値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldarg.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 1 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|03|ldarg.1|引数 1 をスタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 1 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.1`命令は、インデックス 1 の引数の値を読み込むための効率的なエンコーディングします。  
  
 `ldarg.1`命令は引数のインデックスが 1 を評価スタックにプッシュします。 `ldarg.1`命令は、受信の引数からコピーすることで、値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldarg.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 2 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|04|ldarg.2|引数 2 をスタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 2 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.2`命令は、インデックス 2 の引数の値を読み込むための効率的なエンコーディングします。  
  
 `ldarg.2`命令は引数のインデックスが 2 を評価スタックにプッシュします。 `ldarg.2`命令は、受信の引数からコピーすることで、値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldarg.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 3 の引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|05|ldarg.3|引数 3 をスタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 3 の引数の値は、スタックにプッシュされます。  
  
 `ldarg.3`命令はインデックス 3 の引数の値を読み込むため、効率的なエンコーディングします。  
  
 `ldarg.3`命令は引数のインデックスが 3 を評価スタックにプッシュします。 `ldarg.3`命令は、受信の引数からコピーすることで、値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldarg.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した短い形式のインデックスによって参照される引数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg.s `index`|引数を読み込む`index`スタックでは、短い形式。|  
  
 履歴の移行動作を順番には。  
  
1.  引数値`index`がスタックにプッシュされます。  
  
 `ldarg.s`命令はインデックスの引数を読み込む 4 ~ 255 の効率的なエンコードです。  
  
 `ldarg.s`命令がインデックスの引数がプッシュ`index`を評価スタックに引数が 0 以降では、インデックス位置。 `ldarg.s`命令は、受信の引数からコピーすることで、値型またはプリミティブ値をスタックを読み込みを使用することができます。 引数値の型は、現在のメソッドのシグネチャで指定された引数の型と同じです。  
  
 可変長引数リストでは、手順については、`ldarg.s`命令は、最初の可変部分の署名のある引数を固定にのみ使用できます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Arglist>命令の詳細)。  
  
 4 バイト長より小さい整数値を保持している引数を型に拡張されます`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldarg.s` opcode:  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引数アドレスを評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga `index`|インデックスが引数のアドレスをフェッチ`index`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレス`addr`によってインデックス付けされた引数の`index`がスタックにプッシュされます。  
  
 `ldarga`命令アドレスがフェッチされます (型の`*`) によってインデックス付けされた引数の`index`引数が 0 以降からインデックス付けされた場所。 アドレス`addr`は常にターゲット コンピューターの自然な境界に配置されます。  
  
 可変長引数リストでは、手順については、`ldarga`命令は、最初の可変部分の署名のある引数を固定にのみ使用できます。  
  
 `ldarga` 参照渡しパラメーターの引き渡しに使用されます。 それ以外の場合の<xref:System.Reflection.Emit.OpCodes.Ldarg>と<xref:System.Reflection.Emit.OpCodes.Starg>使用する必要があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldarga` opcode:  
  
-   ILGenerator.Emit (オペコード、短い)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引数アドレス (短い形式) を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga.s `index`|インデックスが引数のアドレスをフェッチ`index`、短縮形。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレス`addr`によってインデックス付けされた引数の`index`がスタックにプッシュされます。  
  
 `ldarga.s` (短い形式の`ldarga`) 引数数字 0 ~ 255 に使用してより効率的なエンコーディングします。  
  
 `ldarga.s`命令アドレスがフェッチされます (型の`*`) によってインデックス付けされた引数の`index`引数が 0 以降からインデックス付けされた場所。 アドレス`addr`は常にターゲット コンピューターの自然な境界に配置されます。  
  
 可変長引数リストでは、手順については、`ldarga.s`命令は、最初の可変部分の署名のある引数を固定にのみ使用できます。  
  
 `ldarga.s` 参照渡しパラメーターの引き渡しに使用されます。 それ以外の場合の<xref:System.Reflection.Emit.OpCodes.Ldarg_S>と<xref:System.Reflection.Emit.OpCodes.Starg_S>使用する必要があります。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldarga.s` opcode:  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="int32" /> 型の値を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|20 < `int32` >|目 ldc.i4 `num`|値をプッシュします`num`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  値`num`がスタックにプッシュされます。  
  
 整数-128 ~-1 ~ 8 の 127、および特に短いエンコーディングを短い (およびそのためより効率的な) の特別なエンコーディングがあることに注意してください。 すべての短いエンコーディングは、4 バイト整数をスタックにプッシュします。 長いエンコーディングは、8 バイト整数 4 および 8 バイトの浮動小数点数と短い形式に適合しない 4 バイトの値に使用されます。 8 バイト整数定数をスタックにプッシュする 3 つの方法はあります。  
  
 1. 使用して、<xref:System.Reflection.Emit.OpCodes.Ldc_I8>命令の 32 ビット以上で表現する必要がある定数。  
  
 2. 使用、<xref:System.Reflection.Emit.OpCodes.Ldc_I4>命令を<xref:System.Reflection.Emit.OpCodes.Conv_I8>の 9 ~ 32 ビットを必要とする定数。  
  
 3. 続く短い形式の命令を使用して、<xref:System.Reflection.Emit.OpCodes.Conv_I8>の定数を 8 個以下のビット単位で表すことができます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4` opcode:  
  
-   ILGenerator.Emit (オペコード、int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 0 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|0、スタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 0 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 をプッシュします。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 1 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|1 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 1 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 をプッシュします。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 2 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|2 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 2 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 をプッシュします。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 3 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|3 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 3 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 をプッシュします。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 4 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|4 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 4 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 をプッシュします。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 5 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|5 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 5 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 をプッシュします。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.5` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 6 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|6 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値 6 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 をプッシュします。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.6` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 7 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|7 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  7 という値は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 をプッシュします。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.7` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 8 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|8 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値の 8 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 をプッシュします。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値 -1 を <see langword="int32" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|16|ldc.i4.m1|-1 をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値-1 は、スタックにプッシュされます。  
  
 これは、特殊な短いエンコーディングの整数値 0 をプッシュします。 すべての特殊な短いエンコーディングは、4 バイト整数をスタックにプッシュします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.m1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="int8" /> 値を <see langword="int32" /> として評価スタックにプッシュします (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|1F < `int8` >|ldc.i4.s `num`|プッシュ`num`としてスタックに`int32`、短縮形。|  
  
 履歴の移行動作を順番には。  
  
1.  値`num`がスタックにプッシュされます。  
  
 `ldc.i4.s` -128 から 127 の整数を評価スタックにプッシュをより効率的なエンコーディングです。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i4.s` opcode:  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="int64" /> 型の値を <see langword="int64" /> として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|21 < `int64` >|場合は、ldc.i8 `num`|プッシュ`num`としてスタックに`int64`します。|  
  
 履歴の移行動作を順番には。  
  
1.  値`num`がスタックにプッシュされます。  
  
 このエンコーディング、`int64`値をスタックにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.i8` opcode:  
  
-   ILGenerator.Emit (オペコード、長い)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="float32" /> 型の値を <see langword="F" /> (float) 型として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.r4 `num`|プッシュ`num`としてスタックに`F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  値`num`がスタックにプッシュされます。  
  
 このエンコーディングを`float32`値をスタックにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.r4` opcode:  
  
-   ILGenerator.Emit (オペコード、1 つ)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された <see langword="float64" /> 型の値を <see langword="F" /> (float) 型として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.r8 `num`|プッシュ`num`としてスタックに`F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  値`num`がスタックにプッシュされます。  
  
 このエンコーディングを`float64`値をスタックにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldc.r8` opcode:  
  
-   ILGenerator.Emit (オペコード、double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの要素を命令で指定された型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem `typeTok`|ある要素を読み込みます`index`型としてスタックの一番上に`typeTok`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列は、オブジェクト型の値によって表されるため、`O`します。  
  
 戻り値の型が、トークンで指定された`typeTok`命令でします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはの上限を超える`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="native int" /> 型の要素を <see langword="native int" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|97|ldelem.i|型の要素を読み込みます`native int`で`index`としてスタックの一番上に、`native int`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.i`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.i`は`native int`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int8" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|型の要素を読み込みます`int8`で`index`としてスタックの一番上に、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.i1`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.i1`は`int8`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int16" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|型の要素を読み込みます`int16`で`index`としてスタックの一番上に、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.i2`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.i2`は`int16`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int32" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|型の要素を読み込みます`int32`で`index`としてスタックの一番上に、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.i4`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.i4`は`int32`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="int64" /> 型の要素を <see langword="int64" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|型の要素を読み込みます`int64`で`index`としてスタックの一番上に、`int64`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.i8`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.i8`は`int64`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="float32" /> 型の要素を <see langword="F" /> (float) 型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|型の要素を読み込みます`float32`で`index`型として、スタックの一番上に`F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.r4`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.r4`は`float32`します。  
  
 浮動小数点値が型に変換されます`F`を評価スタックに読み込まれるときにします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="float64" /> 型の要素を <see langword="F" /> (float) 型として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|型の要素を読み込みます`float64`で`index`型としてスタックの一番上に`F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.r8`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.r8`は`float64`します。  
  
 浮動小数点値が型に変換されます`F`を評価スタックに読み込まれるときにします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスのオブジェクト参照を格納している要素を <see langword="O" /> 型 (オブジェクト参照) として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|オブジェクト参照を持つ要素を読み込みます`index`型としてスタックの一番上に`O`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.ref`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.ref`型は、 `O` (オブジェクト参照)。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="unsigned int8" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|型の要素を読み込みます`unsigned int8`で`index`としてスタックの一番上に、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.u1`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.u1`は`int8`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="unsigned int16" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|型の要素を読み込みます`unsigned int16`としてスタックの一番上のインデックス位置にある、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.u2`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.u2`は`int16`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスの <see langword="unsigned int32" /> 型の要素を <see langword="int32" /> として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|型の要素を読み込みます`unsigned int32`としてスタックの一番上のインデックス位置にある、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されている値`index`で`array`が検索されます。  
  
4.  値がスタックにプッシュされます。  
  
 `ldelem.u4`命令は、インデックスを持つ要素の値を読み込みます`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。  
  
 戻り値`ldelem.u4`は`int32`します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 配列が必要な型の要素を保持していない場合にスローされます。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelem.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定した配列インデックスにある配列要素のアドレスを <see langword="&amp;" /> 型 (マネージド ポインター) として評価スタックの一番上に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema `class`|ある配列要素のアドレスをロード`index`型として評価スタックの一番上に`&`(マネージ ポインター)。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`array`がスタックにプッシュされます。  
  
2.  インデックス値`index`がスタックにプッシュされます。  
  
3.  `index` `array`スタックからポップされます。 位置に格納されているアドレス`index`で`array`が検索されます。  
  
4.  アドレスがスタックにプッシュされます。  
  
 `ldelema`オブジェクトの配列内の特定のインデックス位置にあるオブジェクトのアドレスを取得するために使用 (型の`class`)。 `ldelema`命令は、インデックス位置にある値のアドレスをロード`index`(型`native int`)、0 から始まる 1 次元配列で`array`され、スタックの一番上に配置します。 配列はオブジェクト型の値によって表されるため、`O`します。 値型でなければなりません`class`命令に渡されます。  
  
 戻り値`ldelema`マネージ ポインター (型`&`)。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldelema` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照が現在評価スタック上にあるオブジェクト内のフィールドの値を検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld `field`|指定したオブジェクトをスタック内のフィールドの値をプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 (またはポインター) は、スタックにプッシュされます。  
  
2.  オブジェクト参照 (またはポインター) がスタックからポップされます。オブジェクトで指定されたフィールドの値が存在します。  
  
3.  フィールドに格納されている値は、スタックにプッシュされます。  
  
 `ldfld`命令がスタックにオブジェクトにあるフィールドの値をプッシュします。 オブジェクトがオブジェクト参照としてスタック上に存在する必要があります (型`O`)、マネージ ポインター (型`&`)、アンマネージ ポインター (型`native int`)、一時的なポインター (型`*`)、または値型のインスタンス。 検証可能なコードでは、アンマネージ ポインターは使用できません。 オブジェクトのフィールドは、フィールドのメンバーを参照する必要があるメタデータ トークンによって指定されます。 戻り値の型は、フィールドに関連付けられているものと同じです。 (この場合、オブジェクトする必要がありますできない null 参照) のインスタンス フィールドまたは静的フィールドのいずれかのフィールドがあります。  
  
 `ldfld`命令の前に、いずれかまたは両方の<xref:System.Reflection.Emit.OpCodes.Unaligned>と<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックス。  
  
 <xref:System.NullReferenceException> オブジェクトが null とフィールドが静的でない場合にスローされます。  
  
 <xref:System.MissingFieldException> メタデータで指定されたフィールドが見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなく、ネイティブ コードに変換する場合にチェックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldfld` opcode:  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>参照が現在評価スタック上にあるオブジェクト内のフィールドのアドレスを検索します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda `field`|アドレスをプッシュ`field`スタックに指定されたオブジェクト。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照 (またはポインター) は、スタックにプッシュされます。  
  
2.  オブジェクト参照 (またはポインター) がスタックからポップされます。オブジェクトで指定されたフィールドのアドレスが見つかりました。  
  
3.  指定したフィールドのアドレスは、スタックにプッシュされます。  
  
 `ldflda`命令がスタックにオブジェクトにあるフィールドのアドレスをプッシュします。 オブジェクトがオブジェクト参照としてスタック上に存在する必要があります (型`O`)、マネージ ポインター (型`&`)、アンマネージ ポインター (型`native int`)、一時的なポインター (型`*`)、または値型のインスタンス。 検証可能なコードでは、アンマネージ ポインターは使用できません。 オブジェクトのフィールドは、フィールドのメンバーを参照する必要があるメタデータ トークンによって指定されます。  
  
 によって返される値`ldflda`マネージ ポインター (型`&`) オブジェクトをアンマネージ ポインターとしてスタックにプッシュすると、しない限り、場合、戻り値のアドレスもアンマネージ ポインター (型`native int`)。  
  
 `ldflda`命令の前に、いずれかまたは両方の<xref:System.Reflection.Emit.OpCodes.Unaligned>と<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックス。  
  
 <xref:System.InvalidOperationException> アクセス元のアプリケーション ドメイン内のオブジェクトがない場合にスローされます。 アクセスするアプリケーション ドメイン内でないフィールドのアドレスを読み込むことができません。  
  
 <xref:System.NullReferenceException> オブジェクトが null とフィールドが静的でない場合にスローされます。  
  
 <xref:System.MissingFieldException> メタデータで指定されたフィールドが見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなく、ネイティブ コードに変換する場合にチェックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldflda` opcode:  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のメソッドを実装しているネイディブ コードへのアンマネージ ポインター (<see langword="native int" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn `method`|によって参照されるメソッドへのポインターのプッシュ`method`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  特定のメソッドへのアンマネージ ポインターがスタックにプッシュされます。  
  
 特定のメソッド (`method`) を使用して呼び出すことができます、<xref:System.Reflection.Emit.OpCodes.Calli>命令マネージ メソッド (またはアンマネージ コードから移行するスタブ) を参照する場合。  
  
 値には、CLR の呼び出し規約を使用したネイティブ コードにポイントが返されます。 このメソッドのポインターは、コールバック ルーチンとしてアンマネージ ネイティブ コードに渡すことはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldftn` opcode:  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="native int" /> 型の値を <see langword="native int" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4D|ldind.i|読み込み、`native int`アドレスに`addr`としてスタックに、`native int`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.i`ない命令は直接読み込みます、`native int`指定したアドレスからの値 (型の`native int`、 `&`、または *) としてスタックに、`native int`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int8" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|46|ldind.i1|読み込み、`int8`アドレスに`addr`としてスタックに、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます.  
  
 `ldind.i1`ない命令は直接読み込みます、`int8`指定したアドレスからの値 (型の`native int`、 `&`、または *) としてスタックに、`int32`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int16" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|48|ldind.i2|読み込み、`int16`アドレスに`addr`としてスタックに、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.i2`ない命令は直接読み込みます、`int16`指定したアドレスからの値 (型の`native int`、 `&`、または *) としてスタックに、`int32`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int32" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|読み込み、`int32`アドレスに`addr`としてスタックに、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.i4`ない命令は直接読み込みます、`int32`指定したアドレスからの値 (型の`native int`、 `&`、または *) としてスタックに、`int32`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="int64" /> 型の値を <see langword="int64" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4C|ldind.i8|読み込み、`int64`アドレスに`addr`としてスタックに、`int64`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.i8`ない命令は直接読み込みます、`int64`指定したアドレスからの値 (型の`native int`、 `&`、または *) としてスタックに、`int64`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="float32" /> 型の値を <see langword="F" /> (float) 型として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4E|ldind.r4|読み込み、`float32`アドレスに`addr`型としてスタックに`F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.r4`ない命令は直接読み込みます、`float32`指定したアドレスからの値 (型の`native int`、 `&`、または *)、スタックの種類として`F`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="float64" /> 型の値を <see langword="F" /> (float) 型として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4F|ldind.r8|読み込み、`float64`アドレスに`addr`型としてスタックに`F`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.r8`ない命令は直接読み込みます、`float64`指定したアドレスからの値 (型の`native int`、 `&`、または *) としてスタックに、`float64`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照を <see langword="O" /> 型 (オブジェクト参照) として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|50|ldind.ref|アドレスのオブジェクト参照を読み込みます`addr`型としてスタック `O`|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにあるオブジェクトの参照を取得します。  
  
3.  フェッチされた参照は、スタックにプッシュされます。  
  
 `ldind.ref`命令が指定されたアドレスのオブジェクト参照を直接読み込みます (型の`native int`、 `&`、または *) 型としてスタックに`O`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="unsigned int8" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|47|ldind.u1|読み込み、`unsigned int8`アドレスに`addr`としてスタックに、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.u1`ない命令は直接読み込みます、`unsigned int8`指定したアドレスからの値 (型の`native int`、 `&`、または *) としてスタックに、`int32`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="unsigned int16" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|49|ldind.u2|読み込み、`unsigned int16`アドレスに`addr`としてスタックに、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.u2`ない命令は直接読み込みます、`unsigned int16`指定したアドレスからの値 (型の`native int`、 `&`、または *) としてスタックに、`int32`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see langword="unsigned int32" /> 型の値を <see langword="int32" /> として評価スタックに間接的に読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|4B|ldind.u4|読み込み、`unsigned int32`アドレスに`addr`としてスタックに、`int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  アドレスがスタックからポップされます。アドレスにある値を取得します。  
  
3.  フェッチされた値は、スタックにプッシュされます。  
  
 `ldind.u4`ない命令は直接読み込みます、`unsigned int32`指定したアドレスからの値 (型の`native int`、 `&`、または *) としてスタックに、`int32`します。  
  
 すべての`ldind`手順については、ショートカット、<xref:System.Reflection.Emit.OpCodes.Ldobj>命令を対応する組み込みの値のクラスを指定します。  
  
 4 バイト未満の整数値に拡張されたことに注意してください。 `int32` (いない`native int`) を評価スタックに読み込まれるとき。 浮動小数点値に変換されます`F`を評価スタックに読み込まれるときに入力します。  
  
 形式が正しい Microsoft Intermediate Language (MSIL) により、`ldind`命令が、ポインターの型に従った方法で使用されます。  
  
 最初に、スタックにプッシュ アドレスは、コンピューター上のオブジェクトの通常サイズに合わせて配置する必要がありますまたは<xref:System.NullReferenceException>発生することができます (を参照してください、<xref:System.Reflection.Emit.OpCodes.Unaligned>プレフィックスの予防措置の命令)。 アドレスを返すすべての MSIL 命令の結果 (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloca>と<xref:System.Reflection.Emit.OpCodes.Ldarga>) は安全に揃えて配置されます。 1 バイトを超えるデータ型、バイトの順序付けは、ターゲット CPU に依存します。 バイトの順序に依存するコードは、すべてのプラットフォームでは実行されません。  
  
 <xref:System.NullReferenceException> 無効なアドレスが検出された場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldind.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス番号が 0 から始まる 1 次元配列の要素数を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8E|ldlen|長さのプッシュ (型の`natural unsigned int`) のスタックの配列。|  
  
 履歴の移行動作を順番には。  
  
1.  配列へのオブジェクト参照は、スタックにプッシュされます。  
  
2.  配列参照はスタックからポップし、長さが計算されます。  
  
3.  長さは、スタックにプッシュされます。  
  
 配列はオブジェクト型の値によって表されるため、`O`します。 長さとして返されます、`natural unsigned int`します。  
  
 <xref:System.NullReferenceException> 配列の参照が null 参照である場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldlen` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc `index`|インデックスのローカル変数を読み込みます`index`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  指定したインデックス位置にあるローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc`命令はローカル変数が番号付き 0 以降の評価スタックに渡されたインデックス位置にあるローカル変数の数の内容をプッシュします。 ローカル変数は、メソッドの初期化フラグが true の場合にのみ、メソッドを入力する前に 0 に初期化されます。 65,535 がある (2 ^16-1) 使用できるローカル変数 (0 ~ 65,534)。 可能性の高い実装は特定のメソッドのローカル変数の合計数と共に、ローカルの両方のインデックスを追跡するために、2 バイトの整数を使用するために、65,535 のインデックスが無効です。 65535 のインデックスが行われた有効な場合、そのような方法でローカル変数の数を追跡する幅の整数が必要です。  
  
 `ldloc.0`、 `ldloc.1`、 `ldloc.2`、および`ldloc.3`の手順は、最初の 4 つのローカル変数にアクセスするため、効率的なエンコーディングを提供します。  
  
 値の型は、メソッド ヘッダーで指定されているローカル変数の型と同じです。 4 バイト長が型に拡張されますよりも小さいするパーティション I. ローカル変数を参照してください。`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldloc` opcode:  
  
-   ILGenerator.Emit (オペコード、LocalBuilder)  
  
-   ILGenerator.Emit (オペコード、短い)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 0 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|06|ldloc.0|インデックス 0 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 0 位置にあるローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc.0` 特に効率的なエンコーディングの<xref:System.Reflection.Emit.OpCodes.Ldloc>インデックス 0 位置にあるローカル変数へのアクセスを許可します。  
  
 値の型は、メソッド ヘッダーで指定されているローカル変数の型と同じです。 4 バイト長未満のローカル変数は、型に拡張されます`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 1 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|07|ldloc.1|インデックス 1 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 1 のローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc.1` 特に効率的なエンコーディングの<xref:System.Reflection.Emit.OpCodes.Ldloc>インデックス 1 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッド ヘッダーで指定されているローカル変数の型と同じです。 4 バイト長未満のローカル変数は、型に拡張されます`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 2 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|08|ldloc.2|インデックス 2 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 2 のローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc.2` 特に効率的なエンコーディングの<xref:System.Reflection.Emit.OpCodes.Ldloc>インデックス 2 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッド ヘッダーで指定されているローカル変数の型と同じです。 4 バイト長未満のローカル変数は、型に拡張されます`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>インデックス 3 のローカル変数を評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|09|ldloc.3|インデックス 3 のローカル変数を評価スタックに読み込みます。|  
  
 履歴の移行動作を順番には。  
  
1.  インデックス 3 のローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc.3` 特に効率的なエンコーディングの<xref:System.Reflection.Emit.OpCodes.Ldloc>インデックス 3 のローカル変数へのアクセスを許可します。  
  
 値の型は、メソッド ヘッダーで指定されているローカル変数の型と同じです。 4 バイト長未満のローカル変数は、型に拡張されます`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数を評価スタックに読み込みます (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc.s `index`|インデックスのローカル変数を読み込みます`index`スタックでは、短い形式。|  
  
 履歴の移行動作を順番には。  
  
1.  指定したインデックス位置にあるローカル変数の値は、スタックにプッシュされます。  
  
 `ldloc.s`命令はローカル変数が番号付き 0 以降の評価スタックに渡されたインデックス位置にあるローカル変数の数の内容をプッシュします。 ローカル変数は、メソッドの初期化フラグが true の場合、メソッドを入力する前に 0 に初期化されます。 256 がある (2 ^8) ローカルで使用できる変数 (0 ~ 255) 短い形式をより効率的なエンコーディングである`ldloc`します。  
  
 値の型は、メソッド ヘッダーで指定されているローカル変数の型と同じです。 4 バイト長が型に拡張されますよりも小さいするパーティション I. ローカル変数を参照してください。`int32`スタックに読み込まれるとき。 浮動小数点値は、ネイティブ サイズに拡張されます (型`F`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldloc.s` opcode:  
  
-   ILGenerator.Emit (オペコード、LocalBuilder)  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE OD < `unsigned int16` >|ldloca `index`|ローカル変数のアドレスをロード`index`を評価スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  指定したインデックス位置にあるローカル変数に格納されているアドレスは、スタックにプッシュされます。  
  
 `ldloca`命令は、ローカル変数は、番号は 0 以降のスタックに渡されたインデックス位置にあるローカル変数の数のアドレスをプッシュします。 スタックにプッシュされた値が既に正しく整列して使用するなどの命令で<xref:System.Reflection.Emit.OpCodes.Ldind_I>と<xref:System.Reflection.Emit.OpCodes.Stind_I>します。 結果は、一時的なポインター (型`*`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldloca` opcode:  
  
-   ILGenerator.Emit (オペコード、短い)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定のインデックスのローカル変数のアドレスを評価スタックに読み込みます (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s `index`|ローカル変数のアドレスをロード`index`評価スタックの短い形式。|  
  
 履歴の移行動作を順番には。  
  
1.  指定したインデックス位置にあるローカル変数に格納されているアドレスは、スタックにプッシュされます。  
  
 `ldloca.s`命令は、ローカル変数は、番号は 0 以降のスタックに渡されたインデックス位置にあるローカル変数の数のアドレスをプッシュします。 スタックにプッシュされた値が既に正しく整列して使用するなどの命令で<xref:System.Reflection.Emit.OpCodes.Ldind_I>と<xref:System.Reflection.Emit.OpCodes.Stind_I>します。 結果は、一時的なポインター (型`*`)。  
  
 `ldloca.s`命令は 0 ~ 255 のローカル変数で使用するための効率的なエンコーディングします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldloca.s` opcode:  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>null 参照 (<see langword="O" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|14|ldnull|null 参照をスタックにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  Null オブジェクト参照は、スタックにプッシュされます。  
  
 `ldnull` プッシュは null 参照 (型`O`) スタックにします。 これは、データが入力されている前に、または禁止になったときに場所を初期化するために使用されます。  
  
 `ldnull` サイズに依存しない null 参照を提供します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldnull` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アドレスが指す値型オブジェクトを評価スタックの一番上にコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj `class`|値型のインスタンスのコピー`class`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  値型のオブジェクトのアドレスは、スタックにプッシュされます。  
  
2.  アドレスがスタックからポップされ、その特定のアドレスでインスタンスが検索されます。  
  
3.  そのアドレスに格納されているオブジェクトの値は、スタックにプッシュされます。  
  
 `ldobj`値の型をパラメーターとして渡す命令を使用します。  
  
 `ldobj`命令によって示される値をコピーする`addrOfValObj`(型の`&`、 `*`、または`native int`)、スタックの一番上にします。 コピーされたバイト数は、クラスのサイズによって異なります (で指定されたとおり、`class`パラメーター)。 `class`パラメーターは値型を表すメタデータ トークン。  
  
 操作、 `ldobj` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.TypeLoadException> クラスが見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) 命令がランタイムではなくネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldobj` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドの値を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld `field`|値をプッシュ`field`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  特定のフィールドの値は、スタックにプッシュされます。  
  
 `ldsfld`命令は、静的 (クラスのすべてのインスタンスで共有) の値をプッシュ、スタックのフィールド。 戻り値の型は、渡されたメタデータ トークンに関連付けられた`field`します。  
  
 `ldsfld`命令を持つことができます、<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックス。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldsfld` opcode:  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドのアドレスを評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda `field`|アドレスをプッシュ`field`スタック|  
  
 履歴の移行動作を順番には。  
  
1.  特定のフィールドのアドレスは、スタックにプッシュされます。  
  
 `ldsflda`命令は、静的 (クラスのすべてのインスタンスで共有) のアドレス、プッシュ、スタックのフィールド。 アドレスは、一時的なポインターとして表すことができます (型`*`) 場合、メタデータ トークン`field`はメモリがマネージ型を表します。 アンマネージ ポインターに対応するそれ以外の場合、(型`native int`)。 なお`field`場合があります、静的な割り当て済みの相対仮想アドレス (その含む PE ファイルが現在メモリに読み込まれる場合は、ベース アドレスからのフィールドのオフセット) を使用したグローバル メモリが管理されていません。  
  
 `ldsflda`命令を持つことができます、<xref:System.Reflection.Emit.OpCodes.Volatile>プレフィックス。  
  
 <xref:System.MissingFieldException> メタデータでフィールドが見つからない場合にスローされます。 これは、通常、Microsoft Intermediate Language (MSIL) の手順については、ランタイムではなく、ネイティブ コードに変換する場合にチェックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldsflda` opcode:  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータに格納されているリテラル文字列への新しいオブジェクト参照をプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr `mdToken`|メタデータの文字列トークンの文字列オブジェクトをプッシュ`mdToken`します。|  
  
 履歴の移行動作を順番には。  
  
1.  文字列へのオブジェクト参照は、スタックにプッシュされます。  
  
 `ldstr`命令は、プッシュ オブジェクト参照 (型`O`) メタデータに格納されている特定文字列リテラルを表す新しい文字列オブジェクトにします。 `ldstr`命令が必要なメモリを割り当ててし、実行時に必要な文字列形式をファイルで使用される形式から文字列リテラルに変換するために必要な任意の形式変換を実行します。  
  
 共通言語基盤 (CLI) からの 2 つの結果を保証する`ldstr`を同じ文字のシーケンスを持つ 2 つのメタデータ トークンを参照しているオブジェクトを返す正確に同じ文字列 (「文字列のインターン」と呼ばれるプロセス)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldstr` opcode:  
  
-   ILGenerator.Emit (オペコード文字列)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータ トークンをそのランタイム表現に変換し、評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken `token`|メタデータ トークンをそのランタイム表現に変換します。|  
  
 履歴の移行動作を順番には。  
  
1.  渡されたトークンは、変換、`RuntimeHandle`スタックにプッシュされます。  
  
 `ldtoken`命令プッシュ、`RuntimeHandle`の指定したメタデータ トークン。 A`RuntimeHandle`できます、 `fieldref/fielddef`、 `methodref/methoddef`、または`typeref/typedef`します。  
  
 呼び出しでスタックにプッシュする値を使用できます`Reflection`システム クラス ライブラリのメソッド。  
  
 ランタイム ハンドルのについては、次のクラスを参照してください: <xref:System.RuntimeFieldHandle>、 <xref:System.RuntimeTypeHandle>、および<xref:System.RuntimeMethodHandle>します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldtoken` opcode:  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定したオブジェクトに関連付けられた特定の仮想メソッドを実装しているネイティブ コードへのアンマネージ ポインター (<see langword="native int" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn `method`|オブジェクトの仮想メソッドへのポインター プッシュ`method`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  メソッドにオブジェクト参照がスタックし、エントリ ポイントのアドレスからポップされます。 (指定したメタデータ トークンによって`method`) が検索されます。  
  
3.  ポインター`method`がスタックにプッシュされます。  
  
 結果のアンマネージ ポインターをによってスタックにプッシュ、`ldvirtftn`命令を使用して呼び出すことができます、<xref:System.Reflection.Emit.OpCodes.Calli>命令マネージ メソッド (またはアンマネージ コードから移行するスタブ) を参照する場合。  
  
 アンマネージ ポインター、CLR 呼び出し規約を使用したネイティブ コードを指します。 このメソッドのポインターは、コールバック ルーチンとしてアンマネージ ネイティブ コードに渡すことはできません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ldvirtftn` opcode:  
  
-   ILGenerator.Emit (オペコード、MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードの保護領域を終了し、制御を特定のターゲット命令に無条件で転送します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DD < `int32` >|ままにしてください。 `target`|コードの保護領域を終了します。|  
  
 この命令に指定された履歴の移行の動作はありません。  
  
 `leave`命令は無条件で現在の命令を次の命令の先頭から 4 バイト符号付きオフセットとして表される、特定のターゲット命令に制御を転送します。  
  
 `leave`命令と似ています、`br`が命令を使用して、終了、 `try`、 `filter`、または`catch`ブロック内のコントロールを転送するこのようなブロックで通常の分岐命令を使用のみできますです。 `leave`命令を評価スタックを空にして、適切なを囲むにより`finally`ブロックが実行されます。  
  
 使用することはできません、`leave`を終了する命令を`finally`ブロックします。 使用する catch ブロック内から有効な例外ハンドラーのコード生成を容易にする、 `leave` 、関連付けられている任意の命令に制御を転送命令`try`ブロックします。  
  
 最初の制御を転送できますのみ命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `leave` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードの保護領域を終了し、制御をターゲット命令に無条件で転送します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DE < `int8` >|leave.s `target`|短い形式のコードの保護領域を終了します。|  
  
 この命令に指定された履歴の移行の動作はありません。  
  
 `leave.s`命令は無条件で現在の命令を次の命令の先頭から 1 バイトの符号付きオフセットとして表され、渡されたターゲット命令に制御を転送します。  
  
 `leave.s`命令と似ています、`br`が命令を使用して、終了、 `try`、 `filter`、または`catch`ブロック内のコントロールを転送するこのようなブロックで通常の分岐命令を使用のみできますです。 `leave.s`命令を評価スタックを空にして、適切なを囲むにより`finally`ブロックが実行されます。  
  
 使用することはできません、`leave.s`を終了する命令を`finally`ブロックします。 使用する catch ブロック内から有効な例外ハンドラーのコード生成を容易にする、 `leave.s` 、関連付けられている任意の命令に制御を転送命令`try`ブロックします。  
  
 最初の制御を転送できますのみ命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `leave.s` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル動的メモリ プールから特定のバイト数を割り当て、最初に割り当てたバイトのアドレス (遷移ポインター、<see langword="*" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|ローカル ヒープの領域を割り当てます。|  
  
 履歴の移行動作を順番には。  
  
1.  割り当てるバイト数は、スタックにプッシュされます。  
  
2.  バイト数が、スタックからポップされます。サイズに対応するメモリ容量は、ローカルのヒープから割り当てられます。  
  
3.  割り当てられたメモリの最初のバイトへのポインターがスタックにプッシュされます。  
  
 `localloc`命令を割り当てます`size`(型`natural unsigned int`) ローカル動的メモリからバイトをプールし、アドレスを返します (一時ポインター、型`*`)、最初に割り当てたバイトの。 メモリ ブロックのメソッドの初期化フラグが場合にのみ、0 に初期化されますが返される`true`します。 現在のメソッドが実行される場合、 <xref:System.Reflection.Emit.OpCodes.Ret>、ローカル メモリ プールを再利用可能になります。  
  
 結果として得られるアドレスが配置されるように、任意のプリミティブ データ型の格納が使用できます、`stind`命令 (など<xref:System.Reflection.Emit.OpCodes.Stind_I4>) を使用して読み込まれると、`ldind`命令 (など<xref:System.Reflection.Emit.OpCodes.Ldind_I4>)。  
  
 `localloc`命令が内で発生することはできません、 `filter`、 `catch`、 `finally`、または`fault`ブロックします。  
  
 <xref:System.StackOverflowException> 要求を処理する十分なメモリがある場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `localloc` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の型のインスタンスへの型指定された参照を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany `class`|プッシュ型の型指定された参照`class`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  ポインターのデータがスタックにプッシュされます。  
  
2.  ポインターがポップされ、型の型指定された参照に変換`class`します。  
  
3.  型指定された参照は、スタックにプッシュされます。  
  
 `mkrefany`命令には、動的に型指定された参照を渡すことがサポートしています。 ポインター型でなければなりません`&`、 `*`、または`native int`のデータの有効なアドレスを保持しているとします。 `Class` ポインターによって参照されるデータの種類を記述するクラスのトークン。 `Mkrefany` 型指定された参照、ポインターと、型の非透過の記述子を提供する、スタックにプッシュ`class`します。  
  
 パラメーターとして型指定された参照を必要とするメソッドに渡す型指定された参照時に許可されている唯一の有効な操作です。 呼び出し先を使用できますし、<xref:System.Reflection.Emit.OpCodes.Refanytype>と<xref:System.Reflection.Emit.OpCodes.Refanyval>型 (クラス) とアドレスをそれぞれ取得する手順。  
  
 <xref:System.TypeLoadException> 場合にスローされる`class`が見つかりません。 これは、通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブ コードに変換された場合に検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `mkrefany` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を乗算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|5A|mul|スタック上の 2 つの値を乗算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value1`が乗算`value2`します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `mul`命令を乗算します`value1`によって`value2`し、結果をスタックにプッシュします。 整数演算では、オーバーフローについては、上位のビットが自動的に切り捨てられます。  
  
 参照してください<xref:System.Reflection.Emit.OpCodes.Mul_Ovf>整数に固有のオーバーフロー処理での操作を乗算します。  
  
 浮動小数点型の 0 * 無限大 NaN を = です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `mul` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの整数値を乗算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|オーバーフロー チェックを使用してスタック上の 2 つの整数値を乗算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value1`が乗算`value2`、オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `mul.ovf`命令は、整数を乗算します。`value1`整数で`value2`し、結果をスタックにプッシュします。 結果は結果の型に適合しない場合、例外がスローされます。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `mul.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なし整数値を乗算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|オーバーフロー チェックを使用してスタック上の 2 つの符号なしの値を乗算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value1`が乗算`value2`、オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `mul.ovf.un`命令が符号なし整数を乗算します`value1`符号なし整数で`value2`し、結果をスタックにプッシュします。 結果は結果の型に適合しない場合、例外がスローされます。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `mul.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値を無効にし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|65|neg|スタックの一番上に現在の値を否定します。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  値がスタックからポップし、否定します。  
  
3.  結果は、スタックにプッシュされます。  
  
 `neg`命令の値を無効にし、結果をスタックにプッシュします。 戻り値の型は、オペランドの型と同じです。  
  
 整数値の否定は standard 2 の補数の否定。 具体的には、否定されます (これは、正の値に対応する必要はありません) 最も負の数値には、負の数が生成されます。 このオーバーフローを検出するために、<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>命令代わりに (つまり、0 から減算)。  
  
 否定の浮動小数点数と、オーバーフローが発生することはできません、および否定の NaN と NaN が返されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `neg` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>特定の型の要素を持つ、インデックス番号が 0 から始まる新しい 1 次元配列へのオブジェクト参照を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr `etype`|型の要素を持つ新しい配列を作成`etype`です。|  
  
 履歴の移行動作を順番には。  
  
1.  配列内の要素の数は、スタックにプッシュされます。  
  
2.  要素の数がスタックからポップされ、配列が作成されます。  
  
3.  新しい配列にオブジェクト参照は、スタックにプッシュされます。  
  
 `newarr`命令は、プッシュ オブジェクト参照 (型`O`) 型の要素を持つは、新しい、0 から始まる 1 次元配列に`etype`(型を記述するメタデータ トークン)。 として新しい配列の要素の数を指定する必要があります、`native int`します。 有効な配列インデックスの範囲は、0 から最大の要素から 1 を引いた数にします。  
  
 配列の要素には、値型を含む、任意の型を使用できます。  
  
 数値の 0 から始まる 1 次元の配列は、適切な値の型を参照するメタデータ トークンを使用して作成されます (<xref:System.Int32>など)。 配列の要素は、適切な型の 0 に初期化されます。  
  
 始まる 1 次元配列と多次元配列を使用して作成<xref:System.Reflection.Emit.OpCodes.Newobj>なく`newarr`します。 メソッドを使用して作成より一般的に、 <xref:System.Array> in .NET Framework クラス。  
  
 <xref:System.OutOfMemoryException> 要求に対応する十分なメモリがある場合にスローされます。  
  
 <xref:System.OverflowException> 場合にスローされる`numElems`が 0 未満です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `newarr` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しいオブジェクトまたは値型の新しいインスタンスを作成し、オブジェクト参照 (<see langword="O" /> 型) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj `ctor`|初期化されていないオブジェクトまたは値型を割り当て、コンス トラクター メソッドを呼び出して`ctor`します。|  
  
 履歴の移行動作を順番には。  
  
1.  引数`arg1`を通じて`argn`シーケンスで、スタックにプッシュされます。  
  
2.  引数`argn`を通じて`arg1`スタックからポップされに渡される`ctor`オブジェクトを作成します。  
  
3.  新しいオブジェクトへの参照は、スタックにプッシュされます。  
  
 `newobj`命令は、新しいオブジェクトまたは値型の新しいインスタンスを作成します。 `Ctor` メタデータ トークンは、(、`methodref`または`methoddef`コンス トラクターをマークする必要があります)、クラスと名前を呼び出すコンス トラクターのシグネチャを示します。  
  
 `newobj`に関連付けられているクラスの新しいインスタンスを割り当てる命令`ctor`し (適切な型) の 0 または適切な null 参照には、新しいインスタンスのすべてのフィールドを初期化します。 コンス トラクターを呼び出して`ctor`新しく作成されたインスタンスと指定した引数を使用します。 ここがオブジェクト参照を初期化するコンス トラクターが呼び出された後 (型`O`) がスタックにプッシュされます。  
  
 コンス トラクターの観点から初期化されていないオブジェクトは引数が 0 であり、newobj に渡されるその他の引数を順番に従ってください。  
  
 使用してすべての 0 から始まる 1 次元配列が作成された<xref:System.Reflection.Emit.OpCodes.Newarr>ではなく、`newobj`します。 その一方で、その他のすべての配列 (1 つの次元数よりも、または 1 次元が 0 以上) を使用して作成`newobj`です。  
  
 値の型は、通常を使用しないで作成`newobj`です。 引数またはを使用して、ローカル変数として通常割り当てられる`newarr`(の 0 から始まる 1 次元配列の場合) またはオブジェクトのフィールドとして。 使用して初期化される割り当てられると、<xref:System.Reflection.Emit.OpCodes.Initobj>します。 ただし、`newobj`しと、ローカルに格納されている、引数として渡すことができると、スタックに値型の新しいインスタンスを作成する命令を使用できます。  
  
 <xref:System.OutOfMemoryException> 要求に対応する十分なメモリがある場合にスローされます。  
  
 <xref:System.MissingMethodException> コンス トラクター メソッドの場合にスローされる`ctor`指定された名前を持つクラスと署名で見つかりませんでした。 これは、通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなく、ネイティブ コードに変換された場合に検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `newobj` opcode:  
  
-   ILGenerator.Emit (オペコード、ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オペコードがパッチされている場合は、領域を補完します。 循環参照の処理を利用することはできますが、意味のある演算は実行されません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|00|nop|ビヘイビアーを使わない操作を実行します。|  
  
 この命令に対して定義されている、スタックの遷移の動作はありません。  
  
 `nop`操作は何も行いません。 オペコードがパッチされている場合は、スペースを入力するものです。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `nop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある整数値のビットごとの補数を計算し、結果を同じ型として評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|66|not|値のビットごとの補数を計算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value` スタックにプッシュされます。  
  
2.  `value` ポップされ、スタックのビットごとの補数を計算します。  
  
3.  結果は、スタックにプッシュされます。  
  
 `not`命令は整数値のビットごとの補数を計算し、結果をスタックにプッシュします。 戻り値の型は、オペランドの型と同じです。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `not` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタックの一番上にある 2 つの整数値のビットごとの補数を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|60|または|ビットごとの計算または 2 つの整数値の整数を返します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`ビットごとの OR、スタックからポップされます。 計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `or`命令が結果をスタックにプッシュ、スタックの一番上の 2 つの値のビットごとの OR を計算します。  
  
 `Or` 整数に固有の操作です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `or` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にある値を削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|26|pop|スタックから上位の値が表示されます。|  
  
 履歴の移行動作を順番には。  
  
1.  最上位の値は、スタックからポップされます。  
  
 `pop`命令がスタックから最上位の要素を削除します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `pop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これは予約済みの命令です。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以降の配列アドレス演算で、実行時に型チェックを実行しないこと、および変更可能性が制限されたマネージド ポインターを返すことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 1E|読み取り専用です。|以降の配列アドレス演算が実行時に、型チェックを実行しないことと、制限付きの可変性をマネージ ポインターを返すことを指定します。|  
  
 このプレフィックスがすぐ前に表示できるのみ、`ldelema`命令と呼び出しを特殊な`Address`アレイ上のメソッド。 後続の操作に与える影響は、2 つあります。  
  
1.  実行時に、チェックの種類の操作は実行されません。 暗黙的な型のチェックは通常、`ldelema`と`stelem`参照に使用する手順については、配列を入力します。 ないため、値クラスの実行時の型チェックのため`readonly`no-op をその場合は。  
  
2.  検証ツールは、制限付きの可変性のマネージ ポインターとしてアドレスの操作の結果を扱います。  
  
 ポインターは宣言型の値を変更できるかどうかを制御するための変更可能性が制限されていると言います。 ポインターは読み取り専用のパブリック フィールドまたは場所の値を更新するメソッドを公開しない値クラス、(そのため、プレフィックスの名前)。 具体的には、プリミティブ型 (System.Int32 など) を表すクラスは、ミューテーターを公開しないと、そのため、読み取り専用です。  
  
 この方法で制限されたマネージ ポインターは、次の方法でのみ使用できます。  
  
-   として、`object`のパラメーター、 `ldfld`、 `ldflda`、 `stfld`、 `call`、または`constrained callvirt`指示します。  
  
-   として、`pointer`パラメーターを`ldobj`命令またはのいずれかに、`ldind`指示します。  
  
-   として、`source`パラメーターを`cpobj`命令。  
  
 その他の操作が許可されていないなど、 `stobj`、 `initobj`、または`mkrefany`操作、またはのいずれか、`stind`手順。  
  
 目的、`readonly`プレフィックスは、汎用的なコードで配列から要素をフェッチするときに、型チェックを回避するためにします。 たとえば、式`arr[i].m()`が配列の要素型である場合、`arr`メソッドとインターフェイスが存在するが制約されているジェネリック型は、 `m`、次の MSIL にコンパイルすることがあります。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 なし、`readonly`プレフィックス、`ldelema`命令は、大文字と小文字で型チェックを実行する場所です。 0 が参照型。 だけでなく、効率的で、この種類のチェックはありませんが、意味的に正しくないです。 型チェック`ldelema`strong すぎますが、まったく同じです。 配列には、型のサブクラスが保持されている場合です。 0、上記のコードには、型チェックは失敗します。  
  
 配列の要素のアドレスは、フェッチされた、要素自体ではなくのハンドルを確保するために`arr[i]`両方に対して機能が値型と参照型の場合と、そのために渡されることができます、`constrained callvirt`命令。  
  
 一般にセーフ配列には、参照型の要素が保持されている場合は、実行時チェックをスキップすることがなります。 安全のためには、このポインターから配列への変更が行われていないことを確認する必要があります。 検証規則では、これを確認します。 厳密に言うと、値の型は読み取り専用が値型の型の安全性の問題はありません、制限されたマネージ ポインターをインスタンス メソッドの呼び出しのオブジェクトとして渡すことができます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `readonly` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型指定された参照に埋め込まれている型トークンを取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|型指定された参照に格納されている型トークンをプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値型の参照は、スタックにプッシュされます。  
  
2.  型指定された参照がスタックからポップし、その対応する型のトークンを取得します。  
  
3.  型トークンは、スタックにプッシュされます。  
  
 型指定された参照には、型のトークンとオブジェクトのインスタンスにアドレスが含まれています。  
  
 `refanytype`命令は、型指定された参照に埋め込まれている型トークンを取得します。 参照してください、<xref:System.Reflection.Emit.OpCodes.Mkrefany>命令の詳細については型参照を指定します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `refanytype` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型指定された参照に埋め込まれているアドレス (<see langword="&amp;" /> 型) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval `type`|型指定された参照に格納されているアドレスにプッシュします。|  
  
 履歴の移行動作を順番には。  
  
1.  値型の参照は、スタックにプッシュされます。  
  
2.  型指定された参照がスタックからポップし、対応するアドレスを取得します。  
  
3.  アドレスがスタックにプッシュされます。  
  
 型指定された参照には、型のトークンとオブジェクトのインスタンスにアドレスが含まれています。  
  
 `refanyval`命令に埋め込まれているアドレスを取得する、型指定された参照。 スタックに指定された型指定された参照に埋め込まれている型がで指定された型と一致する必要があります`type`(いずれかのメタデータ トークン、`typedef`または`typeref`)。 参照してください、<xref:System.Reflection.Emit.OpCodes.Mkrefany>関連するコンテンツの命令。  
  
 <xref:System.InvalidCastException> 場合にスローされる`type`型参照に格納されている型と同じではありません (この場合、`type`にクラスが提供されます、<xref:System.Reflection.Emit.OpCodes.Mkrefany>構築命令が型指定された参照と呼ばれます)。  
  
 <xref:System.TypeLoadException> 場合にスローされる`type`が見つかりません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `refanyval` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの値を除算し、剰余を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|5D|rem|除算の剰余プッシュ`value1`によって`value2`スタックにします。|  
  
  
 履歴の移行動作を順番には。  
  
1.  A`value1`がスタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックとの残りの部分からポップされます。 `value1` `div` `value2`計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `result` = `value1` `rem` `value2` 次の条件を満たします。  
  
 `result` = `value1` - `value2` `×` (`value1` `div` `value2`)、および。  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124;、記号 (`result`) 記号の = (`value1`) ここで、`div`はゼロに向かって切り捨て除算命令。  
  
 場合`value2`ゼロまたは`value1`無限大 NaN になります。 場合`value2`無限大、結果は`value1`(の否定`-infinity`)。  
  
 整数演算でスロー<xref:System.DivideByZeroException>場合`value2`は 0 です。  
  
 Intel ベース プラットフォームに注意してください、<xref:System.OverflowException>を計算するときにスローされる (minint `rem` -1)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `rem` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>2 つの符号なしの値を除算し、剰余を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|5E|rem.un|符号なしに除算した剰余をプッシュ`value1`符号なしで`value2`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックとの残りの部分からポップされます。 `value1` `div` `value2`計算します。  
  
4.  結果は、スタックにプッシュされます。  
  
 `result` = `value1` `rem.un` `value2` 次の条件を満たします。  
  
 `result` = `value1` - `value2` x (`value1` `div.un` `value2`)、および。  
  
 0 = `result`  < `value2`ここで、`div.un`は符号なしの除算命令。  
  
 `rem.un`命令計算`result`し、スタックにプッシュします。 `Rem.un` 符号なし整数として引数を処理中に<xref:System.Reflection.Emit.OpCodes.Rem>と符号付き整数を扱います。  
  
 `Rem.un` 浮動小数点数に対して指定されていません。  
  
 整数演算でスロー<xref:System.DivideByZeroException>場合`value2`は 0 です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `rem.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のメソッドから戻り、呼び出し先の評価スタックから呼び出し元の評価スタックに戻り値 (存在する場合) をプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|2A|ret|値を返す可能性があるメソッドから返します。|  
  
 履歴の移行動作を順番には。  
  
1.  戻り値は、呼び出し先の評価スタックからポップされます。  
  
2.  手順 1. で取得される戻り値は、呼び出し元の評価スタックにプッシュされます。  
  
 戻り値が呼び出し先の評価スタックに存在しない場合は、値はありませんが (ありませんスタック遷移の動作、呼び出し先または呼び出し元のいずれかのメソッド) に返されます。  
  
 戻り値の型、存在する場合の現在のメソッドを決定します、スタックの一番上と、現在のメソッドを呼び出したメソッドのスタックにコピーしたからフェッチする値の型。 現在のメソッドの評価スタックは、返される値を除く空にする必要があります。  
  
 `ret`命令は、転送の制御を使用することはできません、`try`、 `filter`、 `catch`、または`finally`ブロックします。 内から、`try`または`catch`を使用して、<xref:System.Reflection.Emit.OpCodes.Leave>の宛先の命令を`ret`それを囲むすべての例外ブロックの外側にある命令。 `filter`と`finally`ブロックは、論理的に一部の例外処理と、コードが埋め込まれているメソッドではなく、正しく生成された Microsoft Intermediate Language (MSIL) の手順ではメソッド内からの戻り値は実行しないで、`filter`または`finally`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `ret` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の例外を再スローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 1A|再スローします。|現在の例外を再スローします。|  
  
 この命令の履歴の移行動作が定義されていません。  
  
 `rethrow`命令がの本文内でのみ許可されている、`catch`ハンドラー。 このハンドラーによってキャッチされた例外と同じ例外がスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `rethrow` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を指定したビット数だけ、0 を使用して左にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|62|shl|整数が (0 でシフト) 左にシフトします。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  シフトするビットの量は、スタックにプッシュされます。  
  
3.  シフトするビット数と、値がスタックからポップされます。値は指定されたビット数だけ左にシフトします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `shl`命令シフト値 (型`int32`、`int64`または`native int`) 指定されたビット数だけ左します。 ビット数は、型の値を`int32`または`native int`します。 シフトするビット数が指定された値の幅 (ビット単位) で以上の場合、戻り値は指定されません。  
  
 `Shl` 0 のビットをシフトごとの最下位の位置に挿入します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `shl` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>整数値を指定したビット数だけ、符号を付けて右にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|63|shr|整数を (記号でシフト) 右にシフトします。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  シフトするビットの量は、スタックにプッシュされます。  
  
3.  シフトするビット数と、値がスタックからポップされます。値は指定されたビット数だけ右にシフトします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `shr.un`命令シフト値 (型`int32`、`int64`または`native int`) 指定されたビット数だけ右。 ビット数は、型の値を`int32`または`native int`します。 シフトするビット数が指定された値の幅 (ビット単位) で以上の場合、戻り値は指定されません。  
  
 `Shr` 上位の元の値の符号を保持し、シフトごとのビットを複製、`result`します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `shr` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>符号なし整数値を指定したビット数だけ、0 を使用して右にシフトし、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|64|shr.un|整数値を (0 でシフト) 右にシフトします。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  シフトするビットの量は、スタックにプッシュされます。  
  
3.  シフトするビット数と、値がスタックからポップされます。値は指定されたビット数だけ右にシフトします。  
  
4.  結果は、スタックにプッシュされます。  
  
 `shr.un`命令シフト値 (型`int32`、`int64`または`native int`) 指定されたビット数だけ右。 ビット数は、型の値を`int32`、`int64`または`native int`します。 シフトするビット数が指定された値の幅 (ビット単位) で以上の場合、戻り値は指定されません。  
  
 `Shr.un` 0 ビットをシフトごとの最も高い位置に挿入します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `shr.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供された値型のサイズ (バイト単位) を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof `valType`|として値型のバイト単位のサイズをプッシュする`unsigned int32`します。|  
  
 履歴の移行動作を順番には。  
  
1.  バイト単位で指定された値の型のサイズ (`valType`) がスタックにプッシュされます。  
  
 `valType` メタデータ トークンである必要があります (、`typeref`または`typedef`) 値の型、参照型またはジェネリック型パラメーターを指定します。  
  
 参照型では、返されるサイズは対応する参照値のサイズは参照値によって参照されるオブジェクトに格納されたデータのサイズではなく (32 ビット システムでは 4 バイト) を入力します。 ジェネリック型パラメーターは、型またはそれを定義するメソッドの本体でのみ使用できます。 その型またはメソッドがインスタンス化される、ジェネリック型パラメーターは値型または参照型で置き換えられます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `sizeof` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 0B < `unsigned int16` >|starg `num`|最上位の値をスタックからポップし、引数スロットに格納`num`します。|  
  
 履歴の移行動作を順番には。  
  
1.  スタックの一番上に現在の値がポップされ、引数スロットに配置`num`します。  
  
 `starg`命令がスタックから値をポップし、引数スロットに配置`num`します。 値の型は、現在のメソッドのシグネチャで指定された引数の型と一致する必要があります。  
  
 可変個引数リストを取得する手順については、`starg`命令は、最初の可変部分の署名のある引数を固定にのみ使用できます。  
  
 4 バイト長より小さい整数値を保持している引数に格納を実行すると、スタックから引数が移動すると、値が切り捨てられます。 浮動小数点の値は、ネイティブのサイズから丸められます (型`F`) に関連付けられた引数のサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `starg` opcode:  
  
-   ILGenerator.Emit (オペコード、短い)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある値を指定したインデックスの引数スロットに格納します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg.s `num`|最上位の値をスタックからポップし、引数スロットに格納`num`、短縮形。|  
  
 履歴の移行動作を順番には。  
  
1.  スタックの一番上に現在の値がポップされ、引数スロットに配置`num`します。  
  
 `starg.s`命令がスタックから値をポップし、引数スロットに配置`num`します。 値の型は、現在のメソッドのシグネチャで指定された引数の型と一致する必要があります。  
  
 `starg.s`命令は、最初の 256 個の引数で使用するため、効率的なエンコーディングを提供します。  
  
 可変個引数リストを取得する手順については、`starg.s`命令は、最初の可変部分の署名のある引数を固定にのみ使用できます。  
  
 4 バイト長より小さい整数値を保持している引数に格納を実行すると、スタックから引数が移動すると、値が切り捨てられます。 浮動小数点の値は、ネイティブのサイズから丸められます (型`F`) に関連付けられた引数のサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `starg.s` opcode:  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの、命令で指定された型の値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem `typeTok`|指定したインデックス位置にある配列要素を型の値に置き換えます`typeTok`スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  インデックス値、 `index`、内の要素へ`array`がスタックにプッシュされます。  
  
3.  命令で指定された型の値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックス位置にある配列要素に配置されます。  
  
 `stelem`命令が 1 次元配列で指定された 0 から始まるインデックス位置にある要素の値を置き換えます`array`値を使用します。 値が、トークンで指定された型`typeTok`命令でします。  
  
 配列は、オブジェクト型の値によって表されるため、`O`します。 インデックスの種類は、`native int`します。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stelem` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="native int" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9B|stelem.i|指定したインデックス位置にある配列要素を置換、`native int`スタックの値。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`がスタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックス位置にある配列要素に配置されます。  
  
 `stelem.i`命令は、要素の値を置き換えます`index`1 次元配列で`array`で、`native int`値をスタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`します。 インデックスの種類は、`native int`します。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int8" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|指定したインデックス位置にある配列要素を置換、`int8`スタックの値。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`がスタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックス位置にある配列要素に配置されます。  
  
 `stelem.i1`命令は、要素の値を置き換えます`index`1 次元配列で`array`で、`int8`値をスタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`します。 インデックスの種類は、`native int`します。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int16" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|指定したインデックス位置にある配列要素を置換、`int16`スタックの値。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`がスタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックス位置にある配列要素に配置されます。  
  
 `stelem.i2`命令は、要素の値を置き換えます`index`1 次元配列で`array`で、`int16`値をスタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`します。 インデックスの種類は、`native int`します。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int32" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|指定したインデックス位置にある配列要素を置換、`int32`スタックの値。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`がスタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックス位置にある配列要素に配置されます。  
  
 `stelem.i4`命令は、要素の値を置き換えます`index`1 次元配列で`array`で、`int32`値をスタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`します。 インデックスの種類は、`native int`します。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="int64" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|指定したインデックス位置にある配列要素を置換、`int64`スタックの値。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`がスタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックス位置にある配列要素に配置されます。  
  
 `stelem.i8`命令は、要素の値を置き換えます`index`1 次元配列で`array`で、`int64`値をスタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`します。 インデックスの種類は、`native int`します。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="float32" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|指定したインデックス位置にある配列要素を置換、`float32`スタックの値。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`がスタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックス位置にある配列要素に配置されます。  
  
 `stelem.r4`命令は、要素の値を置き換えます`index`1 次元配列で`array`で、`float32`値をスタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`します。 インデックスの種類は、`native int`します。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素を評価スタックの <see langword="float64" /> 値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|指定したインデックス位置にある配列要素を置換、`float64`スタックの値。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`がスタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックス位置にある配列要素に配置されます。  
  
 `stelem.r8`命令は、要素の値を置き換えます`index`1 次元配列で`array`で、`float64`値をスタックにプッシュします。  
  
 配列はオブジェクト型の値によって表されるため、`O`します。 インデックスの種類は、`native int`します。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定のインデックス位置にある配列要素をオブジェクト参照値 (<see langword="O" /> 型) に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|指定したインデックス位置にある配列要素を置換、`ref`値 (型`O`) スタックにします。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照、配列に`array`スタックにプッシュされます。  
  
2.  内の要素への有効なインデックス`array`がスタックにプッシュされます。  
  
3.  値は、スタックにプッシュされます。  
  
4.  値、インデックス、および配列の参照がスタックからポップされます。値は、指定したインデックス位置にある配列要素に配置されます。  
  
 `stelem.ref`命令が 1 次元配列で指定したインデックス位置にある要素の値を置き換えます`array`で、 `ref` (型`O`) の値がスタックにプッシュされます。  
  
 配列はオブジェクト型の値によって表されるため、`O`します。 インデックスの種類は、`native int`します。  
  
 なお`stelem.ref`の要素の型に指定された値を暗黙的にキャスト`array`配列の要素に値を割り当てる前にします。 検証済みのコードであっても、このキャストが失敗することができます。 したがって、`stelem.ref`命令をスローできます<xref:System.InvalidCastException>します。 0 から始まる 1 次元の配列と多次元配列の場合、<xref:System.Array>クラスには、<xref:System.Array.SetValue%2A>メソッド。  
  
 <xref:System.NullReferenceException> 場合にスローされる`array`は null 参照です。  
  
 <xref:System.IndexOutOfRangeException> 場合にスローされる`index`が負の場合、またはのバインドよりも大きい`array`します。  
  
 <xref:System.ArrayTypeMismatchException> 場合にスローされる`array`必要な型の要素を保持しません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクト参照またはポインターのフィールドに格納された値を新しい値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld `field`|値の置換`field`の新しい値を持つオブジェクト。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照またはポインターがスタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値とオブジェクト参照またはポインターがスタックからポップされます。値`field`オブジェクトでは、指定された値に置き換えられます。  
  
 `stfld`命令は、オブジェクトのフィールドの値を置き換えます (型`O`) またはポインターを使用して (型`native int`、 `&`、または`*`) を指定した値。 `Field` フィールド メンバーの参照を参照するメタデータ トークンです。 `stfld`命令は、のいずれかまたは両方のプレフィックスを持つことができます<xref:System.Reflection.Emit.OpCodes.Unaligned>と<xref:System.Reflection.Emit.OpCodes.Volatile>します。  
  
 <xref:System.NullReferenceException> オブジェクト参照またはポインターが null 参照と、フィールドが静的な場合にスローされます。  
  
 <xref:System.MissingFieldException> 場合にスローされる`field`がメタデータに見つかりません。 これは、通常、Microsoft Intermediate Language (MSIL) 命令がランタイムではなく、ネイティブ コードに変換されるときにチェックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stfld` opcode:  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="native int" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DF|しない|ストア、`native int`特定のアドレスにある値。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。アドレスの値が格納されます。  
  
 `stind.i`命令ストア、`native int`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.i`命令ポインターの型に従った方法で使用します。 操作、 `stind.i` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int8" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|52|stind.i1|ストア、`int8`特定のアドレスにある値。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。アドレスの値が格納されます。  
  
 `stind.i1`命令ストア、`int8`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.i1`命令ポインターの型に従った方法で使用します。 操作、 `stind.i1` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int16" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|53|stind.i2|ストア、`int16`特定のアドレスにある値。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。アドレスの値が格納されます。  
  
 `stind.i2`命令ストア、`int16`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.2i`命令ポインターの型に従った方法で使用します。 操作、 `stind.i2` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int32" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|54|stind.i4|ストア、`int32`特定のアドレスにある値。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。アドレスの値が格納されます。  
  
 `stind.i4`命令ストア、`int32`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.i4`命令ポインターの型に従った方法で使用します。 操作、 `stind.i4` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="int64" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|55|stind.i8|ストア、`int64`特定のアドレスにある値。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。アドレスの値が格納されます。  
  
 `stind.i8`命令ストア、`int64`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.i8`命令ポインターの型に従った方法で使用します。 操作、 `stind.i` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="float32" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|56|stind.r4|ストア、`float32`特定のアドレスにある値。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。アドレスの値が格納されます。  
  
 `stind.r4`命令ストア、`float32`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.r4`命令ポインターの型に従った方法で使用します。 操作、 `stind.r4` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスに <see langword="float64" /> 型の値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|57|stind.r8|ストア、`float64`特定のアドレスにある値。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。アドレスの値が格納されます。  
  
 `stind.r8`命令ストア、`float64`指定されたアドレスにある値 (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.r8`命令ポインターの型に従った方法で使用します。 操作、 `stind.r8` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>提供されたアドレスにオブジェクト参照値を格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|51|stind.ref|オブジェクト参照を格納 (型`O`)、特定のアドレスにある値。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  値は、スタックにプッシュされます。  
  
3.  値と、アドレスがスタックからポップされます。アドレスの値が格納されます。  
  
 `stind.ref`命令に指定されたアドレスにオブジェクト参照値が格納されます (型`native int`、 `*`、または`&`)。  
  
 タイプ セーフな演算では、する必要があります、`stind.ref`命令ポインターの型に従った方法で使用します。 操作、 `stind.ref` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.NullReferenceException> 場合にスローされる`addr`命令のサフィックスが含まれる引数の型が自然に配置できません。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、指定したインデックスのローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 0E < `unsigned int16` >|stloc `index`|値をスタックからポップし、ローカル変数に格納`index`します。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップされ、ローカル変数に格納`index`します。  
  
 `stloc`命令が評価スタックの最上位の値をポップし、ローカル変数の数に移動します`index`番号は 0 以降のローカル変数が、します。 値の型は、ローカルの現在のメソッドのシグネチャで指定されているローカル変数の型と一致する必要があります。  
  
 4 バイト長より小さい整数値を保持しているローカルに保存すると、ローカル変数をスタックから移動する際、値が切り捨てられます。 浮動小数点の値は、ネイティブのサイズから丸められます (型`F`) に関連付けられた引数のサイズにします。  
  
 正しい Microsoft Intermediate Language (MSIL) の手順を必要とする`index`ローカルの有効なインデックスがあります。 `stloc`命令、`index`包括的な 0 ~ 65534 の範囲である必要があります (具体的には、65535 は無効です)。 65535 を除くための実践的: 可能性の高い実装は、ローカルのインデックスと特定のメソッドのローカル変数の合計数の両方を追跡するために、2 バイトの整数を使用します。 65535 のインデックスが行われた有効な場合、そのような方法でローカル変数の数を追跡する幅の整数が必要です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stloc` opcode:  
  
-   ILGenerator.Emit (オペコード、LocalBuilder)  
  
-   ILGenerator.Emit (オペコード、短い)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 0 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0A|stloc.0|0 のローカル変数には、スタックから値をポップします。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップし、インデックスが 0 でローカル変数に格納します。  
  
 `stloc.0`命令が評価スタックの最上位の値をポップし、インデックスが 0 で、ローカル変数に移動します。 値の型は、ローカルの現在のメソッドのシグネチャで指定されているローカル変数の型と一致する必要があります。  
  
 `stloc.0` 0 のローカル変数に値を格納するためのエンコードを特に効果的です。  
  
 4 バイト長より小さい整数値を保持しているローカルに保存すると、ローカル変数をスタックから移動する際、値が切り捨てられます。 浮動小数点の値は、ネイティブのサイズから丸められます (型`F`) に関連付けられた引数のサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 1 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0B|stloc.1|1 のローカル変数には、スタックから値をポップします。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップし、インデックスが 1 でローカル変数に格納します。  
  
 `stloc.1`命令が評価スタックの最上位の値をポップし、インデックスが 1 でローカル変数に移動します。 値の型は、ローカルの現在のメソッドのシグネチャで指定されているローカル変数の型と一致する必要があります。  
  
 `stloc.1` 1 のローカル変数に値を格納するためのエンコーディングを特に効果的です。  
  
 4 バイト長より小さい整数値を保持しているローカルに保存すると、ローカル変数をスタックから移動する際、値が切り捨てられます。 浮動小数点の値は、ネイティブのサイズから丸められます (型`F`) に関連付けられた引数のサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 2 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0C|stloc.2|ローカル変数 2 にスタックから値をポップします。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップし、2 によってインデックス付けされたローカル変数に格納します。  
  
 `stloc.2`命令が評価スタックの最上位の値をポップし、インデックスが 2 でローカル変数に移動します。 値の型は、ローカルの現在のメソッドのシグネチャで指定されているローカル変数の型と一致する必要があります。  
  
 `stloc.2` 2 のローカル変数に値を格納するためのエンコーディングを特に効果的です。  
  
 4 バイト長より小さい整数値を保持しているローカルに保存すると、ローカル変数をスタックから移動する際、値が切り捨てられます。 浮動小数点の値は、ネイティブのサイズから丸められます (型`F`) に関連付けられた引数のサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、インデックス 3 のローカル変数リストに格納します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|0D|stloc.3|3 のローカル変数にスタックから値をポップします。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップし、3 によってインデックス付けされたローカル変数に格納します。  
  
 `stloc.3`命令が評価スタックの最上位の値をポップし、インデックスが 3 でローカル変数に移動します。 値の型は、ローカルの現在のメソッドのシグネチャで指定されているローカル変数の型と一致する必要があります。  
  
 `stloc.3` 3 のローカル変数に値を格納するためのエンコーディングを特に効果的です。  
  
 4 バイト長より小さい整数値を保持しているローカルに保存すると、ローカル変数をスタックから移動する際、値が切り捨てられます。 浮動小数点の値は、ネイティブのサイズから丸められます (型`F`) に関連付けられた引数のサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上から現在の値をポップし、<paramref name="index" /> のローカル変数リストに格納します (短い形式)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s `index`|値をスタックからポップし、ローカル変数に格納`index`、短縮形。|  
  
 履歴の移行動作を順番には。  
  
1.  値がスタックからポップされ、ローカル変数に格納`index`します。  
  
 `stloc.s`命令が評価スタックの最上位の値をポップし、ローカル変数の数に移動します`index`番号は 0 以降のローカル変数が、します。 値の型は、ローカルの現在のメソッドのシグネチャで指定されているローカル変数の型と一致する必要があります。  
  
 `stloc.s`命令は、0 255 までからのローカル変数の効率的なエンコーディングを提供します。  
  
 4 バイト長より小さい整数値を保持しているローカルに保存すると、ローカル変数をスタックから移動する際、値が切り捨てられます。 浮動小数点の値は、ネイティブのサイズから丸められます (型`F`) に関連付けられた引数のサイズにします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stloc.s` opcode:  
  
-   ILGenerator.Emit (オペコード、LocalBuilder)  
  
-   ILGenerator.Emit (オペコード, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックから提供されたメモリ アドレスに、指定した型の値をコピーします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj `class`|型の値を格納`class`メモリにスタックからします。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
2.  型の値型オブジェクト`class`がスタックにプッシュされます。  
  
3.  オブジェクトと、アドレスがスタックからポップされます。アドレスの値の型のオブジェクトが格納されます。  
  
 `stobj`命令アドレスで指定されたアドレスの値の型のオブジェクトのコピー (型のポインター `native int`、 `*`、または`&`)。 コピーされたバイト数で表されるクラスのサイズによって異なります`class`値型を表すメタデータ トークン。  
  
 操作、 `stobj` 、直前の命令を変更できる<xref:System.Reflection.Emit.OpCodes.Volatile>または<xref:System.Reflection.Emit.OpCodes.Unaligned>命令のプレフィックスします。  
  
 <xref:System.TypeLoadException> クラスが見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなくネイティブ コードに変換されるときに検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stobj` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>静的フィールドの値を評価スタックの値に置き換えます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld `field`|値を置き換えます`field`で指定された値。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  値がスタックからポップされに格納されている`field`します。  
  
 `stsfld`命令がスタックから値を持つ静的フィールドの値を置き換えます。 `field` 静的フィールドのメンバーを参照する必要があるメタデータ トークンです。  
  
 `stsfld`命令はによってプレフィックス指定可能性があります<xref:System.Reflection.Emit.OpCodes.Volatile>します。  
  
 <xref:System.MissingFieldException> メタデータでフィールドが見つからない場合にスローされます。 これは、通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなく、ネイティブ コードに変換する場合にチェックします。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `stsfld` opcode:  
  
-   ILGenerator.Emit (オペコード、FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある値から別の値を減算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|59|sub|新しい数値を返す別の 1 つの値を減算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value2`から減算されます`value1`します。  
  
4.  結果は、スタックにプッシュされます。  
  
 整数演算のオーバーフローが検出されない (適切なオーバーフロー処理では、次を参照してください。 <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>)。  
  
 整数の減算飽和よりも、ラップします。 例: 8 ビット整数の場合は、場所`value1`0 に設定されていると`value2`が設定を 1 に「ラップされた」の結果は 255 になります。  
  
 浮動小数点オーバーフロー `+inf` (`PositiveInfinity`) または`-inf`(`NegativeInfinity`)。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `sub` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある整数値を別の整数値から減算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|オーバーフロー チェックを別の 1 つの整数値を減算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value2`から減算されます`value1`オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 この操作が符号付き整数。浮動小数点の値を使用して<xref:System.Reflection.Emit.OpCodes.Sub>します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `sub.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ある符号なし整数値を別の符号なし整数値から減算し、オーバーフロー チェックを実行し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|オーバーフロー チェックを別の 1 つの符号なし整数値を減算します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`スタックからポップされます。`value2`から減算されます`value1`オーバーフローをチェックします。  
  
4.  結果は、スタックにプッシュされます。  
  
 <xref:System.OverflowException> 結果は、結果の型では表されない場合にスローされます。  
  
 この操作が符号付き整数。浮動小数点の値を使用して<xref:System.Reflection.Emit.OpCodes.Sub>します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `sub.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ジャンプ テーブルを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|切り替え (`N`、 `t1`、 `t2`.`tN`)|いずれかにジャンプ`N`値。|  
  
 履歴の移行動作を順番には。  
  
1.  値は、スタックにプッシュされます。  
  
2.  値がスタックからポップし、実行は、値がインデックスを指定されたオフセット位置に命令する転送より小さい`N`します。  
  
 `switch`命令がジャンプ テーブルを実装します。 命令の形式は、`unsigned int32`ターゲットの数を表す`N`、その後に`N`int32 の値を指定するターゲットを移動します。 これらのターゲットは、これを次の命令の先頭からのオフセット (正または負の値) として表されます`switch`命令。  
  
 `switch`命令は、値をスタックからポップし、符号なし整数として、比較`N`します。 値の場合より小さい`N`ターゲットが 0 から番号が、値によってインデックス付けされたターゲットに転送される実行 (値 0 は最初のターゲットを受け取り、値 1 と 2 つ目のターゲットなど)。 値がより大きいか等しい場合`N`、次の命令 (フォール スルー) で実行が続行されます。  
  
 最初の制御を転送できますのみ、ターゲット命令に 1 つ以上のプレフィックス コードがある場合は、これらのプレフィックス。  
  
 転送の入出力制御`try`、 `catch`、 `filter`、および`finally`この命令によってブロックを実行することはできません。 (このような転送は厳しく制限されているし、leave 命令を代わりに使用する必要があります。)  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `switch` opcode です。 `Label[]`引数は、32 ビットのオフセットを表すラベルの配列。  
  
-   (オペコード、Label[]) ILGenerator.Emit  
  
   
  
## Examples  
 次のコード サンプルの使用を示しています、`Switch`の配列を使用してジャンプ テーブルを生成するオペコード<xref:System.Reflection.Emit.Label>します。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実際の呼び出し命令が実行される前に、現在のメソッドのスタック フレームが削除されるように、後置のメソッド呼び出し命令を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 14|末尾。|後続の呼び出しでは、現在のメソッドを終了します。|  
  
 この命令に対して定義されている履歴の移行の動作はありません。  
  
 `tail`プリフィックス命令の直前にする必要があります、 <xref:System.Reflection.Emit.OpCodes.Call>、 <xref:System.Reflection.Emit.OpCodes.Calli>、または<xref:System.Reflection.Emit.OpCodes.Callvirt>命令。 これは、呼び出し命令が実行される前に、現在のメソッドのスタック フレームを削除するかを示します。 また、次の呼び出しから返される値も、現在のメソッドによって返される値と、メソッド間のジャンプに呼び出しを変換したがってできることを意味します。  
  
 スタックは、次の呼び出しによって転送される引数を除く空にする必要があります。 Ret 呼び出し命令を次の命令があります。したがって、唯一の有効なコード シーケンスは`tail. call`(または`calli`または`callvirt`)。 正しい Microsoft Intermediate Language (MSIL) 命令に分岐する必要がありますいない、`call`が、命令に分岐するそれに続く可能性があります<xref:System.Reflection.Emit.OpCodes.Ret>します。  
  
 コントロールに転送される信頼されていないコードから信頼されたコードは、id のセキュリティをコードから、現在のフレームを破棄できません。 発生する可能性がそのための .NET Framework セキュリティ チェックが、`tail`は無視され、標準のまま<xref:System.Reflection.Emit.OpCodes.Call>命令。 同様の順序、呼び出しが返された後に発生する同期された領域を終了できるようにする、`tail`同期済みとマークされているメソッドの終了に使用する場合、プレフィックスは無視されます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `tail` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Opcode オブジェクトのインスタンス。</param>
        <summary>提供されたオペコードが 1 バイト引数をとる場合は、true または false を返します。</summary>
        <returns><see langword="True" /> または <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、どの MSIL オペレーション コードでは、"short"、使用する形式が最適化されたコードで使用できます。  
  
 `TakesSingleByteArgument` 返します`true`場合、<xref:System.Reflection.Emit.OpCode>インスタンスは、次の場合、1 バイト引数を取得します。  
  
-   オペコード サイズのバイトのアドレスにする分岐命令を実行します (たとえば、<xref:System.Reflection.Emit.OpCodes.Br_S>と<xref:System.Reflection.Emit.OpCodes.Bgt_S>)。  
  
-   オペコードがバイト値をスタックにプッシュ (たとえば、 <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>)。  
  
-   オペコード参照変数または引数のバイト サイズ「省略形」を使用して (たとえば、<xref:System.Reflection.Emit.OpCodes.Ldloc_S>と<xref:System.Reflection.Emit.OpCodes.Stloc_S>)。  
  
 それ以外の場合は、`false` を返します。  
  
 次の例の使用を示します`TakesSingleByteArgument`に反映して、`OpCodes`クラスとテストを参照してくださいかどうか各`OpCode`フィールドは 1 バイト引数になります。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックにある例外オブジェクトをスローします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|7A|throw|例外をスローします。|  
  
 履歴の移行動作を順番には。  
  
1.  (例外) へのオブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照はスタックとスローされる例外からポップされます。  
  
 `throw`命令は、例外オブジェクトをスローします。 (型`O`) 現在のスタックにします。  
  
 <xref:System.NullReferenceException> オブジェクト参照が null 参照である場合にスローされます。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `throw` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にあるアドレスが、直後の <see langword="ldind" />、<see langword="stind" />、<see langword="ldfld" />、<see langword="stfld" />、<see langword="ldobj" />、<see langword="stobj" />、<see langword="initblk" /> または <see langword="cpblk" /> の各命令の通常サイズに合わせて配置されていない可能性があることを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 12 < `unsigned int8` >|アラインされていません。 `alignment`|後続のポインター命令が配置済みである可能性を示します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
 `Unaligned` 指定します、アドレス (アンマネージ ポインター、 `native int`) スタックに適さないことがあります、直後の自然なサイズに`ldind`、 `stind`、 `ldfld`、 `stfld`、 `ldobj`、 `stobj`、`initblk`、または`cpblk`命令。 つまり、用、<xref:System.Reflection.Emit.OpCodes.Ldind_I4>命令のアドレスのアラインメントは 4 バイト境界にできない可能性があります。 `initblk`と`cpblk`の既定の配置が依存しているアーキテクチャ (32 ビット Cpu では、64 ビット Cpu での 8 バイトでは 4 バイト)。 32 ビット ワード サイズには、出力を制限しないコード ジェネレーターを使用する必要があります`unaligned`不明の場合、配置はコンパイル時に 8 バイトにします。  
  
 配置の値は、1、2、または 4 および生成されたコードでは、アドレスは、バイト、2 バイト、またはクアッド バイトでアライン、それぞれのことを想定してください手段である必要があります。 その一時的なものに注意してくださいポインター (型`*`) は常に揃えて配置されます。  
  
 配置中に、`cpblk`命令は 2 つの数値 (1 つのソース) と、変換先の 1 つ、論理的には存在しません顕著な影響はパフォーマンスにだけ少ない数を指定します。  
  
 `unaligned`と`volatile`プレフィックスは任意の順序で組み合わせることができます。 これらの直前にする必要があります、 `ldind`、 `stind`、 `ldfld`、 `stfld`、 `ldobj`、 `stobj`、 `initblk`、または`cpblk`命令。 のみ、<xref:System.Reflection.Emit.OpCodes.Volatile>のプレフィックスは許可されて、<xref:System.Reflection.Emit.OpCodes.Ldsfld>と<xref:System.Reflection.Emit.OpCodes.Stsfld>指示します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `unaligned` opcode:  
  
-   ILGenerator.Emit (オペコード、ラベル)  
  
-   ILGenerator.Emit (オペコード, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>値型のボックス化変換された形式をボックス化が解除された形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|79 < `T` >|ボックス化解除します。 `valType`|値型のデータを抽出します`obj`、その表現をボックス化します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照は、スタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップされ、値型のポインターをボックス化解除します。  
  
3.  値型のポインターがスタックにプッシュされます。  
  
 値型では、共通言語基盤 (CLI) 内に 2 つの個別の表現があります。  
  
-   値の型が別のオブジェクトに埋め込まれたときに使用される '生' のフォームです。  
  
-   場所、値の型のデータにラップされます (手書き) オブジェクトのため、個別のエンティティとして存在する可能性が 'ボックス化' の形式。  
  
 `unbox`命令がオブジェクト参照に変換します (型`O`)、値型のポインターに値の型の表現をボックス化 (マネージ ポインター型`&`)、そのフォームをボックス化解除します。 指定された値の型 (`valType`) はボックス化されたオブジェクト内に含まれる値の型の種類を示すメタデータ トークンです。  
  
 異なり<xref:System.Reflection.Emit.OpCodes.Box>、オブジェクトで使用する値型のコピーを作成するために必要な`unbox`オブジェクトから値の型をコピーする必要はありません。 通常はボックス化されたオブジェクト内に存在する値の型のアドレスを単に計算します。  
  
 <xref:System.InvalidCastException> オブジェクトがないとしてボックス化された場合にスローされる`valType`します。  
  
 <xref:System.NullReferenceException> オブジェクト参照が null 参照である場合にスローされます。  
  
 <xref:System.TypeLoadException> 型の値がある場合にスローされる`valType`が見つかりません。 これは、通常、Microsoft 中間言語 (MSIL) 命令が実行時ではなく、ネイティブ コードに変換された場合に検出します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `unbox` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>命令で指定された型のボックス化変換された形式を、ボックス化が解除された形式に変換します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft intermediate language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|A5 < `T` >|unbox.any `typeTok`|データの抽出`obj`、その表現をボックス化します。|  
  
 履歴の移行動作を順番には。  
  
1.  オブジェクト参照`obj`がスタックにプッシュされます。  
  
2.  オブジェクト参照がスタックからポップし、命令で指定された型にボックス化解除します。  
  
3.  結果として得られるオブジェクトの参照または値の型は、スタックにプッシュされます。  
  
 値の型のボックス化された形式に適用すると、`unbox.any`命令に含まれる値を抽出します`obj`(型の`O`) と同じため`unbox`続けて`ldobj`します。  
  
 参照型に適用すると、`unbox.any`命令と同じ効果を持つ`castclass``typeTok`します。  
  
 場合、オペランド`typeTok`がジェネリック型パラメーターでは、実行時の動作は、そのジェネリック型パラメーターに指定された型によって決定されます。  
  
 <xref:System.InvalidCastException> 場合にスローされる`obj`ボックス化された型ではありません。  
  
 <xref:System.NullReferenceException> 場合にスローされる`obj`は null 参照です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `unbox.any` opcode:  
  
-   ILGenerator.Emit (オペコード、型)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在評価スタックの一番上にあるアドレスが揮発性である可能性があるため、この位置の読み取り結果をキャッシュできないこと、またはこの位置への複数の格納を中止できないことを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|FE 13|揮発性です。|後続のポインターの参照が揮発性であることを示します。|  
  
 履歴の移行動作を順番には。  
  
1.  アドレスがスタックにプッシュされます。  
  
 `volatile`。 アドレスが揮発性のアドレスを指定します (つまり、参照できる外部実行の現在のスレッドに) と、結果の読み取りの場所をキャッシュできない、またはその場所に複数の店舗を抑制することはできません。 あるアクセス`volatile`へのアクセスを 1 つだけある影響を同じ場所の他のアクセスを個別にマークする必要があります。 揮発性の場所へのアクセスをアトミックに実行する必要はありません。  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned>と`volatile`プレフィックスは任意の順序で組み合わせることができます。 これらの直前にする必要があります、 `ldind`、 `stind`、 `ldfld`、 `stfld`、 `ldobj`、 `stobj`、 `initblk`、または`cpblk`命令。 のみ、`volatile`のプレフィックスは許可されて、<xref:System.Reflection.Emit.OpCodes.Ldsfld>と<xref:System.Reflection.Emit.OpCodes.Stsfld>指示します。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `volatile` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>評価スタックの一番上にある 2 つの値のビットごとの XOR を計算し、結果を評価スタックにプッシュします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表は、命令の 16 進数と簡単なリファレンス概要と共に、Microsoft Intermediate Language (MSIL) アセンブリの形式を示します。  
  
|形式|アセンブリの形式|説明|  
|------------|---------------------|-----------------|  
|61|xor|2 つの整数値のビットごとの XOR を計算し、整数を返します。|  
  
 履歴の移行動作を順番には。  
  
1.  `value1` スタックにプッシュされます。  
  
2.  `value2` スタックにプッシュされます。  
  
3.  `value2` `value1`がポップされますスタックとのビットごとの XOR を計算します。  
  
4.  ビットごとの XOR`value2`と`value1`がスタックにプッシュされます。  
  
 `xor`上位 2 つのビットごとの XOR、スタックの値し、スタックに結果を残します命令を計算します。  
  
 `Xor` 整数に固有の操作です。  
  
 次<xref:System.Reflection.Emit.ILGenerator.Emit%2A>メソッドのオーバー ロードを使用できる、 `xor` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
