<Type Name="CanExecuteRoutedEventHandler" FullName="System.Windows.Input.CanExecuteRoutedEventHandler">
  <TypeSignature Language="C#" Value="public delegate void CanExecuteRoutedEventHandler(object sender, CanExecuteRoutedEventArgs e);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed CanExecuteRoutedEventHandler extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.CanExecuteRoutedEventHandler" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Sub CanExecuteRoutedEventHandler(sender As Object, e As CanExecuteRoutedEventArgs)" />
  <TypeSignature Language="C++ CLI" Value="public delegate void CanExecuteRoutedEventHandler(System::Object ^ sender, CanExecuteRoutedEventArgs ^ e);" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Parameters>
    <Parameter Name="sender" Type="System.Object" />
    <Parameter Name="e" Type="System.Windows.Input.CanExecuteRoutedEventArgs" />
  </Parameters>
  <ReturnValue>
    <ReturnType>System.Void</ReturnType>
  </ReturnValue>
  <Docs>
    <param name="sender"><span data-ttu-id="b331e-101">ハンドラーを起動しているコマンドの対象。</span><span class="sxs-lookup"><span data-stu-id="b331e-101">The command target that is invoking the handler.</span></span></param>
    <param name="e"><span data-ttu-id="b331e-102">イベントのデータ。</span><span class="sxs-lookup"><span data-stu-id="b331e-102">The event data.</span></span></param>
    <summary><span data-ttu-id="b331e-103"><see cref="E:System.Windows.Input.CommandBinding.CanExecute" /> イベントを処理するメソッドを表します。</span><span class="sxs-lookup"><span data-stu-id="b331e-103">Represents the method that will handle the <see cref="E:System.Windows.Input.CommandBinding.CanExecute" /> event.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b331e-104"><xref:System.Windows.Input.CanExecuteRoutedEventHandler>イベント ソースに関連付けられたコマンドがコマンド ターゲットで実行できるかどうかを決定します。</span><span class="sxs-lookup"><span data-stu-id="b331e-104">The <xref:System.Windows.Input.CanExecuteRoutedEventHandler> determines if the command associated with the event source is able to execute on the command target.</span></span> <span data-ttu-id="b331e-105">コマンドにコマンド ソース、ターゲットを指定したかどうかに、使用するターゲットの情報を取得できます`sender`です。</span><span class="sxs-lookup"><span data-stu-id="b331e-105">If the command has a command source that specifies a target, then the target information can be obtained through `sender`.</span></span> <span data-ttu-id="b331e-106">場合、<xref:System.Windows.Input.ICommandSource.CommandTarget%2A>がキーボード フォーカスを持つ要素が、ターゲットであるし、を取得することもできます、設定されていない`sender`です。</span><span class="sxs-lookup"><span data-stu-id="b331e-106">If the <xref:System.Windows.Input.ICommandSource.CommandTarget%2A> is not set, the element with keyboard focus is the target, and can also be obtained through `sender`.</span></span>  <span data-ttu-id="b331e-107">コマンドが、ターゲットで実行できることが特定された場合、<xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=nameWithType>プロパティに設定する必要があります`true`、それ以外に設定`false`です。</span><span class="sxs-lookup"><span data-stu-id="b331e-107">If it is determined that the command can execute on the target, then the <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A?displayProperty=nameWithType> property should be set to `true`; otherwise, set it to `false`.</span></span>  
  
 <span data-ttu-id="b331e-108">コマンド、ソースとターゲットを特定のイベント データに依存する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b331e-108">You do not need to rely on event data to determine the command, source, and target.</span></span> <span data-ttu-id="b331e-109">これは、コマンドの構造は、イベント ルートの連続する潜在的な目標に同じコマンドを実行するコマンド ルーティングに広範囲に依存している場合に実行するより困難ですが、既知コマンド呼び出しのハンドラーの使用量を制限できます。</span><span class="sxs-lookup"><span data-stu-id="b331e-109">You can limit the usage of the handler to known possible command invocations, although this is more difficult to accomplish if your command structure relies extensively on the command routing to execute the same command on successive potential targets in an event route.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b331e-110">次の例は、<xref:System.Windows.Input.CanExecuteRoutedEventHandler>が設定された<xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A>に`true`です。</span><span class="sxs-lookup"><span data-stu-id="b331e-110">The following example shows a <xref:System.Windows.Input.CanExecuteRoutedEventHandler> that sets <xref:System.Windows.Input.CanExecuteRoutedEventArgs.CanExecute%2A> to `true`.</span></span>  
  
 [!code-csharp[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml.cs#commandhandlercanexecutehandler)]
 [!code-vb[commandwithhandler#CommandHandlerCanExecuteHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/commandWithHandler/VisualBasic/Window1.xaml.vb#commandhandlercanexecutehandler)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.ExecutedRoutedEventHandler" />
  </Docs>
</Type>