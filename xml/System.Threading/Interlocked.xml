<Type Name="Interlocked" FullName="System.Threading.Interlocked">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7fd6b58d4830bad8e69f870f2d493afbb5945295" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48769815" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Interlocked" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Interlocked extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Interlocked" />
  <TypeSignature Language="VB.NET" Value="Public Class Interlocked" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interlocked abstract sealed" />
  <TypeSignature Language="F#" Value="type Interlocked = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0">
      <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="4b969-101">複数のスレッドで共有される変数にアトミックの操作を提供します。</span>
      <span class="sxs-lookup">
        <span data-stu-id="4b969-101">Provides atomic operations for variables that are shared by multiple threads.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-102">このクラスのメソッドは、スレッドが他のスレッドによってアクセスできる変数を更新中にスケジューラがコンテキストを切り替えたとき、または 2 つのスレッドは別々 のプロセッサで同時に実行するときに発生する可能性があるエラーに対して保護します。</span><span class="sxs-lookup"><span data-stu-id="4b969-102">The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors.</span></span> <span data-ttu-id="4b969-103">このクラスのメンバーは、例外をスローしません。</span><span class="sxs-lookup"><span data-stu-id="4b969-103">The members of this class do not throw exceptions.</span></span>  
  
 <span data-ttu-id="4b969-104"><xref:System.Threading.Interlocked.Increment%2A>と<xref:System.Threading.Interlocked.Decrement%2A>メソッドの増減変数と、単一操作で、結果の値を格納します。</span><span class="sxs-lookup"><span data-stu-id="4b969-104">The <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A> methods increment or decrement a variable and store the resulting value in a single operation.</span></span> <span data-ttu-id="4b969-105">ほとんどのコンピューターで変数のインクリメント、次の手順を必要とする、分割不可能な操作ではありません。</span><span class="sxs-lookup"><span data-stu-id="4b969-105">On most computers, incrementing a variable is not an atomic operation, requiring the following steps:</span></span>  
  
1.  <span data-ttu-id="4b969-106">レジスタにインスタンス変数から値を読み込みます。</span><span class="sxs-lookup"><span data-stu-id="4b969-106">Load a value from an instance variable into a register.</span></span>  
  
2.  <span data-ttu-id="4b969-107">インクリメントまたはデクリメント値。</span><span class="sxs-lookup"><span data-stu-id="4b969-107">Increment or decrement the value.</span></span>  
  
3.  <span data-ttu-id="4b969-108">インスタンス変数に値を格納します。</span><span class="sxs-lookup"><span data-stu-id="4b969-108">Store the value in the instance variable.</span></span>  
  
 <span data-ttu-id="4b969-109">使用しない場合<xref:System.Threading.Interlocked.Increment%2A>と<xref:System.Threading.Interlocked.Decrement%2A>スレッドは、最初の 2 つの手順を実行後に割り込まれることができます。</span><span class="sxs-lookup"><span data-stu-id="4b969-109">If you do not use <xref:System.Threading.Interlocked.Increment%2A> and <xref:System.Threading.Interlocked.Decrement%2A>, a thread can be preempted after executing the first two steps.</span></span> <span data-ttu-id="4b969-110">別のスレッドは、すべての 3 つの手順を実行できます。</span><span class="sxs-lookup"><span data-stu-id="4b969-110">Another thread can then execute all three steps.</span></span> <span data-ttu-id="4b969-111">最初のスレッドが実行を再開し、インスタンス変数の値が上書きされますインクリメントまたはデクリメントが 2 番目のスレッドによって実行されるの効果が失われます。</span><span class="sxs-lookup"><span data-stu-id="4b969-111">When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</span></span>  
  
 <span data-ttu-id="4b969-112"><xref:System.Threading.Interlocked.Exchange%2A>メソッドが、指定された変数の値をアトミックに交換します。</span><span class="sxs-lookup"><span data-stu-id="4b969-112">The <xref:System.Threading.Interlocked.Exchange%2A> method atomically exchanges the values of the specified variables.</span></span> <span data-ttu-id="4b969-113"><xref:System.Threading.Interlocked.CompareExchange%2A>メソッドで 2 つの操作を組み合わせています。 比較の結果に基づいて、変数のいずれかの値の 2 つの値を比較すると、3 つ目を格納します。</span><span class="sxs-lookup"><span data-stu-id="4b969-113">The <xref:System.Threading.Interlocked.CompareExchange%2A> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison.</span></span> <span data-ttu-id="4b969-114">比較および交換操作はアトミック操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-114">The compare and exchange operations are performed as an atomic operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b969-115">次のコード例では、スレッド セーフであるリソースのロック機構を示します。</span><span class="sxs-lookup"><span data-stu-id="4b969-115">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="4b969-116">この型はスレッド セーフです。</span>
      <span class="sxs-lookup">
        <span data-stu-id="4b969-116">This type is thread safe.</span>
      </span>
    </threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="4b969-117">マネージド スレッド処理</span>
      <span class="sxs-lookup">
        <span data-stu-id="4b969-117">Managed Threading</span>
      </span>
    </related>
    <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
      <span data-ttu-id="4b969-118">インタロックされました。</span>
      <span class="sxs-lookup">
        <span data-stu-id="4b969-118">Interlocked</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4b969-119">分割不可能な操作として、2 つの整数を加算し、最初の整数を合計で置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-119">Adds two integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static int Add (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Add(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Add(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int -&gt; int" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-120">加算する最初の値を含む変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-120">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="4b969-121">2 つの値の合計は、<c>location1</c> に格納されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-121">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-122">
            <c>location1</c> にある整数に加算する値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-122">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-123">分割不可能な操作として、2 つの 32 ビット整数を加算し、最初の整数を合計で置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-123">Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-124">
            <paramref name="location1" /> に格納された新しい値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-124">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-125">このメソッドがラッピングによってオーバーフロー条件を処理: 場合に値`location1`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>と`value`1 に設定されて、結果は<xref:System.Int32.MinValue?displayProperty=nameWithType>場合`value`が 2 の場合、結果は (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1)。 これにします。</span><span class="sxs-lookup"><span data-stu-id="4b969-125">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int32.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int32.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int32.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="4b969-126">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="4b969-126">No exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-127">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-127">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-128">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-128">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-129">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-129">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static long Add (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Add(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Add(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Add :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Add (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-130">加算する最初の値を含む変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-130">A variable containing the first value to be added.</span>
          </span>
          <span data-ttu-id="4b969-131">2 つの値の合計は、<c>location1</c> に格納されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-131">The sum of the two values is stored in <c>location1</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-132">
            <c>location1</c> にある整数に加算する値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-132">The value to be added to the integer at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-133">分割不可能な操作として、2 つの 64 ビット整数を加算し、最初の整数を合計で置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-133">Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-134">
            <paramref name="location1" /> に格納された新しい値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-134">The new value stored at <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-135">このメソッドがラッピングによってオーバーフロー条件を処理: 場合に値`location1`は<xref:System.Int64.MaxValue?displayProperty=nameWithType>と`value`1 に設定されて、結果は<xref:System.Int64.MinValue?displayProperty=nameWithType>場合`value`が 2 の場合、結果は (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1)。 これにします。</span><span class="sxs-lookup"><span data-stu-id="4b969-135">This method handles an overflow condition by wrapping: if the value at `location1` is <xref:System.Int64.MaxValue?displayProperty=nameWithType> and `value` is 1, the result is <xref:System.Int64.MinValue?displayProperty=nameWithType>; if `value` is 2, the result is (<xref:System.Int64.MinValue?displayProperty=nameWithType> + 1); and so on.</span></span> <span data-ttu-id="4b969-136">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="4b969-136">No exception is thrown.</span></span>  
  
 <span data-ttu-id="4b969-137"><xref:System.Threading.Interlocked.Read%2A>メソッドとの 64 ビットのオーバー ロード、 <xref:System.Threading.Interlocked.Increment%2A>、 <xref:System.Threading.Interlocked.Decrement%2A>、および<xref:System.Threading.Interlocked.Add%2A>メソッドは本当に、システムでのみアトミック場所、 <xref:System.IntPtr?displayProperty=nameWithType> 64 ビット長。</span><span class="sxs-lookup"><span data-stu-id="4b969-137">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="4b969-138">他のシステムでは、これらのメソッドは尊重とデータにアクセスするが、相互にアトミックです。</span><span class="sxs-lookup"><span data-stu-id="4b969-138">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="4b969-139">したがって、32 ビット システムでスレッド セーフにするには、64 ビット値へのアクセスできる必要がありますのメンバーを<xref:System.Threading.Interlocked>クラス。</span><span class="sxs-lookup"><span data-stu-id="4b969-139">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-140">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-140">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-141">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-141">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-142">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-142">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareExchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4b969-143">2 つの値が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-143">Compares two values for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static double CompareExchange (ref double location1, double value, double comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 CompareExchange(float64&amp; location1, float64 value, float64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Double, value As Double, comparand As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double CompareExchange(double % location1, double value, double comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * double * double -&gt; double" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="comparand" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-144">値を <c>comparand</c> と比較し、場合によっては置き換える比較先。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-144">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-145">比較した結果が等しい場合に比較先の値を置き換える値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-145">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="4b969-146">
            <c>location1</c> にある値と比較する値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-146">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-147">2 つの倍精度浮動小数点数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-147">Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-148">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-148">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-149">場合`comparand`値`location1`しが等しいか、`value`に格納されて`location1`します。</span><span class="sxs-lookup"><span data-stu-id="4b969-149">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="4b969-150">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="4b969-150">Otherwise, no operation is performed.</span></span> <span data-ttu-id="4b969-151">比較および交換操作はアトミック操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-151">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="4b969-152">戻り値<xref:System.Threading.Interlocked.CompareExchange%2A>の元の値は、`location1`交換が行われているかどうかを示す、します。</span><span class="sxs-lookup"><span data-stu-id="4b969-152">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b969-153">次のコード例は、累計を実行中のスレッド セーフな方法を示します<xref:System.Double>値。</span><span class="sxs-lookup"><span data-stu-id="4b969-153">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Double> values.</span></span> <span data-ttu-id="4b969-154">2 つのスレッドの追加、一連の<xref:System.Double>スレッド セーフであるメソッドと通常の加算を使用して値を合計を比較する、スレッドが完了します。</span><span class="sxs-lookup"><span data-stu-id="4b969-154">Two threads add a series of <xref:System.Double> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="4b969-155">デュアル プロセッサ コンピューターで、合計に大きな違いがあります。</span><span class="sxs-lookup"><span data-stu-id="4b969-155">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="4b969-156">スレッド セーフな方法では、実行中の合計の初期値が保存をクリックし、<xref:System.Threading.Interlocked.CompareExchange%2A>メソッドは、古い合計新しく計算された合計の交換に使用されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-156">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="4b969-157">戻り値で実行中の合計の保存された値と等しくない場合、別のスレッドが合計を更新したそれまでは。</span><span class="sxs-lookup"><span data-stu-id="4b969-157">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="4b969-158">その場合は、実行中の合計を更新しようとするを繰り返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b969-158">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Double/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-159">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-159">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-160">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-160">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-161">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-161">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static int CompareExchange (ref int location1, int value, int comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareExchange(int32&amp; location1, int32 value, int32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareExchange(int % location1, int value, int comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int * int -&gt; int" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="comparand" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-162">値を <c>comparand</c> と比較し、場合によっては置き換える比較先。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-162">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-163">比較した結果が等しい場合に比較先の値を置き換える値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-163">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="4b969-164">
            <c>location1</c> にある値と比較する値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-164">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-165">2 つの 32 ビット符号付き整数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-165">Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-166">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-166">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-167">場合`comparand`値`location1`しが等しいか、`value`に格納されて`location1`します。</span><span class="sxs-lookup"><span data-stu-id="4b969-167">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="4b969-168">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="4b969-168">Otherwise, no operation is performed.</span></span> <span data-ttu-id="4b969-169">比較および交換操作はアトミック操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-169">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="4b969-170">戻り値<xref:System.Threading.Interlocked.CompareExchange%2A>の元の値は、`location1`交換が行われているかどうかを示す、します。</span><span class="sxs-lookup"><span data-stu-id="4b969-170">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b969-171">次のコード例では、実行中の合計を蓄積するスレッド セーフであるメソッドを示します。</span><span class="sxs-lookup"><span data-stu-id="4b969-171">The following code example demonstrates a thread-safe method that accumulates a running total.</span></span> <span data-ttu-id="4b969-172">実行中の合計の初期値を保存するをクリックし、<xref:System.Threading.Interlocked.CompareExchange%2A>メソッドは、古い合計新しく計算された合計の交換に使用されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-172">The initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="4b969-173">戻り値で実行中の合計の保存された値と等しくない場合、別のスレッドが合計を更新したそれまでは。</span><span class="sxs-lookup"><span data-stu-id="4b969-173">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="4b969-174">その場合は、実行中の合計を更新しようとするを繰り返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b969-174">In that case, the attempt to update the running total must be repeated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b969-175"><xref:System.Threading.Interlocked.Add%2A> .NET Framework のバージョン 2.0 で導入されたメソッドがスレッド セーフである整数の合計を蓄積する方が便利を提供します。</span><span class="sxs-lookup"><span data-stu-id="4b969-175">The <xref:System.Threading.Interlocked.Add%2A> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/CS/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-176">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-176">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-177">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-177">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-178">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-178">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static long CompareExchange (ref long location1, long value, long comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CompareExchange(int64&amp; location1, int64 value, int64 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Long, value As Long, comparand As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CompareExchange(long % location1, long value, long comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * int64 * int64 -&gt; int64" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="comparand" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-179">値を <c>comparand</c> と比較し、場合によっては置き換える比較先。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-179">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-180">比較した結果が等しい場合に比較先の値を置き換える値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-180">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="4b969-181">
            <c>location1</c> にある値と比較する値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-181">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-182">2 つの 64 ビット符号付き整数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-182">Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-183">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-183">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-184">場合`comparand`値`location1`しが等しいか、`value`に格納されて`location1`します。</span><span class="sxs-lookup"><span data-stu-id="4b969-184">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="4b969-185">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="4b969-185">Otherwise, no operation is performed.</span></span> <span data-ttu-id="4b969-186">比較および交換操作はアトミック操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-186">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="4b969-187">戻り値<xref:System.Threading.Interlocked.CompareExchange%2A>の元の値は、`location1`交換が行われているかどうかを示す、します。</span><span class="sxs-lookup"><span data-stu-id="4b969-187">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-188">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-188">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-189">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-189">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-190">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-190">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CompareExchange(native int&amp; location1, native int value, native int comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr CompareExchange(IntPtr % location1, IntPtr value, IntPtr comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * nativeint * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
        <Parameter Name="comparand" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-191">値を <c>comparand</c> の値と比較し、場合によっては <c>value</c> によって置き換える、比較先の <see cref="T:System.IntPtr" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-191">The destination <see cref="T:System.IntPtr" />, whose value is compared with the value of <c>comparand</c> and possibly replaced by <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-192">比較した結果が等しい場合に比較先の値を置き換える <see cref="T:System.IntPtr" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-192">The <see cref="T:System.IntPtr" /> that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="4b969-193">
            <c>location1</c> にある値と比較する <see cref="T:System.IntPtr" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-193">The <see cref="T:System.IntPtr" /> that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-194">2 つのプラットフォーム固有のハンドルまたはポインターが等しいかどうかを比較します。等しい場合は、最初の 1 つを置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-194">Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-195">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-195">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-196">場合`comparand`値`location1`しが等しいか、`value`に格納されて`location1`します。</span><span class="sxs-lookup"><span data-stu-id="4b969-196">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="4b969-197">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="4b969-197">Otherwise, no operation is performed.</span></span> <span data-ttu-id="4b969-198">比較および交換操作はアトミック操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-198">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="4b969-199">このメソッドの戻り値の元の値は、`location1`交換が行われているかどうかを示す、します。</span><span class="sxs-lookup"><span data-stu-id="4b969-199">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b969-200"><xref:System.IntPtr> プラットフォーム固有の型です。</span><span class="sxs-lookup"><span data-stu-id="4b969-200"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-201">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-201">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-202">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-202">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-203">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-203">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static object CompareExchange (ref object location1, object value, object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CompareExchange(object&amp; location1, object value, object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Object, value As Object, comparand As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CompareExchange(System::Object ^ % location1, System::Object ^ value, System::Object ^ comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * obj * obj -&gt; obj" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-204">
            <c>comparand</c> と比較し、場合によっては置き換える比較先のオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-204">The destination object that is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-205">比較した結果が等しい場合に比較先のオブジェクトを置き換えるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-205">The object that replaces the destination object if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="4b969-206">
            <c>location1</c> にあるオブジェクトと比較するオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-206">The object that is compared to the object at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-207">2 つのオブジェクトの参照が等値であるかどうかを比較します。等しい場合は、最初のオブジェクトを置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-207">Compares two objects for reference equality and, if they are equal, replaces the first object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-208">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-208">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-209">場合`comparand`内のオブジェクトと`location1`しが等しいか、`value`に格納されて`location1`します。</span><span class="sxs-lookup"><span data-stu-id="4b969-209">If `comparand` and the object in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="4b969-210">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="4b969-210">Otherwise, no operation is performed.</span></span> <span data-ttu-id="4b969-211">比較および交換操作はアトミック操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-211">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="4b969-212">戻り値<xref:System.Threading.Interlocked.CompareExchange%2A>の元の値は、`location1`交換が行われているかどうかを示す、します。</span><span class="sxs-lookup"><span data-stu-id="4b969-212">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="4b969-213">.NET Framework version 2.0 以降、<xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29>メソッドのオーバー ロードは、参照型の場合、タイプ セーフな代替手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="4b969-213">Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.CompareExchange%60%601%28%60%600%40%2C%60%600%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b969-214">オブジェクトが参照の等価比較なく<xref:System.Object.Equals%2A?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="4b969-214">The objects are compared for reference equality, rather than <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b969-215">その結果、(たとえば、整数 3) 型の値の同じ 2 つのボックス化されたインスタンス常に、等しくない場合に表示され、操作は実行されません。</span><span class="sxs-lookup"><span data-stu-id="4b969-215">As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed.</span></span> <span data-ttu-id="4b969-216">値の型は、このオーバー ロードを使用しません。</span><span class="sxs-lookup"><span data-stu-id="4b969-216">Do not use this overload with value types.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4b969-217">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-217">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-218">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-218">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-219">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-219">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange">
      <MemberSignature Language="C#" Value="public static float CompareExchange (ref float location1, float value, float comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CompareExchange(float32&amp; location1, float32 value, float32 comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange (ByRef location1 As Single, value As Single, comparand As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CompareExchange(float % location1, float value, float comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * single * single -&gt; single" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="comparand" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-220">値を <c>comparand</c> と比較し、場合によっては置き換える比較先。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-220">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-221">比較した結果が等しい場合に比較先の値を置き換える値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-221">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="4b969-222">
            <c>location1</c> にある値と比較する値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-222">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-223">2 つの単精度浮動小数点数が等しいかどうかを比較します。等しい場合は、最初の値を置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-223">Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-224">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-224">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-225">場合`comparand`値`location1`しが等しいか、`value`に格納されて`location1`します。</span><span class="sxs-lookup"><span data-stu-id="4b969-225">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="4b969-226">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="4b969-226">Otherwise, no operation is performed.</span></span> <span data-ttu-id="4b969-227">比較および交換操作はアトミック操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-227">The compare and exchange operations are performed as an atomic operation.</span></span> <span data-ttu-id="4b969-228">戻り値<xref:System.Threading.Interlocked.CompareExchange%2A>の元の値は、`location1`交換が行われているかどうかを示す、します。</span><span class="sxs-lookup"><span data-stu-id="4b969-228">The return value of <xref:System.Threading.Interlocked.CompareExchange%2A> is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b969-229">次のコード例は、累計を実行中のスレッド セーフな方法を示します<xref:System.Single>値。</span><span class="sxs-lookup"><span data-stu-id="4b969-229">The following code example demonstrates a thread-safe method that accumulates a running total of <xref:System.Single> values.</span></span> <span data-ttu-id="4b969-230">2 つのスレッドの追加、一連の<xref:System.Single>スレッド セーフであるメソッドと通常の加算を使用して値を合計を比較する、スレッドが完了します。</span><span class="sxs-lookup"><span data-stu-id="4b969-230">Two threads add a series of <xref:System.Single> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared.</span></span> <span data-ttu-id="4b969-231">デュアル プロセッサ コンピューターで、合計に大きな違いがあります。</span><span class="sxs-lookup"><span data-stu-id="4b969-231">On a dual-processor computer, there is a significant difference in the totals.</span></span>  
  
 <span data-ttu-id="4b969-232">スレッド セーフな方法では、実行中の合計の初期値が保存をクリックし、<xref:System.Threading.Interlocked.CompareExchange%2A>メソッドは、古い合計新しく計算された合計の交換に使用されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-232">In the thread-safe method, the initial value of the running total is saved, and then the <xref:System.Threading.Interlocked.CompareExchange%2A> method is used to exchange the newly computed total with the old total.</span></span> <span data-ttu-id="4b969-233">戻り値で実行中の合計の保存された値と等しくない場合、別のスレッドが合計を更新したそれまでは。</span><span class="sxs-lookup"><span data-stu-id="4b969-233">If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime.</span></span> <span data-ttu-id="4b969-234">その場合は、実行中の合計を更新しようとするを繰り返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b969-234">In that case, the attempt to update the running total must be repeated.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/cs/source.cs#1)]
 [!code-vb[System.Threading.Interlocked CompareExchange Single#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked CompareExchange Single/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-235">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-235">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-236">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-236">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-237">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-237">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="CompareExchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CompareExchange&lt;class T&gt;(!!T&amp; location1, !!T value, !!T comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareExchange(Of T As Class) (ByRef location1 As T, value As T, comparand As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T CompareExchange(T % location1, T value, T comparand);" />
      <MemberSignature Language="F#" Value="static member CompareExchange :  * 'T * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.CompareExchange (location1, value, comparand)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparand" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="4b969-238">使用する型<c>location1</c>、<c>値</c>、および<c>比較対照値</c>します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-238">The type to be used for <c>location1</c>, <c>value</c>, and <c>comparand</c>.</span>
          </span>
          <span data-ttu-id="4b969-239">この型は、参照型である必要があります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-239">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="4b969-240">値を <c>comparand</c> と比較し、場合によっては置き換える比較先。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-240">The destination, whose value is compared with <c>comparand</c> and possibly replaced.</span>
          </span>
          <span data-ttu-id="4b969-241">これは参照パラメーターです (C# では <see langword="ref" />、Visual Basic では <see langword="ByRef" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-241">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-242">比較した結果が等しい場合に比較先の値を置き換える値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-242">The value that replaces the destination value if the comparison results in equality.</span>
          </span>
        </param>
        <param name="comparand">
          <span data-ttu-id="4b969-243">
            <c>location1</c> にある値と比較する値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-243">The value that is compared to the value at <c>location1</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-244">指定した参照型 <paramref name="T" /> の 2 つのインスタンスが等しいかどうかを比較します。等しい場合は、最初の 1 つを置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-244">Compares two instances of the specified reference type <paramref name="T" /> for equality and, if they are equal, replaces the first one.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-245">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-245">The original value in <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-246">場合`comparand`値`location1`しが等しいか、`value`に格納されて`location1`します。</span><span class="sxs-lookup"><span data-stu-id="4b969-246">If `comparand` and the value in `location1` are equal, then `value` is stored in `location1`.</span></span> <span data-ttu-id="4b969-247">それ以外の場合は演算が実行されません。</span><span class="sxs-lookup"><span data-stu-id="4b969-247">Otherwise, no operation is performed.</span></span> <span data-ttu-id="4b969-248">比較と交換は、分割不可能な操作として実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-248">The comparison and the exchange are performed as an atomic operation.</span></span> <span data-ttu-id="4b969-249">このメソッドの戻り値の元の値は、`location1`交換が行われているかどうかを示す、します。</span><span class="sxs-lookup"><span data-stu-id="4b969-249">The return value of this method is the original value in `location1`, whether or not the exchange takes place.</span></span>  
  
 <span data-ttu-id="4b969-250">このメソッドは、参照型のみをサポートします。</span><span class="sxs-lookup"><span data-stu-id="4b969-250">This method only supports reference types.</span></span> <span data-ttu-id="4b969-251">オーバー ロードがあります、<xref:System.Threading.Interlocked.CompareExchange%2A>値型のメソッド<xref:System.Int32>、 <xref:System.Int64>、 <xref:System.IntPtr>、 <xref:System.Single>、および<xref:System.Double>、他の値型のサポートはありません。</span><span class="sxs-lookup"><span data-stu-id="4b969-251">There are overloads of the <xref:System.Threading.Interlocked.CompareExchange%2A> method for the value types <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double>, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b969-252">このメソッドのオーバー ロードをお勧め、<xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29>後者に遅延バインディング アクセス先となるオブジェクトを必要とするため、メソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="4b969-252">This method overload is preferable to the <xref:System.Threading.Interlocked.CompareExchange%28System.Object%40%2CSystem.Object%2CSystem.Object%29> method overload, because the latter requires the destination object to be accessed late-bound.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-253">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-253">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Decrement">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4b969-254">分割不可能な操作として、指定した変数をデクリメントし、結果を格納します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-254">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static int Decrement (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Decrement(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Decrement(int % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="4b969-255">値がデクリメントされる変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-255">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-256">分割不可能な操作として、指定した変数をデクリメントし、結果を格納します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-256">Decrements a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-257">デクリメントされた値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-257">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-258">このメソッドがラッピングによってオーバーフロー条件を処理します。 場合`location`  =  <xref:System.Int32.MinValue?displayProperty=nameWithType>、 `location` - 1 =<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="4b969-258">This method handles an overflow condition by wrapping: If `location` = <xref:System.Int32.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b969-259">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="4b969-259">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b969-260">次の例は、中間値を 1,000 の乱数を生成する 0 から 1,000 までランダムな番号の数が必要ですかを判断します。</span><span class="sxs-lookup"><span data-stu-id="4b969-260">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="4b969-261">中間値、変数の数を追跡する`midpointCount`がセットの 1,000 個に等しいとデクリメントのたびに乱数ジェネレーターは、中間値を返します。</span><span class="sxs-lookup"><span data-stu-id="4b969-261">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value.</span></span> <span data-ttu-id="4b969-262">3 つのスレッド、乱数を生成するため、<xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29>メソッドを呼び出して複数のスレッドを更新しないことを確認する`midpointCount`同時にします。</span><span class="sxs-lookup"><span data-stu-id="4b969-262">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Decrement%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="4b969-263">ロックも使用する乱数ジェネレーター、および保護することに注意してください、<xref:System.Threading.CountdownEvent>オブジェクトを使用することを確認、`Main`メソッドは、次の 3 つのスレッドの前に実行を終了しません。</span><span class="sxs-lookup"><span data-stu-id="4b969-263">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Decrement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement1.vb#1)]  
  
 <span data-ttu-id="4b969-264">使用する点を除いて、次の例は、1 つ前のような<xref:System.Threading.Tasks.Task>50,000 の中間点をランダムな整数を生成するスレッドのプロシージャではなくクラス。</span><span class="sxs-lookup"><span data-stu-id="4b969-264">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="4b969-265">この例では、ラムダ式が置き換えられます、 `GenerateNumbers` 、スレッド プロシージャを呼び出すまで、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>のメソッドが不要、<xref:System.Threading.CountdownEvent>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="4b969-265">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Decrement#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.decrement/cs/decrement2.cs#2)]
 [!code-vb[System.Threading.Interlocked.Decrement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.decrement/vb/decrement2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4b969-266">
            <paramref name="location" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-266">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-267">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-267">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-268">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-268">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static long Decrement (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Decrement(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Decrement(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrement (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Decrement(long % location);" />
      <MemberSignature Language="F#" Value="static member Decrement :  -&gt; int64" Usage="System.Threading.Interlocked.Decrement location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="4b969-269">値がデクリメントされる変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-269">The variable whose value is to be decremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-270">分割不可能な操作として、指定した変数をデクリメントしてその結果を格納します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-270">Decrements the specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-271">デクリメントされた値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-271">The decremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-272">このメソッドがラッピングによってオーバーフロー条件を処理します。 場合`location`  =  <xref:System.Int64.MinValue?displayProperty=nameWithType>、 `location` - 1 =<xref:System.Int64.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="4b969-272">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MinValue?displayProperty=nameWithType>, `location` - 1 = <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b969-273">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="4b969-273">No exception is thrown.</span></span>  
  
 <span data-ttu-id="4b969-274"><xref:System.Threading.Interlocked.Read%2A>メソッドとの 64 ビットのオーバー ロード、 <xref:System.Threading.Interlocked.Increment%2A>、 <xref:System.Threading.Interlocked.Decrement%2A>、および<xref:System.Threading.Interlocked.Add%2A>メソッドは本当に、システムでのみアトミック場所、 <xref:System.IntPtr?displayProperty=nameWithType> 64 ビット長。</span><span class="sxs-lookup"><span data-stu-id="4b969-274">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="4b969-275">他のシステムでは、これらのメソッドは尊重とデータにアクセスするが、相互にアトミックです。</span><span class="sxs-lookup"><span data-stu-id="4b969-275">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="4b969-276">したがって、32 ビット システムでスレッド セーフにするには、64 ビット値へのアクセスできる必要がありますのメンバーを<xref:System.Threading.Interlocked>クラス。</span><span class="sxs-lookup"><span data-stu-id="4b969-276">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4b969-277">
            <paramref name="location" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-277">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-278">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-278">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-279">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-279">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exchange">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4b969-280">分割不可能な操作として指定した値を変数として設定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-280">Sets a variable to a specified value as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static double Exchange (ref double location1, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exchange(float64&amp; location1, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Double, value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exchange(double % location1, double value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * double -&gt; double" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-281">指定した値に設定する変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-281">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-282">
            <c>location1</c> パラメーターに設定される値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-282">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-283">分割不可能な操作として、指定した値を倍精度浮動小数点数として設定し、元の値を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-283">Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-284">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-284">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-285">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-285">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-286">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-286">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-287">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-287">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static int Exchange (ref int location1, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Exchange(int32&amp; location1, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Integer, value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Exchange(int % location1, int value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int -&gt; int" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-288">指定した値に設定する変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-288">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-289">
            <c>location1</c> パラメーターに設定される値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-289">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-290">分割不可能な操作として、指定した値を 32 ビット符号付き整数として設定し、元の値を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-290">Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-291">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-291">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4b969-292">次のコード例では、スレッド セーフであるリソースのロック機構を示します。</span><span class="sxs-lookup"><span data-stu-id="4b969-292">The following code example shows a thread-safe resource locking mechanism.</span></span>  
  
 [!code-cpp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Interlocked.Exchange Int32 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Interlocked.Exchange Int32 Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4b969-293">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-293">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-294">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-294">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-295">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-295">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static long Exchange (ref long location1, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Exchange(int64&amp; location1, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Long, value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Exchange(long % location1, long value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * int64 -&gt; int64" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-296">指定した値に設定する変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-296">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-297">
            <c>location1</c> パラメーターに設定される値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-297">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-298">分割不可能な操作として、指定した値を 64 ビット符号付き整数として設定し、元の値を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-298">Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-299">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-299">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-300">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-300">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-301">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-301">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-302">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-302">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static IntPtr Exchange (ref IntPtr location1, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Exchange(native int&amp; location1, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As IntPtr, value As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Exchange(IntPtr % location1, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * nativeint -&gt; nativeint" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-303">指定した値に設定する変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-303">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-304">
            <c>location1</c> パラメーターに設定される値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-304">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-305">分割不可能な操作として、プラットフォーム固有のハンドルまたはポインターに指定した値を設定し、元の値を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-305">Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-306">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-306">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-307">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-307">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-308">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-308">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-309">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-309">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static object Exchange (ref object location1, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Exchange(object&amp; location1, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Object, value As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Exchange(System::Object ^ % location1, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * obj -&gt; obj" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-310">指定した値に設定する変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-310">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-311">
            <c>location1</c> パラメーターに設定される値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-311">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-312">分割不可能な操作として、指定した値をオブジェクトとして設定し、元のオブジェクトへの参照を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-312">Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-313">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-313">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

> [!NOTE]
> <span data-ttu-id="4b969-314">.NET Framework version 2.0 以降、<xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29>メソッドのオーバー ロードは、参照型の場合、タイプ セーフな代替手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="4b969-314">Beginning with .NET Framework version 2.0, the <xref:System.Threading.Interlocked.Exchange%60%601%28%60%600%40%2C%60%600%29> method overload provides a type-safe alternative for reference types.</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="4b969-315">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-315">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-316">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-316">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-317">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-317">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange">
      <MemberSignature Language="C#" Value="public static float Exchange (ref float location1, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exchange(float32&amp; location1, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange (ByRef location1 As Single, value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exchange(float % location1, float value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * single -&gt; single" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location1" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="location1">
          <span data-ttu-id="4b969-318">指定した値に設定する変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-318">The variable to set to the specified value.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-319">
            <c>location1</c> パラメーターに設定される値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-319">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-320">分割不可能な操作として、指定した値を単精度浮動小数点数として設定し、元の値を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-320">Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-321">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-321">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-322">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-322">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-323">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-323">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-324">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-324">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Exchange&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Exchange&lt;class T&gt;(!!T&amp; location1, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Exchange``1(``0@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exchange(Of T As Class) (ByRef location1 As T, value As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T Exchange(T % location1, T value);" />
      <MemberSignature Language="F#" Value="static member Exchange :  * 'T -&gt; 'T (requires 'T : null)" Usage="System.Threading.Interlocked.Exchange (location1, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="location1" Type="T" RefType="ref" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="4b969-325">使用する型<c>location1</c>と<c>値</c>します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-325">The type to be used for <c>location1</c> and <c>value</c>.</span>
          </span>
          <span data-ttu-id="4b969-326">この型は、参照型である必要があります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-326">This type must be a reference type.</span>
          </span>
        </typeparam>
        <param name="location1">
          <span data-ttu-id="4b969-327">指定した値に設定する変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-327">The variable to set to the specified value.</span>
          </span>
          <span data-ttu-id="4b969-328">これは参照パラメーターです (C# では <see langword="ref" />、Visual Basic では <see langword="ByRef" />)。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-328">This is a reference parameter (<see langword="ref" /> in C#, <see langword="ByRef" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="4b969-329">
            <c>location1</c> パラメーターに設定される値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-329">The value to which the <c>location1</c> parameter is set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-330">分割不可能な操作として、指定した型 <paramref name="T" /> の変数に指定した値を設定し、元の値を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-330">Sets a variable of the specified type <paramref name="T" /> to a specified value and returns the original value, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-331">
            <paramref name="location1" /> の元の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-331">The original value of <paramref name="location1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-332">このメソッドは、参照型のみをサポートします。</span><span class="sxs-lookup"><span data-stu-id="4b969-332">This method only supports reference types.</span></span> <span data-ttu-id="4b969-333">オーバー ロードがあります、<xref:System.Threading.Interlocked.Exchange%2A>のメソッド、 <xref:System.Int32>、 <xref:System.Int64>、 <xref:System.IntPtr>、 <xref:System.Single>、および<xref:System.Double>型の値が、他の値型はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="4b969-333">There are overloads of the <xref:System.Threading.Interlocked.Exchange%2A> method for the <xref:System.Int32>, <xref:System.Int64>, <xref:System.IntPtr>, <xref:System.Single>, and <xref:System.Double> value types, but there is no support for other value types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b969-334">このメソッドのオーバー ロードをお勧め、<xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29>後者の場合、変換先オブジェクトに遅延バインディング アクセスを必要とするため、メソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="4b969-334">This method overload is preferable to the <xref:System.Threading.Interlocked.Exchange%28System.Object%40%2CSystem.Object%29> method overload, because the latter requires late-bound access to the destination object .</span></span>  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-335">
            <paramref name="location1" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-335">The address of <paramref name="location1" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Increment">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4b969-336">分割不可能な操作として、指定した変数をインクリメントし、結果を格納します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-336">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static int Increment (ref int location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Increment(int32&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Increment(int % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="4b969-337">値がインクリメントされる変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-337">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-338">分割不可能な操作として、指定した変数をインクリメントし、結果を格納します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-338">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-339">インクリメントされた値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-339">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-340">このメソッドがラッピングによってオーバーフロー条件を処理します。 場合`location`  =  <xref:System.Int32.MaxValue?displayProperty=nameWithType>、 `location` + 1 =<xref:System.Int32.MinValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="4b969-340">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int32.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int32.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b969-341">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="4b969-341">No exception is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4b969-342">次の例は、中間値を 1,000 の乱数を生成する 0 から 1,000 までランダムな番号の数が必要ですかを判断します。</span><span class="sxs-lookup"><span data-stu-id="4b969-342">The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value.</span></span> <span data-ttu-id="4b969-343">中間値、変数の数を追跡する`midpointCount`を 0 に設定し、乱数ジェネレーターが 10,000 に達するまで、中間値を返しますたびに増分されます。</span><span class="sxs-lookup"><span data-stu-id="4b969-343">To keep track of the number of midpoint values, a variable, `midpointCount`, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000.</span></span> <span data-ttu-id="4b969-344">3 つのスレッド、乱数を生成するため、<xref:System.Threading.Interlocked.Increment%28System.Int32%40%29>メソッドを呼び出して複数のスレッドを更新しないことを確認する`midpointCount`同時にします。</span><span class="sxs-lookup"><span data-stu-id="4b969-344">Because three threads generate the random numbers, the <xref:System.Threading.Interlocked.Increment%28System.Int32%40%29> method is called to ensure that multiple threads don't update `midpointCount` concurrently.</span></span> <span data-ttu-id="4b969-345">ロックも使用する乱数ジェネレーター、および保護することに注意してください、<xref:System.Threading.CountdownEvent>オブジェクトを使用することを確認、`Main`メソッドは、次の 3 つのスレッドの前に実行を終了しません。</span><span class="sxs-lookup"><span data-stu-id="4b969-345">Note that a lock is also used to protect the random number generator, and that a <xref:System.Threading.CountdownEvent> object is used to ensure that the `Main` method doesn't finish execution before the three threads.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment3.cs#3)]
 [!code-vb[System.Threading.Interlocked.Increment2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment3.vb#3)]  
  
 <span data-ttu-id="4b969-346">使用する点を除いて、次の例は、1 つ前のような<xref:System.Threading.Tasks.Task>50,000 の中間点をランダムな整数を生成するスレッドのプロシージャではなくクラス。</span><span class="sxs-lookup"><span data-stu-id="4b969-346">The following example is similar to the previous one, except that it uses the <xref:System.Threading.Tasks.Task> class instead of a thread procedure to generate 50,000 random midpoint integers.</span></span> <span data-ttu-id="4b969-347">この例では、ラムダ式が置き換えられます、 `GenerateNumbers` 、スレッド プロシージャを呼び出すまで、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>のメソッドが不要、<xref:System.Threading.CountdownEvent>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="4b969-347">In this example, a lambda expression replaces the `GenerateNumbers` thread procedure, and the call to the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method eliminates the need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
 [!code-csharp[System.Threading.Interlocked.Increment2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.interlocked.increment2/cs/increment4.cs#4)]
 [!code-vb[System.Threading.Interlocked.Increment2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.interlocked.increment2/vb/Increment4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-348">
            <paramref name="location" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-348">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-349">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-349">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-350">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-350">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static long Increment (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Increment(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Increment(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Increment (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Increment(long % location);" />
      <MemberSignature Language="F#" Value="static member Increment :  -&gt; int64" Usage="System.Threading.Interlocked.Increment location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="4b969-351">値がインクリメントされる変数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-351">The variable whose value is to be incremented.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-352">分割不可能な操作として、指定した変数をインクリメントし、結果を格納します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-352">Increments a specified variable and stores the result, as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-353">インクリメントされた値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-353">The incremented value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-354">このメソッドがラッピングによってオーバーフロー条件を処理します。 場合`location`  =  <xref:System.Int64.MaxValue?displayProperty=nameWithType>、 `location` + 1 =<xref:System.Int64.MinValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="4b969-354">This method handles an overflow condition by wrapping: if `location` = <xref:System.Int64.MaxValue?displayProperty=nameWithType>, `location` + 1 = <xref:System.Int64.MinValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4b969-355">例外をスローすることはありません。</span><span class="sxs-lookup"><span data-stu-id="4b969-355">No exception is thrown.</span></span>  
  
 <span data-ttu-id="4b969-356"><xref:System.Threading.Interlocked.Read%2A>メソッドとの 64 ビットのオーバー ロード、 <xref:System.Threading.Interlocked.Increment%2A>、 <xref:System.Threading.Interlocked.Decrement%2A>、および<xref:System.Threading.Interlocked.Add%2A>メソッドは本当に、システムでのみアトミック場所、 <xref:System.IntPtr?displayProperty=nameWithType> 64 ビット長。</span><span class="sxs-lookup"><span data-stu-id="4b969-356">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="4b969-357">他のシステムでは、これらのメソッドは尊重とデータにアクセスするが、相互にアトミックです。</span><span class="sxs-lookup"><span data-stu-id="4b969-357">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="4b969-358">したがって、32 ビット システムでスレッド セーフにするには、64 ビット値へのアクセスできる必要がありますのメンバーを<xref:System.Threading.Interlocked>クラス。</span><span class="sxs-lookup"><span data-stu-id="4b969-358">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4b969-359">
            <paramref name="location" /> のアドレスは null ポインターです。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-359">The address of <paramref name="location" /> is a null pointer.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <altmember cref="M:System.Threading.Interlocked.Read(System.Int64@)" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-360">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-360">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-361">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-361">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4b969-362">メモリ アクセスを同期します。現在のスレッドを実行中のプロセッサは、<see cref="M:System.Threading.Interlocked.MemoryBarrier" /> を呼び出す前のメモリ アクセスを <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> の呼び出し後のメモリ アクセス以降に実行するように命令を並べ替えることはできなくなります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-362">Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Interlocked.MemoryBarrier" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-363">このメソッドに追加された、<xref:System.Threading.Interlocked>クラス、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ; 利便性のためのラッパーは、<xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="4b969-363">This method was added to the <xref:System.Threading.Interlocked> class in the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] as a convenience; it's a wrapper for the <xref:System.Threading.Thread.MemoryBarrier%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="4b969-364"><xref:System.Threading.Interlocked.MemoryBarrier%2A> 順序付け (たとえば、複数の Intel Itanium プロセッサを使用するシステム) と弱いメモリ型マルチプロセッサ システムでのみが必要です。</span><span class="sxs-lookup"><span data-stu-id="4b969-364"><xref:System.Threading.Interlocked.MemoryBarrier%2A> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="4b969-365">ほとんどの場合、c#、`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、または<xref:System.Threading.Monitor>クラスは、簡単にデータを同期する方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="4b969-365">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrierProcessWide">
      <MemberSignature Language="C#" Value="public static void MemoryBarrierProcessWide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrierProcessWide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.MemoryBarrierProcessWide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrierProcessWide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrierProcessWide();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrierProcessWide : unit -&gt; unit" Usage="System.Threading.Interlocked.MemoryBarrierProcessWide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (ref long location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(int64&amp; location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Interlocked.Read(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (ByRef location As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(long % location);" />
      <MemberSignature Language="F#" Value="static member Read :  -&gt; int64" Usage="System.Threading.Interlocked.Read location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="location">
          <span data-ttu-id="4b969-366">読み込む 64 ビット値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-366">The 64-bit value to be loaded.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4b969-367">分割不可能な操作として 64 ビット値を読み込んで返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-367">Returns a 64-bit value, loaded as an atomic operation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4b969-368">読み込まれた値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-368">The loaded value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4b969-369"><xref:System.Threading.Interlocked.Read%2A>メソッドは、64 ビットの読み取り操作がアトミックであるため、64 ビット システムで必要ではありません。</span><span class="sxs-lookup"><span data-stu-id="4b969-369">The <xref:System.Threading.Interlocked.Read%2A> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic.</span></span> <span data-ttu-id="4b969-370">32 ビット システムで 64 ビットの読み取り操作を使用して実行しない限り、アトミックいない<xref:System.Threading.Interlocked.Read%2A>します。</span><span class="sxs-lookup"><span data-stu-id="4b969-370">On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref:System.Threading.Interlocked.Read%2A>.</span></span>  
  
 <span data-ttu-id="4b969-371"><xref:System.Threading.Interlocked.Read%2A>メソッドとの 64 ビットのオーバー ロード、 <xref:System.Threading.Interlocked.Increment%2A>、 <xref:System.Threading.Interlocked.Decrement%2A>、および<xref:System.Threading.Interlocked.Add%2A>メソッドは本当に、システムでのみアトミック場所、 <xref:System.IntPtr?displayProperty=nameWithType> 64 ビット長。</span><span class="sxs-lookup"><span data-stu-id="4b969-371">The <xref:System.Threading.Interlocked.Read%2A> method and the 64-bit overloads of the <xref:System.Threading.Interlocked.Increment%2A>, <xref:System.Threading.Interlocked.Decrement%2A>, and <xref:System.Threading.Interlocked.Add%2A> methods are truly atomic only on systems where a <xref:System.IntPtr?displayProperty=nameWithType> is 64 bits long.</span></span> <span data-ttu-id="4b969-372">他のシステムでは、これらのメソッドは尊重とデータにアクセスするが、相互にアトミックです。</span><span class="sxs-lookup"><span data-stu-id="4b969-372">On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data.</span></span> <span data-ttu-id="4b969-373">したがって、32 ビット システムでスレッド セーフにするには、64 ビット値へのアクセスできる必要がありますのメンバーを<xref:System.Threading.Interlocked>クラス。</span><span class="sxs-lookup"><span data-stu-id="4b969-373">Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref:System.Threading.Interlocked> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4b969-374"><xref:System.IntPtr> プラットフォーム固有の型です。</span><span class="sxs-lookup"><span data-stu-id="4b969-374"><xref:System.IntPtr> is a platform-specific type.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Threading.Interlocked.Increment" />
        <altmember cref="Overload:System.Threading.Interlocked.Decrement" />
        <altmember cref="Overload:System.Threading.Interlocked.Add" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="4b969-375">マネージド スレッド処理</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-375">Managed Threading</span>
          </span>
        </related>
        <related type="Article" href="http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b">
          <span data-ttu-id="4b969-376">インタロックされました。</span>
          <span class="sxs-lookup">
            <span data-stu-id="4b969-376">Interlocked</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>