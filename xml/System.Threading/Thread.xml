<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fd2bf7c62b10f302d95d138e19563c498a74ec5a" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52219345" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>スレッドを作成および制御し、そのスレッドの優先順位の設定およびステータスの取得を行います。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスの開始時に、共通言語ランタイムは自動的にアプリケーション コードを実行する 1 つのフォア グラウンド スレッドを作成します。 このメインのフォア グラウンド スレッドとプロセスは、プロセスに関連付けられたプログラム コードの一部を実行する 1 つまたは複数のスレッドを作成できます。 これらのスレッドをフォア グラウンドまたはバック グラウンドで実行できます。 さらに、使用、<xref:System.Threading.ThreadPool>クラス、共通言語ランタイムによって管理されるワーカー スレッドでコードを実行します。  
  
 このセクションの内容  
  
 [スレッドの開始](#Starting)   
 [スレッド オブジェクトを取得します。](#Retrieving)   
 [フォア グラウンドとバック グラウンド スレッド](#Foreground)   
 [カルチャとスレッド](#Culture)   
 [情報を取得して、スレッドを制御します。](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a>スレッドの開始  
 スレッドを開始するには、スレッドは、そのクラス コンス トラクターで実行するメソッドを表すデリゲートを指定します。 呼び出して、<xref:System.Threading.Thread.Start%2A>実行を開始するメソッド。  
  
 <xref:System.Threading.Thread>コンス トラクターが実行されるメソッドに引数を渡すかどうかに応じて、2 つのデリゲート型のいずれかを受け取ることができます。  
  
-   渡す引数を持つメソッドがない場合、<xref:System.Threading.ThreadStart>コンス トラクターにデリゲートします。 署名があります。  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     次の例は、作成しを実行するスレッドを開始、`ExecuteInForeground`メソッド。 メソッドは、一部のスレッド プロパティに関する情報を表示しを 0.5 秒の一時停止して経過秒数を表示します。 ループを実行します。 少なくとも 5 秒間、スレッドが実行されたときに、ループが終了し、スレッドが実行を終了します。  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   メソッドに引数がある場合は、渡す、<xref:System.Threading.ParameterizedThreadStart>コンス トラクターにデリゲートします。 署名があります。  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     デリゲートが実行するメソッドが、キャスト (c#) または (Visual Basic) では、パラメーターを適切な型に変換できます。  
  
     呼び出すことを除いて、次の例は前のものと同じ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>コンス トラクター。 このバージョンの`ExecuteInForeground`メソッドには、ループは、実行するミリ秒単位の概数を表す 1 つのパラメーター。  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 参照を保持する必要はありません、<xref:System.Threading.Thread>オブジェクトのスレッドを開始するとします。 スレッドは、スレッド プロシージャが完了するまでの実行を継続します。  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a>スレッド オブジェクトを取得します。  
 静的なを使用することができます (`Shared` Visual Basic で)<xref:System.Threading.Thread.CurrentThread%2A>スレッドが実行されているコードから実行中のスレッドへの参照を取得するプロパティ。 次の例では、<xref:System.Threading.Thread.CurrentThread%2A>プロパティ、アプリケーションのメイン スレッド、もう 1 つのフォア グラウンド スレッド、バック グラウンド スレッドおよびスレッド プールのスレッドに関する情報を表示します。  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a>フォア グラウンドとバック グラウンド スレッド  
 インスタンス、<xref:System.Threading.Thread>クラスは、フォア グラウンド スレッドまたはバック グラウンド スレッドを表します。 バック グラウンド スレッドは例外が 1 つのフォア グラウンド スレッドと同じです。 すべてのフォア グラウンド スレッドが終了した場合、バック グラウンド スレッドが実行されているプロセスを保持しません。 すべてのフォア グラウンド スレッドを停止すると、ランタイムはすべてのバック グラウンド スレッドを停止し、シャット ダウンします。  
  
 既定では、次のスレッドをフォア グラウンドで実行します。  
  
-   メイン アプリケーション スレッドです。  
  
-   呼び出すことによって作成されたすべてのスレッドを<xref:System.Threading.Thread>クラスのコンス トラクター。  
  
 次のスレッドは、既定では、バック グラウンドで実行します。  
  
-   ランタイムによって管理されるワーカー スレッドのプールはプールのスレッドをスレッドです。  使用してスレッド プール スレッドでスレッド プールとスケジュールの作業を構成することができます、<xref:System.Threading.ThreadPool>クラス。  
  
    > [!NOTE]
    >  タスク ベースの非同期操作は、スレッド プールのスレッドで自動的に実行します。 タスク ベースの非同期操作を使用して、<xref:System.Threading.Tasks.Task>と<xref:System.Threading.Tasks.Task%601>を実装するクラス、[タスクベースの非同期パターン](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)します。  
  
-   アンマネージ コードからマネージ実行環境に入るすべてのスレッド。  
  
 設定して、バック グラウンドで実行するスレッドを変更することができます、<xref:System.Threading.Thread.IsBackground%2A>いつでもプロパティ。  バック グラウンド スレッドは、アプリケーションが実行されているが、終了、ファイル システムの変更、または受信ソケット接続の監視などのアプリケーションをしないようにする必要があります限り継続する必要がある操作を行う場合に便利です。  
  
 次の例は、フォア グラウンドとバック グラウンド スレッドの違いを示しています。 最初の例のようなもの、[スレッドを開始](#Starting)セクションで、それを開始する前に、バック グラウンドで実行するスレッドを設定する点が異なります。 出力を 5 秒間の実行前に、ループが中断されます。  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a>カルチャとスレッド  
 各スレッドが、カルチャによって表される、<xref:System.Threading.Thread.CurrentCulture%2A>によって表されるプロパティ、および UI カルチャ、<xref:System.Threading.Thread.CurrentUICulture%2A>プロパティ。  現在のカルチャでは、解析および書式設定、文字列比較と並べ替えなどのカルチャに依存する操作をサポートしているしの書記体系やスレッドで使用する暦にも制御します。 現在の UI カルチャは、リソース ファイル内のリソースのカルチャの取得を提供します。  

> [!IMPORTANT]
> <xref:System.Threading.Thread.CurrentCulture>と<xref:System.Threading.Thread.CurrentUICulture>プロパティは、現在のスレッド以外の任意のスレッドを使用すると確実に機能しません。 .NET framework では、これらのプロパティを読み取り、信頼性が高くはありませんが、現在のスレッド以外のスレッドのこれらのプロパティを設定します。 .NET Core で、<xref:System.InvalidOperationException>スレッドが読み取りまたは別のスレッドでのこれらのプロパティの書き込みを試みるとスローされます。
> 使用することをお勧め、<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType>と<xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType>プロパティを取得して、現在のカルチャを設定します。

 新しいスレッドがインスタンス化されるときは、によって、現在のシステム カルチャと UI カルチャ、およびカルチャと、新しいスレッドの作成元のスレッドの UI カルチャではなく、そのカルチャおよび UI カルチャが定義されています。 つまり、たとえば、現在のシステム カルチャが英語 (米国) とプライマリ アプリケーションのスレッドの現在のカルチャがフランス語 (フランス)、呼び出すことによって作成された新しいスレッドのカルチャの場合、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>プライマリ スレッドからコンス トラクター英語 (米国) とフランス語 (フランス)。 詳細については、の「カルチャとスレッド」セクションを参照してください、<xref:System.Globalization.CultureInfo>クラスに関するトピック。  
  
> [!IMPORTANT]
>  対象とするアプリの非同期操作を実行するスレッドの場合は true でない、[!INCLUDE[net_v46](~/includes/net-v46-md.md)]以降のバージョンでこのケースでは、カルチャおよび UI カルチャでは、非同期の一部と操作のコンテキスト; いるスレッドで非同期操作によって実行される既定のカルチャおよび非同期操作の起動元のスレッドの UI カルチャを継承します。 詳細については、<xref:System.Globalization.CultureInfo> クラスのトピックの「カルチャとタスク ベースの非同期の操作」セクションをご覧ください。  
  
 いずれかを実行することのすべてのスレッドを確認するには、次は、同じカルチャおよび UI カルチャをアプリケーションで実行する共有します。  
  
-   渡すことができます、<xref:System.Globalization.CultureInfo>そのカルチャを表すオブジェクト、<xref:System.Threading.ParameterizedThreadStart>委任または<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType>メソッド。  
  
-   実行されるアプリ、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 、以降のバージョン、カルチャおよび UI カルチャの値を設定して、アプリケーション ドメインで作成されるすべてのスレッドに割り当てられるを定義できます、<xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType>と<xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType>プロパティ。 これはアプリケーションごとのドメインの設定であることに注意してください。  

 詳細と例については、の「カルチャとスレッド」セクションを参照してください、<xref:System.Globalization.CultureInfo>クラスに関するトピック。

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a>情報を取得して、スレッドを制御します。  
 数のスレッドに関する情報を提供するプロパティ値を取得することができます。 場合によっては、スレッドの操作を制御するこれらのプロパティ値を設定することもできます。 これらのスレッド プロパティは次のとおりです。  
  
-   名前。 <xref:System.Threading.Thread.Name%2A> 書き込みが可能-1 回、スレッドを識別するために使用できるプロパティです。  既定値は`null`します。  
  
-   ハッシュ コードを呼び出すことによって取得できます、<xref:System.Threading.Thread.GetHashCode%2A>メソッド。 ハッシュ コードを使用してをスレッドを一意に識別することができます。スレッドの有効期間にわたって、そのハッシュ コードが、値を取得するアプリケーション ドメインに関係なく、他の任意のスレッドからの値の競合しません。  
  
-   スレッド id です。 読み取り専用の値<xref:System.Threading.Thread.ManagedThreadId%2A>プロパティは、ランタイムによって割り当てられているし、そのプロセス内のスレッドを一意に識別します。  
  
    > [!NOTE]
    >  オペレーティング システム [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) とマネージド スレッドの間には固定的な関係はありません。これは、アンマネージド ホストがマネージド スレッドとアンマネージド スレッドの間の関係を制御できるためです。 具体的には、高度なホストが使用できる、 [CLR ホスティング API](https://msdn.microsoft.com/library/ms404385.aspx)同じオペレーティング システム スレッドに対して多くのマネージ スレッドをスケジュールする、または別のオペレーティング システムのスレッド間でのマネージ スレッドを移動します。  
  
-   スレッドの現在の状態。 その存在の期間、スレッドは常に 1 つ以上のによって定義されている状態で、<xref:System.Threading.ThreadState>プロパティ。  
  
-   定義されているスケジュールの優先度レベル、<xref:System.Threading.ThreadPriority>プロパティ。 スレッドの優先順位を要求するには、この値を設定できますが、オペレーティング システムによって受け入れられるには保証されません。  
  
-   読み取り専用<xref:System.Threading.Thread.IsThreadPoolThread%2A>プロパティで、スレッドがスレッド プールのスレッドでかどうかを示します。  
  
-   <xref:System.Threading.Thread.IsBackground%2A> プロパティ。 詳細については、次を参照してください。、[フォア グラウンドとバック グラウンド スレッド](#Foreground)セクション。  
  
## Examples  
 次の例では、単純なスレッド処理の機能を示します。  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 このコードには、次のような出力が生成されます。  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">スレッドの使用とスレッド処理</related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96">スレッド クラスのソースの参照</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表すデリゲート。</param>
        <summary>スレッドの開始時にオブジェクトをスレッドに渡すことを許可するデリゲートを指定して、<see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドでは、作成時にその実行は開始しません。 スレッドの実行をスケジュールするには、呼び出し、<xref:System.Threading.Thread.Start%2A>メソッド。 データ オブジェクトをスレッドに渡すを使用して、<xref:System.Threading.Thread.Start%28System.Object%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  Visual Basic の場合は省略できます、<xref:System.Threading.ThreadStart>スレッドを作成するときに、コンス トラクター。 使用して、`AddressOf`演算子など、メソッドを渡すときに`Dim t As New Thread(AddressOf ThreadProc)`します。 Visual Basic を自動的に呼び出して、<xref:System.Threading.ThreadStart>コンス トラクター。  
  
   
  
## Examples  
 次の例の作成と使用の構文を示しています、<xref:System.Threading.ParameterizedThreadStart>静的メソッドとインスタンス メソッドを持つデリゲート。  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">スレッドの作成</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ThreadStart" /> デリゲート。</param>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドでは、作成時にその実行は開始しません。 スレッドの実行をスケジュールするには、呼び出し、<xref:System.Threading.Thread.Start%2A>メソッド。  
  
> [!NOTE]
>  Visual Basic の場合は省略できます、<xref:System.Threading.ThreadStart>スレッドを作成するときに、コンス トラクター。 使用して、`AddressOf`演算子など、メソッドを渡すときに`Dim t As New Thread(AddressOf ThreadProc)`します。 Visual Basic を自動的に呼び出して、<xref:System.Threading.ThreadStart>コンス トラクター。  
  
   
  
## Examples  
 次のコード例では、静的メソッドを実行するスレッドを作成する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 次のコード例では、インスタンス メソッドを実行するスレッドを作成する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">スレッドの作成</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ParameterizedThreadStart" /> デリゲート。</param>
        <param name="maxStackSize">スレッドが使用する最大スタック サイズ (バイト単位)。実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する場合は 0。  
  
重要: 部分的に信頼されているコードでは、既定のスタック サイズを超える <paramref name="maxStackSize" /> は無視されます。 例外をスローすることはありません。</param>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化して、スレッドの開始時にオブジェクトをスレッドに渡すことを許可するデリゲートとこのスレッドの最大スタック サイズを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクター オーバー ロードを使用しないでください。 使用される既定のスタック サイズ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29>コンス トラクターのオーバー ロードは、スレッドの推奨されるスタック サイズ。 スレッドがある、メモリの問題、最も一般的な原因は無限再帰などのエラーをプログラミングします。  
  
> [!IMPORTANT]
>  以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、完全信頼コードで設定できる専用`maxStackSize`既定のスタック サイズ (1 メガバイト) よりも大きい値にします。 大きい値が指定されて場合`maxStackSize`部分信頼でコードが実行されているときに`maxStackSize`は無視されます、既定のスタック サイズを使用します。 例外をスローすることはありません。 すべての信頼レベルでコードを設定できます`maxStackSize`が既定のスタック サイズより小さい値にします。  
  
> [!NOTE]
>  、部分的に信頼されたコードで使用される完全に信頼されたライブラリを開発しているし、スレッドを開始する必要がある場合は、大量の履歴を必要とするまたは、スレッドを作成する前に、完全な信頼をアサートする必要がありますが、既定のスタック サイズを使用します。 そうしないと、スレッドで実行されるコードを完全に制御する場合を除き、します。  
  
 場合`maxStackSize`が小さい最小スタックのサイズよりも、最小のスタック サイズが使用されます。 場合`maxStackSize`倍数ではない、ページ サイズの大きいページ サイズの倍数に丸められます。 たとえば、Windows Vista を .NET Framework version 2.0 を使用している場合 256 KB (262, 144 バイト) が最小のスタックのサイズとページ サイズは 64 KB (65,536 バイト)。  
  
> [!NOTE]
>  前に Windows XP および Windows Server 2003、Microsoft Windows のバージョンで`maxStackSize`は無視されますと、実行可能ファイルのヘッダーで指定されたスタック サイズが使用されます。  
  
 非常に小さなスタック サイズを指定する場合は、スタック オーバーフローの検出を無効にする必要があります。 スタックが著しく制約されているときに、プローブできます自体、スタック オーバーフローが発生します。 スタック オーバーフローの検出を無効にするには、アプリケーション構成ファイルに、次を追加します。  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStackSize" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">このスレッドが実行を開始するときに呼び出されるメソッドを表す <see cref="T:System.Threading.ThreadStart" /> デリゲート。</param>
        <param name="maxStackSize">スレッドが使用する最大スタック サイズ (バイト単位)。実行可能ファイルのヘッダーで指定された既定の最大スタック サイズを使用する場合は 0。  
  
重要: 部分的に信頼されているコードでは、既定のスタック サイズを超える <paramref name="maxStackSize" /> は無視されます。 例外をスローすることはありません。</param>
        <summary><see cref="T:System.Threading.Thread" /> クラスの新しいインスタンスを初期化して、スレッドの最大スタック サイズを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクター オーバー ロードを使用しないでください。 使用される既定のスタック サイズ、<xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29>コンス トラクターのオーバー ロードは、スレッドの推奨されるスタック サイズ。 スレッドがある、メモリの問題、最も一般的な原因は無限再帰などのエラーをプログラミングします。  
  
> [!IMPORTANT]
>  以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、完全信頼コードで設定できる専用`maxStackSize`既定のスタック サイズ (1 メガバイト) よりも大きい値にします。 大きい値が指定されて場合`maxStackSize`部分信頼でコードが実行されているときに`maxStackSize`は無視されます、既定のスタック サイズを使用します。 例外をスローすることはありません。 すべての信頼レベルでコードを設定できます`maxStackSize`が既定のスタック サイズより小さい値にします。  
  
> [!NOTE]
>  、部分的に信頼されたコードで使用される完全に信頼されたライブラリを開発しているし、スレッドを開始する必要がある場合は、大量の履歴を必要とするまたは、スレッドを作成する前に、完全な信頼をアサートする必要がありますが、既定のスタック サイズを使用します。 そうしないと、スレッドで実行されるコードを完全に制御する場合を除き、します。  
  
 場合`maxStackSize`が小さい最小スタックのサイズよりも、最小のスタック サイズが使用されます。 場合`maxStackSize`倍数ではない、ページ サイズの大きいページ サイズの倍数に丸められます。 たとえば、Windows Vista を .NET Framework version 2.0 を使用している場合 256 KB (262, 144 バイト) が最小のスタックのサイズとページ サイズは 64 KB (65,536 バイト)。  
  
> [!NOTE]
>  前に Windows XP および Windows Server 2003、Microsoft Windows のバージョンで`maxStackSize`は無視されますと、実行可能ファイルのヘッダーで指定されたスタック サイズが使用されます。  
  
 非常に小さなスタック サイズを指定する場合は、スタック オーバーフローの検出を無効にする必要があります。 スタックが著しく制約されているときに、プローブできます自体、スタック オーバーフローが発生します。 スタック オーバーフローの検出を無効にするには、アプリケーション構成ファイルに、次を追加します。  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="start" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStackSize" /> が 0 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このメソッドが呼び出された対象のスレッドで、そのスレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> `Thread.Abort`メソッドは、注意して使用する必要があります。 現在のスレッド以外のスレッドの中止を呼び出すときに特にわからないが、どのようなコードの実行またはときに実行する失敗した、<xref:System.Threading.ThreadAbortException>がスローされたものアプリケーションの状態の特定またはアプリケーションとユーザー状態ことができます維持を担当します。 たとえば、呼び出し`Thread.Abort`静的コンス トラクターが実行されないようにまたはアンマネージ リソースの解放を禁止する可能性があります。 
>
> なお、`Thread.Abort`メソッドは .NET Core でサポートされていません。

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このメソッドが呼び出された対象のスレッドで、そのスレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドでこのメソッドが呼び出されると、システムがスローされます、<xref:System.Threading.ThreadAbortException>スレッドを中止することにします。 `ThreadAbortException` アプリケーションのコードでキャッチできる特殊な例外の最後に再スローされますが、`catch`しない限りブロック<xref:System.Threading.Thread.ResetAbort%2A>が呼び出されます。 `ResetAbort` 中止するには要求をキャンセルできず、`ThreadAbortException`のスレッドを終了します。 実行されていない`finally`ブロックは、スレッドが中止される前に実行されます。  
  
> [!NOTE]
>  スレッドを呼び出すと`Abort`自体の効果は例外をスローすることに似ています、 <xref:System.Threading.ThreadAbortException> 、即座に実行され、結果は予測可能な。 ただし、1 つのスレッドを呼び出す場合`Abort`どのようなコードが実行されているが、中止、別のスレッドで中断します。 静的コンス トラクターが中断される可能性もあります。 まれに、そのクラスのインスタンスを防ぐため、そのアプリケーション ドメインで作成されない可能性がありますこれ。 スレッドが中止される可能性が可能性がある .NET Framework バージョン 1.0 および 1.1 では中、`finally`後者ブロックが実行されて、`finally`ブロックが中止されました。  
  
 スレッドは、すぐに、またはまったくを中止するは保証されません。 このような状況は、スレッドは計算量が境界のない場合に発生することができます、`finally`無期限のために、中止を遅延、中止手順の一部として呼び出されるブロック。 スレッドが中止されるまで待ってを呼び出すことができます、<xref:System.Threading.Thread.Join%2A>メソッドを呼び出した後、スレッド、<xref:System.Threading.Thread.Abort%2A>メソッド、待機が終了する保証はありません。  
  
> [!NOTE]
>  呼び出すスレッド<xref:System.Threading.Thread.Abort%2A>場合などは、コードの保護領域で中止中のスレッドをブロックする可能性があります、`catch`ブロック、`finally`ブロック、または制約された実行領域。 かどうか、スレッドを呼び出す<xref:System.Threading.Thread.Abort%2A>デッドロックが発生することができますが、中止されたスレッドが必要なロックを保持します。  
  
 場合`Abort`と呼びますが開始されていないスレッドでスレッドが中止される場合<xref:System.Threading.Thread.Start%2A>が呼び出されます。 場合`Abort`と呼ばれるはブロックされているかスリープ状態のスレッドでスレッドが中断され、中止されました。  
  
 場合`Abort`が中断されたスレッドで呼び出されます、<xref:System.Threading.ThreadStateException>を呼び出したスレッドでスローされる<xref:System.Threading.Thread.Abort%2A>、および<xref:System.Threading.ThreadState.AbortRequested>に追加されます、<xref:System.Threading.Thread.ThreadState%2A>が中止されたスレッドのプロパティ。 A<xref:System.Threading.ThreadAbortException>まで中断されたスレッドではスローされません<xref:System.Threading.Thread.Resume%2A>が呼び出されます。  
  
 場合`Abort`、アンマネージ コードの実行中に、マネージ スレッドで呼び出されます、`ThreadAbortException`スレッドがマネージ コードに戻るまではスローされません。  
  
 呼び出しは 2 つの場合`Abort`ものでは、同時に、1 回の呼び出しの状態情報を設定すると、その他の呼び出しを実行することは、`Abort`します。 ただし、アプリケーションは、このような状況を検出することはできません。  
  
 後`Abort`が呼び出されたスレッドでスレッドの状態が含まれます<xref:System.Threading.ThreadState.AbortRequested>します。 成功した呼び出しの結果として、スレッドが終了したら`Abort`、スレッドの状態に変更<xref:System.Threading.ThreadState.Stopped>します。 十分なアクセス許可を備えた、スレッドの対象となる、`Abort`中止を使用して、取り消すことができます、`ResetAbort`メソッド。 呼び出し元を示す例については、`ResetAbort`メソッドを参照してください、`ThreadAbortException`クラス。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">中止するスレッドが現在中断されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドでの高度な操作。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">スレッドの使用とスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">スレッドの破棄</related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo">中止するスレッドで使用できる、状態などのアプリケーション固有の情報を格納するオブジェクト。</param>
        <summary>このメソッドが呼び出された対象のスレッドで、スレッドの終了プロセスを開始する <see cref="T:System.Threading.ThreadAbortException" /> を発生させます。またスレッドの終了に関する例外情報も提供します。 このメソッドを呼び出すと、通常、スレッドが終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドでこのメソッドが呼び出されると、システムがスローされます、<xref:System.Threading.ThreadAbortException>スレッドを中止することにします。 `ThreadAbortException` アプリケーションのコードでキャッチできる特殊な例外の最後に再スローされますが、`catch`しない限りブロック<xref:System.Threading.Thread.ResetAbort%2A>が呼び出されます。 `ResetAbort` 中止するには要求をキャンセルできず、`ThreadAbortException`のスレッドを終了します。 実行されていない`finally`ブロックは、スレッドが中止される前に実行されます。  
  
> [!NOTE]
>  スレッドを呼び出すと`Abort`自体の効果は例外をスローすることに似ています、 <xref:System.Threading.ThreadAbortException> 、即座に実行され、結果は予測可能な。 ただし、1 つのスレッドを呼び出す場合`Abort`どのようなコードが実行されているが、中止、別のスレッドで中断します。 静的コンス トラクターが中断される可能性があります。 まれに、そのクラスのインスタンスを防ぐため、そのアプリケーション ドメインで作成されない可能性がありますこれ。 スレッドが中止される可能性が可能性がある .NET Framework バージョン 1.0 および 1.1 では中、`finally`後者ブロックが実行されて、`finally`ブロックが中止されました。  
  
 スレッドは、すぐに、またはまったくを中止するは保証されません。 このような状況は、スレッドは計算量が境界のない場合に発生することができます、`finally`無期限のために、中止を遅延、中止手順の一部として呼び出されるブロック。 スレッドが中止されるまで待ってを呼び出すことができます、<xref:System.Threading.Thread.Join%2A>メソッドを呼び出した後、スレッド、<xref:System.Threading.Thread.Abort%2A>メソッド、待機が終了されるという保証はありません。  
  
> [!NOTE]
>  呼び出すスレッド<xref:System.Threading.Thread.Abort%2A>場合などは、コードの保護領域で中止中のスレッドをブロックする可能性があります、`catch`ブロック、`finally`ブロック、または制約された実行領域。 かどうか、スレッドを呼び出す<xref:System.Threading.Thread.Abort%2A>デッドロックが発生することができますが、中止されたスレッドが必要なロックを保持します。  
  
 場合`Abort`と呼びますが開始されていないスレッドでスレッドが中止される場合<xref:System.Threading.Thread.Start%2A>が呼び出されます。 場合`Abort`と呼ばれるはブロックされているかスリープ状態のスレッドでスレッドが中断され、中止されました。  
  
 場合`Abort`が中断されたスレッドで呼び出されます、<xref:System.Threading.ThreadStateException>を呼び出したスレッドでスローされる<xref:System.Threading.Thread.Abort%2A>、および<xref:System.Threading.ThreadState.AbortRequested>に追加されます、<xref:System.Threading.Thread.ThreadState%2A>が中止されたスレッドのプロパティ。 A<xref:System.Threading.ThreadAbortException>まで中断されたスレッドではスローされません<xref:System.Threading.Thread.Resume%2A>が呼び出されます。  
  
 場合`Abort`、アンマネージ コードの実行中に、マネージ スレッドで呼び出されます、`ThreadAbortException`スレッドがマネージ コードに戻るまではスローされません。  
  
 呼び出しは 2 つの場合`Abort`ものでは、同時に、1 回の呼び出しの状態情報を設定すると、その他の呼び出しを実行することは、`Abort`します。 ただし、アプリケーションは、このような状況を検出することはできません。  
  
 後`Abort`が呼び出されたスレッドでスレッドの状態が含まれます<xref:System.Threading.ThreadState.AbortRequested>します。 成功した呼び出しの結果として、スレッドが終了したら`Abort`、スレッドの状態に変更<xref:System.Threading.ThreadState.Stopped>します。 十分なアクセス許可を備えた、スレッドの対象となる、`Abort`中止を使用して、取り消すことができます、`ResetAbort`メソッド。 呼び出し元を示す例については、`ResetAbort`メソッドを参照してください、`ThreadAbortException`クラス。  
  
   
  
## Examples  
 次のコード例では、中止中のスレッドに情報を渡す方法を示します。  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">中止するスレッドが現在中断されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドでの高度な操作。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md">スレッドの使用とスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">スレッドの破棄</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>無名のデータ スロットをすべてのスレッドに割り当てます。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>すべてのスレッドに割り当てられた名前付きのデータ スロット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用して 2 つのメカニズムが用意されています: スレッド相対静的フィールド (でマークされているフィールドは、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットより優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)します。  
  
 スロットのすべてのスレッドが割り当てられます。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ メカニズムを使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができますが、格納および取得するデータ スロットの値し、スレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 他のスレッド (子スレッドであっても) はそのデータを取得できません。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、同じことを行うデータ スロットを使用する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持するためにします。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次のコード例では、スレッド固有の情報を格納するデータ スロットを使用する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">割り当てられるデータ スロットの名前。</param>
        <summary>名前付きのデータ スロットをすべてのスレッドに割り当てます。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>すべてのスレッドに割り当てられた名前付きのデータ スロット。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用して 2 つのメカニズムが用意されています: スレッド相対静的フィールド (でマークされているフィールドは、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットより優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)します。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ メカニズムを使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができますが、格納および取得するデータ スロットの値し、スレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 他のスレッド (子スレッドであっても) はそのデータを取得できません。  
  
 使用する必要はありません、 <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> 、名前付きデータ スロットを割り当てるため、メソッド、<xref:System.Threading.Thread.GetNamedDataSlot%2A>メソッドは、既に割り当てられていない場合に、スロットを割り当てます。  
  
> [!NOTE]
>  場合、<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>メソッドを使用して、指定した名前のスロットが既に割り当てられている場合に例外をスローしたためには、プログラムの起動時にメイン スレッドでという必要があります。 スロットが既に割り当てられているかどうかをテストする方法はありません。  
  
 このメソッドで割り当てられたスロットを解放する必要があります<xref:System.Threading.Thread.FreeNamedDataSlot%2A>します。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、同じことを行うデータ スロットを使用する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持するためにします。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
> [!NOTE]
>  コード例では使用しません、<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>メソッド、ため、<xref:System.Threading.Thread.GetNamedDataSlot%2A>メソッドは、既に割り当てられていない場合に、スロットを割り当てます。 場合、<xref:System.Threading.Thread.AllocateNamedDataSlot%2A>メソッドを使用して、これは、プログラムの起動時にメイン スレッドで呼び出す必要があります。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定した名前の名前付きデータ スロットは既に存在します。</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドのアパートメント状態を取得または設定します。</summary>
        <value><see cref="T:System.Threading.ApartmentState" /> 値のいずれか。 初期値は <see langword="Unknown" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **<xref:System.Threading.Thread.ApartmentState%2A>プロパティは廃止されています。**  旧式でない代替手段は、<xref:System.Threading.Thread.GetApartmentState%2A>アパートメント状態を取得するメソッドと<xref:System.Threading.Thread.SetApartmentState%2A>アパートメント状態を設定します。  
  
 .NET Framework バージョン 1.0 および 1.1 で、`ApartmentState`プロパティは、スレッドを示すことがシングル スレッドまたはマルチ スレッド アパートメントで実行されます。 スレッドがの場合、このプロパティを設定できます、`Unstarted`または`Running`スレッドの状態です。 ただし、設定できます 1 回だけのスレッド。 プロパティが設定されていないかどうかが返されます`Unknown`します。  
  
 使用した場合、<xref:System.Threading.Thread.ApartmentState%2A>アパートメント状態が既に設定されているスレッドのアパートメント状態を設定するプロパティは無視されます。 ただし、<xref:System.Threading.Thread.SetApartmentState%2A>メソッドがスローされます、<xref:System.InvalidOperationException>ここでします。  
  
> [!IMPORTANT]
>  として、.NET Framework version 2.0 で新しいスレッドの初期化<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>の開始される前に、そのアパートメント状態が設定されていない場合。 メイン アプリケーション スレッドに初期化<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>既定。 不要になったにメイン アプリケーション スレッドを設定できます<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>を設定して、<xref:System.Threading.ApartmentState?displayProperty=nameWithType>コードの最初の行のプロパティ。 使用して、<xref:System.STAThreadAttribute>代わりにします。  
  
 .NET Framework version 2.0 では、COM スレッド モデルを使用して、C++ アプリケーションを指定することができます、 [/CLRTHREADATTRIBUTE (CLR スレッド属性の設定)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8)リンカー オプション。  
  
   
  
## Examples  
 次のコード例では、スレッドのアパートメント状態を設定する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このプロパティを、無効なアパートメント状態 (つまりシングルスレッド アパートメント (<see langword="STA" />) またはマルチスレッド アパートメント (<see langword="MTA" />) 以外のアパートメント状態) に設定しようとしました。</exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドの中止または処理されない例外の影響によりアプリケーション ドメイン内の他のタスクが悪影響を受ける可能性があるコード領域に実行が入ることをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストには、コードの重要および重大でないリージョン内のエラーのさまざまなポリシーを確立できます。 クリティカル領域では、するスレッドの中止または処理されない例外の影響があります、現在のタスクに制限されています。 これに対し、中止または致命的でないコードの領域でエラーには、エラーが発生したタスクのみに影響します。  
  
 たとえば、ロックを保持しているときにメモリを割り当てようとするタスクを検討してください。 メモリの割り当てが失敗した場合がの安定性を確保するための十分な現在のタスクを中止していますが、 <xref:System.AppDomain>、同じロックを待機しているドメインを他のタスクにすることができますがあります。 現在のタスクが終了した場合は、その他のタスクがデッドロックでした。  
  
 全体をアンロードするホストがありますクリティカル領域で、障害が発生したときに<xref:System.AppDomain>可能性がある不安定な状態で実行を続けることのリスクを冒すよりもします。 コードがクリティカル領域を入力することをホストに通知をするために呼び出す<xref:System.Threading.Thread.BeginCriticalRegion%2A>します。 呼び出す<xref:System.Threading.Thread.EndCriticalRegion%2A>と重大でないコードの領域への実行を返します。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。  
  
   
  
## Examples  
 次の例では、使用、<xref:System.Threading.Thread.BeginCriticalRegion%2A>と<xref:System.Threading.Thread.EndCriticalRegion%2A>重要および重大でない地域コードのブロックに分割する方法。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>マネージド コードが現在のオペレーティング システムの物理スレッドの ID に依存する命令の実行を開始することをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 など、共通言語ランタイムの一部のホストでは、独自のスレッド管理を提供します。 独自のスレッド管理を提供するホストに移動できます実行中のタスク 1 つのオペレーティング システムの物理スレッドから別、いつでも。 ほとんどのタスクは、このを切り替えることでは受けません。 ただし、いくつかのタスクはスレッド アフィニティを設定する-は、オペレーティング システムの物理スレッドの id に依存します。 これらのタスクは、スイッチできないコードを実行するときをホストに通知する必要があります。  
  
 呼び出す必要がありますの例では、オペレーティング システムを取得する、アプリケーション呼び出しシステム API をロックする場合、Win32 CRITICAL_SECTION など、スレッドの関係のある<xref:System.Threading.Thread.BeginThreadAffinity%2A>、ロックを取得する前に、<xref:System.Threading.Thread.EndThreadAffinity%2A>ロックを解放した後。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。  
  
   
  
## Examples  
 次の例では、使用、<xref:System.Threading.Thread.BeginThreadAffinity%2A>と<xref:System.Threading.Thread.EndThreadAffinity%2A>メソッドのコード ブロックは、オペレーティング システムの物理スレッドの id に依存しているホストに通知します。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドが実行されている現在のコンテキストを取得します。</summary>
        <value>現在のスレッド コンテキストを表す <see cref="T:System.Runtime.Remoting.Contexts.Context" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのカルチャを取得または設定します。</summary>
        <value>現在のスレッドでカルチャを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Globalization.CultureInfo>と共にその関連付けられているオブジェクトでは、このプロパティによって返されるオブジェクトは、既定の日付の書式、時間、数値、通貨の値、テキストの順序を並べ替え、規則、大文字小文字の区別を特定し、文字列比較。 参照してください、<xref:System.Globalization.CultureInfo>クラスのカルチャの名前と識別子、インバリアント、中立、および特定のカルチャの違いについて説明し、スレッドとアプリケーション ドメインに影響を与える方法のカルチャ情報。 参照してください、<xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType>プロパティをスレッドの既定のカルチャを決定する方法と、ユーザーが自分のコンピューターのカルチャ情報を設定する方法について説明します。  

> [!IMPORTANT]
> <xref:System.Threading.Thread.CurrentCulture>プロパティは、現在のスレッド以外の任意のスレッドを使用すると確実に機能しません。 .NET framework のプロパティの読み取り、信頼性が高くはありませんが、現在のスレッド以外のスレッドを設定することです。 .NET Core で、<xref:System.InvalidOperationException>スレッドが読み取りまたは書き込みを試みる場合にスローされる、<xref:System.Threading.Thread.CurrentCulture>別のスレッドでのプロパティ。
> 使用することをお勧め、<xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType>プロパティを取得して、現在のカルチャを設定します。

 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、設定することができます、<xref:System.Threading.Thread.CurrentCulture%2A>ニュートラル カルチャのプロパティ。 これは、ための動作、<xref:System.Globalization.CultureInfo>クラスが変更された: ニュートラル カルチャで、プロパティの値を表す場合 (具体的には、 <xref:System.Globalization.CultureInfo.Calendar%2A>、 <xref:System.Globalization.CultureInfo.CompareInfo%2A>、 <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>、<xref:System.Globalization.CultureInfo.NumberFormat%2A>と<xref:System.Globalization.CultureInfo.TextInfo%2A>プロパティ) ようになりましたニュートラル カルチャに関連付けられている特定のカルチャを反映します。 .NET Framework の以前のバージョンで、<xref:System.Threading.Thread.CurrentCulture%2A>プロパティをスローしました、<xref:System.NotSupportedException>ニュートラル カルチャが割り当てられたときに例外。  
  
## Examples  
 次の例では、コントロール パネルで設定されているカルチャで表示する Windows フォーム アプリケーションのユーザー インターフェイス スレッドのステートメントを示します。 追加のコードが必要です。  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティが <see langword="null" /> に設定されています。</exception>
        <exception cref="T:System.InvalidOperationException">.NET Core のみ: 別のスレッドからのスレッドのカルチャの読み取りまたは書き込みはサポートされていません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">プロパティを設定します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ロールベースのセキュリティに関する、スレッドの現在のプリンシパルを取得または設定します。</summary>
        <value>セキュリティ コンテキストを表す <see cref="T:System.Security.Principal.IPrincipal" /> 値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、設定およびスレッドのプリンシパルを取得する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、プリンシパルの設定に必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">プリンシパル オブジェクトを操作します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在実行中のスレッドを取得します。</summary>
        <value>現在実行中のスレッドを表す <see cref="T:System.Threading.Thread" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、さらに 20 件の子タスクを作成するタスクを作成します。 それぞれのタスクとして、アプリケーション自体を呼び出す、`ShowThreadInformation`メソッドを使用して、<xref:System.Threading.Thread.CurrentThread%2A>プロパティが実行されているスレッドに関する情報を表示します。  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 各子タスクでは、1 から 1,000,000 まで 100万乱数を生成し、平均値を返します。 親タスクの呼び出し、<xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType>各タスクによって返される、平均値を表示する前に、子タスクが完了したことを確認する方法および手段の平均を計算します。  
  
 アプリケーションがフォア グラウンド スレッドで実行中にスレッド プールのスレッドで各タスクが実行に注意してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>実行時にカルチャ固有のリソースを検索するためにリソース マネージャーで使用される、現在のカルチャを取得または設定します。</summary>
        <value>現在のカルチャを表すオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 UI カルチャでは、アプリケーションがユーザーの入力と出力をサポートするために必要があるあり、既定では、オペレーティング システムのカルチャと同じリソースを指定します。 参照してください、<xref:System.Globalization.CultureInfo>クラスのカルチャの名前と識別子、インバリアント、中立、および特定のカルチャの違いについて説明し、スレッドとアプリケーション ドメインに影響を与える方法のカルチャ情報。 参照してください、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティをスレッドの既定 UI カルチャを決定する方法について説明します。  

> [!IMPORTANT]
> <xref:System.Threading.Thread.CurrentUICulture>プロパティは、現在のスレッド以外の任意のスレッドを使用すると確実に機能しません。 .NET framework のプロパティの読み取り、信頼性が高くはありませんが、現在のスレッド以外のスレッドを設定することです。 .NET Core で、<xref:System.InvalidOperationException>スレッドが読み取りまたは書き込みを試みる場合にスローされる、<xref:System.Threading.Thread.CurrentUICulture>別のスレッドでのプロパティ。
> 使用することをお勧め、<xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType>プロパティを取得して、現在のカルチャを設定します。

 <xref:System.Globalization.CultureInfo>ニュートラル カルチャは、このプロパティによって返されます。 ニュートラル カルチャは、メソッドなどの書式設定では使用できません<xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>、 <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>、および<xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>します。 使用して、 <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> 、特定のカルチャを取得または使用するメソッド、<xref:System.Threading.Thread.CurrentCulture%2A>プロパティ。  
  
> [!NOTE]
>  <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType>メソッドがスローされます<xref:System.ArgumentException>のニュートラル カルチャ"Zh-hant"("ZH-CHT") と"Zh-hans"("ZH-CHS")。  
  
   
  
## Examples  
 次の例では、現在のスレッド UI カルチャの言語がフランス語でかどうかを判断します。 そうでない場合、現在のスレッド UI カルチャが英語 (米国) に設定します。  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 次のコード例では、コントロール パネルで設定されているカルチャで表示する Windows フォームのユーザー インターフェイス スレッドのステートメントを示します。 追加のコードが必要です。  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">プロパティが <see langword="null" /> に設定されています。</exception>
        <exception cref="T:System.ArgumentException">プロパティが、リソース ファイルの検索に使用できないカルチャ名に設定されています。 リソース ファイル名に含めることができるのは、文字、数字、ハイフン、またはアンダースコアだけです。</exception>
        <exception cref="T:System.InvalidOperationException">.NET Core のみ: 別のスレッドからのスレッドのカルチャの読み取りまたは書き込みはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのランタイム呼び出し可能ラッパー (RCW: Runtime Callable Wrapper) の自動クリーンアップをオフにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定で、共通言語ランタイム (CLR) は自動的にクリーンアップするランタイム呼び出し可能ラッパー。 少数のアプリケーションの再入の問題が発生すると、クリーンアップ中に CLR ポンプ メッセージは、次の異常な条件を満たします。  
  
-   アプリケーションは、独自のメッセージ ポンプは。  
  
-   アプリケーションは、メッセージ ポンプが発生したときに正確に制御する必要があります。  
  
 このようなアプリケーションを使用できる、<xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A>メソッドを CLR が呼び出し可能ラッパーの実行時の自動回復を実行するを防ぐためにします。  
  
 このメソッドは、スレッドで呼び出されると、自動クリーンアップがそのスレッドに再度有効にすることはできません。 使用して、アプリケーションのランタイム呼び出し可能ラッパーをクリーンアップする準備ができたら、<xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType>現在のコンテキスト内のすべてのランタイム呼び出し可能ラッパーをクリーンアップするランタイムに指示するメソッド。 メッセージ ポンプは、メソッドの実行中に発生します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドの中止または処理されない例外の影響が現在のタスクだけに及ぶコード領域に実行が入ることをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 などの共通言語ランタイム (CLR) のホストには、コードの重要および重大でないリージョン内のエラーのさまざまなポリシーを確立できます。 クリティカル領域では、するスレッドの中止または処理されない例外の影響があります、現在のタスクに制限されています。 これに対し、中止または致命的でないコードの領域でエラーには、エラーが発生したタスクのみに影響します。  
  
 たとえば、ロックを保持しているときにメモリを割り当てようとするタスクを検討してください。 メモリの割り当てが失敗した場合がの安定性を確保するための十分な現在のタスクを中止していますが、 <xref:System.AppDomain>、同じロックを待機しているドメインを他のタスクにすることができますがあります。 現在のタスクが終了した場合は、その他のタスクがデッドロックでした。  
  
 全体をアンロードするホストがありますクリティカル領域で、障害が発生したときに<xref:System.AppDomain>可能性がある不安定な状態で実行を続けることのリスクを冒すよりもします。 コードがクリティカル領域を入力することをホストに通知をするために呼び出す<xref:System.Threading.Thread.BeginCriticalRegion%2A>します。 呼び出す<xref:System.Threading.Thread.EndCriticalRegion%2A>と重大でないコードの領域への実行を返します。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。  
  
   
  
## Examples  
 次の例では、使用、<xref:System.Threading.Thread.BeginCriticalRegion%2A>と<xref:System.Threading.Thread.EndCriticalRegion%2A>重要および重大でない地域コードのブロックに分割する方法。  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>マネージド コードが現在のオペレーティング システムの物理スレッドの ID に依存する命令の実行を完了したことをホストに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Microsoft SQL Server 2005 など、共通言語ランタイムの一部のホストでは、独自のスレッド管理を提供します。 独自のスレッド管理を提供するホストに移動できます実行中のタスク 1 つのオペレーティング システムの物理スレッドから別、いつでも。 ほとんどのタスクは、このを切り替えることでは受けません。 ただし、いくつかのタスクはスレッド アフィニティを設定する-は、オペレーティング システムの物理スレッドの id に依存します。 これらのタスクは、スイッチできないコードを実行するときをホストに通知する必要があります。  
  
 呼び出す必要がありますの例では、オペレーティング システムを取得する、アプリケーション呼び出しシステム API をロックする場合、Win32 CRITICAL_SECTION など、スレッドの関係のある<xref:System.Threading.Thread.BeginThreadAffinity%2A>、ロックを取得する前に、<xref:System.Threading.Thread.EndThreadAffinity%2A>ロックを解放した後。  
  
 SQL Server 2005 で実行されるコードでこのメソッドを使用するには、最上位のホストの保護レベルで実行されるコードが必要です。  
  
   
  
## Examples  
 次の例では、使用、<xref:System.Threading.Thread.BeginThreadAffinity%2A>と<xref:System.Threading.Thread.EndThreadAffinity%2A>メソッドのコード ブロックは、オペレーティング システムの物理スレッドの id に依存しているホストに通知します。  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのさまざまなコンテキストに関する情報を格納する <see cref="T:System.Threading.ExecutionContext" /> オブジェクトを取得します。</summary>
        <value>現在のスレッドのコンテキスト情報を統合する <see cref="T:System.Threading.ExecutionContext" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ExecutionContext>クラスは、実行の論理スレッドに関連するすべての情報の 1 つのコンテナーを提供します。 これには、セキュリティ コンテキスト、コンテキストを呼び出し、同期コンテキスト、ローカリゼーション コンテキスト、およびトランザクション コンテキストが含まれます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ガベージ コレクターが <see cref="T:System.Threading.Thread" /> を再利用しているときに、リソースが解放され、他のクリーンアップ操作が確実に実行されるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ガベージ コレクター<xref:System.Threading.Thread.Finalize%2A>と現在のオブジェクトが完了するを準備します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">解放されるデータ スロットの名前。</param>
        <summary>プロセス内のすべてのスレッドに関して、名前とスロットの関連付けを解除します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用して 2 つのメカニズムが用意されています: スレッド相対静的フィールド (でマークされているフィールドは、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットより優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)します。  
  
 いずれかのスレッドの呼び出し後`FreeNamedDataSlot`、他のスレッドを呼び出す<xref:System.Threading.Thread.GetNamedDataSlot%2A>と同じ名前は、名前に関連付けられた新しいスロットを割り当てます。 後続の呼び出し`GetNamedDataSlot`任意のスレッドでは、新しいスロットを返します。 ただし、任意のスレッドをまだ、<xref:System.LocalDataStoreSlot?displayProperty=nameWithType>を以前の呼び出しによって返される`GetNamedDataSlot`を引き続き古いスロットを使用できます。  
  
 名前と関連付けられているスロットがリリースされた場合にのみすべて`LocalDataStoreSlot`への呼び出しの前に取得された`FreeNamedDataSlot`リリースされ、ガベージ コレクションします。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ メカニズムを使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができますが、格納および取得するデータ スロットの値し、スレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 他のスレッド (子スレッドであっても) はそのデータを取得できません。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、同じことを行うデータ スロットを使用する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持するためにします。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アパートメント状態を示す <see cref="T:System.Threading.ApartmentState" /> 値を返します。</summary>
        <returns>マネージド スレッドのアパートメント状態を示す <see cref="T:System.Threading.ApartmentState" /> 値の 1 つ。 既定値は、<see cref="F:System.Threading.ApartmentState.Unknown" /> です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、と共に、<xref:System.Threading.Thread.SetApartmentState%2A>メソッドと<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッド、置換、<xref:System.Threading.Thread.ApartmentState%2A>プロパティ。  
  
   
  
## Examples  
 次のコード例に示します、 <xref:System.Threading.Thread.GetApartmentState%2A>、 <xref:System.Threading.Thread.SetApartmentState%2A>、および<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッド。 このコード例では、スレッドを作成します。 スレッドを開始すると、前に<xref:System.Threading.Thread.GetApartmentState%2A>初期表示<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>状態と<xref:System.Threading.Thread.SetApartmentState%2A>状態に変更します<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>します。 <xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドが戻ります`false`に状態を変更しようとしています。<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>アパートメント状態が既に設定されているためです。 場合は、同じ操作で<xref:System.Threading.Thread.SetApartmentState%2A>、<xref:System.InvalidOperationException>がスローされました。  
  
 スレッドを開始した後、<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドは、もう一度使用します。 これは、ときにスローします<xref:System.Threading.ThreadStateException>スレッドが既に開始されています。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのスタックをキャプチャするために使用できる <see cref="T:System.Threading.CompressedStack" /> オブジェクトを返します。</summary>
        <returns>なし。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはサポートされなくなりました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">常にスローします。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot">値の取得元の <see cref="T:System.LocalDataStoreSlot" />。</param>
        <summary>現在のスレッドの現在のドメイン内で指定した現在のスレッドのスロットから値を取得します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>取得された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用して 2 つのメカニズムが用意されています: スレッド相対静的フィールド (でマークされているフィールドは、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットより優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)します。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ メカニズムを使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができますが、格納および取得するデータ スロットの値し、スレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 他のスレッド (子スレッドであっても) はそのデータを取得できません。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.GetData%2A> `Shared`別のスレッドを参照する変数を使用してメソッドを呼び出す場合でも常に、現在実行中のスレッドに適用されるメソッド。 混乱を回避するには、クラス名を呼び出すときに使用`Shared`メソッド:`Dim test As Object = Thread.GetData(testSlot)`します。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、同じことを行うデータ スロットを使用する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持するためにします。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、スレッド固有の情報を格納するデータ スロットを使用する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドが実行されている現在のドメインを返します。</summary>
        <returns>実行中のスレッドの現在のアプリケーション ドメインを表す <see cref="T:System.AppDomain" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例の ID と名前を取得する方法を示しています、`AppDomain`でスレッドが実行されています。  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>一意のアプリケーション ドメイン識別子を返します。</summary>
        <returns>アプリケーション ドメインを一意に識別する 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例の ID と名前を取得する方法を示しています、`AppDomain`でスレッドが実行されています。  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのハッシュ コードを返します。</summary>
        <returns>整数ハッシュ コード値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハッシュ コードは、一意であることは保証されません。 使用して、<xref:System.Threading.Thread.ManagedThreadId%2A>マネージ スレッドの一意の識別子が必要な場合のプロパティ。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">ローカル データ スロットの名前。</param>
        <summary>名前付きデータ スロットを検索します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <returns>このスレッドに割り当てられた <see cref="T:System.LocalDataStoreSlot" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用して 2 つのメカニズムが用意されています: スレッド相対静的フィールド (でマークされているフィールドは、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットより優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)します。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ メカニズムを使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができますが、格納および取得するデータ スロットの値し、スレッドの有効期限が切れた後に再利用するため、スロットを解放します。 データ スロットは、スレッドごとに一意です。 他のスレッド (子スレッドであっても) はそのデータを取得できません。  
  
 名前付きスロットが存在しない場合は、新しいスロットが割り当てられます。 名前付きデータ スロットをパブリックにしてすべてのユーザーによって操作されることができます。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、同じことを行うデータ スロットを使用する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持するためにします。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see langword="WaitSleepJoin" /> スレッド状態のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このスレッドが待機、スリープ、または結合状態で現在ブロックされていない場合は、次にブロックを開始すると中断されます。  
  
 <xref:System.Threading.ThreadInterruptedException> 中断されたスレッドでは、スレッドがブロックまでがスローされます。 スレッドがブロックされない場合、例外がスローされず、そのため、スレッドが中断されることがなく完了ことがあります。  
  
   
  
## Examples  
 次のコード例が中断され、その後がブロックされたときに、実行中のスレッドの動作を示します。  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドでの高度な操作。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">スレッドの一時中断および中断</related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">マネージド スレッドの状態</related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの実行ステータスを示す値を取得します。</summary>
        <value>このスレッドが起動されて、正常終了していないまたは中止されていない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドがバックグラウンド スレッドであるかどうかを示す値を取得または設定します。</summary>
        <value>このスレッドがバックグラウンド スレッドである場合またはバックグラウンド スレッドになる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、バック グラウンド スレッドまたはフォア グラウンド スレッドのいずれかです。 バック グラウンド スレッドが妨げられないプロセスを終了する点を除いて、バック グラウンド スレッドはフォア グラウンド スレッドと同じです。 プロセスに属するすべてのフォア グラウンド スレッドが終了すると、共通言語ランタイム プロセスを終了します。 残りのバック グラウンド スレッドはすべて、その実行しないでください。  
  
 既定では、次のスレッドはフォア グラウンドで実行 (つまり、その<xref:System.Threading.Thread.IsBackground%2A>プロパティが返す`false`)。  
  
-   プライマリ スレッド (またはメイン アプリケーション スレッド)。  
  
-   呼び出すことによって作成されたすべてのスレッドを<xref:System.Threading.Thread>クラスのコンス トラクター。  
  
 既定では、次のスレッドがバック グラウンドで実行 (つまり、その<xref:System.Threading.Thread.IsBackground%2A>プロパティが返す`true`)。  
  
-   ランタイムによって管理されるワーカー スレッドのプールはプールのスレッドをスレッドです。 使用してスレッド プール スレッドでスレッド プールとスケジュールの作業を構成することができます、<xref:System.Threading.ThreadPool>クラス。  
  
    > [!NOTE]
    >  タスク ベースの非同期操作は、スレッド プールのスレッドで自動的に実行します。  
  
-   アンマネージ コードからマネージ実行環境に入るすべてのスレッド。  
  
   
  
## Examples  
 次の例では、フォア グラウンドとバック グラウンド スレッドの動作を比較します。 フォア グラウンド スレッドとバック グラウンド スレッドを作成します。 フォア グラウンド スレッドはまでを実行しているプロセスが完了すると、`for`ループを終了します。 ただし、フォア グラウンド スレッドの実行が完了するための出力の例に示す、バック グラウンド スレッドの実行が完了する前に、のプロセスでは終了します。  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが停止しています。</exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md">フォアグラウンド スレッドとバックグラウンド スレッド</related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドがマネージド スレッド プールに所属しているかどうかを示す値を取得します。</summary>
        <value>このスレッドがマネージド スレッド プールに所属している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。[マネージ スレッド プール](~/docs/standard/threading/the-managed-thread-pool.md)します。  
  
   
  
## Examples  
 次のコード例では、スレッドがスレッド プールからかどうかを判断する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">マネージド スレッド プール</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このインスタンスが表すスレッドが終了するまで、呼び出し元のスレッドをブロックします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスが表すスレッドが終了するまで、呼び出し元のスレッドをブロックします。標準 COM および <see langword="SendMessage" /> ポンピングの実行は継続されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%2A> スレッドまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドですが<xref:System.Threading.Thread.Join%2A>メソッドが呼び出されますが完了します。 このメソッドを使用すると、スレッドが終了されたことを確認します。 スレッドが終了しない場合、呼び出し元が無期限にブロックされます。 次の例では、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、原因となる`Thread1`までブロックする`Thread2`が完了します。  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 場合は、スレッドが終了とき既に<xref:System.Threading.Thread.Join%2A>と呼ばれるメソッドをすぐに返します。  
  
> [!WARNING]
>  呼び出さないようにする必要があります、<xref:System.Threading.Thread.Join%2A>のメソッド、<xref:System.Threading.Thread>現在のスレッドからの現在のスレッドを表すオブジェクト。 これにより、現在のスレッドは自身に無期限に待機するためにハングするアプリ  
  
 このメソッドを含めるには、呼び出し元のスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>します。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>状態。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">呼び出し元が、<see cref="F:System.Threading.ThreadState.Unstarted" /> 状態のスレッドを結合しようとしました。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">スレッドが待機中に中断されます。</exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">マネージド スレッドの状態</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">スレッドが終了するまでの待機時間を表すミリ秒数。</param>
        <summary>このインスタンスが表すスレッドが終了するまで、または指定された時間が経過するまで、呼び出し元のスレッドをブロックします。標準 COM/SendMessage ポンピングの実行は継続されます。</summary>
        <returns>スレッドが終了した場合は <see langword="true" />。<paramref name="millisecondsTimeout" /> パラメーターで指定した時間が経過してもスレッドが終了していない場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.Int32%29> いずれかのスレッドまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドが<xref:System.Threading.Thread.Join%2A>メソッドが呼び出されますが完了またはタイムアウト間隔が経過しました。 次の例では、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、原因となる`Thread1`までのいずれかをブロックする`Thread2`が完了したか、2 秒が経過しました。  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 場合<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>が指定されて、`millisecondsTimeout`パラメーターでは、このメソッドの動作、<xref:System.Threading.Thread.Join>メソッド オーバー ロードで戻り値を除く。  
  
 場合は、スレッドが終了とき既に<xref:System.Threading.Thread.Join%2A>と呼ばれるメソッドをすぐに返します。  
  
 このメソッドを含めるには、呼び出し元のスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>します。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>状態。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> の値が負で、ミリ秒単位の <see cref="F:System.Threading.Timeout.Infinite" /> と等しくありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが起動されていません。</exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">マネージド スレッドの状態</related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">スレッドが終了するのを待機する時間に設定される <see cref="T:System.TimeSpan" />。</param>
        <summary>このインスタンスが表すスレッドが終了するまで、または指定された時間が経過するまで、呼び出し元のスレッドをブロックします。標準 COM/SendMessage ポンピングの実行は継続されます。</summary>
        <returns>スレッドが終了した場合は <see langword="true" />。<paramref name="timeout" /> パラメーターで指定した時間が経過してもスレッドが終了していない場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.Join%28System.TimeSpan%29> いずれかのスレッドまで (つまり、メソッドを呼び出すスレッド) の呼び出し元のスレッドをブロックする同期メソッドが<xref:System.Threading.Thread.Join%2A>メソッドが呼び出されますが完了またはタイムアウト間隔が経過しました。 次の例では、`Thread1`スレッドの呼び出し、<xref:System.Threading.Thread.Join>メソッドの`Thread2`、原因となる`Thread1`までのいずれかをブロックする`Thread2`が完了したか、2 秒が経過しました。  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 場合<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>が指定されて`timeout`、このメソッドの動作、<xref:System.Threading.Thread.Join>メソッド オーバー ロードで戻り値を除く。  
  
 場合は、スレッドが終了とき既に<xref:System.Threading.Thread.Join%2A>と呼ばれるメソッドをすぐに返します。  
  
 このメソッドを含めるには、現在のスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin>します。 呼び出すことはできません`Join`内にあるスレッドで、<xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType>状態。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します、`TimeSpan`値を`Join`メソッド。  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> の値が負で、ミリ秒単位の <see cref="F:System.Threading.Timeout.Infinite" /> と等しくないか、または <see cref="F:System.Int32.MaxValue" /> ミリ秒より大きいです。</exception>
        <exception cref="T:System.Threading.ThreadStateException">呼び出し元が、<see cref="F:System.Threading.ThreadState.Unstarted" /> 状態のスレッドを結合しようとしました。</exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">マネージド スレッドの状態</related>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のマネージド スレッドの一意の識別子を取得します。</summary>
        <value>このマネージド スレッドの一意の識別子を表す整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドの<xref:System.Threading.Thread.ManagedThreadId%2A>プロパティの値がそのプロセス内でそのスレッドを一意に識別するために使用します。  
  
 値、<xref:System.Threading.Thread.ManagedThreadId%2A>プロパティでは、共通言語ランタイムをホストするアンマネージ コードは、ファイバーとスレッドを実装している場合でも、時間の経過と共に変化しません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メモリ アクセスを同期します。現在のスレッドを実行中のプロセッサは、<see cref="M:System.Threading.Thread.MemoryBarrier" /> を呼び出す前のメモリ アクセスを <see cref="M:System.Threading.Thread.MemoryBarrier" /> の呼び出し後のメモリ アクセス以降に実行するように命令を並べ替えることはできなくなります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.MemoryBarrier%2A> (複数の Intel Itanium プロセッサを使用するシステムなど) の順序付け脆弱なメモリ型マルチプロセッサ システムにのみ必要です。  
  
 ほとんどの場合、c#、`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、または<xref:System.Threading.Monitor>クラスは、簡単にデータを同期する方法を提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドの名前を取得または設定します。</summary>
        <value>スレッドの名前を含む文字列。名前が設定されていない場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは書き込み-とします。 のスレッドの既定値<xref:System.Threading.Thread.Name%2A>プロパティは`null`、かどうか、名前が既に明示的に割り当てられて、スレッドと比較して確認できます`null`します。  
  
 割り当てられた文字列、<xref:System.Threading.Thread.Name%2A>プロパティは、任意の Unicode 文字を含めることができます。  
  
   
  
## Examples  
 次の例では、スレッドに名前を付ける方法を示します。  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">設定操作が要求されましたが、<see langword="Name" /> プロパティは既に設定されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドのスケジューリング優先順位を示す値を取得または設定します。</summary>
        <value><see cref="T:System.Threading.ThreadPriority" /> 値のいずれか。 既定値は <see cref="F:System.Threading.ThreadPriority.Normal" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の優先順位のいずれかのスレッドを割り当てることができる<xref:System.Threading.ThreadPriority>値。  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 オペレーティング システムは、スレッドの優先度を優先する必要はありません。  
  
   
  
## Examples  
 次の例では、スレッドの優先度の変更の結果を示します。 3 つのスレッドが作成されると、1 つのスレッドの優先順位に設定されて<xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>とに 1 秒あたりの優先順位が設定されて<xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>します。 各スレッド内の変数をインクリメントする、`while`ループと、設定時間実行されます。  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが <see cref="F:System.Threading.ThreadState.Aborted" /> などの最終状態に達しています。</exception>
        <exception cref="T:System.ArgumentException">設定操作として指定した値が、無効な <see cref="T:System.Threading.ThreadPriority" /> 値です。</exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md">スレッドのスケジューリング</related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドに対して要求された <see cref="M:System.Threading.Thread.Abort(System.Object)" /> をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、適切なアクセス許可を持つコードによってのみ呼び出すことができます。  
  
 呼び出しはに対して行われた場合`Abort`、スレッドを終了するには、システムがスローされます、<xref:System.Threading.ThreadAbortException>します。 `ThreadAbortException` アプリケーションのコードでキャッチできますが catch ブロックの最後に再スローされる場合を除き、特別な例外は、`ResetAbort`が呼び出されます。 `ResetAbort` 中止するには要求をキャンセルできず、`ThreadAbortException`のスレッドを終了します。  
  
 参照してください<xref:System.Threading.ThreadAbortException>呼び出し元を示す例については、`ResetAbort`メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <exception cref="T:System.Threading.ThreadStateException"><see langword="Abort" /> が、現在のスレッドで呼び出されませんでした。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、現在のスレッドに必要なセキュリティ アクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドでの高度な操作。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> (関連する列挙体)</permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md">スレッドの破棄</related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">マネージド スレッドの状態</related>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>中断されたスレッドを再開します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  使用しないでください、<xref:System.Threading.Thread.Suspend%2A>と<xref:System.Threading.Thread.Resume%2A>のスレッドのアクティビティを同期する方法。 中断した場合、スレッドは、どのようなコードを実行するかを知ることがあるありません。 内の他のスレッドのセキュリティ権限の評価中にロックを保持している間にスレッドを中断した場合、<xref:System.AppDomain>ブロックされる可能性があります。 内の他のスレッド クラスのコンス トラクターが実行中にスレッドを中断した場合、<xref:System.AppDomain>クラスがブロックされていることを使用しようとします。 デッドロックは、非常に簡単に発生することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが、起動されていない、停止している、または中断されていない状態です。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドでの高度な操作。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">スレッドの一時中断および中断</related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">マネージド スレッドの状態</related>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">新しいアパートメント状態。</param>
        <summary>スレッドを開始する前にスレッドのアパートメント状態を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいスレッドとして初期化された<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>の開始される前に、そのアパートメント状態が設定されていない場合。 スレッドを開始する前に、アパートメント状態を設定する必要があります。  
  
> [!NOTE]
>  メイン アプリケーション スレッドに初期化<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>既定。 メイン アプリケーション スレッドのアパートメント状態を設定する唯一の方法<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>が適用される、<xref:System.STAThreadAttribute>エントリ ポイント メソッドに属性します。  
  
 <xref:System.Threading.Thread.SetApartmentState%2A>メソッドと共に、<xref:System.Threading.Thread.GetApartmentState%2A>メソッドと<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッド、置換、<xref:System.Threading.Thread.ApartmentState%2A>プロパティ。  
  
   
  
## Examples  
 次のコード例に示します、 <xref:System.Threading.Thread.GetApartmentState%2A>、 <xref:System.Threading.Thread.SetApartmentState%2A>、および<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッド。 このコード例では、スレッドを作成します。 スレッドを開始すると、前に<xref:System.Threading.Thread.GetApartmentState%2A>初期表示<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>状態と<xref:System.Threading.Thread.SetApartmentState%2A>状態に変更します<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>します。 <xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドが戻ります`false`に状態を変更しようとしています。<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>アパートメント状態が既に設定されているためです。 場合は、同じ操作で<xref:System.Threading.Thread.SetApartmentState%2A>、<xref:System.InvalidOperationException>がスローされました。  
  
 スレッドを開始した後、<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドは、もう一度使用します。 これは、ときにスローします<xref:System.Threading.ThreadStateException>スレッドが既に開始されています。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: macOS および Linux プラットフォームでは、このメンバーはサポートされていません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="state" /> が有効なアパートメント状態ではありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に起動しています。</exception>
        <exception cref="T:System.InvalidOperationException">アパートメント状態は既に初期化されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack">現在のスレッドに適用される <see cref="T:System.Threading.CompressedStack" /> オブジェクト。</param>
        <summary>キャプチャした <see cref="T:System.Threading.CompressedStack" /> を現在のスレッドに適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはサポートされなくなりました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">常にスローします。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot">値を設定する <see cref="T:System.LocalDataStoreSlot" />。</param>
        <param name="data">設定される値です。</param>
        <summary>現在実行中のスレッド上にある指定されたスロット内のデータを、そのスレッドの現在のドメインに設定します。 パフォーマンスを向上させるためには、<see cref="T:System.ThreadStaticAttribute" /> 属性でマークされたフィールドを代わりに使用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework には、スレッド ローカル ストレージ (TLS) を使用して 2 つのメカニズムが用意されています: スレッド相対静的フィールド (でマークされているフィールドは、<xref:System.ThreadStaticAttribute>属性) とデータ スロット。 スレッド相対静的フィールドは、データ スロットより優れたパフォーマンスを提供し、コンパイル時の型チェックを有効にします。 詳細については、TLS を使用して、次を参照してください。[スレッド ローカル ストレージ: スレッド相対静的フィールドとデータ スロット](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md)します。  
  
 スレッドは、スレッド固有のデータを格納するのにローカル ストアのメモリ メカニズムを使用します。 共通言語ランタイムは、作成時に、各プロセスにマルチ スロットのデータ ストア配列を割り当てます。 スレッドは、データ ストア内のデータ スロットを割り当てることができます、格納および取得するデータ スロットの値し、スレッド プロシージャの終了後に再利用するため、スロットを解放し、<xref:System.Threading.Thread>オブジェクトがガベージ コレクションによって解放されました。 データ スロットは、スレッドごとに一意です。 他のスレッド (子スレッドであっても) はそのデータを取得できません。  
  
> [!NOTE]
>  <xref:System.Threading.Thread.SetData%2A> `Shared`別のスレッドを参照する変数を使用してメソッドを呼び出す場合でも常に、現在実行中のスレッドに適用されるメソッド。 混乱を回避するには、クラス名を呼び出すときに使用`Shared`メソッド:`Thread.SetData(testSlot, "test data")`します。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例でマークされているフィールドを使用する方法を示しています、<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持する属性。 2 番目の例では、同じことを行うデータ スロットを使用する方法を示します。  
  
 **最初の例**  
  
 次の例でマークされているフィールドを使用する方法を示します<xref:System.ThreadStaticAttribute>スレッド固有の情報を保持するためにします。 この手法は、2 番目の例で示す方法よりも優れたパフォーマンスを提供します。  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 **2 番目の例**  
  
 次の例では、名前付きデータ スロットを使用して、スレッド固有の情報を格納する方法を示します。  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md">スレッド ローカル ストレージ : スレッド相対静的フィールドとデータ スロット</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した時間の長さにわたって現在のスレッドを中断します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">スレッドが中断ブロックされるミリ秒数。 <paramref name="millisecondsTimeout" /> 引数の値が 0 である場合は、スレッドは自らのタイム スライスの残りの部分を放棄し、実行する準備ができている同じ優先順位の他のスレッドに渡します。 優先順位が同じで実行する準備ができている他のスレッドが存在しない場合は、現在のスレッドの実行は中断されません。</param>
        <summary>指定したミリ秒数の間現在のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、指定した時間、オペレーティング システムでの実行スケジュールされません。 このメソッドに含めるスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin>します。  
  
 指定できる<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>の`millisecondsTimeout`を無期限にスレッドを中断するパラメーター。 他に使用すること勧めただし、<xref:System.Threading?displayProperty=nameWithType>などのクラス<xref:System.Threading.Mutex>、 <xref:System.Threading.Monitor>、 <xref:System.Threading.EventWaitHandle>、または<xref:System.Threading.Semaphore>代わりに同期のスレッドにまたはリソースを管理します。  
  
 特定のレートでシステム クロックのティックには、時計の解像度が呼び出されます。 実際のタイムアウトできない可能性があります正確に指定されたタイムアウトを指定したタイムアウト時間を調整してクロック ティックと一致しているためです。 時計の解像度と待機時間の詳細については、次を参照してください。、[関数をスリープ状態](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)トピック。 このメソッドは、[関数をスリープ状態](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx)から、Windows システム Api。  
  
 このメソッドは、標準の COM および 1 つは実行されません。  
  
> [!NOTE]
>  かどうか必要のあるスレッドでスリープ状態を<xref:System.STAThreadAttribute>、標準の COM および 1 つの実行のオーバー ロードのいずれかの使用を検討するには、<xref:System.Threading.Thread.Join%2A>タイムアウト間隔を指定するメソッド。  
  
   
  
## Examples  
 次の例では、<xref:System.Threading.Thread.Sleep%2A>メソッドは、アプリケーションのメイン スレッドをブロックします。  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">タイムアウト値が負か、<see cref="F:System.Threading.Timeout.Infinite" /> と等しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">スレッドが中断される時間の長さ。 <paramref name="millisecondsTimeout" /> 引数の値が <see cref="F:System.TimeSpan.Zero" /> である場合は、スレッドは自らのタイム スライスの残りの部分を放棄し、実行する準備ができている同じ優先順位の他のスレッドに渡します。 優先順位が同じで実行する準備ができている他のスレッドが存在しない場合は、現在のスレッドの実行は中断されません。</param>
        <summary>指定した時間の長さにわたって現在のスレッドを中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、指定した時間、オペレーティング システムでの実行スケジュールされません。 このメソッドに含めるスレッドの状態を変更する<xref:System.Threading.ThreadState.WaitSleepJoin>します。  
  
 指定できる<xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType>の`timeout`を無期限にスレッドを中断するパラメーター。 他に使用すること勧めただし、<xref:System.Threading?displayProperty=nameWithType>などのクラス<xref:System.Threading.Mutex>、 <xref:System.Threading.Monitor>、 <xref:System.Threading.EventWaitHandle>、または<xref:System.Threading.Semaphore>代わりに同期のスレッドにまたはリソースを管理します。  
  
 このオーバー ロード<xref:System.Threading.Thread.Sleep%2A>で整数のミリ秒単位の合計数を使用して`timeout`します。 小数ミリ秒は破棄されます。  
  
 このメソッドは、標準の COM および 1 つは実行されません。  
  
> [!NOTE]
>  かどうか必要のあるスレッドでスリープ状態を<xref:System.STAThreadAttribute>、標準の COM および 1 つの実行のオーバー ロードのいずれかの使用を検討するには、<xref:System.Threading.Thread.Join%2A>タイムアウト間隔を指定するメソッド。  
  
   
  
## Examples  
 次の例では、 <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> 2 秒ごとに 5 回、アプリケーションのメイン スレッドをブロックするメソッドのオーバー ロードします。  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> の値が負で、ミリ秒単位の <see cref="F:System.Threading.Timeout.Infinite" /> と等しくないか、または <see cref="F:System.Int32.MaxValue" /> ミリ秒より大きいです。</exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations">スレッドが待機する時間を定義する 32 ビット符号付き整数。</param>
        <summary>スレッドを <paramref name="iterations" /> パラメーターで定義した時間の間待機させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.SpinWait%2A>メソッドはロックを実装するために役立ちます。 などの .NET framework では、クラス<xref:System.Threading.Monitor>と<xref:System.Threading.ReaderWriterLock>、このメソッドを内部的に使用します。 <xref:System.Threading.Thread.SpinWait%2A> で指定されたループ カウントを非常に短いループに、プロセッサが本質的には、`iterations`パラメーター。 そのため、待機時間は、プロセッサの速度に依存します。  
  
 これと対照的に、<xref:System.Threading.Thread.Sleep%2A>メソッド。 呼び出すスレッド<xref:System.Threading.Thread.Sleep%2A>指定した間隔が 0 の場合でも、プロセッサ時間の現在のスライスの残りの部分を生成します。 0 以外の間隔を指定する<xref:System.Threading.Thread.Sleep%2A>時間間隔が経過するまでスレッドをスレッド スケジューラによって考慮の対象から削除します。  
  
 <xref:System.Threading.Thread.SpinWait%2A> 通常のアプリケーションの一般的に便利ではありません。 ほとんどの場合、.NET Framework で提供される同期クラスを使用する必要があります。たとえば、呼び出す<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>またはラップするステートメント<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>(`lock` (C#) または`SyncLock`Visual Basic で)。  
  
> [!CAUTION]
>  まれなケースがわかっている場合、状態の変化が迫っていないかなどのコンテキスト スイッチを回避するへの呼び出しを行い、<xref:System.Threading.Thread.SpinWait%2A>ループ内のメソッド。 コード<xref:System.Threading.Thread.SpinWait%2A>実行は複数のプロセッサを搭載したコンピューターで発生する可能性がある問題を防ぐために設計されています。 たとえば、ハイパー スレッディング テクノロジを使用して複数の Intel プロセッサを搭載したコンピューター上<xref:System.Threading.Thread.SpinWait%2A>特定の状況でプロセッサの枯渇を防止します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>スレッドの実行をスケジュールします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オペレーティング システムによって、現在のインスタンスの状態を <see cref="F:System.Threading.ThreadState.Running" /> に変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが開始すると、<xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>状態では、オペレーティング システムを使用すると実行をスケジュールできます。 スレッドがによって表されるメソッドの最初の行で実行を開始、<xref:System.Threading.ThreadStart>または<xref:System.Threading.ParameterizedThreadStart>スレッド コンス トラクターに提供されるデリゲート。 なお、呼び出し<xref:System.Threading.Thread.Start%2A>呼び出し元のスレッドをブロックしません。  
  
> [!NOTE]
>  使用して作成されたスレッドでこのオーバー ロードを使用するかどうか、<xref:System.Threading.ParameterizedThreadStart>デリゲート`null`スレッドによって実行されるメソッドに渡されます。  
  
 スレッドが終了すると、別の呼び出しでは再開できません`Start`します。  
  
   
  
## Examples  
 次の例では、作成し、スレッドを開始します。  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に起動しています。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリが不足しているため、このスレッドを起動できません。</exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">スレッドおよびスレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">スレッドを作成し、開始時にデータを渡す</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter">スレッドが実行するメソッドで使用するデータを格納するオブジェクト。</param>
        <summary>オペレーティング システムによって現在のインスタンスの状態が <see cref="F:System.Threading.ThreadState.Running" /> に変更され、オプションでスレッドが実行するメソッドで使用するデータを格納するオブジェクトが提供されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが開始すると、<xref:System.Threading.ThreadState.Running?displayProperty=nameWithType>状態では、オペレーティング システムを使用すると実行をスケジュールできます。 スレッドがによって表されるメソッドの最初の行で実行を開始、<xref:System.Threading.ThreadStart>または<xref:System.Threading.ParameterizedThreadStart>スレッド コンス トラクターに提供されるデリゲート。 なお、呼び出し<xref:System.Threading.Thread.Start%2A>呼び出し元のスレッドをブロックしません。  
  
 スレッドが終了すると、別の呼び出しでは再開できません`Start`します。  
  
 このオーバー ロードと<xref:System.Threading.ParameterizedThreadStart>デリゲートをしやすく、スレッド プロシージャにデータを渡す、手法、タイプ セーフであるためは任意のオブジェクトは、このオーバー ロードに渡すことができます。 データをスレッド プロシージャに渡すより堅牢な方法は、ワーカーのオブジェクトにデータ フィールドとスレッド プロシージャの両方を格納します。 詳細については、次を参照してください。[スレッドの作成と開始時にデータを渡す](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md)します。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Threading.ParameterizedThreadStart>静的メソッドとインスタンス メソッドを持つデリゲート。  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に起動しています。</exception>
        <exception cref="T:System.OutOfMemoryException">メモリ不足のため、このスレッドを開始できません。</exception>
        <exception cref="T:System.InvalidOperationException">このスレッドは、<see cref="T:System.Threading.ThreadStart" /> デリゲートではなく、<see cref="T:System.Threading.ParameterizedThreadStart" /> デリゲートを使用して作成されています。</exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md">スレッドの作成</related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>スレッドを中断します。スレッドが既に中断されている場合は無効です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドが既に中断されている場合は、このメソッドに影響はありません。  
  
> [!CAUTION]
>  使用しないでください、<xref:System.Threading.Thread.Suspend%2A>と<xref:System.Threading.Thread.Resume%2A>のスレッドのアクティビティを同期する方法。 中断した場合、スレッドは、どのようなコードを実行するかを知ることがあるありません。 内の他のスレッドのセキュリティ権限の評価中にロックを保持している間にスレッドを中断した場合、<xref:System.AppDomain>ブロックされる可能性があります。 内の他のスレッド クラスのコンス トラクターが実行中にスレッドを中断した場合、<xref:System.AppDomain>クラスがブロックされていることを使用しようとします。 デッドロックは、非常に簡単に発生することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">.NET Core のみ: このメンバーはサポートされていません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが起動されていないか、停止しています。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、適切な <see cref="T:System.Security.Permissions.SecurityPermission" /> がありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">スレッドでの高度な操作。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /> (関連する列挙体)</permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md">スレッドの一時中断および中断</related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">マネージド スレッドの状態</related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来利用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetIDsOfNames`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトによって提供される型情報インターフェイスの数を受け取る場所へのポインター。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetTypeInfoCount`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来利用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::Invoke`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの状態を示す値を取得します。</summary>
        <value>現在のスレッドの状態を示す <see cref="T:System.Threading.ThreadState" /> 値の 1 つ。 初期値は <see langword="Unstarted" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.ThreadState%2A>プロパティよりも詳細な情報を提供する、<xref:System.Threading.Thread.IsAlive%2A>プロパティ。  
  
> [!IMPORTANT]
>  スレッドの状態のみがデバッグ シナリオで重要です。 スレッドの動作を同期化する目的でコード内でスレッドの状態を使用しないでください。  
  
   
  
## Examples  
 次のコード例に示しますへのアクセス、`ThreadState`スレッドの。  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md">マネージド スレッドの状態</related>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state">新しいアパートメント状態。</param>
        <summary>スレッドを開始する前にスレッドのアパートメント状態を設定します。</summary>
        <returns>アパートメント状態が設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しいスレッドとして初期化された<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>の開始される前に、そのアパートメント状態が設定されていない場合。 スレッドを開始する前に、アパートメント状態を設定する必要があります。  
  
> [!NOTE]
>  メイン アプリケーション スレッドに初期化<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>既定。 メイン アプリケーション スレッドのアパートメント状態を設定する唯一の方法<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>が適用される、<xref:System.STAThreadAttribute>エントリ ポイント メソッドに属性します。  
  
 <xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドと共に、<xref:System.Threading.Thread.GetApartmentState%2A>メソッドと<xref:System.Threading.Thread.SetApartmentState%2A>メソッド、置換、<xref:System.Threading.Thread.ApartmentState%2A>プロパティ。  
  
   
  
## Examples  
 次のコード例に示します、 <xref:System.Threading.Thread.GetApartmentState%2A>、 <xref:System.Threading.Thread.SetApartmentState%2A>、および<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッド。 このコード例では、スレッドを作成します。 スレッドを開始すると、前に<xref:System.Threading.Thread.GetApartmentState%2A>初期表示<xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType>状態と<xref:System.Threading.Thread.SetApartmentState%2A>状態に変更します<xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>します。 <xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドが戻ります`false`に状態を変更しようとしています。<xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType>アパートメント状態が既に設定されているためです。 場合は、同じ操作で<xref:System.Threading.Thread.SetApartmentState%2A>、<xref:System.InvalidOperationException>がスローされました。  
  
 スレッドを開始した後、<xref:System.Threading.Thread.TrySetApartmentState%2A>メソッドは、もう一度使用します。 これは、ときにスローします<xref:System.Threading.ThreadStateException>スレッドが既に開始されています。  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="state" /> が有効なアパートメント状態ではありません。</exception>
        <exception cref="T:System.Threading.ThreadStateException">スレッドが既に起動しています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address">読み取られるフィールド。</param>
        <summary>フィールドの値を読み取ります。 この値は、プロセッサの数やプロセッサ キャッシュの状態にかかわらず、コンピューター内のいずれかのプロセッサによって書き込まれた最新の値です。</summary>
        <returns>いずれかのプロセッサによってフィールドに書き込まれた最新の値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileRead%2A>いずれかのプロセッサによってメモリ位置に書き込まれた最新の値を取得します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address">値を書き込むフィールド。</param>
        <param name="value">書き込む値。</param>
        <summary>値をフィールドにすぐに書き込みます。値はコンピューター内のすべてのプロセッサに対して可視になります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Thread.VolatileRead%2A> <xref:System.Threading.Thread.VolatileWrite%2A>は、同期の特殊なケースです。 通常の状況で、c#`lock`ステートメントでは、Visual Basic`SyncLock`ステートメント、および<xref:System.Threading.Monitor>クラスは、簡単な代替手段を提供します。  
  
 マルチプロセッサ システムで<xref:System.Threading.Thread.VolatileWrite%2A>メモリ位置に書き込まれた値がすべてのプロセッサにすぐに表示することを確認します。 これにより、プロセッサのキャッシュのフラッシュが必要があります。  
  
 ユニプロセッサ システムでは、上であっても<xref:System.Threading.Thread.VolatileRead%2A>と<xref:System.Threading.Thread.VolatileWrite%2A>値の読み取りまたはメモリ、書き込みし、(たとえば、プロセッサのレジスタ) にキャッシュされていないことを確認します。 したがって、別のスレッドによって、またはハードウェアによって更新可能なフィールドへのアクセスを同期するのにことを使用することができます。  
  
 このメソッドを呼び出すと、1 つのメモリ アクセスのみが影響します。 フィールドの効果的な同期を提供する、フィールドへのすべてのアクセスを使用する必要があります<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
> [!NOTE]
>  C# を使用して、`volatile`フィールド修飾子フィールドへのすべてのアクセスを使用していることを保証<xref:System.Threading.Thread.VolatileRead%2A>または<xref:System.Threading.Thread.VolatileWrite%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>呼び出し元のスレッドから、現在のプロセッサ上で実行する準備が整っている別のスレッドに実行を切り替えます。 実行の切り替え先のスレッドは、オペレーティング システムによって選択されます。</summary>
        <returns>オペレーティング システムによって実行が別のスレッドに切り替えられた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが成功すると、スレッドの現在のタイム スライスの残りの部分が返されます。 オペレーティング システムでは、その優先順位と実行に使用できる他のスレッドの状態に応じて、別のタイム スライスの呼び出し元のスレッドをスケジュールします。  
  
 応答は、呼び出し元のスレッドを実行しているプロセッサに制限されます。 そのプロセッサがアイドル状態または優先順位の低いスレッドが実行されている場合でも、オペレーティング システムは、別のプロセッサに実行を切り替えられません。 現在のプロセッサで実行することができるその他のスレッドがないかどうか、オペレーティング システムでは、実行を作成しませんし、このメソッドが戻る`false`します。  
  
 このメソッドは、ネイティブの Win32 プラットフォームを使用して呼び出し`SwitchToThread`関数。 呼び出す必要があります、<xref:System.Threading.Thread.Yield%2A>プラットフォーム呼び出しのバイパス、カスタム スレッドの動作、ホストが要求されたため、プラットフォームを使用する代わりにメソッドを呼び出します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>