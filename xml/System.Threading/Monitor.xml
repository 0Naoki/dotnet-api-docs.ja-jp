<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4fb10be5601161de84aea8fd8f2a00a50eba6966" /><Meta Name="ms.sourcegitcommit" Value="5c332e8417c001736f7e2f33a84791feebba2cd7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="07/30/2019" /><Meta Name="ms.locfileid" Value="68632371" /></Metadata><TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>オブジェクトへのアクセスを同期する機構を提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クラスを使用すると、、、および<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>の<xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>各メソッドを呼び出すことによって、 <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>特定のオブジェクトのロックを取得して解放することにより、コード領域へのアクセスを同期できます。 <xref:System.Threading.Monitor> オブジェクトロックは、一般にクリティカルセクションと呼ばれる、コードブロックへのアクセスを制限する機能を提供します。 スレッドがオブジェクトのロックを所有している間、他のスレッドがそのロックを取得することはできません。 また、 <xref:System.Threading.Monitor>クラスを使用して、他のスレッドが別のロックされたオブジェクトを使用してコードを実行している場合を除き、ロック所有者によって実行されるアプリケーションコードのセクションに他のスレッドがアクセスできないようにすることもできます。  
  
 この記事の内容:  
  
 [Monitor クラス:概要](#Overview)   
 [Lock オブジェクト](#Lock)   
 [クリティカルセクション](#CriticalSection)   
 [Pulse、System.threading.monitor.pulseall、Wait](#Pulse)   
 [モニターと待機ハンドル](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a>Monitor クラス:概要  
 <xref:System.Threading.Monitor>には次の機能があります。  
  
-   要求時にオブジェクトに関連付けられています。  
  
-   バインド解除されているため、任意のコンテキストから直接呼び出すことができます。  
  
-   <xref:System.Threading.Monitor>クラスのインスタンスを作成することはできません。 <xref:System.Threading.Monitor>クラスのメソッドはすべて静的です。 各メソッドには、クリティカルセクションへのアクセスを制御する同期されたオブジェクトが渡されます。  
  
> [!NOTE]
>  値型<xref:System.Threading.Monitor>ではなく、文字列以外のオブジェクト (つまり、以外<xref:System.String>の参照型) をロックするには、クラスを使用します。 詳細については、この記事<xref:System.Threading.Monitor.Enter%2A>で後述する「メソッドと[lock オブジェクト](#Lock)のオーバーロード」を参照してください。  
  
 次の表では、同期されたオブジェクトにアクセスするスレッドで実行できる操作について説明します。  
  
|アクション|説明|  
|------------|-----------------|  
|<xref:System.Threading.Monitor.Enter%2A>、 <xref:System.Threading.Monitor.TryEnter%2A>|オブジェクトのロックを取得します。 この操作は、クリティカルセクションの開始を示すこともできます。 他のスレッドは、別のロックされたオブジェクトを使用してクリティカルセクションの命令を実行しない限り、クリティカルセクションに入ることはできません。|  
|<xref:System.Threading.Monitor.Wait%2A>|オブジェクトのロックを解除し、他のスレッドがオブジェクトにロックしてアクセスできるようにします。 呼び出し元のスレッドは、別のスレッドがオブジェクトにアクセスしている間、待機します。 パルスシグナルは、オブジェクトの状態に対する変更について、待機中のスレッドに通知するために使用されます。|  
|<xref:System.Threading.Monitor.Pulse%2A>(シグナル)、<xref:System.Threading.Monitor.PulseAll%2A>|1つ以上の待機中のスレッドにシグナルを送信します。 シグナルは、ロックされたオブジェクトの状態が変化したこと、およびロックの所有者がロックを解放する準備ができたことを待機中のスレッドに通知します。 待機中のスレッドは、オブジェクトのロックを最終的に受け取る可能性があるように、オブジェクトの準備完了キューに配置されます。 スレッドがロック状態になったら、オブジェクトの新しい状態をチェックして、必要な状態に達したかどうかを確認できます。|  
|<xref:System.Threading.Monitor.Exit%2A>|オブジェクトのロックを解放します。 この操作は、ロックされたオブジェクトによって保護されているクリティカルセクションの終了もマークします。|  
  
 以降では、メソッド<xref:System.Threading.Monitor.Enter%2A>と<xref:System.Threading.Monitor.TryEnter%2A>メソッドに2つのオーバーロードセットがあります。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 1組のオーバーロードには`ref` 、ロックを取得するときに例外がスローされた場合`true`でも、ロックが取得された場合にはアトミックにに設定される (in C#) または`ByRef` (Visual Basic) <xref:System.Boolean>パラメーターがあります。 ロックが保護されているリソースが一貫性のある状態ではない場合でも、常にロックを解放することが重要な場合は、これらのオーバーロードを使用します。  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a>Lock オブジェクト  
 Monitor クラスは、クリティカル`static`セクションへC#のアクセス`Shared`を制御するオブジェクトを操作する (では) メソッドまたは (Visual Basic) メソッドで構成されます。  同期されたオブジェクトごとに、次の情報が保持されます。  
  
-   現在ロックを保持しているスレッドへの参照。  
  
-   準備完了のキューへの参照。ロックを取得する準備ができているスレッドを格納します。  
  
-   待機中のキューへの参照。ロックされたオブジェクトの状態の変更の通知を待機しているスレッドを格納します。  
  
 <xref:System.Threading.Monitor> は値型ではなく、オブジェクト (つまり、参照型) をロックします。 値型を <xref:System.Threading.Monitor.Enter%2A> と <xref:System.Threading.Monitor.Exit%2A> に渡すことができますが、値型は呼び出しごとに個別にボックス化されます。 呼び出しごとに個別のオブジェクトが作成されるので、<xref:System.Threading.Monitor.Enter%2A> は決してコードをブロックすることはなく、保護していると想定しているコードは実際には同期されません。 さらに、<xref:System.Threading.Monitor.Exit%2A> に渡されたオブジェクトは <xref:System.Threading.Monitor.Enter%2A> に渡されたオブジェクトとは異なるため、<xref:System.Threading.Monitor> は「オブジェクトの同期メソッドが、コードの非同期ブロックから呼び出されました。」というメッセージとともに <xref:System.Threading.SynchronizationLockException> 例外をスローします。  
  
 この問題を説明する例を次に示します。 10 個のタスクが起動され、それぞれが 250 ミリ秒間スリープ状態になります。 次に、各タスクはカウンター変数である `nTasks` を更新します。これは実際に起動、実行されるタスクの数をカウントするためのものです。 `nTasks` は複数のタスクで同時に更新可能なグローバル変数なので、複数のタスクによる同時変更を防止するためにモニターを使用します。 しかし、例に示す出力のように、各タスクは <xref:System.Threading.SynchronizationLockException> 例外をスローします。  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 各タスクの <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> メソッドに対する呼び出しの前に `nTasks` 変数がボックス化されるため、各タスクは <xref:System.Threading.SynchronizationLockException> 例外をスローします。 つまり、各メソッドの呼び出しは他のメソッドから独立している個別の変数に渡されます。 `nTasks` は <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> メソッドへの呼び出しで再びボックス化されます。 こうして 10 個の新しいボックス化された変数が作成されます。これらは互いに独立したものであり、`nTasks` からも <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> メソッドへの呼び出しで作成された 10 個のボックス化された変数からも独立しています。 それで、以前ロックされていなかった新規に作成された変数のロックを解放しようとしているため、例外がスローされます。  
  
 次の例に示すように、<xref:System.Threading.Monitor.Enter%2A> と <xref:System.Threading.Monitor.Exit%2A> の呼び出しの前に値型の変数をボックス化したり、ボックス化された同じオブジェクトを両方のメソッドに渡したりできますが、これを行う利点はありません。 ボックス化解除された変数への変更は、ボックス化されたコピーには反映されません。またボックス化されたコピーの値を変更する方法はありません。  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 同期するオブジェクトを選択するときは、プライベートまたは内部のオブジェクトのみをロックする必要があります。 外部オブジェクトをロックするとデッドロックが発生する可能性があります。これは、関連のないコードが、異なる目的でロックする同じオブジェクトを選択する可能性があるためです。  
  
 ロックに使用されるオブジェクトがから<xref:System.MarshalByRefObject>派生している場合は、複数のアプリケーションドメイン内のオブジェクトを同期できます。  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a>クリティカルセクション  
 クリティカルセクションの<xref:System.Threading.Monitor.Exit%2A>開始と終了をマークするには、メソッドとメソッドを使用します。<xref:System.Threading.Monitor.Enter%2A>  
  
> [!NOTE]
>  メソッド<xref:System.Threading.Monitor.Enter%2A>と[](~/docs/csharp/language-reference/keywords/lock-statement.md) C# [](~/docs/visual-basic/language-reference/statements/synclock-statement.md)メソッドによって提供される機能は、の lock ステートメントと Visual Basic の SyncLock ステートメントによって提供される機能と同じですが、言語構成要素が<xref:System.Threading.Monitor.Exit%2A> <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType>メソッドの<xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>オーバーロードと、 `try`...`finally` ブロックして、モニターがリリースされていることを確認します。  
  
 クリティカルセクションが一連の連続する命令である場合、 <xref:System.Threading.Monitor.Enter%2A>メソッドによって取得されたロックは、ロックされたオブジェクトを使用して、囲まれたコードを1つのスレッドだけが実行できることを保証します。 この場合は、そのコードを`try`ブロックに配置し、 <xref:System.Threading.Monitor.Exit%2A>メソッド`finally`への呼び出しをブロックに配置することをお勧めします。 これにより、例外が発生しても必ずロックが解放されるようになります。 次のコードは、このパターンを示しています。  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 この機能は、通常、クラスの静的メソッドまたはインスタンスメソッドへのアクセスを同期するために使用されます。  
  
 クリティカルセクションがメソッド全体にまたがっている場合は、 <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>をメソッドに配置し、の<xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>コンストラクターで<xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized>値を指定することによって、ロック機能を実現できます。 この属性を使用する場合、 <xref:System.Threading.Monitor.Enter%2A>メソッド<xref:System.Threading.Monitor.Exit%2A>とメソッドの呼び出しは必要ありません。 次のコードは、このパターンを示しています。  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 属性によって、メソッドが戻るまで、ロックを保持するために、現在のスレッドに注意してください。ロックがすぐに解放する場合は、使用、<xref:System.Threading.Monitor>クラスの C#[ロック](~/docs/csharp/language-reference/keywords/lock-statement.md)ステートメント、または Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md)属性ではなく、メソッド内でステートメント。  
  
 指定されたオブジェクトを<xref:System.Threading.Monitor.Enter%2A>ロック<xref:System.Threading.Monitor.Exit%2A>して解放するステートメントとステートメントは、メンバーまたはクラスの境界の間またはその両方になる可能性がありますが、この方法はお勧めできません。  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a>Pulse、System.threading.monitor.pulseall、Wait  
 スレッドがロックを所有していて、ロックによって保護されているクリティカルセクション<xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>に<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>入ると<xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> 、、、およびの各メソッドを呼び出すことができます。  
  
 ロックを保持するスレッドがを呼び<xref:System.Threading.Monitor.Wait%2A>出すと、ロックが解放され、スレッドが同期されたオブジェクトの待機キューに追加されます。 準備完了キュー内の最初のスレッド (存在する場合) は、ロックを取得し、クリティカルセクションに入ります。 が呼び出さ<xref:System.Threading.Monitor.Wait%2A>れたスレッドは、 <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType>メソッド<xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>またはメソッドがロックを保持しているスレッドによって呼び出されたときに、待機キューから準備キューに移動されます (移動するには、スレッドが待機キューの先頭にある必要があります)。 メソッド<xref:System.Threading.Monitor.Wait%2A>は、呼び出し元のスレッドがロックを再取得たときにを返します。  
  
 ロックを保持するスレッドがを呼び<xref:System.Threading.Monitor.Pulse%2A>出すと、待機キューの先頭にあるスレッドが、準備完了キューに移動されます。 <xref:System.Threading.Monitor.PulseAll%2A>メソッドを呼び出すと、すべてのスレッドが待機キューから準備完了キューに移動されます。  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a>モニターと待機ハンドル  
 <xref:System.Threading.Monitor>クラスと<xref:System.Threading.WaitHandle>オブジェクトの使用方法の違いに注意することが重要です。  
  
-   <xref:System.Threading.Monitor>クラスは純粋に管理され、完全に移植可能であり、オペレーティングシステムのリソース要件に関してより効率的な場合があります。  
  
-   <xref:System.Threading.WaitHandle> オブジェクトはオペレーティング システムの待機可能オブジェクトを表しており、マネージドとアンマネージド コード間で同期するのに便利です。また一度に多くのオブジェクトを待機できる機能などの高度なオペレーティング システム機能を公開します。  
  
   
  
## Examples  
 クラスを使用<xref:System.Threading.Monitor>し<xref:System.Random>て、クラスによって表される乱数ジェネレーターの1つのインスタンスへのアクセスを同期する例を次に示します。 この例では、スレッドプールのスレッドで非同期的に実行される10個のタスクを作成します。 各タスクは、1万の乱数を生成し、平均値を計算し、生成された乱数の合計数と合計を保持する2つのプロシージャレベル変数を更新します。 すべてのタスクが実行された後、これらの2つの値を使用して全体的な平均が計算されます。  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 スレッドプールのスレッドで実行されている任意のタスクからアクセスできるため、変数`total`へ`n`のアクセスとも同期される必要があります。 この<xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType>目的では、メソッドが使用されます。  
  
 次の<xref:System.Threading.Monitor>例で`lock`は、クラス (または`SyncLock`言語<xref:System.Threading.AutoResetEvent>コンストラクトで実装)、 <xref:System.Threading.Interlocked>クラス、およびクラスを組み合わせて使用する方法を示します。 2 つの `internal` クラス (C# の場合) または `Friend` クラス (Visual Basic の場合)、`SyncResource` と `UnSyncResource` を定義します。これらはそれぞれ、リソースへの同期アクセスと非同期アクセスを提供します。 同期アクセスと非同期アクセスの違い (各メソッド呼び出しが迅速に完了する場合に違いが生じる可能性がある) を示すために、次の例では、メソッドにランダムな遅延を含めてあります。<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> プロパティが偶数であるスレッドでは、メソッドが <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> を呼び出して、2,000 ミリ秒の遅延を生じさせます。 `SyncResource` クラスはパブリックではなく、同期されたリソースでロックを取得するクライアント コードは存在しないので、内部クラス自体がロックを取得することに注意してください。 これにより、悪意のあるコードがパブリック オブジェクトでロックを取得するのを防ぐことができます。  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 例では、リソースにアクセスしようとするスレッドの数を定義する変数 `numOps` を定義します。 アプリケーション スレッドは、同期アクセスの場合も非同期アクセスの場合もそれぞれ 5 回、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> メソッドを呼び出します。 <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> メソッドにはパラメーターが 1 つしかありません。パラメーターを受け入れず値を返さないデリゲートです。 同期アクセスの場合は `SyncUpdateResource` メソッドを呼び出し、非同期アクセスの場合は `UnSyncUpdateResource` メソッドを呼び出します。 メソッドが呼び出されるたびに、アプリケーションスレッドは[system.threading.waithandle.waitone](xref:System.Threading.WaitHandle.WaitOne*)メソッドを呼び出して、 <xref:System.Threading.AutoResetEvent>インスタンスがシグナル状態になるまでブロックされるようにします。  
  
 `SyncUpdateResource` メソッドを呼び出すたびに、内部 `SyncResource.Access` メソッドが呼び出され、<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> メソッドが呼び出されて、`numOps` カウンターがデクリメントされます。 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>メソッドは、カウンターをデクリメントするために使用されます。それ以外の場合、最初のスレッドのデクリメントされた値が変数に格納される前に、2番目のスレッドが値にアクセスすることはありません。 最後に同期されたワーカースレッドがカウンターを0に減らした場合、同期されたすべてのスレッド`SyncUpdateResource`がリソースへ<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>のアクセスを完了したことを示します。メソッドは、メインスレッドに続行を通知するメソッドを呼び出します。例外.  
  
 `UnSyncUpdateResource` メソッドを呼び出すたびに、内部 `UnSyncResource.Access` メソッドが呼び出され、<xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> メソッドが呼び出されて、`numOps` カウンターがデクリメントされます。 この場合も、 <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType>メソッドを使用してカウンターをデクリメントすることで、最初のスレッドのデクリメントされた値が変数に割り当てられる前に、2番目のスレッドが値にアクセスしないようにします。 最後の同期されていないワーカースレッドがカウンターをゼロにデクリメントすると、そのリソース`UnSyncUpdateResource`にアクセスする必要がある非同期のスレッドがないことが示されます。このメソッドは、メインスレッドに実行を継続するように通知する<xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType>メソッドを呼び出します。  
  
 例の出力からわかるように、同期アクセスでは、呼び出し元スレッドが保護リソースを終了してからでないと別のスレッドがそれにアクセスできません。つまり各スレッドはその先行処理を待機します。 その一方で、ロックがない `UnSyncResource.Access` メソッドは、スレッドが到達する順序で呼び出されます。  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">スレッド処理オブジェクトと機能</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したオブジェクトの排他ロックを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">モニター ロックを取得する対象となるオブジェクト。</param>
        <summary>指定したオブジェクトの排他ロックを取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーター `Enter`として<xref:System.Threading.Monitor>渡されたオブジェクトのを取得するには、を使用します。 別のスレッドがオブジェクトに`Enter`対してを実行したが、対応<xref:System.Threading.Monitor.Exit%2A>するをまだ実行していない場合、現在のスレッドは、他のスレッドがオブジェクトを解放するまでブロックされます。 同じスレッドをブロックせずに複数回`Enter`呼び出すことはできますが、オブジェクトを待機している`Exit`他のスレッドがブロック解除される前に、同じ数の呼び出しを呼び出す必要があります。  
  
 値<xref:System.Threading.Monitor>型ではなく、オブジェクト (参照型) をロックするために使用します。 値型の変数をに`Enter`渡すと、オブジェクトとしてボックス化されます。 同じ変数を再びに`Enter`渡すと、別のオブジェクトとしてボックス化され、スレッドはブロックされません。 この場合、保護されて`Monitor`いると思われるコードは保護されていません。 さらに、変数をに`Exit`渡した場合でも、別の個別のオブジェクトが作成されます。 に`Exit`渡されたオブジェクトはに`Enter`渡されるオブジェクトとは異なる`Monitor`ため<xref:System.Threading.SynchronizationLockException>、はをスローします。 詳細については、概念説明のトピック「[モニター](xref:System.Threading.Monitor)」を参照してください。  
  
 <xref:System.Threading.Thread.Interrupt%2A>は、オブジェクトへのへの`Monitor`入力を待機しているスレッドを中断できます。 がスローされます。 <xref:System.Threading.ThreadInterruptedException>  
  
 C# を使用して、 `try`.`finally` ブロック (`Try`.`Finally` VVisual Basic)、モニターを解放するか、または、C# を使用する`lock`ステートメント (`SyncLock` Visual Basic でのステートメント)、ラップ、<xref:System.Threading.Monitor.Enter%2A>と<xref:System.Threading.Monitor.Exit%2A>メソッド、`try`.`finally` ブロックです。  
  
   
  
## Examples  
 `Enter` メソッドの使用方法を次の例に示します。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <param name="lockTaken">ロックを取得しようとした結果で、参照渡しです。 入力時には <see langword="false" /> にする必要があります。 ロックが取得された場合、出力は <see langword="true" /> になります。それ以外の場合、出力は <see langword="false" /> です。 ロックを取得しようとしている間に例外が発生した場合でも、出力は設定されます。  
  
メモ   例外が発生しない場合、このメソッドの出力は常に <see langword="true" /> です。</param>
        <summary>指定したオブジェクトの排他ロックを取得し、ロックが取得されたかどうかを示す値をアトミックに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーターとし`Enter`て<xref:System.Threading.Monitor>渡されたオブジェクトのを取得するには、を使用します。 `obj` 別のスレッドがオブジェクトに`Enter`対してを実行したが、対応<xref:System.Threading.Monitor.Exit%2A>するをまだ実行していない場合、現在のスレッドは、他のスレッドがオブジェクトを解放するまでブロックされます。 同じスレッドをブロックせずに複数回`Enter`呼び出すことはできますが、オブジェクトを待機している`Exit`他のスレッドがブロック解除される前に、同じ数の呼び出しを呼び出す必要があります。  
  
 例外がスローされたためにロックが取得されなかった場合、 `lockTaken`パラメーターに`false`指定された変数は、このメソッドが終了した後になります。 これにより、プログラムは常に、ロックを解放する必要があるかどうかを判断できます。 このメソッドが例外をスローせずに戻る場合、 `lockTaken`パラメーターに指定された変数は常に`true`であり、テストする必要はありません。  
  
 値<xref:System.Threading.Monitor>型ではなく、オブジェクト (参照型) をロックするために使用します。 値型の変数をに`Enter`渡すと、オブジェクトとしてボックス化されます。 同じ変数を再びに`Enter`渡すと、別のオブジェクトとしてボックス化され、スレッドはブロックされません。 この場合、保護されて`Monitor`いると思われるコードは保護されていません。 さらに、変数をに`Exit`渡すと、別の個別のオブジェクトが作成されます。 に`Exit`渡されたオブジェクトはに`Enter`渡されるオブジェクトとは異なる`Monitor`ため<xref:System.Threading.SynchronizationLockException>、はをスローします。 詳細については、概念説明のトピック「[モニター](xref:System.Threading.Monitor)」を参照してください。  
  
 <xref:System.Threading.Thread.Interrupt%2A>は、オブジェクトへのへの`Monitor`入力を待機しているスレッドを中断できます。 がスローされます。 <xref:System.Threading.ThreadInterruptedException>  
  
   
  
## Examples  
 次のコードは、 <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>メソッドオーバーロードを使用するための基本的なパターンを示しています。 このオーバーロードは、メソッドが例外をスローした場合でも`ref` 、パラメーター`ByRef`に渡される`lockTaken`変数の値 (Visual Basic) を常に設定します。したがって、変数の値は、ロックを使用する必要があるかどうかをテストするための信頼性の高い方法です。たら.  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> への入力は <see langword="true" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">ロックを解放する対象となるオブジェクト。</param>
        <summary>指定したオブジェクトの排他ロックを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出し元のスレッドは、 `obj`パラメーターのロックを所有している必要があります。 呼び出し元のスレッドが、指定されたオブジェクトのロックを所有していて`Exit` 、 <xref:System.Threading.Monitor.Enter%2A>そのオブジェクトに対して同じ数のおよび呼び出しを行った場合は、ロックが解放されます。 呼び出し元のスレッドがと`Exit` `Enter`して何度も呼び出されていない場合、ロックは解放されません。  
  
 ロックが解除され、他のスレッドがそのオブジェクトの準備完了キューにある場合、スレッドの1つがロックを取得します。 他のスレッドがロックの取得を待機している待機キューにある場合、ロックの所有者がを呼び出し`Exit`たときに、そのスレッドは自動的に ready キューに移動されません。 1つ以上の待機中のスレッドを準備完了キューに<xref:System.Threading.Monitor.Pulse%2A>移動<xref:System.Threading.Monitor.PulseAll%2A>するに`Exit`は、を呼び出す前にまたはを呼び出します。  
  
   
  
## Examples  
 `Exit` メソッドの使用方法を次の例に示します。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">現在のスレッドが、指定したオブジェクトのロックを所有していません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">テストするオブジェクト。</param>
        <summary>現在のスレッドが指定したオブジェクトのロックを保持しているかどうかを判断します。</summary>
        <returns>現在のスレッドが <paramref name="obj" /> のロックを保持している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの動作のメソッドを使用して取得されるロックに対してのみ、<xref:System.Threading.Monitor>クラス、またはを使用して、C#`lock`ステートメントまたは Visual Basic`SyncLock`ステートメントで実装される<xref:System.Threading.Monitor>します。  
  
 このメソッドは、 <xref:System.Diagnostics.Debug.Assert%2A>メソッド<xref:System.Diagnostics.Contracts.Contract>やクラスなどの診断ツールと共に使用して、クラスに<xref:System.Threading.Monitor>関連するロックの問題をデバッグします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="LockContentionCount">
      <MemberSignature Language="C#" Value="public static long LockContentionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 LockContentionCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Monitor.LockContentionCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LockContentionCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long LockContentionCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LockContentionCount : int64" Usage="System.Threading.Monitor.LockContentionCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モニターのロックを取得しようとするときに、接続があった回数を取得します。</summary>
        <value>モニターのロックを取得しようとしたときに競合が発生した回数。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">スレッドが待機するオブジェクト。</param>
        <summary>ロックされたオブジェクトの状態が変更されたことを、待機キュー内のスレッドに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ロックの現在の所有者だけが、を使用して`Pulse`待機中のオブジェクトを通知できます。  
  
 現在、指定したオブジェクトのロックを所有しているスレッドは、このメソッドを呼び出して、ロックの行の次のスレッドを通知します。 パルスを受け取ると、待機中のスレッドが準備完了キューに移動されます。 呼び出さ`Pulse`れたスレッドがロックを解放すると、準備完了キュー内の次のスレッド (これは必ずしも、公開されていたスレッドではない) がロックを取得します。  
  
> [!IMPORTANT]
>  クラス<xref:System.Threading.Monitor>は、 <xref:System.Threading.Monitor.Pulse%2A>メソッドが呼び出されたことを示す状態を保持しません。 したがって、待機し<xref:System.Threading.Monitor.Pulse%2A>ているスレッドがないときにを呼び出すと<xref:System.Threading.Monitor.Wait%2A> 、が呼び出さ<xref:System.Threading.Monitor.Pulse%2A>れていないかのように、ブロックを呼び出す次のスレッドが呼び出されます。 2つのスレッドが<xref:System.Threading.Monitor.Pulse%2A>を<xref:System.Threading.Monitor.Wait%2A>使用して操作を行っている場合、デッドロックが発生する可能性があります。 これは、 <xref:System.Threading.AutoResetEvent>クラスの動作と比較します。<xref:System.Threading.AutoResetEvent> <xref:System.Threading.AutoResetEvent> <xref:System.Threading.WaitHandle.WaitAll%2A> <xref:System.Threading.WaitHandle.WaitAny%2A> <xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを呼び出してを通知し、待機中のスレッドがない場合、は、スレッドが、、またはを呼び出すまで、シグナル状態のままになります。 <xref:System.Threading.EventWaitHandle.Set%2A> は<xref:System.Threading.AutoResetEvent> 、スレッドを解放し、非シグナル状態に戻ります。  
  
 同期されたオブジェクトには、現在ロックを保持しているスレッドへの参照、準備完了キューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照が保持されていることに注意してください。オブジェクトの状態が変更されたことを示す通知を待機しているスレッドを格納します。  
  
 、 `Pulse` 、<xref:System.Threading.Monitor.PulseAll%2A>および<xref:System.Threading.Monitor.Wait%2A>の各メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 複数のスレッドを通知するに<xref:System.Threading.Monitor.PulseAll%2A>は、メソッドを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼び出し元のスレッドは、指定したオブジェクトのロックを所有していません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">パルスを送るオブジェクト。</param>
        <summary>オブジェクトの状態が変更されたことを、待機中のすべてのスレッドに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在、指定されたオブジェクトのロックを所有しているスレッドは、このメソッドを呼び出して、オブジェクトのロックの取得を待機しているすべてのスレッドに通知します。 シグナルが送信されると、待機中のスレッドが準備完了キューに移動されます。 呼び出さ`PulseAll`れたスレッドによってロックが解放されると、準備完了キュー内の次のスレッドがロックを取得します。  
  
 同期されたオブジェクトには、現在ロックを保持しているスレッドへの参照、準備完了キューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照が保持されていることに注意してください。オブジェクトの状態が変更されたことを示す通知を待機しているスレッドを格納します。  
  
 、 <xref:System.Threading.Monitor.Pulse%2A> 、`PulseAll`および<xref:System.Threading.Monitor.Wait%2A>の各メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A>メソッドの解説では、スレッドが待機<xref:System.Threading.Monitor.Pulse%2A>していないときにが呼び出された場合の動作について説明します。  
  
 1つのスレッドを通知するに`Pulse`は、メソッドを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼び出し元のスレッドは、指定したオブジェクトのロックを所有していません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したオブジェクトの排他ロックの取得を試みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <summary>指定したオブジェクトの排他ロックの取得を試みます。</summary>
        <returns>現在のスレッドがロックを取得した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成功した場合、このメソッドは`obj`パラメーターの排他ロックを取得します。 このメソッドは、ロックが使用可能かどうかにかかわらず、直ちに戻ります。  
  
 このメソッドはに似<xref:System.Threading.Monitor.Enter%2A>ていますが、現在のスレッドをブロックすることはありません。 スレッドがブロックせずに入力できない場合、 `false,`メソッドはを返します。  
  
> [!NOTE]
>  値<xref:System.Threading.Monitor>型ではなく、オブジェクト (参照型) をロックするために使用します。 詳細については<xref:System.Threading.Monitor> 、「」を参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、メソッドの戻り値を調べて、その戻り値が`true`の場合にのみクリティカルセクションでコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した<xref:System.Threading.Monitor.Exit%2A>場合に`finally` 、呼び出し元のスレッドがクリティカルセクションのロックを解放するように、ブロックでを呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 次のコード例は、`TryEnter` メソッドの使用方法を示します。  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <param name="lockTaken">ロックを取得しようとした結果で、参照渡しです。 入力時には <see langword="false" /> にする必要があります。 ロックが取得された場合、出力は <see langword="true" /> になります。それ以外の場合、出力は <see langword="false" /> です。 ロックを取得しようとしている間に例外が発生した場合でも、出力は設定されます。</param>
        <summary>指定したオブジェクトの排他ロックの取得を試み、ロックが取得されたかどうかを示す値をアトミックに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成功した場合、このメソッドは`obj`パラメーターの排他ロックを取得します。 このメソッドは、ロックが使用可能かどうかにかかわらず、直ちに戻ります。  
  
 例外がスローされたためにロックが取得されなかった場合、 `lockTaken`パラメーターに`false`指定された変数は、このメソッドが終了した後になります。 これにより、プログラムは常に、ロックを解放する必要があるかどうかを判断できます。  
  
 このメソッドはに似<xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>ていますが、現在のスレッドをブロックすることはありません。 スレッドがブロック`lockTaken`せずに入力できない場合、メソッドから`false`制御が戻ったときに引数がに設定されます。  
  
> [!NOTE]
>  値<xref:System.Threading.Monitor>型ではなく、オブジェクト (参照型) をロックするために使用します。 詳細については、「<xref:System.Threading.Monitor>」の記事を参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、の`lockTaken`値を調べ、その値が`true`の場合にのみクリティカルセクションのコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した<xref:System.Threading.Monitor.Exit%2A>場合に`finally` 、呼び出し元のスレッドがクリティカルセクションのロックを解放するように、ブロックでを呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 次のコードは、 <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>メソッドオーバーロードを使用するための基本的なパターンを示しています。 このオーバーロードは、メソッドが例外をスローした場合でも`ref` 、パラメーター`ByRef`に渡される`lockTaken`変数の値 (Visual Basic) を常に設定します。したがって、変数の値は、ロックを使用する必要があるかどうかをテストするための信頼性の高い方法です。たら.  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> への入力は <see langword="true" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <param name="millisecondsTimeout">ロックを待機するミリ秒単位の時間。</param>
        <summary>指定したミリ秒間に、指定したオブジェクトの排他ロックの取得を試みます。</summary>
        <returns>現在のスレッドがロックを取得した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーターがと等しい<xref:System.Threading.Timeout.Infinite>場合、 <xref:System.Threading.Monitor.Enter%2A>このメソッドはと同じです。 `millisecondsTimeout` が`millisecondsTimeout` 0 に等しい場合、このメソッドは<xref:System.Threading.Monitor.TryEnter%2A>と同じです。  
  
> [!NOTE]
>  値<xref:System.Threading.Monitor>型ではなく、オブジェクト (参照型) をロックするために使用します。 詳細については<xref:System.Threading.Monitor> 、「」を参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、メソッドの戻り値を調べて、その戻り値が`true`の場合にのみクリティカルセクションでコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した<xref:System.Threading.Monitor.Exit%2A>場合に`finally` 、呼び出し元のスレッドがクリティカルセクションのロックを解放するように、ブロックでを呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は負の値で、 <see cref="F:System.Threading.Timeout.Infinite" />と等しくありません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <param name="timeout">ロックを待機する時間を表す <see cref="T:System.TimeSpan" />。 -1 ミリ秒という値は、無期限の待機を指定します。</param>
        <summary>指定した時間内に、指定したオブジェクトの排他ロックの取得を試みます。</summary>
        <returns>現在のスレッドがロックを取得した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ミリ秒に変換さ`timeout`れたパラメーターの値が-1 と等しい場合、この<xref:System.Threading.Monitor.Enter%2A>メソッドはと同じになります。 の`timeout`値が0の場合、このメソッドは<xref:System.Threading.Monitor.TryEnter%2A>と同じです。  
  
> [!NOTE]
>  値<xref:System.Threading.Monitor>型ではなく、オブジェクト (参照型) をロックするために使用します。 詳細については<xref:System.Threading.Monitor> 、クラスのトピックを参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、メソッドの戻り値を調べて、その戻り値が`true`の場合にのみクリティカルセクションでコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した<xref:System.Threading.Monitor.Exit%2A>場合に`finally` 、呼び出し元のスレッドがクリティカルセクションのロックを解放するように、ブロックでを呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ミリ秒の値が負の値であり、<see cref="F:System.Threading.Timeout.Infinite" /> (-1 ミリ秒) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <param name="millisecondsTimeout">ロックを待機するミリ秒単位の時間。</param>
        <param name="lockTaken">ロックを取得しようとした結果で、参照渡しです。 入力時には <see langword="false" /> にする必要があります。 ロックが取得された場合、出力は <see langword="true" /> になります。それ以外の場合、出力は <see langword="false" /> です。 ロックを取得しようとしている間に例外が発生した場合でも、出力は設定されます。</param>
        <summary>指定したオブジェクトの排他ロックの取得を指定したミリ秒間試み、ロックが取得されたかどうかを示す値をアトミックに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パラメーターがと等しい<xref:System.Threading.Timeout.Infinite>場合、 <xref:System.Threading.Monitor.Enter%28System.Object%29>このメソッドはと同じです。 `millisecondsTimeout` が`millisecondsTimeout` 0 に等しい場合、このメソッドは<xref:System.Threading.Monitor.TryEnter%28System.Object%29>と同じです。  
  
 例外がスローされたためにロックが取得されなかった場合、 `lockTaken`パラメーターに`false`指定された変数は、このメソッドが終了した後になります。 これにより、プログラムは常に、ロックを解放する必要があるかどうかを判断できます。  
  
> [!NOTE]
>  値<xref:System.Threading.Monitor>型ではなく、オブジェクト (参照型) をロックするために使用します。 詳細については、 <xref:System.Threading.Monitor>クラスのトピックを参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、の`lockTaken`値を調べ、その値が`true`の場合にのみクリティカルセクションのコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した<xref:System.Threading.Monitor.Exit%2A>場合に`finally` 、呼び出し元のスレッドがクリティカルセクションのロックを解放するように、ブロックでを呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 次のコードは、 <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29>メソッドオーバーロードを使用するための基本的なパターンを示しています。 このオーバーロードは、メソッドが例外をスローした場合でも`ref` 、パラメーター`ByRef`に渡される`lockTaken`変数の値 (Visual Basic) を常に設定します。したがって、変数の値は、ロックを使用する必要があるかどうかをテストするための信頼性の高い方法です。たら.  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> への入力は <see langword="true" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は負の値で、 <see cref="F:System.Threading.Timeout.Infinite" />と等しくありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">ロックの取得が行われるオブジェクト。</param>
        <param name="timeout">ロックを待機する時間。 -1 ミリ秒という値は、無期限の待機を指定します。</param>
        <param name="lockTaken">ロックを取得しようとした結果で、参照渡しです。 入力時には <see langword="false" /> にする必要があります。 ロックが取得された場合、出力は <see langword="true" /> になります。それ以外の場合、出力は <see langword="false" /> です。 ロックを取得しようとしている間に例外が発生した場合でも、出力は設定されます。</param>
        <summary>指定したオブジェクトの排他ロックの取得を指定した時間にわたって試み、ロックが取得されたかどうかを示す値をアトミックに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ミリ秒に変換さ`timeout`れたパラメーターの値が-1 と等しい場合、この<xref:System.Threading.Monitor.Enter%28System.Object%29>メソッドはと同じになります。 の`timeout`値が0の場合、このメソッドは<xref:System.Threading.Monitor.TryEnter%28System.Object%29>と同じです。  
  
 例外がスローされたためにロックが取得されなかった場合、 `lockTaken`パラメーターに`false`指定された変数は、このメソッドが終了した後になります。 これにより、プログラムは常に、ロックを解放する必要があるかどうかを判断できます。  
  
> [!NOTE]
>  値<xref:System.Threading.Monitor>型ではなく、オブジェクト (参照型) をロックするために使用します。 詳細については、 <xref:System.Threading.Monitor>クラスのトピックを参照してください。  
  
 スレッドがクリティカルセクションを入力しないようにするには、の`lockTaken`値を調べ、その値が`true`の場合にのみクリティカルセクションのコードを実行する必要があります。 次のコード片は、このメソッドの呼び出しに使用されるパターンを示しています。 例外が発生した<xref:System.Threading.Monitor.Exit%2A>場合に`finally` 、呼び出し元のスレッドがクリティカルセクションのロックを解放するように、ブロックでを呼び出す必要があることに注意してください。  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="lockTaken" /> への入力は <see langword="true" /> です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> ミリ秒の値が負の値であり、<see cref="F:System.Threading.Timeout.Infinite" /> (-1 ミリ秒) と等しくないか、または <see cref="F:System.Int32.MaxValue" /> を超えています。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。</summary>
        <returns>呼び出し元が、指定したオブジェクトのロックを再取得したために呼び出しが返された場合は <see langword="true" />。 このメソッドは、ロックが再取得されないと制御を戻しません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在、指定したオブジェクトのロックを所有しているスレッドは、別のスレッドがアクセスできるようにオブジェクトを解放するために、このメソッドを呼び出します。 ロックの再取得を待機している間に、呼び出し元がブロックされました。 このメソッドは、別のスレッドの操作の結果として発生する状態の変化を呼び出し元が待機する必要があるときに呼び出されます。  
  
 スレッドがを呼び`Wait`出すと、オブジェクトのロックが解放され、オブジェクトの待機キューに入ります。 オブジェクトの準備完了キュー内の次のスレッド (存在する場合) は、ロックを取得し、オブジェクトを排他的に使用します。 を呼び出し`Wait`たすべてのスレッドは、ロックの所有者によって送信<xref:System.Threading.Monitor.PulseAll%2A>されたまたはから<xref:System.Threading.Monitor.Pulse%2A>のシグナルを受信するまで待機キューに残ります。 `Pulse`が送信されると、待機キューの先頭にあるスレッドだけが影響を受けます。 `PulseAll`が送信されると、オブジェクトを待機しているすべてのスレッドが影響を受けます。 シグナルを受信すると、1つまたは複数のスレッドが待機キューを離れ、準備完了キューに入ります。 準備完了キュー内のスレッドは、ロックを再取得することが許可されています。  
  
 このメソッドは、呼び出し元のスレッドがオブジェクトのロックを再取得たときにを返します。 ロックの所有者がまたは`Pulse` `PulseAll`を呼び出さない場合、このメソッドは無期限にブロックすることに注意してください。  
  
 呼び出し元は`Wait` 、指定したオブジェクトに対して<xref:System.Threading.Monitor.Enter%2A>が呼び出された回数に関係なく、1回だけ実行されます。 概念的には`Wait` 、メソッドは、 `Enter`呼び出し元がオブジェクトに対して呼び出した回数`Exit`を格納し、ロックされたオブジェクトを完全に解放するために必要な回数だけ呼び出します。 その後、オブジェクトの再取得を待機している間、呼び出し元はブロックします。 呼び出し元がロックを再取得すると、システム`Enter`は、呼び出し元に対して保存さ`Enter`れたカウントを復元するために必要な回数だけを呼び出します。 を`Wait`呼び出すと、指定したオブジェクトのロックのみが解放されます。呼び出し元が他のオブジェクトのロックの所有者である場合、これらのロックは解放されません。  
  
 同期されたオブジェクトには、現在ロックを保持しているスレッドへの参照、準備完了キューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照が保持されていることに注意してください。オブジェクトの状態が変更されたことを示す通知を待機しているスレッドを格納します。  
  
 、 <xref:System.Threading.Monitor.Pulse%2A> 、<xref:System.Threading.Monitor.PulseAll%2A>および`Wait`の各メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A>メソッドの解説では、スレッドが待機<xref:System.Threading.Monitor.Pulse%2A>していないときにが呼び出された場合の動作について説明します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼び出し元のスレッドは、指定したオブジェクトのロックを所有していません。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" /> を呼び出したスレッドは、後で待機中の状態を中断されます。 これは、他のスレッドがこのスレッドの <see cref="M:System.Threading.Thread.Interrupt" /> メソッドを呼び出すときに起こります。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <param name="millisecondsTimeout">スレッドが実行待ちキューに入るまでの待機時間 (ミリ秒)。</param>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。 指定されたタイムアウト期限を過ぎると、スレッドは実行待ちキューに入ります。</summary>
        <returns>指定した時間が経過する前にロックが再取得された場合は <see langword="true" />。指定した時間が経過した後にロックが再取得された場合は <see langword="false" />。 このメソッドは、ロックが再取得されるまで制御を戻しません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 `obj`パラメーターに対して排他ロックを再取得するまで、を返しません。  
  
 現在、指定したオブジェクトのロックを所有しているスレッドは、別のスレッドがアクセスできるようにオブジェクトを解放するために、このメソッドを呼び出します。 ロックの再取得を待機している間に、呼び出し元がブロックされました。 このメソッドは、別のスレッドの操作の結果として発生する状態の変化を呼び出し元が待機する必要があるときに呼び出されます。  
  
 タイムアウトにより、別のスレッドがメソッドまたは<xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A>メソッドを呼び出さずにロックを解放した場合に、現在のスレッドが無期限にブロックされないようにすることができます。 また、スレッドを準備完了キューに移動し、待機キュー内で他のスレッドをバイパスして、ロックをすぐに再取得できるようにします。 スレッドは、 <xref:System.Threading.Monitor.Wait%2A>メソッドの戻り値をテストして、タイムアウト前にロックを再取得するかどうかを判断できます。スレッドは、待機に入る原因となった条件を評価できます。必要に応じ<xref:System.Threading.Monitor.Wait%2A>て、メソッドを再度呼び出します。  
  
 スレッドがを呼び`Wait`出すと、オブジェクトのロックが解放され、オブジェクトの待機キューに入ります。 オブジェクトの準備完了キュー内の次のスレッド (存在する場合) は、ロックを取得し、オブジェクトを排他的に使用します。 を`Wait`呼び出したスレッドは、ロックを保持しているスレッドが呼び出さ<xref:System.Threading.Monitor.PulseAll%2A>れるか、またはキュー <xref:System.Threading.Monitor.Pulse%2A>内の次のスレッドが呼び出されるまで、待機キューに残ります。 ただし、 `millisecondsTimeout`別の<xref:System.Threading.Monitor.Pulse%2A>スレッドがこのオブジェクトまたは<xref:System.Threading.Monitor.PulseAll%2A>メソッドを呼び出す前にが経過すると、ロックを取り戻すために元のスレッドが準備完了キューに移動されます。  
  
> [!NOTE]
>  パラメーターにが指定されている<xref:System.Threading.Timeout.Infinite>場合、ロックの所有者がまたは<xref:System.Threading.Monitor.PulseAll%2A>を<xref:System.Threading.Monitor.Pulse%2A>呼び出す場合を除き、このメソッドは無期限にブロックします。 `millisecondsTimeout` が`millisecondsTimeout` 0 に等しい場合、を呼び出し`Wait`たスレッドはロックを解放し、ロックを再び開始するためにすぐに準備待ちキューに入ります。  
  
 呼び出し元は`Wait` 、指定したオブジェクトに対して<xref:System.Threading.Monitor.Enter%2A>が呼び出された回数に関係なく、1回だけ実行されます。 概念的には`Wait` 、メソッドは、 <xref:System.Threading.Monitor.Enter%2A>呼び出し元がオブジェクトに対して呼び出した回数<xref:System.Threading.Monitor.Exit%2A>を格納し、ロックされたオブジェクトを完全に解放するために必要な回数だけ呼び出します。 その後、オブジェクトの再取得を待機している間、呼び出し元はブロックします。 呼び出し元がロックを再取得すると、システム<xref:System.Threading.Monitor.Enter%2A>は、呼び出し元に対して保存さ<xref:System.Threading.Monitor.Enter%2A>れたカウントを復元するために必要な回数だけを呼び出します。 を`Wait`呼び出すと、指定したオブジェクトのロックのみが解放されます。呼び出し元が他のオブジェクトのロックの所有者である場合、これらのロックは解放されません。  
  
> [!NOTE]
>  同期されたオブジェクトは、現在ロックを保持しているスレッドへの参照、準備されたキューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照を保持します。これには、オブジェクトの状態の変更の通知を待機しているスレッド。  
  
 、 <xref:System.Threading.Monitor.Pulse%2A> 、<xref:System.Threading.Monitor.PulseAll%2A>および`Wait`の各メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A>メソッドの解説では、スレッドが待機<xref:System.Threading.Monitor.Pulse%2A>していないときにが呼び出された場合の動作について説明します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼び出し元のスレッドは、指定したオブジェクトのロックを所有していません。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" /> を呼び出したスレッドは、後で待機中の状態を中断されます。 これは、他のスレッドがこのスレッドの <see cref="M:System.Threading.Thread.Interrupt" /> メソッドを呼び出すときに起こります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> パラメーターの値が負で、<see cref="F:System.Threading.Timeout.Infinite" /> と等しくありません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <param name="timeout">スレッドが実行待ちキューに入るまでの時間を表す <see cref="T:System.TimeSpan" />。</param>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。 指定されたタイムアウト期限を過ぎると、スレッドは実行待ちキューに入ります。</summary>
        <returns>指定した時間が経過する前にロックが再取得された場合は <see langword="true" />。指定した時間が経過した後にロックが再取得された場合は <see langword="false" />。 このメソッドは、ロックが再取得されるまで制御を戻しません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 `obj`パラメーターに対して排他ロックを再取得するまで、を返しません。  
  
 現在、指定したオブジェクトのロックを所有しているスレッドは、別のスレッドがアクセスできるようにオブジェクトを解放するために、このメソッドを呼び出します。 ロックの再取得を待機している間に、呼び出し元がブロックされました。 このメソッドは、別のスレッドの操作の結果として発生する状態の変化を呼び出し元が待機する必要があるときに呼び出されます。  
  
 タイムアウトにより、別のスレッドがメソッドまたは<xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A>メソッドを呼び出さずにロックを解放した場合に、現在のスレッドが無期限にブロックされないようにすることができます。 また、スレッドを準備完了キューに移動し、待機キュー内で他のスレッドをバイパスして、ロックをすぐに再取得できるようにします。 スレッドは、 <xref:System.Threading.Monitor.Wait%2A>メソッドの戻り値をテストして、タイムアウト前にロックを再取得するかどうかを判断できます。スレッドは、待機に入る原因となった条件を評価できます。必要に応じ<xref:System.Threading.Monitor.Wait%2A>て、メソッドを再度呼び出します。  
  
 スレッドがを呼び`Wait`出すと、オブジェクトのロックが解放され、オブジェクトの待機キューに入ります。 オブジェクトの準備完了キュー内の次のスレッド (存在する場合) は、ロックを取得し、オブジェクトを排他的に使用します。 を`Wait`呼び出したスレッドは、ロックを保持しているスレッドが呼び出さ<xref:System.Threading.Monitor.PulseAll%2A>れるか、またはキュー <xref:System.Threading.Monitor.Pulse%2A>内の次のスレッドが呼び出されるまで、待機キューに残ります。 ただし、 `timeout`別の<xref:System.Threading.Monitor.Pulse%2A>スレッドがこのオブジェクトまたは<xref:System.Threading.Monitor.PulseAll%2A>メソッドを呼び出す前にが経過すると、ロックを取り戻すために元のスレッドが準備完了キューに移動されます。  
  
> [!NOTE]
>  パラメーターに-1 ミリ秒を<xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A>表すが指定されている場合、ロックの所有者がまたはを呼び出す場合を除き、このメソッドは無期限に<xref:System.TimeSpan>ブロック `timeout`します。 が`timeout` 0 ミリ秒の場合、を呼び出し`Wait`たスレッドはロックを解放し、ロックを再び開始するためにすぐに準備待ちキューに入ります。  
  
 呼び出し元は`Wait` 、指定したオブジェクトに対して<xref:System.Threading.Monitor.Enter%2A>が呼び出された回数に関係なく、1回だけ実行されます。 概念的には`Wait` 、メソッドは、 <xref:System.Threading.Monitor.Enter%2A>呼び出し元がオブジェクトに対して呼び出した回数<xref:System.Threading.Monitor.Exit%2A>を格納し、ロックされたオブジェクトを完全に解放するために必要な回数だけ呼び出します。 その後、オブジェクトの再取得を待機している間、呼び出し元はブロックします。 呼び出し元がロックを再取得すると、システム<xref:System.Threading.Monitor.Enter%2A>は、呼び出し元に対して保存さ<xref:System.Threading.Monitor.Enter%2A>れたカウントを復元するために必要な回数だけを呼び出します。 を`Wait`呼び出すと、指定したオブジェクトのロックのみが解放されます。呼び出し元が他のオブジェクトのロックの所有者である場合、これらのロックは解放されません。  
  
> [!NOTE]
>  同期されたオブジェクトは、現在ロックを保持しているスレッドへの参照、準備されたキューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照を保持します。これには、オブジェクトの状態の変更の通知を待機しているスレッド。  
  
 、 <xref:System.Threading.Monitor.Pulse%2A> 、<xref:System.Threading.Monitor.PulseAll%2A>および`Wait`の各メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A>メソッドの解説では、スレッドが待機<xref:System.Threading.Monitor.Pulse%2A>していないときにが呼び出された場合の動作について説明します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException">呼び出し元のスレッドは、指定したオブジェクトのロックを所有していません。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" /> を呼び出したスレッドは、後で待機中の状態を中断されます。 これは、他のスレッドがこのスレッドの <see cref="M:System.Threading.Thread.Interrupt" /> メソッドを呼び出すときに起こります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> パラメーターのミリ秒単位の値が負で、かつ <see cref="F:System.Threading.Timeout.Infinite" /> (-1 ミリ秒) ではありません。または <see cref="F:System.Int32.MaxValue" /> より大きい値です。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <param name="millisecondsTimeout">スレッドが実行待ちキューに入るまでの待機時間 (ミリ秒)。</param>
        <param name="exitContext">待機の前にコンテキストの同期ドメイン (同期されたコンテキストの場合) を終了および再取得する場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</param>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。 指定されたタイムアウト期限を過ぎると、スレッドは実行待ちキューに入ります。 このメソッドは、コンテキストの同期ドメイン (同期されたコンテキストの場合) が待機の前に終了し、後で再取得されるかどうかも指定します。</summary>
        <returns>指定した時間が経過する前にロックが再取得された場合は <see langword="true" />。指定した時間が経過した後にロックが再取得された場合は <see langword="false" />。 このメソッドは、ロックが再取得されるまで制御を戻しません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 `obj`パラメーターに対して排他ロックを再取得するまで、を返しません。  
  
 現在、指定したオブジェクトのロックを所有しているスレッドは、別のスレッドがアクセスできるようにオブジェクトを解放するために、このメソッドを呼び出します。 ロックの再取得を待機している間に、呼び出し元がブロックされました。 このメソッドは、別のスレッドの操作の結果として発生する状態の変化を呼び出し元が待機する必要があるときに呼び出されます。  
  
 タイムアウトにより、別のスレッドがメソッドまたは<xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A>メソッドを呼び出さずにロックを解放した場合に、現在のスレッドが無期限にブロックされないようにすることができます。 また、スレッドを準備完了キューに移動し、待機キュー内で他のスレッドをバイパスして、ロックをすぐに再取得できるようにします。 スレッドは、 <xref:System.Threading.Monitor.Wait%2A>メソッドの戻り値をテストして、タイムアウト前にロックを再取得するかどうかを判断できます。スレッドは、待機に入る原因となった条件を評価できます。必要に応じ<xref:System.Threading.Monitor.Wait%2A>て、メソッドを再度呼び出します。  
  
 スレッドがを呼び`Wait`出すと、ロックが解放され、待機キューに入ります。 この時点で、準備完了キュー内の次のスレッド (存在する場合) は、ロックの制御を許可されます。 を`Wait`呼び出したスレッドは、ロックを保持しているスレッドが呼び出さ<xref:System.Threading.Monitor.PulseAll%2A>れるか、またはキュー <xref:System.Threading.Monitor.Pulse%2A>内の次のスレッドが呼び出されるまで、待機キューに残ります。 ただし、 `millisecondsTimeout`別の<xref:System.Threading.Monitor.Pulse%2A>スレッドがこのオブジェクトまたは<xref:System.Threading.Monitor.PulseAll%2A>メソッドを呼び出す前にが経過すると、ロックを取り戻すために元のスレッドが準備完了キューに移動されます。  
  
> [!NOTE]
>  パラメーターにが指定されている<xref:System.Threading.Timeout.Infinite>場合、ロックの所有者がまたは<xref:System.Threading.Monitor.PulseAll%2A>を<xref:System.Threading.Monitor.Pulse%2A>呼び出す場合を除き、このメソッドは無期限にブロックします。 `millisecondsTimeout` が`millisecondsTimeout` 0 に等しい場合、を呼び出し`Wait`たスレッドはロックを解放し、ロックを再び開始するためにすぐに準備待ちキューに入ります。  
  
 呼び出し元は`Wait` 、指定したオブジェクトに対して<xref:System.Threading.Monitor.Enter%2A>が呼び出された回数に関係なく、1回だけ実行されます。 概念的には`Wait` 、メソッドは、 <xref:System.Threading.Monitor.Enter%2A>呼び出し元がオブジェクトに対して呼び出した回数<xref:System.Threading.Monitor.Exit%2A>を格納し、ロックされたオブジェクトを完全に解放するために必要な回数だけ呼び出します。 その後、オブジェクトの再取得を待機している間、呼び出し元はブロックします。 呼び出し元がロックを再取得すると、システム<xref:System.Threading.Monitor.Enter%2A>は、呼び出し元に対して保存さ<xref:System.Threading.Monitor.Enter%2A>れたカウントを復元するために必要な回数だけを呼び出します。 を`Wait`呼び出すと、指定したオブジェクトのロックのみが解放されます。呼び出し元が他のオブジェクトのロックの所有者である場合、これらのロックは解放されません。  
  
> [!NOTE]
>  同期されたオブジェクトは、現在ロックを保持しているスレッドへの参照、準備されたキューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照を保持します。これには、オブジェクトの状態の変更の通知を待機しているスレッド。  
  
 、 <xref:System.Threading.Monitor.Pulse%2A> 、<xref:System.Threading.Monitor.PulseAll%2A>および`Wait`の各メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A>メソッドの解説では、スレッドが待機<xref:System.Threading.Monitor.Pulse%2A>していないときにが呼び出された場合の動作について説明します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 既定`exitContext`以外のマネージコンテキスト内から<xref:System.Threading.Monitor.Wait%2A>メソッドが呼び出されない限り、パラメーターは無効です。 これは、スレッドがから<xref:System.ContextBoundObject>派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 から<xref:System.ContextBoundObject>派生<xref:System.ContextBoundObject>していないクラスのメソッドを現在実行している場合でも、が現在のアプリケーションドメインのスタック上にある場合は、既定以外のコンテキストにすることができます。 <xref:System.String>  
  
 コードが既定以外のコンテキストで実行されて`true`いる`exitContext`場合、にを指定すると、スレッドは<xref:System.Threading.Monitor.Wait%2A>メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 メソッドの<xref:System.Threading.Monitor.Wait%2A>呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>属性が適用されている場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが<xref:System.Threading.Monitor.Wait%2A>メソッドを呼び出し、に`exitContext`を`true`指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドを続行できます。 メソッドから<xref:System.Threading.Monitor.Wait%2A>制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> は、同期されたコード ブロック内からは呼び出されません。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><see langword="Wait" /> を呼び出したスレッドは、後で待機中の状態を中断されます。 これは、他のスレッドがこのスレッドの <see cref="M:System.Threading.Thread.Interrupt" /> メソッドを呼び出すときに起こります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> パラメーターの値が負で、<see cref="F:System.Threading.Timeout.Infinite" /> と等しくありません。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">待機を行うオブジェクト。</param>
        <param name="timeout">スレッドが実行待ちキューに入るまでの時間を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機の前にコンテキストの同期ドメイン (同期されたコンテキストの場合) を終了および再取得する場合は<see langword="true" /> 。それ以外の場合は <see langword="false" />。</param>
        <summary>オブジェクトのロックを解放し、現在のスレッドがロックを再取得するまでそのスレッドをブロックします。 指定されたタイムアウト期限を過ぎると、スレッドは実行待ちキューに入ります。 または、待機の前に同期化されたコンテキストの同期ドメインを終了し、ドメインを後で再取得します。</summary>
        <returns>指定した時間が経過する前にロックが再取得された場合は <see langword="true" />。指定した時間が経過した後にロックが再取得された場合は <see langword="false" />。 このメソッドは、ロックが再取得されるまで制御を戻しません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、 `obj`パラメーターに対して排他ロックを再取得するまで、を返しません。  
  
 現在、指定したオブジェクトのロックを所有しているスレッドは、別のスレッドがアクセスできるようにオブジェクトを解放するために、このメソッドを呼び出します。 ロックの再取得を待機している間に、呼び出し元がブロックされました。 このメソッドは、別のスレッドの操作の結果として発生する状態の変化を呼び出し元が待機する必要があるときに呼び出されます。  
  
 タイムアウトにより、別のスレッドがメソッドまたは<xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A>メソッドを呼び出さずにロックを解放した場合に、現在のスレッドが無期限にブロックされないようにすることができます。 また、スレッドを準備完了キューに移動し、待機キュー内で他のスレッドをバイパスして、ロックをすぐに再取得できるようにします。 スレッドは、 <xref:System.Threading.Monitor.Wait%2A>メソッドの戻り値をテストして、タイムアウト前にロックを再取得するかどうかを判断できます。スレッドは、待機に入る原因となった条件を評価できます。必要に応じ<xref:System.Threading.Monitor.Wait%2A>て、メソッドを再度呼び出します。  
  
 スレッドがを呼び`Wait`出すと、ロックが解放され、待機キューに入ります。 この時点で、準備完了キュー内の次のスレッド (存在する場合) は、ロックの制御を許可されます。 を`Wait`呼び出したスレッドは、ロックを保持しているスレッドが呼び出さ<xref:System.Threading.Monitor.PulseAll%2A>れるか、またはキュー <xref:System.Threading.Monitor.Pulse%2A>内の次のスレッドが呼び出されるまで、待機キューに残ります。 ただし、別`timeout`の<xref:System.Threading.Monitor.Pulse%2A>スレッドがこのオブジェクトまたは<xref:System.Threading.Monitor.PulseAll%2A>メソッドを呼び出す前にミリ秒が経過した場合、元のスレッドはロックを取り戻すために準備完了キューに移動されます。  
  
> [!NOTE]
>  パラメーターに-1 ミリ秒を<xref:System.Threading.Monitor.Pulse%2A> <xref:System.Threading.Monitor.PulseAll%2A>表すが指定されている場合、ロックの所有者がまたはを呼び出す場合を除き、このメソッドは無期限に<xref:System.TimeSpan>ブロック `timeout`します。 が`timeout` 0 ミリ秒の場合、を呼び出し`Wait`たスレッドはロックを解放し、ロックを再び開始するためにすぐに準備待ちキューに入ります。  
  
 呼び出し元は`Wait` 、指定したオブジェクトに対して<xref:System.Threading.Monitor.Enter%2A>が呼び出された回数に関係なく、1回だけ実行されます。 概念的には`Wait` 、メソッドは、 <xref:System.Threading.Monitor.Enter%2A>呼び出し元がオブジェクトに対して呼び出した回数<xref:System.Threading.Monitor.Exit%2A>を格納し、ロックされたオブジェクトを完全に解放するために必要な回数だけ呼び出します。 その後、オブジェクトの再取得を待機している間、呼び出し元はブロックします。 呼び出し元がロックを再取得すると、システム<xref:System.Threading.Monitor.Enter%2A>は、呼び出し元に対して保存さ<xref:System.Threading.Monitor.Enter%2A>れたカウントを復元するために必要な回数だけを呼び出します。 を`Wait`呼び出すと、指定したオブジェクトのロックのみが解放されます。呼び出し元が他のオブジェクトのロックの所有者である場合、これらのロックは解放されません。  
  
> [!NOTE]
>  同期されたオブジェクトは、現在ロックを保持しているスレッドへの参照、準備されたキューへの参照、ロックを取得する準備ができているスレッドを含む、待機キューへの参照など、いくつかの参照を保持します。これには、オブジェクトの状態の変更の通知を待機しているスレッド。  
  
 、 <xref:System.Threading.Monitor.Pulse%2A> 、<xref:System.Threading.Monitor.PulseAll%2A>および`Wait`の各メソッドは、同期されたコードブロック内から呼び出す必要があります。  
  
 <xref:System.Threading.Monitor.Pulse%2A>メソッドの解説では、スレッドが待機<xref:System.Threading.Monitor.Pulse%2A>していないときにが呼び出された場合の動作について説明します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了に関する注意事項  
 既定`exitContext`以外のマネージコンテキスト内から<xref:System.Threading.Monitor.Wait%2A>メソッドが呼び出されない限り、パラメーターは無効です。 これは、スレッドがから<xref:System.ContextBoundObject>派生したクラスのインスタンスの呼び出し内にある場合に発生する可能性があります。 から<xref:System.ContextBoundObject>派生<xref:System.ContextBoundObject>していないクラスのメソッドを現在実行している場合でも、が現在のアプリケーションドメインのスタック上にある場合は、既定以外のコンテキストにすることができます。 <xref:System.String>  
  
 コードが既定以外のコンテキストで実行されて`true`いる`exitContext`場合、にを指定すると、スレッドは<xref:System.Threading.Monitor.Wait%2A>メソッドを実行する前に、既定以外のマネージコンテキスト (つまり、既定のコンテキストに遷移する) を終了します。 メソッドの<xref:System.Threading.Monitor.Wait%2A>呼び出しが完了した後、元の既定以外のコンテキストに戻ります。  
  
 これは、コンテキストバインドクラスに<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>属性が適用されている場合に便利です。 その場合、クラスのメンバーへのすべての呼び出しが自動的に同期され、同期ドメインがクラスのコード本文全体になります。 メンバーの呼び出し履歴内のコードが<xref:System.Threading.Monitor.Wait%2A>メソッドを呼び出し、に`exitContext`を`true`指定した場合、スレッドは同期ドメインを終了します。これにより、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドを続行できます。 メソッドから<xref:System.Threading.Monitor.Wait%2A>制御が戻ったとき、呼び出しを行ったスレッドは、同期ドメインの再入力を待機する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="obj" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.SynchronizationLockException"><see langword="Wait" /> は、同期されたコード ブロック内からは呼び出されません。</exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">Wait を呼び出すスレッドは、後で待機状態の途中で中断されます。 これは、他のスレッドがこのスレッドの <see cref="M:System.Threading.Thread.Interrupt" /> メソッドを呼び出すときに起こります。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> パラメーターが負で <see cref="F:System.Threading.Timeout.Infinite" /> (-1 ミリ秒) を表していないか、<see cref="F:System.Int32.MaxValue" /> よりも大きいです。</exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
      </Docs>
    </Member>
  </Members>
</Type>
