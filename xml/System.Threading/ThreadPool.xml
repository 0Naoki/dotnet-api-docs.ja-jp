<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3affe4872ffccc66fbf65bb8eeb4555921416133" />
    <Meta Name="ms.sourcegitcommit" Value="4303c81814c0b4fd5963444073ed25c176c5ddad" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="07/31/2018" />
    <Meta Name="ms.locfileid" Value="39361194" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="e0130-101">タスクの実行、作業項目のポスト、非同期 I/O の処理、他のスレッドの代理で行う待機、およびタイマーの処理に使用できるスレッドのプールを提供します。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e0130-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-102">多くのアプリケーションでは、費やしません時間スリープの状態で発生するイベントを待機しているスレッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="e0130-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="e0130-103">他のスレッドは、スリープ状態の変更をポーリングまたは状態情報を更新する定期的にスリープ解除する場合にのみを入力します。</span><span class="sxs-lookup"><span data-stu-id="e0130-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="e0130-104">スレッド プールでは、システムによって管理されているワーカー スレッドのプールを使用してアプリケーションを提供することでスレッドをより効率的に使用することができます。</span><span class="sxs-lookup"><span data-stu-id="e0130-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="e0130-105">スレッド プールのスレッドを使用して、操作の例を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="e0130-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="e0130-106">作成するときに、<xref:System.Threading.Tasks.Task>または<xref:System.Threading.Tasks.Task%601>スレッド プールのスレッドで実行するタスクをスケジュールする既定で非同期的にいくつかのタスクを実行するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="e0130-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="e0130-107">非同期のタイマーは、スレッド プールを使用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="e0130-108">スレッド プールのスレッドからのコールバックの実行、<xref:System.Threading.Timer?displayProperty=nameWithType>クラスし、からのイベントを発生させる、<xref:System.Timers.Timer?displayProperty=nameWithType>クラス。</span><span class="sxs-lookup"><span data-stu-id="e0130-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="e0130-109">登録済みの待機ハンドルを使用すると、システム スレッドは待機ハンドルの状態を監視します。</span><span class="sxs-lookup"><span data-stu-id="e0130-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="e0130-110">待機操作が完了したら、スレッド プールからワーカー スレッドは、対応するコールバック関数を実行します。</span><span class="sxs-lookup"><span data-stu-id="e0130-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="e0130-111">呼び出すと、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>スレッド プールのスレッドで実行するためのメソッドをキューにします。</span><span class="sxs-lookup"><span data-stu-id="e0130-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="e0130-112">メソッドに渡すことによって、これを行う、<xref:System.Threading.WaitCallback>を委任します。</span><span class="sxs-lookup"><span data-stu-id="e0130-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="e0130-113">デリゲートのシグネチャを持ちます</span><span class="sxs-lookup"><span data-stu-id="e0130-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="e0130-114">場所`state`はデリゲートで使用されるデータを含むオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="e0130-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="e0130-115">実際のデータは、呼び出すことによって、デリゲートに渡すことができます、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e0130-116">マネージ スレッド プール内のスレッドは、バック グラウンド スレッドです。</span><span class="sxs-lookup"><span data-stu-id="e0130-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="e0130-117">つまり、その<xref:System.Threading.Thread.IsBackground%2A>プロパティは、`true`します。</span><span class="sxs-lookup"><span data-stu-id="e0130-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="e0130-118">つまり、<xref:System.Threading.ThreadPool>スレッドはすべてのフォア グラウンド スレッドが終了した後に実行されるアプリケーションには保持されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e0130-119">スレッド ローカル ストレージまたはでマークされているフィールドのデータは消去されません、スレッド プール スレッドを再利用、ときに、<xref:System.ThreadStaticAttribute>属性。</span><span class="sxs-lookup"><span data-stu-id="e0130-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="e0130-120">そのため、メソッドがスレッド ローカル ストレージを検査またはフィールドが付いて、<xref:System.ThreadStaticAttribute>属性、値が見つかる可能性があるから残されたスレッド プールのスレッドの以前の使用。</span><span class="sxs-lookup"><span data-stu-id="e0130-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="e0130-121">また、スレッド プールに、待機操作に関連していない作業項目をキューできます。</span><span class="sxs-lookup"><span data-stu-id="e0130-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="e0130-122">作業項目をスレッド プール内のスレッドで処理することを要求するには、呼び出し、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="e0130-123">このメソッドは、メソッドまたはスレッド プールから選択したスレッドで呼び出されるデリゲートへの参照をパラメーターとして受け取ります。</span><span class="sxs-lookup"><span data-stu-id="e0130-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="e0130-124">キューに作業項目を取り消す手段はありません。</span><span class="sxs-lookup"><span data-stu-id="e0130-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="e0130-125">タイマー キューのタイマーと登録された待機操作もスレッド プールを使用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="e0130-126">スレッド プールには、これらのコールバック関数がキューに登録します。</span><span class="sxs-lookup"><span data-stu-id="e0130-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="e0130-127">プロセスごとに 1 つのスレッド プールがあります。</span><span class="sxs-lookup"><span data-stu-id="e0130-127">There is one thread pool per process.</span></span> <span data-ttu-id="e0130-128">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 以降では、プロセスのスレッド プールの既定のサイズは、仮想アドレス空間のサイズなど、いくつかの要素によって決まります。</span><span class="sxs-lookup"><span data-stu-id="e0130-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="e0130-129">スレッドの数は、プロセスで <xref:System.Threading.ThreadPool.GetMaxThreads%2A> メソッドを呼び出せば確認できます。</span><span class="sxs-lookup"><span data-stu-id="e0130-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="e0130-130">使用して、スレッド プールのスレッド数を変更することができます、<xref:System.Threading.ThreadPool.SetMaxThreads%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="e0130-131">各スレッドは、既定のスタック サイズを使用し、既定の優先順位で実行します。</span><span class="sxs-lookup"><span data-stu-id="e0130-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e0130-132">.NET Framework をホストするアンマネージ コードを使用してスレッド プールのサイズを変更することができます、 `CorSetMaxThreads` mscoree.h ファイルで定義されている関数。</span><span class="sxs-lookup"><span data-stu-id="e0130-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="e0130-133">スレッド プールは、新しい worker スレッドまたは I/O 完了スレッド オンデマンドでカテゴリごとの最小値に達するまで。</span><span class="sxs-lookup"><span data-stu-id="e0130-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="e0130-134">以上に達すると、スレッド プールはそのカテゴリで追加のスレッドを作成または、いくつかのタスクを完了するまで待機できます。</span><span class="sxs-lookup"><span data-stu-id="e0130-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="e0130-135">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 以降では、スループットを最適化するために、スレッド プールでワーカー スレッドの作成と破棄が行われます。スループットは、タスクの単位時間あたりの完了数として定義されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="e0130-136">スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e0130-137">要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="e0130-138">これらの最小値は、<xref:System.Threading.ThreadPool.GetMinThreads%2A> メソッドを使用して取得できます。</span><span class="sxs-lookup"><span data-stu-id="e0130-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e0130-139">使用することができます、<xref:System.Threading.ThreadPool.SetMinThreads%2A>スレッドの最小数を増加させます。</span><span class="sxs-lookup"><span data-stu-id="e0130-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="e0130-140">ただし、これらの値を必要以上に大きくすると、パフォーマンスの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="e0130-141">同時に開始するタスクの数が多すぎる場合は、すべてのタスクで処理速度が低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="e0130-142">ほとんどの場合、スレッドを割り当てるためのスレッド プール独自のアルゴリズムを使用することでスレッド プールのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="e0130-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e0130-143">次の例では、メイン アプリケーション スレッド キューという名前のメソッド`ThreadProc`スリープ、1 秒間と終了し、スレッド プールのスレッド上で実行します。</span><span class="sxs-lookup"><span data-stu-id="e0130-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="e0130-144">`ThreadProc`メソッドには、単にメッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="e0130-145">呼び出しをコメントにする場合、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッド、メソッドがスレッド プールのスレッドで実行する前に、メイン スレッドが終了しました。</span><span class="sxs-lookup"><span data-stu-id="e0130-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="e0130-146">スレッド プールでは、アプリケーションのすべてのフォア グラウンド スレッドが終了した場合に実行を継続しないバック グラウンドのスレッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="e0130-147">(これは、競合状態の簡単な例です)。</span><span class="sxs-lookup"><span data-stu-id="e0130-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="e0130-148">この型はスレッド セーフです。</span>
      <span class="sxs-lookup">
        <span data-stu-id="e0130-148">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e0130-149">オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-149">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="e0130-150">ハンドルを保持する <see cref="T:System.IntPtr" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-150">An <see cref="T:System.IntPtr" /> that holds the handle.</span>
          </span>
          <span data-ttu-id="e0130-151">ハンドルは、アンマネージ側の重複 I/O 用に開かれている必要があります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-151">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-152">オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-152">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-153">ハンドルがバインドされている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-153">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e0130-154">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-154">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e0130-155">アンマネージ コードを呼び出す機能。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-155">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e0130-156">
            <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-156">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="e0130-157">オペレーティング システム ハンドルを保持する <see cref="T:System.Runtime.InteropServices.SafeHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span>
          </span>
          <span data-ttu-id="e0130-158">ハンドルは、アンマネージ側の重複 I/O 用に開かれている必要があります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-158">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-159">オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-159">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-160">ハンドルがバインドされている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-160">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-161">`osHandle`パラメーターは、 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>、抽象から派生した<xref:System.Runtime.InteropServices.SafeHandle>クラス。</span><span class="sxs-lookup"><span data-stu-id="e0130-161">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e0130-162">
            <paramref name="osHandle" /> は <see langword="null" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-162">
              <paramref name="osHandle" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e0130-163">アンマネージ コードを呼び出す機能。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-163">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="e0130-164">
            <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-164">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="e0130-165">使用できるワーカー スレッドの数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-165">The number of available worker threads.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="e0130-166">使用できる非同期 I/O スレッドの数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-166">The number of available asynchronous I/O threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-167">スレッド プール スレッドの最大数 (<see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> メソッドから返される) と現在アクティブなスレッドの数との差を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-167">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-168">ときに<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>で指定された変数を返します`workerThreads`開始できる追加のワーカー スレッドとで指定された変数の数を含んでいる`completionPortThreads`ことができるその他の非同期 I/O スレッドの数が含まれています。開始します。</span><span class="sxs-lookup"><span data-stu-id="e0130-168">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="e0130-169">利用可能なスレッドがない場合は、追加のスレッド プールの要求は、スレッド プールのスレッドが使用可能になるまでキューに入れたのままです。</span><span class="sxs-lookup"><span data-stu-id="e0130-169">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e0130-170">次の例では、単純なアプリが開始されると、ワーカー スレッドと I/O スレッドが使用可能なの数が表示されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-170">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="e0130-171">スレッド プール内のワーカー スレッドの最大数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-171">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="e0130-172">スレッド プール内の非同期 I/O スレッドの最大数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-172">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-173">同時にアクティブにできるスレッド プールへの要求の数を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-173">Retrieves the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="e0130-174">この数を超える要求はすべて、スレッド プール スレッドが使用可能になるまでキューに置かれたままになります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-174">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-175">ときに<xref:System.Threading.ThreadPool.GetMaxThreads%2A>で指定された変数を返します`workerThreads`、スレッド プールで許可されているワーカー スレッドとで指定された変数の最大数を含む`completionPortThreads`で許可されている非同期の I/O スレッドの最大数が含まれています、。スレッド プールです。</span><span class="sxs-lookup"><span data-stu-id="e0130-175">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="e0130-176">使用することができます、<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>メソッドを任意の時点でスレッド プール内のスレッドの実際の数を決定します。</span><span class="sxs-lookup"><span data-stu-id="e0130-176">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="e0130-177">使用することができます、<xref:System.Threading.ThreadPool.SetMaxThreads%2A>スレッド プールでワーカー スレッドと非同期 I/O スレッドの最大数を設定します。</span><span class="sxs-lookup"><span data-stu-id="e0130-177">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="e0130-178">システム メモリは、多くのスレッド プールの要求とキューに配置できます。</span><span class="sxs-lookup"><span data-stu-id="e0130-178">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="e0130-179">スレッド プールのスレッドよりもより多くの要求がある場合は、追加の要求は、スレッド プールのスレッドが使用可能になるまでキューに入れたのままです。</span><span class="sxs-lookup"><span data-stu-id="e0130-179">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e0130-180">次のコード例では、スレッド プール内のスレッドの最大値と使用可能な数のカウントを取得する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="e0130-180">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="e0130-181">使用する作業項目がキューに`FileStream`2 つのファイルを非同期的に書き込む。</span><span class="sxs-lookup"><span data-stu-id="e0130-181">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="e0130-182">重複するのには、コールバック メソッドがタイムアウトになりました。</span><span class="sxs-lookup"><span data-stu-id="e0130-182">The callback methods are timed to overlap.</span></span> <span data-ttu-id="e0130-183">ワーカー スレッドが作業項目を処理し、1 つまたは 2 つの完了ポート スレッドによって、コンピューター上のプロセッサの数と速度、書き込み操作を処理します。</span><span class="sxs-lookup"><span data-stu-id="e0130-183">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="e0130-184">このメソッドが戻るとき、スレッド プールがオンデマンドで作成するワーカー スレッドの最小数が含まれています。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-184">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="e0130-185">このメソッドが戻るとき、スレッド プールがオンデマンドで作成する非同期 I/O スレッドの最小数が含まれています。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-185">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-186">スレッドがオンデマンドで (新しい要求の発生ごとに) 作成するスレッド プールの数を取得します。この数を超えると、スレッドの作成と破棄を管理するためのアルゴリズムに切り替わります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-186">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-187">スレッド プールは、新しい worker スレッドまたは I/O 完了スレッド オンデマンドでカテゴリごとの最小値に達するまで。</span><span class="sxs-lookup"><span data-stu-id="e0130-187">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="e0130-188">既定では、スレッドの最小数は、システム上のプロセッサの数に設定します。</span><span class="sxs-lookup"><span data-stu-id="e0130-188">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="e0130-189">最小値に達すると、スレッド プールはそのカテゴリで追加のスレッドを作成または、いくつかのタスクを完了するまで待機できます。</span><span class="sxs-lookup"><span data-stu-id="e0130-189">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="e0130-190">以降では、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、スレッド プールを作成し、時間の単位あたりの完了タスクの数として定義されているスループットを最適化するためにスレッドを破棄します。</span><span class="sxs-lookup"><span data-stu-id="e0130-190">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="e0130-191">スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-191">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e0130-192">要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-192">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e0130-193">次の例では、ワーカー スレッドの最小数を 4 に設定し、非同期 I/O 完了スレッドの最小数の元の値を保持します。</span><span class="sxs-lookup"><span data-stu-id="e0130-193">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e0130-194">メソッドを実行するためのキューに置きます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-194">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="e0130-195">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-195">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="e0130-196">実行するメソッドを表す <see cref="T:System.Threading.WaitCallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-196">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-197">メソッドを実行するためのキューに置きます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-197">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="e0130-198">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-198">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-199">メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-199">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-200">キューに置かれたメソッド、クラス、メソッドが定義されている場合、または使用することができますのインスタンス フィールドで必要なデータを配置することができます、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>を必要なデータを格納するオブジェクトを受け入れるオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="e0130-200">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e0130-201">Visual Basic の場合は省略できます、<xref:System.Threading.WaitCallback>コンス トラクター、および使用して、`AddressOf`演算子にコールバック メソッドを渡すときに<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>します。</span><span class="sxs-lookup"><span data-stu-id="e0130-201">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="e0130-202">Visual Basic は、自動的に適切なデリゲート コンス トラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e0130-202">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="e0130-203">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="e0130-203">Version Information</span></span>  
 <span data-ttu-id="e0130-204">.NET Framework version 2.0 で、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値はワーカー スレッドに反映を使用してキューに置かれた、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-204">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="e0130-205">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-205">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e0130-206">次の例では、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29>メソッドのオーバー ロードによって表される、タスクをキューに入れ、`ThreadProc`メソッドは、スレッドが使用可能なときに実行します。</span><span class="sxs-lookup"><span data-stu-id="e0130-206">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="e0130-207">このオーバー ロードでタスク情報が提供されていません。</span><span class="sxs-lookup"><span data-stu-id="e0130-207">No task information is supplied with this overload.</span></span> <span data-ttu-id="e0130-208">そのため、使用可能な情報、`ThreadProc`メソッドは、メソッドが属するオブジェクトに制限されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-208">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e0130-209">
            <paramref name="callBack" /> は <see langword="null" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-209">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="e0130-210">共通言語ランタイム (CLR) がホストされており、ホストではこのアクションがサポートされていません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-210">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="e0130-211">実行するメソッドを表す <see cref="T:System.Threading.WaitCallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-211">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="e0130-212">メソッドが使用するデータを格納したオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-212">An object containing data to be used by the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-213">実行するためのキューにメソッドを置き、そのメソッドが使用するデータを含んだオブジェクトを指定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-213">Queues a method for execution, and specifies an object containing data to be used by the method.</span>
          </span>
          <span data-ttu-id="e0130-214">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-214">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-215">メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-215">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-216">コールバック メソッドは、複雑なデータを必要とする場合は、データを格納するクラスを定義することができます。</span><span class="sxs-lookup"><span data-stu-id="e0130-216">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="e0130-217">Visual Basic の場合は省略できます、<xref:System.Threading.WaitCallback>コンス トラクター、および使用して、`AddressOf`演算子にコールバック メソッドを渡すときに<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>します。</span><span class="sxs-lookup"><span data-stu-id="e0130-217">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="e0130-218">Visual Basic は、自動的に適切なデリゲート コンス トラクターを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="e0130-218">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="e0130-219">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="e0130-219">Version Information</span></span>  
 <span data-ttu-id="e0130-220">.NET Framework version 2.0 で、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値はワーカー スレッドに反映を使用してキューに置かれた、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-220">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="e0130-221">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-221">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e0130-222">次の例では、.NET スレッド プールを使用して計算する、 `Fibonacci` 20 ~ 40 の間の 5 つの数値の結果。</span><span class="sxs-lookup"><span data-stu-id="e0130-222">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="e0130-223">各 `Fibonacci` の結果は `Fibonacci` クラスによって表され、このクラスには計算を実行する `ThreadPoolCallback` という名前のメソッドがあります。</span><span class="sxs-lookup"><span data-stu-id="e0130-223">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="e0130-224">`Fibonacci` の各値を表すオブジェクトが作成され、`ThreadPoolCallback` メソッドが <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> に渡されます。このメソッドは、プール内の使用可能なスレッドを割り当てて、渡されたメソッドを実行します。</span><span class="sxs-lookup"><span data-stu-id="e0130-224">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="e0130-225">ため、各`Fibonacci`オブジェクトには、計算に準ランダムな値が指定し、各スレッドは、プロセッサ時間の競合は、ため、5 つすべての結果を計算するかかる事前にどれくらいの時間を知ることはできません。</span><span class="sxs-lookup"><span data-stu-id="e0130-225">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="e0130-226">そのため、各 `Fibonacci` オブジェクトには構築の間に <xref:System.Threading.ManualResetEvent> クラスのインスタンスを渡されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-226">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="e0130-227">各オブジェクトが指定されたイベント オブジェクトに通知と、計算が完了すると、これにより、プライマリ スレッドで実行をブロック<xref:System.Threading.WaitHandle.WaitAll%2A>まで 5 つすべて`Fibonacci`オブジェクトが、結果を計算します。</span><span class="sxs-lookup"><span data-stu-id="e0130-227">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="e0130-228">その後、`Main` メソッドは各 `Fibonacci` の結果を表示します。</span><span class="sxs-lookup"><span data-stu-id="e0130-228">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="e0130-229">共通言語ランタイム (CLR) がホストされており、ホストではこのアクションがサポートされていません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-229">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e0130-230">
            <paramref name="callBack" /> は <see langword="null" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-230">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e0130-231">
            <see cref="T:System.Threading.WaitHandle" /> を待機しているデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-231">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="e0130-232">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-232">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="e0130-233">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-233">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="e0130-234">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-234">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="e0130-235">デリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-235">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="e0130-236">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-236">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="e0130-237">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-237">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="e0130-238">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-238">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="e0130-239">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-239">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-240">ミリ秒単位のタイムアウトとして 32 ビット符号付き整数を指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-240">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-241">ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-241">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-242">完了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出しの<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="e0130-242">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="e0130-243">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="e0130-243">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="e0130-244">ガベージ コレクションの詳細は効率的に動作を呼び出す場合、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録済みの待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="e0130-244">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="e0130-245"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドがスレッド プールに指定したデリゲートをキューします。</span><span class="sxs-lookup"><span data-stu-id="e0130-245">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="e0130-246">次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="e0130-246">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="e0130-247">指定したオブジェクトはシグナルの状態です。</span><span class="sxs-lookup"><span data-stu-id="e0130-247">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="e0130-248">タイムアウト間隔が経過しました。</span><span class="sxs-lookup"><span data-stu-id="e0130-248">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="e0130-249"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドは、指定したオブジェクトの現在の状態を確認します。<xref:System.Threading.WaitHandle>します。</span><span class="sxs-lookup"><span data-stu-id="e0130-249">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="e0130-250">オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="e0130-250">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="e0130-251">待機操作は、スレッド プールのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-251">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="e0130-252">デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-252">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="e0130-253">場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト間隔が経過するたびに、タイマーがリセットされます。</span><span class="sxs-lookup"><span data-stu-id="e0130-253">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e0130-254">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するためのコールバックに対する相互排除を行いません`WT_EXECUTEDEFAULT`フラグ、個別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="e0130-254">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="e0130-255">代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore> 1 の最大数。</span><span class="sxs-lookup"><span data-stu-id="e0130-255">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="e0130-256">待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-256">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="e0130-257">待機スレッドが Win32 を使用して`WaitForMultipleObjects`登録済みの待機操作を監視する関数。</span><span class="sxs-lookup"><span data-stu-id="e0130-257">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="e0130-258">そのため、同じネイティブのオペレーティング システム ハンドルを使用する場合を複数回呼び出す<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。</span><span class="sxs-lookup"><span data-stu-id="e0130-258">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="e0130-259">渡されたイベント オブジェクトをしないパルスする必要がありますに注意してください。<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためです。</span><span class="sxs-lookup"><span data-stu-id="e0130-259">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="e0130-260">関数は、戻る前に、一部の種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="e0130-260">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="e0130-261">変更は、オブジェクトがシグナル状態の原因となった待機条件を満たす場合にのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="e0130-261">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="e0130-262">たとえば、セマフォのカウントは 1 つ減少します。</span><span class="sxs-lookup"><span data-stu-id="e0130-262">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="e0130-263">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="e0130-263">Version Information</span></span>  
 <span data-ttu-id="e0130-264">.NET Framework バージョン 2.0 以降、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値はワーカー スレッドに反映を使用してキューに置かれた、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-264">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="e0130-265">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-265">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e0130-266">
            <paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-266">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="e0130-267">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-267">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="e0130-268">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-268">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="e0130-269">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-269">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="e0130-270">デリゲートに渡されたオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-270">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="e0130-271">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-271">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="e0130-272">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-272">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="e0130-273">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-273">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="e0130-274">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-274">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-275">64 ビット符号付き整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-275">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-276">ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-276">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-277">完了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出しの<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="e0130-277">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="e0130-278">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="e0130-278">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="e0130-279">ガベージ コレクションの詳細は効率的に動作を呼び出す場合、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録済みの待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="e0130-279">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="e0130-280"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドがスレッド プールに指定したデリゲートをキューします。</span><span class="sxs-lookup"><span data-stu-id="e0130-280">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="e0130-281">次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="e0130-281">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="e0130-282">指定したオブジェクトはシグナルの状態です。</span><span class="sxs-lookup"><span data-stu-id="e0130-282">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="e0130-283">タイムアウト間隔が経過しました。</span><span class="sxs-lookup"><span data-stu-id="e0130-283">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="e0130-284"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドは、指定したオブジェクトの現在の状態を確認します。<xref:System.Threading.WaitHandle>します。</span><span class="sxs-lookup"><span data-stu-id="e0130-284">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="e0130-285">オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="e0130-285">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="e0130-286">待機操作は、スレッド プールのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-286">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="e0130-287">デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-287">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="e0130-288">場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト間隔が経過するたびに、タイマーがリセットされます。</span><span class="sxs-lookup"><span data-stu-id="e0130-288">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e0130-289">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するためのコールバックに対する相互排除を行いません`WT_EXECUTEDEFAULT`フラグ、個別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="e0130-289">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="e0130-290">代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore> 1 の最大数。</span><span class="sxs-lookup"><span data-stu-id="e0130-290">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="e0130-291">待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-291">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="e0130-292">待機スレッドが Win32 を使用して`WaitForMultipleObjects`登録済みの待機操作を監視する関数。</span><span class="sxs-lookup"><span data-stu-id="e0130-292">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="e0130-293">そのため、同じネイティブのオペレーティング システム ハンドルを使用する場合を複数回呼び出す<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。</span><span class="sxs-lookup"><span data-stu-id="e0130-293">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="e0130-294">渡されたイベント オブジェクトをしないパルスする必要がありますに注意してください。<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためです。</span><span class="sxs-lookup"><span data-stu-id="e0130-294">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="e0130-295">関数は、戻る前に、一部の種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="e0130-295">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="e0130-296">変更は、オブジェクトがシグナル状態の原因となった待機条件を満たす場合にのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="e0130-296">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="e0130-297">たとえば、セマフォのカウントは 1 つ減少します。</span><span class="sxs-lookup"><span data-stu-id="e0130-297">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="e0130-298">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="e0130-298">Version Information</span></span>  
 <span data-ttu-id="e0130-299">.NET Framework バージョン 2.0 以降、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値はワーカー スレッドに反映を使用してキューに置かれた、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-299">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="e0130-300">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-300">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e0130-301">
            <paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-301">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="e0130-302">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-302">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="e0130-303">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-303">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="e0130-304">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-304">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="e0130-305">デリゲートに渡されたオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-305">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="e0130-306">
            <see cref="T:System.TimeSpan" /> で表されるタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-306">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="e0130-307">
            <c>timeout</c> が 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-307">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="e0130-308">
            <c>timeout</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-308">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="e0130-309">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-309">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-310">
            <see cref="T:System.TimeSpan" /> 値をタイムアウトとして指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-310">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-311">ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-311">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-312">完了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出しの<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="e0130-312">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="e0130-313">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="e0130-313">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="e0130-314">ガベージ コレクションの詳細は効率的に動作を呼び出す場合、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録済みの待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="e0130-314">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="e0130-315"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドがスレッド プールに指定したデリゲートをキューします。</span><span class="sxs-lookup"><span data-stu-id="e0130-315">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="e0130-316">次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="e0130-316">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="e0130-317">指定したオブジェクトはシグナルの状態です。</span><span class="sxs-lookup"><span data-stu-id="e0130-317">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="e0130-318">タイムアウト間隔が経過しました。</span><span class="sxs-lookup"><span data-stu-id="e0130-318">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="e0130-319"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドは、指定したオブジェクトの現在の状態を確認します。<xref:System.Threading.WaitHandle>します。</span><span class="sxs-lookup"><span data-stu-id="e0130-319">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="e0130-320">オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="e0130-320">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="e0130-321">待機操作は、スレッド プールのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-321">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="e0130-322">デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-322">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="e0130-323">場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト間隔が経過するたびに、タイマーがリセットされます。</span><span class="sxs-lookup"><span data-stu-id="e0130-323">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e0130-324">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するためのコールバックに対する相互排除を行いません`WT_EXECUTEDEFAULT`フラグ、個別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="e0130-324">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="e0130-325">代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore> 1 の最大数。</span><span class="sxs-lookup"><span data-stu-id="e0130-325">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="e0130-326">待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-326">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="e0130-327">待機スレッドが Win32 を使用して`WaitForMultipleObjects`登録済みの待機操作を監視する関数。</span><span class="sxs-lookup"><span data-stu-id="e0130-327">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="e0130-328">そのため、同じネイティブのオペレーティング システム ハンドルを使用する場合を複数回呼び出す<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。</span><span class="sxs-lookup"><span data-stu-id="e0130-328">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="e0130-329">渡されたイベント オブジェクトをしないパルスする必要がありますに注意してください。<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためです。</span><span class="sxs-lookup"><span data-stu-id="e0130-329">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="e0130-330">関数は、戻る前に、一部の種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="e0130-330">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="e0130-331">変更は、オブジェクトがシグナル状態の原因となった待機条件を満たす場合にのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="e0130-331">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="e0130-332">たとえば、セマフォのカウントは 1 つ減少します。</span><span class="sxs-lookup"><span data-stu-id="e0130-332">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="e0130-333">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="e0130-333">Version Information</span></span>  
 <span data-ttu-id="e0130-334">.NET Framework バージョン 2.0 以降、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値はワーカー スレッドに反映を使用してキューに置かれた、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-334">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="e0130-335">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-335">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e0130-336">
            <paramref name="timeout" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-336">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="e0130-337">
            <paramref name="timeout" /> パラメーターが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-337">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="e0130-338">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-338">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="e0130-339">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-339">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="e0130-340">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-340">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="e0130-341">デリゲートに渡されたオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-341">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="e0130-342">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-342">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="e0130-343">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-343">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="e0130-344">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-344">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="e0130-345">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-345">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-346">32 ビット符号なし整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-346">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-347">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-347">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-348">完了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出しの<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="e0130-348">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="e0130-349">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="e0130-349">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="e0130-350">ガベージ コレクションの詳細は効率的に動作を呼び出す場合、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録済みの待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="e0130-350">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="e0130-351"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドがスレッド プールに指定したデリゲートをキューします。</span><span class="sxs-lookup"><span data-stu-id="e0130-351">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="e0130-352">次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="e0130-352">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="e0130-353">指定したオブジェクトはシグナルの状態です。</span><span class="sxs-lookup"><span data-stu-id="e0130-353">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="e0130-354">タイムアウト間隔が経過しました。</span><span class="sxs-lookup"><span data-stu-id="e0130-354">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="e0130-355"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドは、指定したオブジェクトの現在の状態を確認します。<xref:System.Threading.WaitHandle>します。</span><span class="sxs-lookup"><span data-stu-id="e0130-355">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="e0130-356">オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="e0130-356">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="e0130-357">待機操作は、スレッド プールのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-357">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="e0130-358">デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-358">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="e0130-359">場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト間隔が経過するたびに、タイマーがリセットされます。</span><span class="sxs-lookup"><span data-stu-id="e0130-359">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="e0130-360">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するためのコールバックに対する相互排除を行いません`WT_EXECUTEDEFAULT`フラグ、個別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="e0130-360">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="e0130-361">代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore> 1 の最大数。</span><span class="sxs-lookup"><span data-stu-id="e0130-361">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="e0130-362">待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-362">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="e0130-363">待機スレッドが Win32 を使用して`WaitForMultipleObjects`登録済みの待機操作を監視する関数。</span><span class="sxs-lookup"><span data-stu-id="e0130-363">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="e0130-364">そのため、同じネイティブのオペレーティング システム ハンドルを使用する場合を複数回呼び出す<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。</span><span class="sxs-lookup"><span data-stu-id="e0130-364">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="e0130-365">渡されたイベント オブジェクトをしないパルスする必要がありますに注意してください。<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないためです。</span><span class="sxs-lookup"><span data-stu-id="e0130-365">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="e0130-366">関数は、戻る前に、一部の種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="e0130-366">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="e0130-367">変更は、オブジェクトがシグナル状態の原因となった待機条件を満たす場合にのみ発生します。</span><span class="sxs-lookup"><span data-stu-id="e0130-367">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="e0130-368">たとえば、セマフォのカウントは 1 つ減少します。</span><span class="sxs-lookup"><span data-stu-id="e0130-368">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="e0130-369">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="e0130-369">Version Information</span></span>  
 <span data-ttu-id="e0130-370">.NET Framework バージョン 2.0 以降、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値はワーカー スレッドに反映を使用してキューに置かれた、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-370">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="e0130-371">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-371">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e0130-372">次の例は、使用する方法を示します、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>指定した待機ハンドルがシグナル通知されたときに、指定されたコールバック メソッドを実行するメソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-372">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="e0130-373">この例では、コールバック メソッドは`WaitProc`、待機ハンドルがあり、<xref:System.Threading.AutoResetEvent>します。</span><span class="sxs-lookup"><span data-stu-id="e0130-373">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="e0130-374">例では、定義、`TaskInfo`を実行するときに、コールバックに渡される情報を保持するクラス。</span><span class="sxs-lookup"><span data-stu-id="e0130-374">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="e0130-375">例は、作成、`TaskInfo`オブジェクトし、文字列データを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="e0130-375">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="e0130-376"><xref:System.Threading.RegisteredWaitHandle>によって返される、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>に割り当てられているメソッド、`Handle`のフィールド、`TaskInfo`オブジェクトをコールバック メソッドへのアクセスを持つよう、<xref:System.Threading.RegisteredWaitHandle>します。</span><span class="sxs-lookup"><span data-stu-id="e0130-376">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="e0130-377">指定するだけでなく`TaskInfo`への呼び出し、コールバック メソッドに渡すためにオブジェクトとして、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドを指定します、 <xref:System.Threading.AutoResetEvent> 、タスクが待機する、<xref:System.Threading.WaitOrTimerCallback>を表すデリゲート、`WaitProc`コールバック メソッド、1 秒のタイムアウト間隔、および複数のコールバック。</span><span class="sxs-lookup"><span data-stu-id="e0130-377">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="e0130-378">メイン スレッドに通知すると、<xref:System.Threading.AutoResetEvent>を呼び出してその<xref:System.Threading.EventWaitHandle.Set%2A>メソッド、<xref:System.Threading.WaitOrTimerCallback>デリゲートが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="e0130-378">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="e0130-379">`WaitProc`メソッド テスト<xref:System.Threading.RegisteredWaitHandle>タイムアウトが発生したかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="e0130-379">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="e0130-380">待機ハンドルがシグナル通知されたため、コールバックが呼び出された場合、`WaitProc`メソッドの登録を解除、<xref:System.Threading.RegisteredWaitHandle>コールバックの追加を停止しています。</span><span class="sxs-lookup"><span data-stu-id="e0130-380">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="e0130-381">タイムアウトの場合は、タスクが待機する続けます。</span><span class="sxs-lookup"><span data-stu-id="e0130-381">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="e0130-382">`WaitProc`メソッドは、コンソールにメッセージを出力することによって終了します。</span><span class="sxs-lookup"><span data-stu-id="e0130-382">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e0130-383">
            <paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-383">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="e0130-384">スレッド プール内のワーカー スレッドの最大数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-384">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="e0130-385">スレッド プール内の非同期 I/O スレッドの最大数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-385">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-386">同時にアクティブにできるスレッド プールへの要求の数を設定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-386">Sets the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="e0130-387">この数を超える要求はすべて、スレッド プール スレッドが使用可能になるまでキューに置かれたままになります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-387">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-388">変更が成功した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-388">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-389">設定できません worker スレッドまたは I/O 完了スレッドの最大数を数値に、コンピューター上のプロセッサの数より小さい。</span><span class="sxs-lookup"><span data-stu-id="e0130-389">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="e0130-390">プロセッサの数が存在するかを判断するには、値を取得、<xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="e0130-390">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="e0130-391">さらに、ワーカー スレッドまたはワーカー スレッドの対応する最小数よりも小さい数に、I/O 完了スレッドまたは I/O 完了スレッドの最大数を設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="e0130-391">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="e0130-392">最小のスレッド プールのサイズを確認するのには、呼び出し、<xref:System.Threading.ThreadPool.GetMinThreads%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="e0130-392">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="e0130-393">共通言語ランタイムがホストされている場合などによって、インターネット インフォメーション サービス (IIS) または SQL Server では、ホストを制限したりスレッド プールのサイズが変更されないようにできます。</span><span class="sxs-lookup"><span data-stu-id="e0130-393">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="e0130-394">スレッド プール内のスレッドの最大数を変更する場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-394">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="e0130-395">コードにとって有益なときに、変更は、コード ライブラリを使用するに悪影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-395">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="e0130-396">スレッド プールのサイズが大きすぎる設定と、パフォーマンスの問題が発生することができます。</span><span class="sxs-lookup"><span data-stu-id="e0130-396">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="e0130-397">スレッドが多すぎると同時に実行されて場合のタスクの切り替えは重要な要因をオーバーヘッドになります。</span><span class="sxs-lookup"><span data-stu-id="e0130-397">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e0130-398">スレッドを制御する機能。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-398">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="e0130-399">アクセス許可の値。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-399">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="e0130-400">スレッド プールがオンデマンドで作成するワーカー スレッドの最小数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-400">The minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="e0130-401">スレッド プールがオンデマンドで作成する非同期 I/O スレッドの最小数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-401">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-402">スレッドがオンデマンドで (新しい要求の発生ごとに) 作成するスレッド プールの数を設定します。この数を超えると、スレッドの作成と破棄を管理するためのアルゴリズムに切り替わります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-402">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-403">変更が成功した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-403">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-404">スレッド プールは、新しい worker スレッドまたは I/O 完了スレッド オンデマンドでカテゴリごとの最小値に達するまで。</span><span class="sxs-lookup"><span data-stu-id="e0130-404">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="e0130-405">最小値に達すると、スレッド プールはそのカテゴリで追加のスレッドを作成または、いくつかのタスクを完了するまで待機できます。</span><span class="sxs-lookup"><span data-stu-id="e0130-405">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="e0130-406">以降では、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、スレッド プールを作成し、時間の単位あたりの完了タスクの数として定義されているスループットを最適化するためにスレッドを破棄します。</span><span class="sxs-lookup"><span data-stu-id="e0130-406">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="e0130-407">スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-407">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="e0130-408">要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-408">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="e0130-409">負の数またはアクティブなスレッド プールのスレッドの最大数より大きい数値を指定する場合 (を使用して取得<xref:System.Threading.ThreadPool.GetMaxThreads%2A>)、<xref:System.Threading.ThreadPool.SetMinThreads%2A>返します`false`最小値のいずれかが変更されていないとします。</span><span class="sxs-lookup"><span data-stu-id="e0130-409">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e0130-410">既定では、スレッドの最小数は、システム上のプロセッサの数に設定します。</span><span class="sxs-lookup"><span data-stu-id="e0130-410">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="e0130-411">使用することができます、<xref:System.Threading.ThreadPool.SetMinThreads%2A>最小番号 ofthreads を増加させます。</span><span class="sxs-lookup"><span data-stu-id="e0130-411">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="e0130-412">ただし、これらの値を必要以上に大きくすると、パフォーマンスの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-412">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="e0130-413">同時に開始するタスクの数が多すぎる場合は、すべてのタスクで処理速度が低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="e0130-413">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="e0130-414">ほとんどの場合、スレッド プール パフォーマンスが向上スレッドを割り当てるための独自のアルゴリズムを使用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-414">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="e0130-415">プロセッサの数、パフォーマンスが低下もより小さくするには、最小値を減らします。</span><span class="sxs-lookup"><span data-stu-id="e0130-415">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e0130-416">次の例では、ワーカー スレッドの最小数を 4 に設定し、非同期 I/O 完了スレッドの最小数の元の値を保持します。</span><span class="sxs-lookup"><span data-stu-id="e0130-416">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="e0130-417">スレッドを制御する機能。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-417">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="e0130-418">アクセス許可の値。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-418">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <span data-ttu-id="e0130-419">キューに置く <see cref="T:System.Threading.NativeOverlapped" /> 構造体。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-419">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-420">重複した I/O 操作を、実行するためのキューに置きます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-420">Queues an overlapped I/O operation for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-421">操作が I/O 完了ポートのキューに正常に置かれた場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-421">
              <see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-422">重複 I/O をネイティブ Win32 の使用に関する情報を参照してください、<xref:System.Threading.Overlapped>クラス、<xref:System.Threading.NativeOverlapped>構造体、および`OVERLAPPED`Win32 プラットフォーム SDK の構造体。</span><span class="sxs-lookup"><span data-stu-id="e0130-422">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e0130-423">使用して、<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>メソッドは、セキュリティ ホールを誤って開けません。</span><span class="sxs-lookup"><span data-stu-id="e0130-423">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="e0130-424">コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可には、そのアクセス許可チェックを行います。</span><span class="sxs-lookup"><span data-stu-id="e0130-424">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="e0130-425">使用してスレッド プール スレッドで作業がキューに置かれたときに<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="e0130-425">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="e0130-426">悪意のあるコードができるアクセス許可のチェックを回避するためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-426">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e0130-427">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-427">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e0130-428">このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-428">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="e0130-429">スレッド プール内のスレッドが作業項目をピック アップするときに呼び出すデリゲートを表す <see cref="T:System.Threading.WaitCallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-429">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="e0130-430">スレッド プールから処理されるときにデリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-430">The object that is passed to the delegate when serviced from the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-431">指定したデリゲートをスレッド プールのキューに置きます。ただし、コール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-431">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-432">メソッドが成功した場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.OutOfMemoryException" /> がスローされます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-432">
              <see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-433">異なり、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッド、<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>は、ワーカー スレッドに呼び出し元のスタックに伝達されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-433">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="e0130-434">これにより、コード、呼び出し履歴が失われると、セキュリティ特権を昇格することができます。</span><span class="sxs-lookup"><span data-stu-id="e0130-434">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e0130-435">使用して<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>セキュリティ ホールを開くことが誤ってでした。</span><span class="sxs-lookup"><span data-stu-id="e0130-435">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="e0130-436">コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可には、そのアクセス許可チェックを行います。</span><span class="sxs-lookup"><span data-stu-id="e0130-436">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="e0130-437">使用してスレッド プール スレッドで作業がキューに置かれたときに<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="e0130-437">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="e0130-438">悪意のあるコードができるアクセス許可のチェックを回避するためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-438">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e0130-439">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-439">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="e0130-440">メモリが不足しています。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-440">An out-of-memory condition was encountered.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="e0130-441">作業項目をキューに配置できません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-441">The work item could not be queued.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="e0130-442">
            <paramref name="callBack" /> は <see langword="null" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-442">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e0130-443">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-443">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e0130-444">このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-444">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="e0130-445">
            <see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。ただし、コール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-445">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="e0130-446">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-446">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="e0130-447">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-447">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="e0130-448">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-448">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="e0130-449">デリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-449">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="e0130-450">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-450">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="e0130-451">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-451">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="e0130-452">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-452">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="e0130-453">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-453">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-454">ミリ秒単位のタイムアウトとして 32 ビット符号付き整数を使用して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-454">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="e0130-455">このメソッドはコール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-455">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-456">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-456">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-457">異なり、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>は、ワーカー スレッドに呼び出し元のスタックに伝達されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-457">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="e0130-458">これにより、コード、呼び出し履歴が失われると、セキュリティ特権を昇格することができます。</span><span class="sxs-lookup"><span data-stu-id="e0130-458">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e0130-459">使用して<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>セキュリティ ホールを開くことが誤ってでした。</span><span class="sxs-lookup"><span data-stu-id="e0130-459">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="e0130-460">コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可には、そのアクセス許可チェックを行います。</span><span class="sxs-lookup"><span data-stu-id="e0130-460">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="e0130-461">使用してスレッド プール スレッドで作業がキューに置かれたときに<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="e0130-461">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="e0130-462">悪意のあるコードができるアクセス許可のチェックを回避するためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-462">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="e0130-463">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するためのコールバックに対する相互排除を行いません`WT_EXECUTEDEFAULT`フラグ、個別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="e0130-463">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="e0130-464">完了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出しの<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="e0130-464">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="e0130-465">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="e0130-465">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="e0130-466">ガベージ コレクションの詳細は効率的に動作を呼び出す場合、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録済みの待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="e0130-466">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e0130-467">
            <paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-467">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e0130-468">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-468">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e0130-469">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-469">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e0130-470">このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-470">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="e0130-471">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-471">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="e0130-472">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-472">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="e0130-473">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-473">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="e0130-474">デリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-474">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="e0130-475">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-475">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="e0130-476">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-476">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="e0130-477">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-477">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="e0130-478">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-478">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-479">64 ビット符号付き整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-479">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="e0130-480">このメソッドはコール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-480">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-481">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-481">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-482">異なり、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>は、ワーカー スレッドに呼び出し元のスタックに伝達されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-482">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="e0130-483">これにより、コード、呼び出し履歴が失われると、セキュリティ特権を昇格することができます。</span><span class="sxs-lookup"><span data-stu-id="e0130-483">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e0130-484">使用して<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>セキュリティ ホールを開くことが誤ってでした。</span><span class="sxs-lookup"><span data-stu-id="e0130-484">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="e0130-485">コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可には、そのアクセス許可チェックを行います。</span><span class="sxs-lookup"><span data-stu-id="e0130-485">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="e0130-486">使用してスレッド プール スレッドで作業がキューに置かれたときに<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="e0130-486">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="e0130-487">悪意のあるコードができるアクセス許可のチェックを回避するためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-487">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="e0130-488">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するためのコールバックに対する相互排除を行いません`WT_EXECUTEDEFAULT`フラグ、個別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="e0130-488">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="e0130-489">完了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出しの<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="e0130-489">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="e0130-490">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="e0130-490">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="e0130-491">ガベージ コレクションの詳細は効率的に動作を呼び出す場合、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録済みの待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="e0130-491">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e0130-492">
            <paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-492">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e0130-493">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-493">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e0130-494">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-494">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e0130-495">このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-495">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="e0130-496">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-496">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="e0130-497">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-497">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="e0130-498">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-498">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="e0130-499">デリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-499">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="e0130-500">
            <see cref="T:System.TimeSpan" /> で表されるタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-500">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="e0130-501">
            <c>timeout</c> が 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-501">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="e0130-502">
            <c>timeout</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-502">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="e0130-503">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-503">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-504">
            <see cref="T:System.TimeSpan" /> 値をタイムアウトとして指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。このメソッドはコール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-504">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-505">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-505">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-506">異なり、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>は、ワーカー スレッドに呼び出し元のスタックに伝達されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-506">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="e0130-507">これにより、コード、呼び出し履歴が失われると、セキュリティ特権を昇格することができます。</span><span class="sxs-lookup"><span data-stu-id="e0130-507">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e0130-508">使用して<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>セキュリティ ホールを開くことが誤ってでした。</span><span class="sxs-lookup"><span data-stu-id="e0130-508">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="e0130-509">コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可には、そのアクセス許可チェックを行います。</span><span class="sxs-lookup"><span data-stu-id="e0130-509">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="e0130-510">使用してスレッド プール スレッドで作業がキューに置かれたときに<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="e0130-510">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="e0130-511">悪意のあるコードができるアクセス許可のチェックを回避するためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-511">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="e0130-512">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するためのコールバックに対する相互排除を行いません`WT_EXECUTEDEFAULT`フラグ、個別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="e0130-512">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="e0130-513">完了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出しの<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="e0130-513">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="e0130-514">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="e0130-514">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="e0130-515">ガベージ コレクションの詳細は効率的に動作を呼び出す場合、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録済みの待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="e0130-515">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="e0130-516">
            <paramref name="timeout" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-516">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="e0130-517">
            <paramref name="timeout" /> パラメーターが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-517">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e0130-518">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-518">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e0130-519">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-519">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e0130-520">このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-520">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="e0130-521">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-521">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="e0130-522">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-522">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="e0130-523">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-523">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="e0130-524">デリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-524">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="e0130-525">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-525">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="e0130-526">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-526">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="e0130-527">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-527">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="e0130-528">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-528">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="e0130-529">32 ビット符号なし整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-529">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="e0130-530">このメソッドはコール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-530">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="e0130-531">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-531">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e0130-532">異なり、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>は、ワーカー スレッドに呼び出し元のスタックに伝達されません。</span><span class="sxs-lookup"><span data-stu-id="e0130-532">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="e0130-533">これにより、コード、呼び出し履歴が失われると、セキュリティ特権を昇格することができます。</span><span class="sxs-lookup"><span data-stu-id="e0130-533">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="e0130-534">使用して<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>セキュリティ ホールを開くことが誤ってでした。</span><span class="sxs-lookup"><span data-stu-id="e0130-534">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="e0130-535">コード アクセス セキュリティは、スタック上のすべての呼び出し元のアクセス許可には、そのアクセス許可チェックを行います。</span><span class="sxs-lookup"><span data-stu-id="e0130-535">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="e0130-536">使用してスレッド プール スレッドで作業がキューに置かれたときに<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="e0130-536">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="e0130-537">悪意のあるコードができるアクセス許可のチェックを回避するためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="e0130-537">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="e0130-538">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するためのコールバックに対する相互排除を行いません`WT_EXECUTEDEFAULT`フラグ、個別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="e0130-538">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="e0130-539">完了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出しの<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="e0130-539">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="e0130-540">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="e0130-540">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="e0130-541">ガベージ コレクションの詳細は効率的に動作を呼び出す場合、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録済みの待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="e0130-541">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="e0130-542">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-542">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="e0130-543">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-543">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="e0130-544">このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="e0130-544">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>