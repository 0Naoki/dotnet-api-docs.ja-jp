<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2a9494e53c8c3c4a4db1cc0f00c52b716f7945b8" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36406997" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="8ed2c-101">タスクの実行、作業項目のポスト、非同期 I/O の処理、他のスレッドの代理で行う待機、およびタイマーの処理に使用できるスレッドのプールを提供します。</span>
      <span class="sxs-lookup">
        <span data-stu-id="8ed2c-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-102">多くのアプリケーションでは、長時間時間スリープ状態で、イベントの発生を待機しているスレッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="8ed2c-103">他のスレッドは、スリープ状態の変更をポーリングまたは状態情報の更新を定期的にスリープ解除する場合にのみを入力します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="8ed2c-104">スレッド プールでは、システムによって管理されるワーカー スレッドのプールを使用してアプリケーションを提供することにより、スレッドをより効率的に使用することができます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="8ed2c-105">スレッド プールのスレッドを使用する操作の例については、次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="8ed2c-106">作成するときに、<xref:System.Threading.Tasks.Task>または<xref:System.Threading.Tasks.Task%601>タスクがスレッド プールのスレッドで実行するスケジュールを既定では、非同期的にいくつかのタスクを実行するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="8ed2c-107">非同期のタイマーは、スレッド プールを使用します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="8ed2c-108">スレッド プールのスレッドからのコールバックを実行する、<xref:System.Threading.Timer?displayProperty=nameWithType>クラスおよびからイベントを発生させる、<xref:System.Timers.Timer?displayProperty=nameWithType>クラスです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="8ed2c-109">登録された待機ハンドルを使用するときにシステム スレッドが待機ハンドルの状態を監視します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="8ed2c-110">待機操作が完了すると、スレッド プールからワーカー スレッドは、対応するコールバック関数を実行します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="8ed2c-111">呼び出すと、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>スレッド プールのスレッド上で実行するメソッドをキューにします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="8ed2c-112">メソッドを渡すことによって、これを行う、<xref:System.Threading.WaitCallback>を委任します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="8ed2c-113">デリゲートのシグネチャを持ちます</span><span class="sxs-lookup"><span data-stu-id="8ed2c-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="8ed2c-114">ここで`state`デリゲートによって使用されるデータを含むオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="8ed2c-115">実際のデータは、呼び出すことによって、デリゲートに渡すことが、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8ed2c-116">マネージ スレッド プール内のスレッドには、バック グラウンド スレッドがあります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="8ed2c-117">つまり、その<xref:System.Threading.Thread.IsBackground%2A>プロパティは、`true`です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="8ed2c-118">つまり、<xref:System.Threading.ThreadPool>スレッドでは、すべてのフォア グラウンド スレッドが終了した後に実行されるアプリケーションは保持されません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8ed2c-119">スレッド ローカル ストレージまたはでマークされたフィールドのデータは消去されません、スレッド プールには、スレッドが再利用、ときに、<xref:System.ThreadStaticAttribute>属性。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="8ed2c-120">したがって、メソッドがスレッド ローカル ストレージを検査またはフィールドが付いている、<xref:System.ThreadStaticAttribute>属性、値が見つかる可能性があります残されるスレッド プールのスレッドの以前の使用。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="8ed2c-121">また、スレッド プールに、待機操作に関連していない作業項目をキューできます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="8ed2c-122">作業項目をスレッド プール内のスレッドで処理することを要求するには、呼び出し、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="8ed2c-123">このメソッドは、メソッドまたはスレッド プールから選択したスレッドで呼び出されるデリゲートへの参照をパラメーターとして受け取ります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="8ed2c-124">キューに登録されましたが、作業項目をキャンセルする方法はありません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="8ed2c-125">タイマー キュー タイマーおよび登録された待機操作もスレッド プールを使用します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="8ed2c-126">これらのコールバック関数は、スレッド プールにキューに入っています。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="8ed2c-127">プロセスごとに 1 つのスレッド プールがあります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-127">There is one thread pool per process.</span></span> <span data-ttu-id="8ed2c-128">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 以降では、プロセスのスレッド プールの既定のサイズは、仮想アドレス空間のサイズなど、いくつかの要素によって決まります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="8ed2c-129">スレッドの数は、プロセスで <xref:System.Threading.ThreadPool.GetMaxThreads%2A> メソッドを呼び出せば確認できます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="8ed2c-130">使用しているスレッド プール内のスレッドの数を変更することができます、<xref:System.Threading.ThreadPool.SetMaxThreads%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="8ed2c-131">各スレッドは、既定のスタック サイズを使用し、既定の優先順位で実行します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8ed2c-132">.NET Framework をホストするアンマネージ コードを使用して、スレッド プールのサイズを変更できます、 `CorSetMaxThreads` mscoree.h ファイルで定義された関数。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="8ed2c-133">スレッド プールを提供新しいワーカー スレッドまたは I/O 完了スレッド要求時に各カテゴリの最小値に達するまでします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="8ed2c-134">最低限に達すると、スレッド プールはそのカテゴリに追加のスレッドを作成または、いくつかのタスクを完了するまで待機できます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="8ed2c-135">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 以降では、スループットを最適化するために、スレッド プールでワーカー スレッドの作成と破棄が行われます。スループットは、タスクの単位時間あたりの完了数として定義されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="8ed2c-136">スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8ed2c-137">要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="8ed2c-138">これらの最小値は、<xref:System.Threading.ThreadPool.GetMinThreads%2A> メソッドを使用して取得できます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8ed2c-139">使用することができます、<xref:System.Threading.ThreadPool.SetMinThreads%2A>スレッドの最小数を増加させます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="8ed2c-140">ただし、これらの値を必要以上に大きくすると、パフォーマンスの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="8ed2c-141">同時に開始するタスクの数が多すぎる場合は、すべてのタスクで処理速度が低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="8ed2c-142">ほとんどの場合、スレッドを割り当てるためのスレッド プール独自のアルゴリズムを使用することでスレッド プールのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ed2c-143">メイン アプリケーション スレッド キューという名前のメソッドに次の例では、`ThreadProc`スレッド プールのスレッドで 1 秒、および終了します。 スリープでを実行します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="8ed2c-144">`ThreadProc`メソッドには、単にメッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="8ed2c-145">呼び出しをコメントにする場合、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッド、メソッドは、スレッド プールのスレッドで実行する前に、メイン スレッドが終了しました。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="8ed2c-146">スレッド プールは、アプリケーションのすべてのフォア グラウンド スレッドが終了した場合に実行を継続しないバック グラウンドのスレッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="8ed2c-147">(これは、競合状態の簡単な例です)。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="8ed2c-148">この型はスレッド セーフです。</span>
      <span class="sxs-lookup">
        <span data-stu-id="8ed2c-148">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8ed2c-149">オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-149">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="8ed2c-150">ハンドルを保持する <see cref="T:System.IntPtr" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-150">An <see cref="T:System.IntPtr" /> that holds the handle.</span>
          </span>
          <span data-ttu-id="8ed2c-151">ハンドルは、アンマネージ側の重複 I/O 用に開かれている必要があります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-151">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-152">オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-152">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-153">ハンドルがバインドされている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-153">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8ed2c-154">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-154">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="8ed2c-155">アンマネージ コードを呼び出す必要なアクセス許可。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-155">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="8ed2c-156">
            <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-156">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle">
          <span data-ttu-id="8ed2c-157">オペレーティング システム ハンドルを保持する <see cref="T:System.Runtime.InteropServices.SafeHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-157">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span>
          </span>
          <span data-ttu-id="8ed2c-158">ハンドルは、アンマネージ側の重複 I/O 用に開かれている必要があります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-158">The handle must have been opened for overlapped I/O on the unmanaged side.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-159">オペレーティング システム ハンドルを <see cref="T:System.Threading.ThreadPool" /> にバインドします。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-159">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-160">ハンドルがバインドされている場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-160">
              <see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-161">`osHandle`パラメーターでなければなりません、 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>、抽象から派生した<xref:System.Runtime.InteropServices.SafeHandle>クラスです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-161">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8ed2c-162">
            <paramref name="osHandle" /> は <see langword="null" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-162">
              <paramref name="osHandle" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="8ed2c-163">アンマネージ コードを呼び出す必要なアクセス許可。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-163">for the ability to call unmanaged code.</span>
          </span>
          <span data-ttu-id="8ed2c-164">
            <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-164">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="8ed2c-165">使用できるワーカー スレッドの数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-165">The number of available worker threads.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="8ed2c-166">使用できる非同期 I/O スレッドの数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-166">The number of available asynchronous I/O threads.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-167">スレッド プール スレッドの最大数 (<see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> メソッドから返される) と現在アクティブなスレッドの数との差を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-167">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-168">ときに<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>で指定された変数を返します`workerThreads`を開始する追加のワーカー スレッドとで指定された変数の数を表す`completionPortThreads`ことができるその他の非同期 I/O スレッドの数が含まれています。開始しました。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-168">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="8ed2c-169">使用可能なスレッドがない場合は、追加のスレッド プールの要求までキューに置かれたスレッド プールのスレッドが使用可能になるです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-169">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ed2c-170">次の例では、簡単なアプリが開始されたときに、ワーカー スレッドと使用可能な I/O スレッドの数が表示されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-170">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="8ed2c-171">スレッド プール内のワーカー スレッドの最大数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-171">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="8ed2c-172">スレッド プール内の非同期 I/O スレッドの最大数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-172">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-173">同時にアクティブにできるスレッド プールへの要求の数を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-173">Retrieves the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="8ed2c-174">この数を超える要求はすべて、スレッド プール スレッドが使用可能になるまでキューに置かれたままになります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-174">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-175">ときに<xref:System.Threading.ThreadPool.GetMaxThreads%2A>で指定された変数を返します`workerThreads`スレッド プールで許可されるワーカー スレッドとで指定された変数の最大数を含む`completionPortThreads`で許可されている非同期 I/O スレッドの最大数が含まれています、。スレッド プールです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-175">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="8ed2c-176">使用することができます、<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>メソッドを特定の時点で実際のスレッド プール内のスレッド数を決定します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-176">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="8ed2c-177">使用することができます、<xref:System.Threading.ThreadPool.SetMaxThreads%2A>をスレッド プールでワーカー スレッドと非同期の I/O スレッドの最大数を設定します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-177">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="8ed2c-178">システム メモリが許す限り多くのスレッド プールの要求とキューにできます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-178">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="8ed2c-179">スレッド プールのスレッドよりも多くの要求がある場合、追加の要求までキューに置かれたスレッド プールのスレッドが使用可能になります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-179">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ed2c-180">次のコード例では、スレッド プール内のスレッドの最大値と使用可能な数のカウントを取得する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-180">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="8ed2c-181">使用する作業項目がキューに`FileStream`非同期に 2 つのファイルを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-181">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="8ed2c-182">オーバー ラップには、コールバック メソッドがタイムアウトしました。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-182">The callback methods are timed to overlap.</span></span> <span data-ttu-id="8ed2c-183">ワーカー スレッドが作業項目を処理し、速度と、コンピューター上のプロセッサの数に応じて 1 つまたは 2 つの完了ポート スレッドが書き込み操作を処理します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-183">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="8ed2c-184">このメソッドが戻るとき、スレッド プールがオンデマンドで作成するワーカー スレッドの最小数が含まれています。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-184">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="8ed2c-185">このメソッドが戻るとき、スレッド プールがオンデマンドで作成する非同期 I/O スレッドの最小数が含まれています。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-185">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-186">スレッドがオンデマンドで (新しい要求の発生ごとに) 作成するスレッド プールの数を取得します。この数を超えると、スレッドの作成と破棄を管理するためのアルゴリズムに切り替わります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-186">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-187">スレッド プールを提供新しいワーカー スレッドまたは I/O 完了スレッド要求時に各カテゴリの最小値に達するまでします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-187">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="8ed2c-188">既定では、スレッドの最小数は、システム上のプロセッサの数を設定します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-188">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="8ed2c-189">最低限に達すると、スレッド プールはそのカテゴリに追加のスレッドを作成または、いくつかのタスクを完了するまで待機できます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-189">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="8ed2c-190">以降で、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、スレッド プールを作成し、タスクの単位時間あたりの完了数として定義されるスループットを最適化するためにスレッドを破棄します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-190">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="8ed2c-191">スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-191">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8ed2c-192">要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-192">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ed2c-193">次の例では、ワーカー スレッドの最小数を 4 に設定し、非同期 I/O 完了スレッドの最小数の元の値を保持します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-193">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8ed2c-194">メソッドを実行するためのキューに置きます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-194">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="8ed2c-195">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-195">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="8ed2c-196">実行するメソッドを表す <see cref="T:System.Threading.WaitCallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-196">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-197">メソッドを実行するためのキューに置きます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-197">Queues a method for execution.</span>
          </span>
          <span data-ttu-id="8ed2c-198">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-198">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-199">メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-199">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-200">クラス、メソッドが定義されている、または使用することができますのインスタンス フィールドでキューに置かれたメソッドで必要なデータを配置することができます、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>を必要なデータを格納するオブジェクトを受け入れるオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-200">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8ed2c-201">Visual Basic の場合は省略できます、<xref:System.Threading.WaitCallback>コンス トラクター、および使用するだけで、`AddressOf`演算子にコールバック メソッドを渡すときに<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-201">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="8ed2c-202">Visual Basic では、適切なデリゲート コンス トラクターは、自動的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-202">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8ed2c-203">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="8ed2c-203">Version Information</span></span>  
 <span data-ttu-id="8ed2c-204">.NET framework version 2.0 では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-204">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="8ed2c-205">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-205">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ed2c-206">次の例で、<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29>メソッドのオーバー ロードによって表される、タスクをキューに入れ、`ThreadProc`メソッドは、スレッドが使用可能なになったときに実行します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-206">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="8ed2c-207">このオーバー ロードでタスク情報は提供されません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-207">No task information is supplied with this overload.</span></span> <span data-ttu-id="8ed2c-208">そのための情報に提供される、`ThreadProc`メソッドは、メソッドが属するオブジェクトに制限されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-208">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8ed2c-209">
            <paramref name="callBack" /> は <see langword="null" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-209">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8ed2c-210">共通言語ランタイム (CLR) がホストされており、ホストではこのアクションがサポートされていません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-210">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="8ed2c-211">実行するメソッドを表す <see cref="T:System.Threading.WaitCallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-211">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8ed2c-212">メソッドが使用するデータを格納したオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-212">An object containing data to be used by the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-213">実行するためのキューにメソッドを置き、そのメソッドが使用するデータを含んだオブジェクトを指定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-213">Queues a method for execution, and specifies an object containing data to be used by the method.</span>
          </span>
          <span data-ttu-id="8ed2c-214">メソッドは、スレッド プール スレッドが使用可能になったときに実行されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-214">The method executes when a thread pool thread becomes available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-215">メソッドが正常にキューに配置された場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.NotSupportedException" /> がスローされます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-215">
              <see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-216">コールバック メソッドには、複雑なデータが必要とする場合は、データを格納するクラスを定義することができます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-216">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8ed2c-217">Visual Basic の場合は省略できます、<xref:System.Threading.WaitCallback>コンス トラクター、および使用するだけで、`AddressOf`演算子にコールバック メソッドを渡すときに<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-217">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="8ed2c-218">Visual Basic では、適切なデリゲート コンス トラクターは、自動的に呼び出します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-218">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8ed2c-219">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="8ed2c-219">Version Information</span></span>  
 <span data-ttu-id="8ed2c-220">.NET framework version 2.0 では、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-220">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="8ed2c-221">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-221">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ed2c-222">次の例では、タスクの情報を含むオブジェクトを作成する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-222">The following example shows how to create an object that contains task information.</span></span> <span data-ttu-id="8ed2c-223">実行のキューにタスクをスレッド プール内にそのオブジェクトを渡す方法も示します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-223">It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8ed2c-224">共通言語ランタイム (CLR) がホストされており、ホストではこのアクションがサポートされていません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-224">The common language runtime (CLR) is hosted, and the host does not support this action.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8ed2c-225">
            <paramref name="callBack" /> は <see langword="null" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-225">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8ed2c-226">
            <see cref="T:System.Threading.WaitHandle" /> を待機しているデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-226">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8ed2c-227">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-227">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8ed2c-228">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-228">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8ed2c-229">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-229">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8ed2c-230">デリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-230">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8ed2c-231">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-231">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8ed2c-232">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-232">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8ed2c-233">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-233">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8ed2c-234">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-234">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-235">ミリ秒単位のタイムアウトとして 32 ビット符号付き整数を指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-235">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-236">ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-236">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-237">終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-237">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8ed2c-238">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-238">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8ed2c-239">ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-239">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="8ed2c-240"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>キューにスレッド プールに指定されたデリゲート メソッド。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-240">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="8ed2c-241">次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-241">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="8ed2c-242">指定したオブジェクトはシグナルの状態です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-242">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="8ed2c-243">タイムアウト間隔が経過しました。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-243">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="8ed2c-244"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドの指定されたオブジェクトの現在の状態をチェックする<xref:System.Threading.WaitHandle>です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-244">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="8ed2c-245">オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-245">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="8ed2c-246">待機操作は、スレッド プールのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-246">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="8ed2c-247">デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-247">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="8ed2c-248">場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト期間が経過するたびに、タイマーがリセットします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-248">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8ed2c-249">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-249">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="8ed2c-250">代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore> 1 の最大数にします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-250">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="8ed2c-251">待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-251">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8ed2c-252">待機スレッドが、Win32 を使用して`WaitForMultipleObjects`登録された待機操作を監視する関数。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-252">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="8ed2c-253">したがってで同じオペレーティング システムのネイティブ ハンドルを使用する場合は複数回呼び出す<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-253">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="8ed2c-254">渡されたイベント オブジェクトをパルスする必要がありますいないことに注意してください<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないため、します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-254">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="8ed2c-255">、戻る前に、この関数は、一部の種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-255">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="8ed2c-256">変更は、シグナル状態には、条件が満たされる待機条件が原因となったオブジェクトの場合のみ発生します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-256">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="8ed2c-257">たとえば、セマフォのカウントは 1 ずつ減少します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-257">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8ed2c-258">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="8ed2c-258">Version Information</span></span>  
 <span data-ttu-id="8ed2c-259">.NET Framework バージョン 2.0 以降の<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-259">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="8ed2c-260">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-260">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8ed2c-261">
            <paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-261">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8ed2c-262">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-262">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8ed2c-263">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-263">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8ed2c-264">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-264">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8ed2c-265">デリゲートに渡されたオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-265">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8ed2c-266">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-266">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8ed2c-267">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-267">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8ed2c-268">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-268">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8ed2c-269">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-269">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-270">64 ビット符号付き整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-270">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-271">ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-271">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-272">終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-272">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8ed2c-273">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-273">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8ed2c-274">ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-274">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="8ed2c-275"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>キューにスレッド プールに指定されたデリゲート メソッド。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-275">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="8ed2c-276">次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-276">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="8ed2c-277">指定したオブジェクトはシグナルの状態です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-277">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="8ed2c-278">タイムアウト間隔が経過しました。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-278">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="8ed2c-279"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドの指定されたオブジェクトの現在の状態をチェックする<xref:System.Threading.WaitHandle>です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-279">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="8ed2c-280">オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-280">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="8ed2c-281">待機操作は、スレッド プールのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-281">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="8ed2c-282">デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-282">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="8ed2c-283">場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト期間が経過するたびに、タイマーがリセットします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-283">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8ed2c-284">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-284">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="8ed2c-285">代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore> 1 の最大数にします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-285">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="8ed2c-286">待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-286">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8ed2c-287">待機スレッドが、Win32 を使用して`WaitForMultipleObjects`登録された待機操作を監視する関数。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-287">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="8ed2c-288">したがってで同じオペレーティング システムのネイティブ ハンドルを使用する場合は複数回呼び出す<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-288">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="8ed2c-289">渡されたイベント オブジェクトをパルスする必要がありますいないことに注意してください<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないため、します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-289">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="8ed2c-290">、戻る前に、この関数は、一部の種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-290">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="8ed2c-291">変更は、シグナル状態には、条件が満たされる待機条件が原因となったオブジェクトの場合のみ発生します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-291">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="8ed2c-292">たとえば、セマフォのカウントは 1 ずつ減少します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-292">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8ed2c-293">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="8ed2c-293">Version Information</span></span>  
 <span data-ttu-id="8ed2c-294">.NET Framework バージョン 2.0 以降の<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-294">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="8ed2c-295">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-295">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8ed2c-296">
            <paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-296">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8ed2c-297">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-297">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8ed2c-298">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-298">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8ed2c-299">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-299">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8ed2c-300">デリゲートに渡されたオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-300">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="8ed2c-301">
            <see cref="T:System.TimeSpan" /> で表されるタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-301">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="8ed2c-302">
            <c>timeout</c> が 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-302">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8ed2c-303">
            <c>timeout</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-303">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8ed2c-304">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-304">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-305">
            <see cref="T:System.TimeSpan" /> 値をタイムアウトとして指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-305">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-306">ネイティブ ハンドルをカプセル化する <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-306">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-307">終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-307">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8ed2c-308">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-308">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8ed2c-309">ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-309">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="8ed2c-310"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>キューにスレッド プールに指定されたデリゲート メソッド。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-310">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="8ed2c-311">次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-311">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="8ed2c-312">指定したオブジェクトはシグナルの状態です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-312">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="8ed2c-313">タイムアウト間隔が経過しました。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-313">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="8ed2c-314"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドの指定されたオブジェクトの現在の状態をチェックする<xref:System.Threading.WaitHandle>です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-314">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="8ed2c-315">オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-315">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="8ed2c-316">待機操作は、スレッド プールのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-316">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="8ed2c-317">デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-317">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="8ed2c-318">場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト期間が経過するたびに、タイマーがリセットします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-318">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8ed2c-319">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-319">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="8ed2c-320">代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore> 1 の最大数にします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-320">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="8ed2c-321">待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-321">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8ed2c-322">待機スレッドが、Win32 を使用して`WaitForMultipleObjects`登録された待機操作を監視する関数。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-322">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="8ed2c-323">したがってで同じオペレーティング システムのネイティブ ハンドルを使用する場合は複数回呼び出す<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-323">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="8ed2c-324">渡されたイベント オブジェクトをパルスする必要がありますいないことに注意してください<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないため、します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-324">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="8ed2c-325">、戻る前に、この関数は、一部の種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-325">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="8ed2c-326">変更は、シグナル状態には、条件が満たされる待機条件が原因となったオブジェクトの場合のみ発生します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-326">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="8ed2c-327">たとえば、セマフォのカウントは 1 ずつ減少します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-327">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8ed2c-328">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="8ed2c-328">Version Information</span></span>  
 <span data-ttu-id="8ed2c-329">.NET Framework バージョン 2.0 以降の<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-329">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="8ed2c-330">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-330">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8ed2c-331">
            <paramref name="timeout" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-331">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8ed2c-332">
            <paramref name="timeout" /> パラメーターが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-332">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8ed2c-333">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-333">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8ed2c-334">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-334">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8ed2c-335">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出す <see cref="T:System.Threading.WaitOrTimerCallback" /> デリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-335">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8ed2c-336">デリゲートに渡されたオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-336">The object passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8ed2c-337">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-337">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8ed2c-338">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-338">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8ed2c-339">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-339">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8ed2c-340">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-340">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-341">32 ビット符号なし整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-341">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-342">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-342">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-343">終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-343">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8ed2c-344">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-344">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8ed2c-345">ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-345">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="8ed2c-346"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>キューにスレッド プールに指定されたデリゲート メソッド。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-346">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="8ed2c-347">次のいずれかが発生すると、ワーカー スレッドは、デリゲートを実行します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-347">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="8ed2c-348">指定したオブジェクトはシグナルの状態です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-348">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="8ed2c-349">タイムアウト間隔が経過しました。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-349">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="8ed2c-350"><xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドの指定されたオブジェクトの現在の状態をチェックする<xref:System.Threading.WaitHandle>です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-350">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="8ed2c-351">オブジェクトの状態が通知されていない場合、メソッドは、待機操作を登録します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-351">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="8ed2c-352">待機操作は、スレッド プールのスレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-352">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="8ed2c-353">デリゲートは、オブジェクトの状態がシグナル状態またはタイムアウト間隔が経過すると、ワーカー スレッドによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-353">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="8ed2c-354">場合、`timeOutInterval`パラメーターが 0 (ゼロ) と`executeOnlyOnce`パラメーターが`false`イベントがシグナル状態またはタイムアウト期間が経過するたびに、タイマーがリセットします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-354">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8ed2c-355">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-355">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="8ed2c-356">代わりに、<xref:System.Threading.Mutex>を使用して、 <xref:System.Threading.Semaphore> 1 の最大数にします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-356">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="8ed2c-357">待機操作をキャンセルする、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-357">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8ed2c-358">待機スレッドが、Win32 を使用して`WaitForMultipleObjects`登録された待機操作を監視する関数。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-358">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="8ed2c-359">したがってで同じオペレーティング システムのネイティブ ハンドルを使用する場合は複数回呼び出す<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>、Win32 を使用してハンドルを複製する必要があります`DuplicateHandle`関数。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-359">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="8ed2c-360">渡されたイベント オブジェクトをパルスする必要がありますいないことに注意してください<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>待機スレッドでイベントがシグナル状態にリセットされます。 前に、検出されないため、します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-360">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="8ed2c-361">、戻る前に、この関数は、一部の種類の同期オブジェクトの状態を変更します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-361">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="8ed2c-362">変更は、シグナル状態には、条件が満たされる待機条件が原因となったオブジェクトの場合のみ発生します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-362">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="8ed2c-363">たとえば、セマフォのカウントは 1 ずつ減少します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-363">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="8ed2c-364">バージョン情報</span><span class="sxs-lookup"><span data-stu-id="8ed2c-364">Version Information</span></span>  
 <span data-ttu-id="8ed2c-365">.NET Framework バージョン 2.0 以降の<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティの値は、ワーカー スレッドに反映されるキューを使用して、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-365">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="8ed2c-366">以前のバージョンでは、プリンシパルの情報は反映されません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-366">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ed2c-367">次の例を使用する方法を示しています、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドを指定した待機ハンドルがシグナルを受け取ると、指定されたコールバック メソッドを実行します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-367">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="8ed2c-368">この例では、コールバック メソッドは`WaitProc`、および待機ハンドルは、<xref:System.Threading.AutoResetEvent>です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-368">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="8ed2c-369">例では、定義、`TaskInfo`に実行すると、コールバックに渡される情報を保持するクラス。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-369">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="8ed2c-370">例は、作成、`TaskInfo`オブジェクトを文字列データを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-370">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="8ed2c-371"><xref:System.Threading.RegisteredWaitHandle>によって返される、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>に割り当てられているメソッド、`Handle`のフィールド、`TaskInfo`オブジェクトをコールバック メソッドへのアクセスには、<xref:System.Threading.RegisteredWaitHandle>です。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-371">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="8ed2c-372">指定するだけでなく`TaskInfo`への呼び出し、コールバック メソッドに渡すオブジェクトとして、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッドを指定します、 <xref:System.Threading.AutoResetEvent> 、タスクが待機する、<xref:System.Threading.WaitOrTimerCallback>を表すデリゲート、`WaitProc`コールバック メソッド、1 秒のタイムアウト間隔、および複数のコールバック。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-372">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="8ed2c-373">メイン スレッドに通知すると、<xref:System.Threading.AutoResetEvent>を呼び出してその<xref:System.Threading.EventWaitHandle.Set%2A>メソッド、<xref:System.Threading.WaitOrTimerCallback>デリゲートが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-373">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="8ed2c-374">`WaitProc`メソッド テスト<xref:System.Threading.RegisteredWaitHandle>をタイムアウトが発生したかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-374">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="8ed2c-375">待機ハンドルがシグナルため、コールバックが呼び出された場合、`WaitProc`メソッドの登録を解除、<xref:System.Threading.RegisteredWaitHandle>コールバックの追加を停止します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-375">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="8ed2c-376">場合は、タイムアウトは、タスクが待機する続けます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-376">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="8ed2c-377">`WaitProc`メソッドは、コンソールにメッセージを出力することによって終了します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-377">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8ed2c-378">
            <paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-378">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="8ed2c-379">スレッド プール内のワーカー スレッドの最大数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-379">The maximum number of worker threads in the thread pool.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="8ed2c-380">スレッド プール内の非同期 I/O スレッドの最大数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-380">The maximum number of asynchronous I/O threads in the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-381">同時にアクティブにできるスレッド プールへの要求の数を設定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-381">Sets the number of requests to the thread pool that can be active concurrently.</span>
          </span>
          <span data-ttu-id="8ed2c-382">この数を超える要求はすべて、スレッド プール スレッドが使用可能になるまでキューに置かれたままになります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-382">All requests above that number remain queued until thread pool threads become available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-383">変更が成功した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-383">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-384">ことはできませんワーカー スレッドまたは I/O 完了スレッドの最大数未満に設定、数、コンピューター上のプロセッサの数。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-384">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="8ed2c-385">プロセッサの数が存在するには、値の取得、<xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType>プロパティです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-385">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="8ed2c-386">さらに、ワーカー スレッドまたは I/O 完了スレッド、対応する最小ワーカー スレッド数より小さい数にまたは I/O 完了スレッドの最大数を設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-386">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="8ed2c-387">最小スレッド プールのサイズを調べるを呼び出して、<xref:System.Threading.ThreadPool.GetMinThreads%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-387">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="8ed2c-388">共通言語ランタイムがホストされている場合など、インターネット インフォメーション サービス (IIS) または SQL Server によって、ホストを制限したり、スレッド プールのサイズを変更できないようにできます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-388">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="8ed2c-389">スレッド プール内のスレッドの最大数を変更する場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-389">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="8ed2c-390">コードがメリットがあるときに、変更はコード ライブラリを使用するに悪影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-390">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="8ed2c-391">スレッド プールのサイズが大きすぎる設定と、パフォーマンス問題が発生することができます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-391">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="8ed2c-392">スレッドが多すぎるを同時に実行する場合のタスクの切り替えは重要な要因をオーバーヘッドになります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-392">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="8ed2c-393">スレッドを制御する権限です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-393">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="8ed2c-394">アクセス許可の値。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-394">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads">
          <span data-ttu-id="8ed2c-395">スレッド プールがオンデマンドで作成するワーカー スレッドの最小数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-395">The minimum number of worker threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <param name="completionPortThreads">
          <span data-ttu-id="8ed2c-396">スレッド プールがオンデマンドで作成する非同期 I/O スレッドの最小数。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-396">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-397">スレッドがオンデマンドで (新しい要求の発生ごとに) 作成するスレッド プールの数を設定します。この数を超えると、スレッドの作成と破棄を管理するためのアルゴリズムに切り替わります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-397">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-398">変更が成功した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-398">
              <see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-399">スレッド プールを提供新しいワーカー スレッドまたは I/O 完了スレッド要求時に各カテゴリの最小値に達するまでします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-399">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="8ed2c-400">最低限に達すると、スレッド プールはそのカテゴリに追加のスレッドを作成または、いくつかのタスクを完了するまで待機できます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-400">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="8ed2c-401">以降で、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、スレッド プールを作成し、タスクの単位時間あたりの完了数として定義されるスループットを最適化するためにスレッドを破棄します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-401">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="8ed2c-402">スレッドが少なすぎると使用可能なリソースが最適に使用されない可能性があり、スレッドが多すぎるとリソースの競合が増える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-402">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="8ed2c-403">要求が少ないときは、スレッド プールの実際のスレッド数が最小値を下回る場合があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-403">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="8ed2c-404">負の数またはアクティブなスレッド プールのスレッドの最大数より大きい数値を指定する場合 (を使用して取得<xref:System.Threading.ThreadPool.GetMaxThreads%2A>)、<xref:System.Threading.ThreadPool.SetMinThreads%2A>返します`false`が最小値のいずれかが変更されていないとします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-404">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8ed2c-405">既定では、スレッドの最小数は、システム上のプロセッサの数を設定します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-405">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="8ed2c-406">使用することができます、<xref:System.Threading.ThreadPool.SetMinThreads%2A>最小番号 ofthreads を増加させます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-406">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="8ed2c-407">ただし、これらの値を必要以上に大きくすると、パフォーマンスの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-407">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="8ed2c-408">同時に開始するタスクの数が多すぎる場合は、すべてのタスクで処理速度が低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-408">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="8ed2c-409">ほとんどの場合、スレッド プールが優れてスレッドを割り当てるための独自のアルゴリズムでします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-409">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="8ed2c-410">プロセッサの数もパフォーマンスを低下させる可能性がより小さくする最低限の削減。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-410">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8ed2c-411">次の例では、ワーカー スレッドの最小数を 4 に設定し、非同期 I/O 完了スレッドの最小数の元の値を保持します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-411">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="8ed2c-412">スレッドを制御する権限です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-412">for the ability to control threads.</span>
          </span>
          <span data-ttu-id="8ed2c-413">アクセス許可の値。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-413">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped">
          <span data-ttu-id="8ed2c-414">キューに置く <see cref="T:System.Threading.NativeOverlapped" /> 構造体。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-414">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-415">重複した I/O 操作を、実行するためのキューに置きます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-415">Queues an overlapped I/O operation for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-416">操作が I/O 完了ポートのキューに正常に置かれた場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-416">
              <see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-417">ネイティブ Win32 を使用して情報には、I/O がオーバー ラップされたを参照してください、<xref:System.Threading.Overlapped>クラス、<xref:System.Threading.NativeOverlapped>構造体、および`OVERLAPPED`Win32 プラットフォーム SDK の構造体。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-417">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8ed2c-418">使用して、<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>メソッドは、セキュリティ ホールを誤って開けません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-418">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="8ed2c-419">コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-419">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8ed2c-420">ときに作業をキューに置かれたスレッド プールのスレッドを使用して、 <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-420">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="8ed2c-421">悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-421">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ed2c-422">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-422">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ed2c-423">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-423">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack">
          <span data-ttu-id="8ed2c-424">スレッド プール内のスレッドが作業項目をピック アップするときに呼び出すデリゲートを表す <see cref="T:System.Threading.WaitCallback" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-424">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8ed2c-425">スレッド プールから処理されるときにデリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-425">The object that is passed to the delegate when serviced from the thread pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-426">指定したデリゲートをスレッド プールのキューに置きます。ただし、コール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-426">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-427">メソッドが成功した場合は <see langword="true" />。作業項目をキューに配置できなかった場合は <see cref="T:System.OutOfMemoryException" /> がスローされます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-427">
              <see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-428">異なり、<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>メソッド、<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>呼び出しスタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-428">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="8ed2c-429">これにより、コード、呼び出し履歴が失われるとセキュリティ特権を昇格することができます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-429">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8ed2c-430">使用して<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>セキュリティ ホールを開くことが誤っています。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-430">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="8ed2c-431">コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-431">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8ed2c-432">ときに作業をキューに置かれたスレッド プールのスレッドを使用して、 <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-432">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="8ed2c-433">悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-433">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8ed2c-434">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-434">The caller does not have the required permission.</span>
          </span>
        </exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="8ed2c-435">メモリが不足しています。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-435">An out-of-memory condition was encountered.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="8ed2c-436">作業項目をキューに配置できません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-436">The work item could not be queued.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="8ed2c-437">
            <paramref name="callBack" /> は <see langword="null" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-437">
              <paramref name="callBack" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ed2c-438">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-438">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ed2c-439">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-439">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8ed2c-440">
            <see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。ただし、コール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-440">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8ed2c-441">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-441">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8ed2c-442">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-442">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8ed2c-443">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-443">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8ed2c-444">デリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-444">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8ed2c-445">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-445">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8ed2c-446">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-446">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8ed2c-447">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-447">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8ed2c-448">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-448">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-449">ミリ秒単位のタイムアウトとして 32 ビット符号付き整数を使用して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-449">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8ed2c-450">このメソッドはコール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-450">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-451">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-451">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-452">異なり、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>呼び出しスタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-452">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="8ed2c-453">これにより、コード、呼び出し履歴が失われるとセキュリティ特権を昇格することができます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-453">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8ed2c-454">使用して<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>セキュリティ ホールを開くことが誤っています。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-454">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="8ed2c-455">コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-455">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8ed2c-456">ときに作業をキューに置かれたスレッド プールのスレッドを使用して、 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-456">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="8ed2c-457">悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-457">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="8ed2c-458">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-458">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="8ed2c-459">終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-459">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8ed2c-460">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-460">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8ed2c-461">ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-461">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8ed2c-462">
            <paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-462">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8ed2c-463">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-463">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ed2c-464">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-464">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ed2c-465">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-465">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8ed2c-466">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-466">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8ed2c-467">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-467">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8ed2c-468">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-468">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8ed2c-469">デリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-469">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8ed2c-470">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-470">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8ed2c-471">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-471">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8ed2c-472">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-472">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8ed2c-473">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-473">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-474">64 ビット符号付き整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-474">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8ed2c-475">このメソッドはコール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-475">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-476">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-476">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-477">異なり、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>呼び出しスタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-477">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="8ed2c-478">これにより、コード、呼び出し履歴が失われるとセキュリティ特権を昇格することができます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-478">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8ed2c-479">使用して<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>セキュリティ ホールを開くことが誤っています。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-479">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="8ed2c-480">コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-480">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8ed2c-481">ときに作業をキューに置かれたスレッド プールのスレッドを使用して、 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-481">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="8ed2c-482">悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-482">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="8ed2c-483">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-483">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="8ed2c-484">終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-484">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8ed2c-485">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-485">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8ed2c-486">ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-486">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8ed2c-487">
            <paramref name="millisecondsTimeOutInterval" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-487">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8ed2c-488">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-488">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ed2c-489">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-489">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ed2c-490">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-490">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8ed2c-491">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-491">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8ed2c-492">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-492">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8ed2c-493">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-493">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8ed2c-494">デリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-494">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="8ed2c-495">
            <see cref="T:System.TimeSpan" /> で表されるタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-495">The time-out represented by a <see cref="T:System.TimeSpan" />.</span>
          </span>
          <span data-ttu-id="8ed2c-496">
            <c>timeout</c> が 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-496">If <c>timeout</c> is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8ed2c-497">
            <c>timeout</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-497">If <c>timeout</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8ed2c-498">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-498">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-499">
            <see cref="T:System.TimeSpan" /> 値をタイムアウトとして指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。このメソッドはコール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-499">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-500">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-500">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-501">異なり、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>呼び出しスタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-501">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="8ed2c-502">これにより、コード、呼び出し履歴が失われるとセキュリティ特権を昇格することができます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-502">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8ed2c-503">使用して<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>セキュリティ ホールを開くことが誤っています。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-503">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="8ed2c-504">コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-504">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8ed2c-505">ときに作業をキューに置かれたスレッド プールのスレッドを使用して、 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-505">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="8ed2c-506">悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-506">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="8ed2c-507">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-507">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="8ed2c-508">終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-508">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8ed2c-509">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-509">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8ed2c-510">ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-510">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="8ed2c-511">
            <paramref name="timeout" /> パラメーターが -1 未満。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-511">The <paramref name="timeout" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8ed2c-512">
            <paramref name="timeout" /> パラメーターが <see cref="F:System.Int32.MaxValue" /> より大きい値です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-512">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8ed2c-513">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-513">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ed2c-514">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-514">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ed2c-515">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-515">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">
          <span data-ttu-id="8ed2c-516">登録する <see cref="T:System.Threading.WaitHandle" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-516">The <see cref="T:System.Threading.WaitHandle" /> to register.</span>
          </span>
          <span data-ttu-id="8ed2c-517">
            <see cref="T:System.Threading.Mutex" /> 以外の <see cref="T:System.Threading.WaitHandle" /> を使用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-517">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span>
          </span>
        </param>
        <param name="callBack">
          <span data-ttu-id="8ed2c-518">
            <c>waitObject</c> パラメーターがシグナル通知されたときに呼び出すデリゲート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-518">The delegate to call when the <c>waitObject</c> parameter is signaled.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="8ed2c-519">デリゲートに渡されるオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-519">The object that is passed to the delegate.</span>
          </span>
        </param>
        <param name="millisecondsTimeOutInterval">
          <span data-ttu-id="8ed2c-520">ミリ秒単位のタイムアウト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-520">The time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8ed2c-521">
            <c>millisecondsTimeOutInterval</c> パラメーターが 0 (ゼロ) の場合、関数はオブジェクトの状態をテストして、すぐに制御を戻します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-521">If the <c>millisecondsTimeOutInterval</c> parameter is 0 (zero), the function tests the object's state and returns immediately.</span>
          </span>
          <span data-ttu-id="8ed2c-522">
            <c>millisecondsTimeOutInterval</c> が -1 の場合、関数はタイムアウトしません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-522">If <c>millisecondsTimeOutInterval</c> is -1, the function's time-out interval never elapses.</span>
          </span>
        </param>
        <param name="executeOnlyOnce">
          <span data-ttu-id="8ed2c-523">デリゲートの呼び出し後、スレッドが <c>waitObject</c> パラメーターを待機しなくなる場合は <see langword="true" />。待機が登録解除されるまでは、待機操作が完了するたびにタイマーをリセットする場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-523">
              <see langword="true" /> to indicate that the thread will no longer wait on the <c>waitObject</c> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8ed2c-524">32 ビット符号なし整数でミリ秒単位のタイムアウトを指定して、<see cref="T:System.Threading.WaitHandle" /> を待機するデリゲートを登録します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-524">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span>
          </span>
          <span data-ttu-id="8ed2c-525">このメソッドはコール スタックをワーカー スレッドに反映しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-525">This method does not propagate the calling stack to the worker thread.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8ed2c-526">登録された待機操作をキャンセルするために使用できる <see cref="T:System.Threading.RegisteredWaitHandle" /> オブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-526">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8ed2c-527">異なり、<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>メソッド、<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>呼び出しスタックをワーカー スレッドに反映しません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-527">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="8ed2c-528">これにより、コード、呼び出し履歴が失われるとセキュリティ特権を昇格することができます。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-528">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="8ed2c-529">使用して<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>セキュリティ ホールを開くことが誤っています。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-529">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="8ed2c-530">コード アクセス セキュリティは、スタックに基づいて、すべての呼び出し元のアクセス許可をその権限のチェックを行います。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-530">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="8ed2c-531">ときに作業をキューに置かれたスレッド プールのスレッドを使用して、 <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>、スレッド プールのスレッドのスタックには、実際の呼び出し元のコンテキストはありません。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-531">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="8ed2c-532">悪意のあるコードが必要になるアクセス許可のチェックを避けるためにこれを利用します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-532">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="8ed2c-533">使用して、<xref:System.Threading.Mutex>の`waitObject`基になる Win32 API は、既定値を使用するため、コールバックの相互排他は提供されません`WT_EXECUTEDEFAULT`フラグ、別のスレッド プールのスレッドで各コールバックがディスパッチされるようにします。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-533">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="8ed2c-534">終了したらを使用して、<xref:System.Threading.RegisteredWaitHandle>このメソッドによって返される、呼び出し、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>待機ハンドルへの参照を解放します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-534">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="8ed2c-535">常に呼び出すことをお勧め、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドを指定する場合でも`true`の`executeOnlyOnce`します。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-535">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="8ed2c-536">ガベージ コレクションより効率的に動作を呼び出す場合は、<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>メソッドの代わりに、登録された待機ハンドルのファイナライザーによって異なります。</span><span class="sxs-lookup"><span data-stu-id="8ed2c-536">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="8ed2c-537">呼び出し元に、必要なアクセス許可がありません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-537">The caller does not have the required permission.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="8ed2c-538">直前の呼び出し元に対する完全な信頼が必要です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-538">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="8ed2c-539">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="8ed2c-539">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>