<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="046aa46d0a3da304f9348792a16e1353c5fa4596" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56403032" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>共有リソースへの排他アクセスの待機に使用するオペレーティング システム固有のオブジェクトをカプセル化します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.WaitHandle>クラスはネイティブのオペレーティング システムの同期ハンドルをカプセル化し、ランタイム内の複数の待機操作を許可するすべての同期オブジェクトを表すために使用します。 他の同期オブジェクトと待機ハンドルの比較は、次を参照してください。[同期プリミティブの概要](~/docs/standard/threading/overview-of-synchronization-primitives.md)します。  
  
 <xref:System.Threading.WaitHandle>クラス自体が抽象クラス。 派生したクラス<xref:System.Threading.WaitHandle>を取得または解放の共有リソースへのアクセスを示すシグナリング機構を定義しますが、使用、継承された<xref:System.Threading.WaitHandle>へのアクセスの待機中にブロックするメソッドがリソースを共有します。 派生したクラス<xref:System.Threading.WaitHandle>が含まれます。  
  
-   
  <xref:System.Threading.Mutex> クラス 参照してください[ミュー テックス](~/docs/standard/threading/mutexes.md)します。  
  
-   <xref:System.Threading.EventWaitHandle>クラスとその派生クラスでは、<xref:System.Threading.AutoResetEvent>と<xref:System.Threading.ManualResetEvent>します。  
  
-   
  <xref:System.Threading.Semaphore> クラス 参照してください[Semaphore と SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)します。  
  
 インスタンス メソッドを呼び出して個々 の待機ハンドルに対してスレッドをブロックできます<xref:System.Threading.WaitHandle.WaitOne%2A>から派生したクラスによって継承<xref:System.Threading.WaitHandle>します。  
  
 派生クラスの<xref:System.Threading.WaitHandle>のスレッド アフィニティが異なります。 イベント待機ハンドル (<xref:System.Threading.EventWaitHandle>、 <xref:System.Threading.AutoResetEvent>、および<xref:System.Threading.ManualResetEvent>) セマフォにはスレッド アフィニティがありません。 任意のスレッドは、イベント待機ハンドルまたはセマフォを通知できます。 ミュー テックス、一方ではスレッド アフィニティが;ミュー テックスを所有するスレッドを解放する必要があります、およびスレッドの呼び出し、例外がスローされますが、<xref:System.Threading.Mutex.ReleaseMutex%2A>ミュー テックスを所有していないメソッドです。  
  
 <xref:System.Threading.WaitHandle>クラスから派生<xref:System.MarshalByRefObject>、これらのクラスは、アプリケーション ドメイン境界を越えてスレッドのアクティビティを同期するために使用できます。  
  
 その派生クラスでだけでなく、<xref:System.Threading.WaitHandle>クラスにはさまざまな 1 つまでスレッドをブロックする静的メソッドまたは複数の同期オブジェクトがシグナルを受信します。 次の設定があります。  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>、スレッドの 1 つの待機ハンドルを通知し、すぐに別の待つことができます。  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>、、スレッド、配列内のすべての待機ハンドルがシグナルを受信するまで待機することができます。  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>、、スレッドの待機ハンドルの指定したセットのいずれかが通知されたまで待機することができます。  
  
 これらのメソッドのオーバー ロードは、待機、およびその他のスレッド同期コンテキストを使用できるように、待機に入る前に同期コンテキストを終了する機会を放棄するためのタイムアウト間隔を提供します。  
  
> [!IMPORTANT]
>  この型は <xref:System.IDisposable> インターフェイスを実装します。 型またはその派生型を使用してが完了したら、直接的または間接的にそれを破棄する必要があります。 直接的に型を破棄するには、`try` / `catch` ブロック内で <xref:System.Threading.WaitHandle.Close%2A> メソッドを呼び出します。 間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。 詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。  
  
 <xref:System.Threading.WaitHandle> 実装して、<xref:System.IDisposable.Dispose%2A>パターン。 参照してください [Dispose メソッドの](~/docs/standard/garbage-collection/implementing-dispose.md) を実装します。 派生させた場合<xref:System.Threading.WaitHandle>を使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>ネイティブのオペレーティング システム ハンドルを格納するプロパティ。 保護されたをオーバーライドする必要はありません<xref:System.Threading.WaitHandle.Dispose%2A>メソッド追加されているアンマネージ リソースを使用する場合を除き、します。  
  
   
  
## Examples  
 次のコード例に示す 2 つのスレッドができる方法は、メインの中にバック グラウンド タスク スレッド、静的なを使用して、タスクの待機<xref:System.Threading.WaitHandle.WaitAny%2A>と<xref:System.Threading.WaitHandle.WaitAll%2A>のメソッド、<xref:System.Threading.WaitHandle>クラス。  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">スレッド</related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">スレッド処理オブジェクトと機能</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d">EventWaitHandle、AutoResetEvent、および ManualResetEvent</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">セマフォ</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> によって保持されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックな実装の<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>のメソッド、<xref:System.Threading.WaitHandle>クラスとその派生クラス。 呼び出す標準実装されています。、`Dispose(Boolean)`オーバー ロードを`true`引数に呼び出し、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>メソッド。 インスタンスによって保持されているすべてのリソースを解放するには、このメソッドを呼び出す`WaitHandle`または派生クラス。  
  
 このメソッドが呼び出されると、現在のインスタンスへの参照は未定義の動作が発生します。  
  
> [!NOTE]
>  常に呼び出す<xref:System.Threading.WaitHandle.Close%2A>または<xref:System.Threading.WaitHandle.Dispose>への参照を解放する前に、<xref:System.Threading.WaitHandle>します。 それ以外の場合、使用されているリソースは解放されません。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする必要があります、<see langword="Dispose(Boolean)" />で割り当てられているリソースを解放するメソッドがクラスを派生します。</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Dispose メソッドの実装</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Threading.WaitHandle.Close%2A>メソッド。  
  
> [!NOTE]
>  常に呼び出す<xref:System.Threading.WaitHandle.Close%2A>または<xref:System.Threading.WaitHandle.Dispose>への参照を解放する前に、<xref:System.Threading.WaitHandle>します。 それ以外の場合、使用されているリソースは解放されません。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">アンマネージ リソースのクリーンアップ</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>派生クラスでオーバーライドされると、<see cref="T:System.Threading.WaitHandle" /> によって使用されているアンマネージド リソースを解放し、オプションでマネージド リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Threading.WaitHandle.Close%2A>と<xref:System.Threading.WaitHandle.Dispose>メソッド、`explicitDisposing`パラメーターに設定`true`。  ときに、`explicitDisposing`パラメーターが`true`、このメソッドは、すべてのマネージ オブジェクトによって保持されているすべてのリソースを解放します。 この<xref:System.Threading.WaitHandle>オブジェクト参照。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする必要があります、<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />で割り当てられているリソースを解放するメソッドがクラスを派生します。  
  
<see cref="M:System.Threading.WaitHandle.Close" />または<see cref="M:System.Threading.WaitHandle.Dispose" />メソッドは、他のオブジェクトで複数回呼び出すことがあります。 このメソッドをオーバーライドする場合は、事前に呼び出したで破棄されたオブジェクトを参照しないように注意する<see langword="Dispose" />または<see langword="Close" />します。</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Dispose メソッドの実装</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスに保持されているリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> このメンバーは、.NET Framework version 2.0 およびそれ以降のバージョンから削除されました。 このトピックでは、このトピックの後半の「バージョン情報」に示したバージョンにのみ適用されます。


アプリケーション コードには、このメソッドは呼び出しません。ガベージ コレクターによって終了処理が無効になっている場合を除き、ガベージ コレクション中に自動的に呼び出されます。 詳細については、次のトピックを参照してください。 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> および <xref:System.Object.Finalize> このメソッドは、<xref:System.Object.Finalize> をオーバーライドします。

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネイティブ オペレーティング システム ハンドルを取得または設定します。</summary>
        <value>ネイティブ オペレーティング システム ハンドルを表す <see langword="IntPtr" />。 既定値は <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> フィールドの値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しい値を割り当てる、<xref:System.Threading.WaitHandle.Handle%2A>プロパティが以前のハンドルを終了していません。 これは、結果、漏洩したハンドル。  
  
 .NET framework version 2.0 以降です。 このプロパティを使用しません。使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティ代わりにします。 このプロパティの設定を有効なハンドルもセット、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティに設定すると<xref:System.Threading.WaitHandle.InvalidHandle>リークしたハンドルで発生することができます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">プロパティ値を設定する直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで設定することはできません。</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">派生型である必要があります<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />プロパティ値を設定します。</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>無効なネイティブ オペレーティング システム ハンドルを表します。 このフィールドは読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 初期化するために内部的に使用される、<xref:System.Threading.WaitHandle.Handle%2A>プロパティ。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>この値を使用するには判断するかどうか、<see cref="P:System.Threading.WaitHandle.Handle" />プロパティに有効なネイティブ オペレーティング システム ハンドルが含まれています。</para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネイティブ オペレーティング システム ハンドルを取得または設定します。</summary>
        <value>ネイティブ オペレーティング システム ハンドルを表す <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しい値を割り当てるとき、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティ、ときに、前のハンドルを閉じるは前<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>オブジェクトを収集します。 手動でハンドルを終了しないで、この結果、ため、<xref:System.ObjectDisposedException>ときに、<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>ハンドルを終了しようとしています。  
  
 <xref:System.Threading.WaitHandle> 実装して、<xref:System.IDisposable.Dispose%2A>パターン。 参照してください [Dispose メソッドの](~/docs/standard/garbage-collection/implementing-dispose.md) を実装します。 派生させた場合<xref:System.Threading.WaitHandle>を使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>ネイティブのハンドルのオペレーティング システム ハンドルを格納するプロパティ。 保護されたをオーバーライドする必要はありません<xref:System.Threading.WaitHandle.Dispose%2A>メソッド追加されているアンマネージ リソースを使用する場合を除き、します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">派生型である必要があります<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />このメンバーを呼び出します。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</summary>
        <returns>通知と待機の両方が正常に完了した場合は <see langword="true" />。待機が完了しない場合、メソッドから制御は戻りません。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この操作はアトミックであるは保証されません。 現在のスレッドの信号後`toSignal`までの間待機している`toWaitOn`、別のプロセッサで実行されているスレッドを通知`toWaitOn`待機またはします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>ブロックされたスレッドのシグナルを待ってから、スレッドがタスクを完了するまでメイン スレッドを許可するメソッドのオーバー ロードします。  
  
 例では、5 つのスレッドを開始、ブロックすることができます、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>フラグ、およびユーザーが ENTER キーを押す、リリースの 1 つのスレッド時間。 例では、別の 5 つのスレッドのキューし、すべてを使用して、解放、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>フラグ。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="toWaitOn" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">メソッドは <see cref="T:System.STAThreadAttribute" /> を持つスレッドで呼び出されました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 98 および Windows Millennium Edition ではサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="toSignal" /> はセマフォで、カウントは既に最大値になっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="millisecondsTimeout">待機する間隔を表す整数。 この値が <see cref="F:System.Threading.Timeout.Infinite" />、つまり -1 の場合、待機は無期限となります。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として 32 ビット符号付き整数を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</summary>
        <returns>通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この操作はアトミックであるは保証されません。 現在のスレッドの信号後`toSignal`までの間待機している`toWaitOn`、別のプロセッサで実行されているスレッドを通知`toWaitOn`待機またはします。  
  
 場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。 テストの状態、`toWaitOn`をすぐに返します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.SignalAndWait%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。 派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。 派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッド。 呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。 その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="toWaitOn" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">メソッドは <see cref="T:System.STAThreadAttribute" /> を持つスレッドで呼び出されます。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 98 および Windows Millennium Edition ではサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException">カウントの最大値を超えるため、<see cref="T:System.Threading.WaitHandle" /> はシグナル状態にはできません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">通知対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="toWaitOn">待機対象の <see cref="T:System.Threading.WaitHandle" />。</param>
        <param name="timeout">待機間隔を表す <see cref="T:System.TimeSpan" />。 この値が -1 の場合、待機は無期限となります。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として <see cref="T:System.TimeSpan" /> を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</summary>
        <returns>通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この操作はアトミックであるは保証されません。 現在のスレッドの信号後`toSignal`までの間待機している`toWaitOn`、別のプロセッサで実行されているスレッドを通知`toWaitOn`待機またはします。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
 場合`timeout`が 0 の場合、メソッドはブロックしません。 テストの状態、`toWaitOn`をすぐに返します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.SignalAndWait%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。 派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。 派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッド。 呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。 その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="toSignal" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="toWaitOn" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">メソッドは <see cref="T:System.STAThreadAttribute" /> を持つスレッドで呼び出されました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 98 および Windows Millennium Edition ではサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="toSignal" /> はセマフォで、カウントは既に最大値になっています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は、-1 以外の負のミリ秒値となります。  
  
または 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> によって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
呼び出す`Dispose`によって使用されるリソースの使用、<xref:System.Threading.WaitHandle>他の目的で再割り当てします。 詳細については`Dispose`を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)します。

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />。それ以外の場合は、待機を続けます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>メソッドは、すべてのハンドルがシグナルを返します。 一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。 配列に重複が含まれている場合、呼び出しは、<xref:System.DuplicateWaitObjectException>します。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>が含まれるスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>します。  
  
 呼び出しと同じですがこのメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定する (または<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) の`millisecondsTimeout`と`true`の`exitContext`します。  
  
   
  
## Examples  
 次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループを出力する方法を示します。 個々 の書き込み操作は、作業項目および信号としてキューに登録が完了します。 メイン スレッドは、すべての項目からの通知の待機し、終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。 または 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
または 
 <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
または 
<see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary><see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了する、つまりすべてのハンドルがシグナル状態になるとき、またはタイムアウトが発生したときに、メソッドが返されます。 一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。 配列に重複がある場合、呼び出しは、<xref:System.DuplicateWaitObjectException>します。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>が含まれるスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>します。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
または 
 <paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
または 
<see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary><see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</summary>
        <returns><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了するすべてのハンドルがシグナル状態になることを意味するか、タイムアウトが発生するときに、メソッドが返されます。 一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。 配列に重複が含まれている場合、呼び出しは失敗します。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>が含まれるスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>します。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
または 
 <paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 <paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
または 
<see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
または 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了する、つまりすべてのハンドルがシグナル状態になるとき、またはタイムアウトが発生したときに、メソッドが返されます。 一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。 配列に重複がある場合、呼び出しは、<xref:System.DuplicateWaitObjectException>します。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>が含まれるスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitAll%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。 派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。 派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッド。 呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには、<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>属性。 その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。  
  
   
  
## Examples  
 次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループを出力する方法を示します。 個々 の書き込み操作は、作業項目および信号としてキューに登録が完了します。 メイン スレッドは、すべての項目からの通知の待機し、終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
または 
 <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
または 
<see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。 この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了するすべてのハンドルがシグナル状態になることを意味するか、タイムアウトが発生するときに、メソッドが返されます。 一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。 配列に重複が含まれている場合、呼び出しは失敗します。  
  
> [!NOTE]
>  <xref:System.Threading.WaitHandle.WaitAll%2A>が含まれるスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>します。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitAll%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。 派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。 派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッド。 呼び出しの後に元の既定以外のコンテキストを返します、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。 その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。  
  
   
  
## Examples  
 次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループを出力する方法を示します。 個々 の書き込み操作は、作業項目および信号としてキューに登録が完了します。 メイン スレッドは、すべての項目からの通知の待機し、終了します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。  
  
または 
 <paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</exception>
        <exception cref="T:System.DuplicateWaitObjectException"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。  
  
または 
<see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</exception>
        <exception cref="T:System.ApplicationException"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
または 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行するオブジェクトの配列インデックス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスが破棄されたため、待機が終了した場合。 放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号でリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 では、スレッドが終了するか明示的に解放しないままを中止する場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`は0 ではなく 128 です。  
  
 このメソッドは、いずれかのハンドルがシグナルを受け取るを返します。 呼び出し中に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。 一部の実装の詳細は 64 ハンドルが渡される場合に、<xref:System.NotSupportedException>がスローされます。  
  
 呼び出しと同じですがこのメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定する (または<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) の`millisecondsTimeout`と`true`の`exitContext`します。  
  
   
  
## Examples  
 次のコード例は、呼び出し元を示します、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッド。  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ApplicationException">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>32 ビット符号付き整数を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号でリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
 このメソッドは、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに、待機が終了するときに返します。 呼び出し中に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。 一部の実装の詳細は 64 ハンドルが渡される場合に、<xref:System.NotSupportedException>がスローされます。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号でリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
 このメソッドは、ハンドルのいずれかが通知されるとき、または、タイムアウトが発生したときに、待機が終了するときに返します。 呼び出し中に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。 一部の実装の詳細は 64 ハンドルが渡される場合に、<xref:System.NotSupportedException>がスローされます。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
または 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="waitHandles" /> は、要素を持たない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>32 ビットの符号付き整数を使用して時間間隔を指定し、待機する前に同期ドメインを終了するかどうかを指定して、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスが破棄されたため、待機が終了した場合。 放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号でリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 では、スレッドが終了するか明示的に解放しないままを中止する場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`は0 ではなく 128 です。  
  
 このメソッドは、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに、待機が終了するときに返します。 呼び出し中に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。 一部の実装の詳細は 64 ハンドルが渡される場合に、<xref:System.NotSupportedException>がスローされます。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitAny%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。 派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。 派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッド。 呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。 その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。  
  
   
  
## Examples  
 次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。 領域の考慮事項は、各ディスクのルート ディレクトリのみが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ApplicationException">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</param>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した配列内のいずれかの要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスが破棄されたため、待機が終了した場合。 放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 <xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。 場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号でリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 では、スレッドが終了するか明示的に解放しないままを中止する場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`は0 ではなく 128 です。  
  
 このメソッドは、ハンドルのいずれかが通知されるとき、または、タイムアウトが発生したときに、待機が終了するときに返します。 呼び出し中に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。 一部の実装の詳細は 64 ハンドルが渡される場合に、<xref:System.NotSupportedException>がスローされます。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitAny%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。 派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。 派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッド。 呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。 その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。  
  
   
  
## Examples  
 次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。 領域の考慮事項は、各ディスクのルート ディレクトリのみが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。  
  
または 
<paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</exception>
        <exception cref="T:System.ApplicationException">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
または 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.ArgumentException">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</summary>
        <returns>現在のインスタンスがシグナルを受け取った場合は <see langword="true" />。 現在のインスタンスがシグナルを受け取らない場合は、<see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> はシグナルを受け取るまで待機を続けます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 このメソッドは、現在のインスタンスまで無期限にブロックの呼び出し元がシグナルを受信します。 このメソッドを使用するまでブロック、<xref:System.Threading.WaitHandle>が別のスレッドからシグナルを受け取る、非同期操作の完了時に、生成がなど。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 呼び出しと同じですがこのメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定するまたは<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>、最初のパラメーターと`false`2 番目のパラメーター。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
   
  
## Examples  
 次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機する間に終了してから、プロセスを監視する方法を示します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>32 ビット符号付き整数を使用して時間間隔をミリ秒単位で指定し、現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで、現在のスレッドをブロックします。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元に発生します。 このメソッドを使用するまでブロック、<xref:System.Threading.WaitHandle>が別のスレッドからシグナルを受け取る、非同期操作の完了時に、生成がなど。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
   
  
## Examples  
 次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機する間に終了してから、プロセスを監視する方法を示します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <summary><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元に発生します。 このメソッドを使用するまでブロック、<xref:System.Threading.WaitHandle>が別のスレッドからシグナルを受け取る、非同期操作の完了時に、生成がなど。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
 呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
または 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで現在のスレッドをブロックします。時間間隔を指定するために 32 ビット符号付き整数を使用し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元に発生します。 このメソッドを使用するまでブロック、<xref:System.Threading.WaitHandle>が別のスレッドからシグナルを受け取る、非同期操作の完了時に、生成がなど。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitOne%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。 派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。 派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド。 呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。 その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。  
  
   
  
## Examples  
 次の例は、どのように<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>同期ドメイン内で呼び出されたときのメソッドのオーバー ロードの動作します。 最初に、スレッドが待機する`exitContext`設定`false`し、待機がタイムアウトになるまでブロックします。 2 番目のスレッドを実行後、最初のスレッドを終了し、待つ`exitContext`に設定`true`します。 この 2 つ目のスレッドの待機ハンドルの通知への呼び出しがブロックされていないと、印刷待ちタイムアウトする前に、スレッドが完了するとします。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</param>
        <param name="exitContext">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</summary>
        <returns>現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`が 0 の場合、メソッドはブロックしません。 これにより、待機ハンドルの状態をテストし、すぐに返します。  
  
 <xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。 以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。 放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。 システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。 例外には、デバッグに役立つ情報が含まれています。  
  
 現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元に発生します。 このメソッドを使用するまでブロック、<xref:System.Threading.WaitHandle>が別のスレッドからシグナルを受け取る、非同期操作の完了時に、生成がなど。 詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。  
  
 派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。  
  
 最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。  
  
## <a name="notes-on-exiting-the-context"></a>コンテキストの終了時の注意  
 `exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitOne%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。 派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。 派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。  
  
 既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド。 呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが完了するとします。  
  
 これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。 その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。 メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。 ときに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。  
  
   
  
## Examples  
 次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機する間に終了してから、プロセスを監視する方法を示します。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。 
または 
 <paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。 Windows 98 または Windows Millennium Edition では、この例外はスローされません。</exception>
        <exception cref="T:System.InvalidOperationException">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>待機ハンドルがシグナル状態になる前に <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作がタイムアウトになったことを示します。 このフィールドは定数です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このフィールドは戻り値のいずれかの`WaitAny`します。  
  
   
  
## Examples  
 次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。 領域の考慮事項は、各ディスクのルート ディレクトリのみが検索されます。  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>