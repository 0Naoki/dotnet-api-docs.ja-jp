<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6ebd81e2bf7d5cd0f3352fe967172936ade87ae8" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57934250" /></Metadata><TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="F#" Value="type WaitHandle = class&#xA;    inherit MarshalByRefObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1e58e-101">共有リソースへの排他アクセスの待機に使用するオペレーティング システム固有のオブジェクトをカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-101">Encapsulates operating system-specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-102"><xref:System.Threading.WaitHandle>クラスはネイティブのオペレーティング システムの同期ハンドルをカプセル化し、ランタイム内の複数の待機操作を許可するすべての同期オブジェクトを表すために使用します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-102">The <xref:System.Threading.WaitHandle> class encapsulates a native operating system synchronization handle and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="1e58e-103">他の同期オブジェクトと待機ハンドルの比較は、次を参照してください。[同期プリミティブの概要](~/docs/standard/threading/overview-of-synchronization-primitives.md)します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="1e58e-104"><xref:System.Threading.WaitHandle>クラス自体が抽象クラス。</span><span class="sxs-lookup"><span data-stu-id="1e58e-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="1e58e-105">派生したクラス<xref:System.Threading.WaitHandle>を取得または解放の共有リソースへのアクセスを示すシグナリング機構を定義しますが、使用、継承された<xref:System.Threading.WaitHandle>へのアクセスの待機中にブロックするメソッドがリソースを共有します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="1e58e-106">派生したクラス<xref:System.Threading.WaitHandle>が含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="1e58e-107">
  <xref:System.Threading.Mutex> クラス</span><span class="sxs-lookup"><span data-stu-id="1e58e-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="1e58e-108">参照してください[ミュー テックス](~/docs/standard/threading/mutexes.md)します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="1e58e-109"><xref:System.Threading.EventWaitHandle>クラスとその派生クラスでは、<xref:System.Threading.AutoResetEvent>と<xref:System.Threading.ManualResetEvent>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span>  
  
-   <span data-ttu-id="1e58e-110">
  <xref:System.Threading.Semaphore> クラス</span><span class="sxs-lookup"><span data-stu-id="1e58e-110">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="1e58e-111">参照してください[Semaphore と SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-111">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="1e58e-112">インスタンス メソッドを呼び出して個々 の待機ハンドルに対してスレッドをブロックできます<xref:System.Threading.WaitHandle.WaitOne%2A>から派生したクラスによって継承<xref:System.Threading.WaitHandle>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-112">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="1e58e-113">派生クラスの<xref:System.Threading.WaitHandle>のスレッド アフィニティが異なります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-113">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="1e58e-114">イベント待機ハンドル (<xref:System.Threading.EventWaitHandle>、 <xref:System.Threading.AutoResetEvent>、および<xref:System.Threading.ManualResetEvent>) セマフォにはスレッド アフィニティがありません。 任意のスレッドは、イベント待機ハンドルまたはセマフォを通知できます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-114">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="1e58e-115">ミュー テックス、一方ではスレッド アフィニティが;ミュー テックスを所有するスレッドを解放する必要があります、およびスレッドの呼び出し、例外がスローされますが、<xref:System.Threading.Mutex.ReleaseMutex%2A>ミュー テックスを所有していないメソッドです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-115">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="1e58e-116"><xref:System.Threading.WaitHandle>クラスから派生<xref:System.MarshalByRefObject>、これらのクラスは、アプリケーション ドメイン境界を越えてスレッドのアクティビティを同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-116">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="1e58e-117">その派生クラスでだけでなく、<xref:System.Threading.WaitHandle>クラスにはさまざまな 1 つまでスレッドをブロックする静的メソッドまたは複数の同期オブジェクトがシグナルを受信します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-117">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.</span></span> <span data-ttu-id="1e58e-118">次の設定があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-118">These include:</span></span>  
  
-   <span data-ttu-id="1e58e-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>、スレッドの 1 つの待機ハンドルを通知し、すぐに別の待つことができます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-119"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="1e58e-120"><xref:System.Threading.WaitHandle.WaitAll%2A>、、スレッド、配列内のすべての待機ハンドルがシグナルを受信するまで待機することができます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-120"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="1e58e-121"><xref:System.Threading.WaitHandle.WaitAny%2A>、、スレッドの待機ハンドルの指定したセットのいずれかが通知されたまで待機することができます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-121"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled.</span></span>  
  
 <span data-ttu-id="1e58e-122">これらのメソッドのオーバー ロードは、待機、およびその他のスレッド同期コンテキストを使用できるように、待機に入る前に同期コンテキストを終了する機会を放棄するためのタイムアウト間隔を提供します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-122">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="1e58e-123">この型は <xref:System.IDisposable> インターフェイスを実装します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-123">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="1e58e-124">型またはその派生型を使用してが完了したら、直接的または間接的にそれを破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-124">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="1e58e-125">直接的に型を破棄するには、`try` / `catch` ブロック内で <xref:System.Threading.WaitHandle.Close%2A> メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-125">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="1e58e-126">間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-126">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="1e58e-127">詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1e58e-127">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="1e58e-128"><xref:System.Threading.WaitHandle> 実装して、<xref:System.IDisposable.Dispose%2A>パターン。</span><span class="sxs-lookup"><span data-stu-id="1e58e-128"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="1e58e-129">参照してください [Dispose メソッドの](~/docs/standard/garbage-collection/implementing-dispose.md) を実装します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-129">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="1e58e-130">派生させた場合<xref:System.Threading.WaitHandle>を使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>ネイティブのオペレーティング システム ハンドルを格納するプロパティ。</span><span class="sxs-lookup"><span data-stu-id="1e58e-130">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native operating system handle.</span></span> <span data-ttu-id="1e58e-131">保護されたをオーバーライドする必要はありません<xref:System.Threading.WaitHandle.Dispose%2A>メソッド追加されているアンマネージ リソースを使用する場合を除き、します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-131">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-132">次のコード例に示す 2 つのスレッドができる方法は、メインの中にバック グラウンド タスク スレッド、静的なを使用して、タスクの待機<xref:System.Threading.WaitHandle.WaitAny%2A>と<xref:System.Threading.WaitHandle.WaitAll%2A>のメソッド、<xref:System.Threading.WaitHandle>クラス。</span><span class="sxs-lookup"><span data-stu-id="1e58e-132">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="1e58e-133">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-133">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="1e58e-134">スレッド</span><span class="sxs-lookup"><span data-stu-id="1e58e-134">Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md"><span data-ttu-id="1e58e-135">スレッド処理オブジェクトと機能</span><span class="sxs-lookup"><span data-stu-id="1e58e-135">Threading Objects and Features</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="1e58e-136">ミューテックス</span><span class="sxs-lookup"><span data-stu-id="1e58e-136">Mutexes</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/cd94fc34-ac15-427f-b723-a1240a4fab7d"><span data-ttu-id="1e58e-137">EventWaitHandle、AutoResetEvent、および ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="1e58e-137">EventWaitHandle, AutoResetEvent, and ManualResetEvent</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="1e58e-138">セマフォ</span><span class="sxs-lookup"><span data-stu-id="1e58e-138">Semaphores</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1e58e-139"><see cref="T:System.Threading.WaitHandle" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-139">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="waitHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1e58e-140">現在の <see cref="T:System.Threading.WaitHandle" /> によって保持されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-140">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-141">このメソッドは、パブリックな実装の<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>のメソッド、<xref:System.Threading.WaitHandle>クラスとその派生クラス。</span><span class="sxs-lookup"><span data-stu-id="1e58e-141">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="1e58e-142">呼び出す標準実装されています。、`Dispose(Boolean)`オーバー ロードを`true`引数に呼び出し、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-142">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1e58e-143">インスタンスによって保持されているすべてのリソースを解放するには、このメソッドを呼び出す`WaitHandle`または派生クラス。</span><span class="sxs-lookup"><span data-stu-id="1e58e-143">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="1e58e-144">このメソッドが呼び出されると、現在のインスタンスへの参照は未定義の動作が発生します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-144">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1e58e-145">常に呼び出す<xref:System.Threading.WaitHandle.Close%2A>または<xref:System.Threading.WaitHandle.Dispose>への参照を解放する前に、<xref:System.Threading.WaitHandle>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-145">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="1e58e-146">それ以外の場合、使用されているリソースは解放されません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-146">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1e58e-147">オーバーライドする必要があります、<see langword="Dispose(Boolean)" />で割り当てられているリソースを解放するメソッドがクラスを派生します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-147">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="1e58e-148">Dispose メソッドの実装</span><span class="sxs-lookup"><span data-stu-id="1e58e-148">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1e58e-149"><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-149">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="waitHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1e58e-150"><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-150">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-151">このメソッドは、<xref:System.Threading.WaitHandle.Close%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-151">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1e58e-152">常に呼び出す<xref:System.Threading.WaitHandle.Close%2A>または<xref:System.Threading.WaitHandle.Dispose>への参照を解放する前に、<xref:System.Threading.WaitHandle>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-152">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="1e58e-153">それ以外の場合、使用されているリソースは解放されません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-153">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="1e58e-154">アンマネージ リソースのクリーンアップ</span><span class="sxs-lookup"><span data-stu-id="1e58e-154">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="waitHandle.Dispose explicitDisposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing"><span data-ttu-id="1e58e-155">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-155"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="1e58e-156">派生クラスでオーバーライドされると、<see cref="T:System.Threading.WaitHandle" /> によって使用されているアンマネージド リソースを解放し、オプションでマネージド リソースも解放します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-156">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-157">このメソッドは、<xref:System.Threading.WaitHandle.Close%2A>と<xref:System.Threading.WaitHandle.Dispose>メソッド、`explicitDisposing`パラメーターに設定`true`。</span><span class="sxs-lookup"><span data-stu-id="1e58e-157">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="1e58e-158">ときに、`explicitDisposing`パラメーターが`true`、このメソッドは、すべてのマネージ オブジェクトによって保持されているすべてのリソースを解放します。 この<xref:System.Threading.WaitHandle>オブジェクト参照。</span><span class="sxs-lookup"><span data-stu-id="1e58e-158">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1e58e-159">オーバーライドする必要があります、<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />で割り当てられているリソースを解放するメソッドがクラスを派生します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-159">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
<span data-ttu-id="1e58e-160"><see cref="M:System.Threading.WaitHandle.Close" />または<see cref="M:System.Threading.WaitHandle.Dispose" />メソッドは、他のオブジェクトで複数回呼び出すことがあります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-160">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="1e58e-161">このメソッドをオーバーライドする場合は、事前に呼び出したで破棄されたオブジェクトを参照しないように注意する<see langword="Dispose" />または<see langword="Close" />します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-161">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="1e58e-162">Dispose メソッドの実装</span><span class="sxs-lookup"><span data-stu-id="1e58e-162">Implementing a Dispose Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!WaitHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="waitHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1e58e-163">現在のインスタンスに保持されているリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-163">Releases the resources held by the current instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  

> [!NOTE]
> <span data-ttu-id="1e58e-164">このメンバーは、.NET Framework version 2.0 およびそれ以降のバージョンから削除されました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-164">This member has been removed from the .NET Framework version 2.0 and subsequent versions.</span></span> <span data-ttu-id="1e58e-165">このトピックでは、このトピックの後半の「バージョン情報」に示したバージョンにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-165">This topic applies only to the versions listed in "Version Information" later in this topic.</span></span>


<span data-ttu-id="1e58e-166">アプリケーション コードには、このメソッドは呼び出しません。ガベージ コレクターによって終了処理が無効になっている場合を除き、ガベージ コレクション中に自動的に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-166">Application code does not call this method; it is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled.</span></span> <span data-ttu-id="1e58e-167">詳細については、次のトピックを参照してください。 <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> および <xref:System.Object.Finalize></span><span class="sxs-lookup"><span data-stu-id="1e58e-167">For more information, see <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> and <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="1e58e-168">このメソッドは、<xref:System.Object.Finalize> をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-168">This method overrides <xref:System.Object.Finalize>.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint with get, set" Usage="System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1e58e-169">ネイティブ オペレーティング システム ハンドルを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-169">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="1e58e-170">ネイティブ オペレーティング システム ハンドルを表す <see langword="IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-170">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="1e58e-171">既定値は <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> フィールドの値です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-171">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-172">新しい値を割り当てる、<xref:System.Threading.WaitHandle.Handle%2A>プロパティが以前のハンドルを終了していません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-172">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="1e58e-173">これは、結果、漏洩したハンドル。</span><span class="sxs-lookup"><span data-stu-id="1e58e-173">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="1e58e-174">.NET framework version 2.0 以降です。 このプロパティを使用しません。使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティ代わりにします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-174">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="1e58e-175">このプロパティの設定を有効なハンドルもセット、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティに設定すると<xref:System.Threading.WaitHandle.InvalidHandle>リークしたハンドルで発生することができます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-175">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1e58e-176">プロパティ値を設定する直前の呼び出し元に対する完全な信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-176">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="1e58e-177">このメンバーは、部分的に信頼されたまたは透過的なコードで設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-177">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="1e58e-178">派生型である必要があります<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />プロパティ値を設定します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-178">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberSignature Language="F#" Value=" staticval mutable InvalidHandle : nativeint" Usage="System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1e58e-179">無効なネイティブ オペレーティング システム ハンドルを表します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-179">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="1e58e-180">このフィールドは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-180">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-181">初期化するために内部的に使用される、<xref:System.Threading.WaitHandle.Handle%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="1e58e-181">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="1e58e-182">この値を使用するには判断するかどうか、<see cref="P:System.Threading.WaitHandle.Handle" />プロパティに有効なネイティブ オペレーティング システム ハンドルが含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-182">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeWaitHandle with get, set" Usage="System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="1e58e-183">ネイティブ オペレーティング システム ハンドルを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-183">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="1e58e-184">ネイティブ オペレーティング システム ハンドルを表す <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-184">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-185">新しい値を割り当てるとき、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティ、ときに、前のハンドルを閉じるは前<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>オブジェクトを収集します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-185">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="1e58e-186">手動でハンドルを終了しないで、この結果、ため、<xref:System.ObjectDisposedException>ときに、<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>ハンドルを終了しようとしています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-186">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="1e58e-187"><xref:System.Threading.WaitHandle> 実装して、<xref:System.IDisposable.Dispose%2A>パターン。</span><span class="sxs-lookup"><span data-stu-id="1e58e-187"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="1e58e-188">参照してください [Dispose メソッドの](~/docs/standard/garbage-collection/implementing-dispose.md) を実装します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-188">See [Implementing a Dispose method](~/docs/standard/garbage-collection/implementing-dispose .md).</span></span> <span data-ttu-id="1e58e-189">派生させた場合<xref:System.Threading.WaitHandle>を使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>ネイティブのハンドルのオペレーティング システム ハンドルを格納するプロパティ。</span><span class="sxs-lookup"><span data-stu-id="1e58e-189">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="1e58e-190">保護されたをオーバーライドする必要はありません<xref:System.Threading.WaitHandle.Dispose%2A>メソッド追加されているアンマネージ リソースを使用する場合を除き、します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-190">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="1e58e-191">直前の呼び出し元に対する完全な信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-191">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="1e58e-192">このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-192">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="1e58e-193">派生型である必要があります<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />このメンバーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-193">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1e58e-194">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-194">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="1e58e-195">通知対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-195">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="1e58e-196">待機対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-196">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="1e58e-197">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-197">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns><span data-ttu-id="1e58e-198">通知と待機の両方が正常に完了した場合は <see langword="true" />。待機が完了しない場合、メソッドから制御は戻りません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-198"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-199">この操作はアトミックであるは保証されません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-199">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="1e58e-200">現在のスレッドの信号後`toSignal`までの間待機している`toWaitOn`、別のプロセッサで実行されているスレッドを通知`toWaitOn`待機またはします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-200">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-201">次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>ブロックされたスレッドのシグナルを待ってから、スレッドがタスクを完了するまでメイン スレッドを許可するメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-201">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="1e58e-202">例では、5 つのスレッドを開始、ブロックすることができます、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>フラグ、およびユーザーが ENTER キーを押す、リリースの 1 つのスレッド時間。</span><span class="sxs-lookup"><span data-stu-id="1e58e-202">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="1e58e-203">例では、別の 5 つのスレッドのキューし、すべてを使用して、解放、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>フラグ。</span><span class="sxs-lookup"><span data-stu-id="1e58e-203">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-204"><paramref name="toSignal" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-204"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-205">- または -</span><span class="sxs-lookup"><span data-stu-id="1e58e-205">-or-</span></span> 
 <span data-ttu-id="1e58e-206"><paramref name="toWaitOn" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-206"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-207">メソッドは <see cref="T:System.STAThreadAttribute" /> を持つスレッドで呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-207">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="1e58e-208">このメソッドは、Windows 98 および Windows Millennium Edition ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-208">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-209"><paramref name="toSignal" /> はセマフォで、カウントは既に最大値になっています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-209"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-210">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-210">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-211">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-211">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="1e58e-212">通知対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-212">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="1e58e-213">待機対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-213">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1e58e-214">待機する間隔を表す整数。</span><span class="sxs-lookup"><span data-stu-id="1e58e-214">An integer that represents the interval to wait.</span></span> <span data-ttu-id="1e58e-215">この値が <see cref="F:System.Threading.Timeout.Infinite" />、つまり -1 の場合、待機は無期限となります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-215">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1e58e-216">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-216"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1e58e-217">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として 32 ビット符号付き整数を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-217">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="1e58e-218">通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-218"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-219">この操作はアトミックであるは保証されません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-219">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="1e58e-220">現在のスレッドの信号後`toSignal`までの間待機している`toWaitOn`、別のプロセッサで実行されているスレッドを通知`toWaitOn`待機またはします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-220">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="1e58e-221">場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-221">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-222">テストの状態、`toWaitOn`をすぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-222">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1e58e-223">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="1e58e-223">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1e58e-224">`exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.SignalAndWait%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-224">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1e58e-225">派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-225">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1e58e-226">派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-226">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1e58e-227">既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-227">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="1e58e-228">呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが完了するとします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-228">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="1e58e-229">これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-229">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1e58e-230">その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。</span><span class="sxs-lookup"><span data-stu-id="1e58e-230">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1e58e-231">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-231">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1e58e-232">ときに、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-232">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-233"><paramref name="toSignal" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-233"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-234">- または -</span><span class="sxs-lookup"><span data-stu-id="1e58e-234">-or-</span></span> 
 <span data-ttu-id="1e58e-235"><paramref name="toWaitOn" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-235"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-236">メソッドは <see cref="T:System.STAThreadAttribute" /> を持つスレッドで呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-236">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="1e58e-237">このメソッドは、Windows 98 および Windows Millennium Edition ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-237">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-238">カウントの最大値を超えるため、<see cref="T:System.Threading.WaitHandle" /> はシグナル状態にはできません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-238">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-239"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-239"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-240">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-240">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-241">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-241">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member SignalAndWait : System.Threading.WaitHandle * System.Threading.WaitHandle * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.SignalAndWait (toSignal, toWaitOn, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="1e58e-242">通知対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-242">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="1e58e-243">待機対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-243">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="1e58e-244">待機間隔を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-244">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="1e58e-245">この値が -1 の場合、待機は無期限となります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-245">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1e58e-246">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-246"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1e58e-247">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として <see cref="T:System.TimeSpan" /> を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-247">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns><span data-ttu-id="1e58e-248">通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-248"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-249">この操作はアトミックであるは保証されません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-249">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="1e58e-250">現在のスレッドの信号後`toSignal`までの間待機している`toWaitOn`、別のプロセッサで実行されているスレッドを通知`toWaitOn`待機またはします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-250">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="1e58e-251">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-251">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1e58e-252">場合`timeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-252">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-253">テストの状態、`toWaitOn`をすぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-253">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1e58e-254">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="1e58e-254">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1e58e-255">`exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.SignalAndWait%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-255">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1e58e-256">派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-256">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1e58e-257">派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-257">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1e58e-258">既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-258">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="1e58e-259">呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが完了するとします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-259">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="1e58e-260">これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-260">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1e58e-261">その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。</span><span class="sxs-lookup"><span data-stu-id="1e58e-261">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1e58e-262">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-262">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1e58e-263">ときに、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-263">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-264"><paramref name="toSignal" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-264"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-265">- または -</span><span class="sxs-lookup"><span data-stu-id="1e58e-265">-or-</span></span> 
 <span data-ttu-id="1e58e-266"><paramref name="toWaitOn" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-266"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-267">メソッドは <see cref="T:System.STAThreadAttribute" /> を持つスレッドで呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-267">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="1e58e-268">このメソッドは、Windows 98 および Windows Millennium Edition ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-268">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-269"><paramref name="toSignal" /> はセマフォで、カウントは既に最大値になっています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-269"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-270"><paramref name="timeout" /> は、-1 以外の負のミリ秒値となります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-270"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
<span data-ttu-id="1e58e-271">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-271">-or-</span></span> 
 <span data-ttu-id="1e58e-272"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-272"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-273">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-273">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-274">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-274">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1e58e-275"><see cref="T:System.Threading.WaitHandle" /> によって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-275">Releases all resources used by the <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="1e58e-276">呼び出す`Dispose`によって使用されるリソースの使用、<xref:System.Threading.WaitHandle>他の目的で再割り当てします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-276">Calling `Dispose` allows the resources used by the <xref:System.Threading.WaitHandle> to be reallocated for other purposes.</span></span> <span data-ttu-id="1e58e-277">詳細については`Dispose`を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-277">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1e58e-278">指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-278">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1e58e-279">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="1e58e-279">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1e58e-280">この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-280">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="1e58e-281">指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-281">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="1e58e-282"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />。それ以外の場合は、待機を続けます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-282"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-283"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-283"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1e58e-284">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-284">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1e58e-285">放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-285">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1e58e-286">システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-286">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1e58e-287">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-287">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1e58e-288"><xref:System.Threading.WaitHandle.WaitAll%2A>メソッドは、すべてのハンドルがシグナルを返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-288">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="1e58e-289">一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-289">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1e58e-290">配列に重複が含まれている場合、呼び出しは、<xref:System.DuplicateWaitObjectException>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-290">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1e58e-291"><xref:System.Threading.WaitHandle.WaitAll%2A>が含まれるスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-291">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1e58e-292">呼び出しと同じですがこのメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定する (または<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) の`millisecondsTimeout`と`true`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-292">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-293">次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループを出力する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-293">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="1e58e-294">個々 の書き込み操作は、作業項目および信号としてキューに登録が完了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-294">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="1e58e-295">メイン スレッドは、すべての項目からの通知の待機し、終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-295">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-296"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-296">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="1e58e-297">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-297">-or-</span></span> 
<span data-ttu-id="1e58e-298"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-298">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-299">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-299">-or-</span></span> 
 <span data-ttu-id="1e58e-300"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-300"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="1e58e-301"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-301">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="1e58e-302"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-302">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-303"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-303">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="1e58e-304">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-304">-or-</span></span> 
<span data-ttu-id="1e58e-305"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-305">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1e58e-306"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-306"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-307">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-307">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-308">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-308">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-309"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-309">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1e58e-310">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="1e58e-310">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1e58e-311">この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-311">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1e58e-312">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="1e58e-312">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1e58e-313"><see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-313">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1e58e-314"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-314"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-315">場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-315">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-316">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-316">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-317"><xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了する、つまりすべてのハンドルがシグナル状態になるとき、またはタイムアウトが発生したときに、メソッドが返されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-317">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="1e58e-318">一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-318">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1e58e-319">配列に重複がある場合、呼び出しは、<xref:System.DuplicateWaitObjectException>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-319">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1e58e-320"><xref:System.Threading.WaitHandle.WaitAll%2A>が含まれるスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-320">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1e58e-321">呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-321">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-322"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-322">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-323">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-323">-or-</span></span> 
<span data-ttu-id="1e58e-324"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-324">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-325">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-325">-or-</span></span> 
 <span data-ttu-id="1e58e-326"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-326"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="1e58e-327"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-327">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="1e58e-328"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-328">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-329"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-329">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="1e58e-330">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-330">-or-</span></span> 
<span data-ttu-id="1e58e-331"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-331">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-332"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-332"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-333">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-333">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-334">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-334">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-335"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-335">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1e58e-336">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="1e58e-336">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1e58e-337">この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-337">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="1e58e-338">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-338">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1e58e-339"><see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-339">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1e58e-340"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-340"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-341">場合`timeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-341">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-342">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-342">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-343"><xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了するすべてのハンドルがシグナル状態になることを意味するか、タイムアウトが発生するときに、メソッドが返されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-343">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="1e58e-344">一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-344">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1e58e-345">配列に重複が含まれている場合、呼び出しは失敗します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-345">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1e58e-346"><xref:System.Threading.WaitHandle.WaitAll%2A>が含まれるスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-346">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1e58e-347">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-347">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1e58e-348">呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-348">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-349"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-349">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-350">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-350">-or-</span></span> 
<span data-ttu-id="1e58e-351"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-351">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-352">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-352">-or-</span></span> 
 <span data-ttu-id="1e58e-353"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-353"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="1e58e-354"><see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-354">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="1e58e-355"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-355">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-356"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-356">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="1e58e-357">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-357">-or-</span></span> 
<span data-ttu-id="1e58e-358"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-358">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-359"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-359"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1e58e-360">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-360">-or-</span></span> 
 <span data-ttu-id="1e58e-361"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-361"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-362">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-362">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-363">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-363">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-364"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-364">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * int * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1e58e-365">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="1e58e-365">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1e58e-366">この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-366">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1e58e-367">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="1e58e-367">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1e58e-368">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-368"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1e58e-369">指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-369">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1e58e-370"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は<see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-370"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-371">場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-371">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-372">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-372">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-373"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-373"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1e58e-374">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-374">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1e58e-375">放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-375">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1e58e-376">システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-376">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1e58e-377">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-377">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1e58e-378"><xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了する、つまりすべてのハンドルがシグナル状態になるとき、またはタイムアウトが発生したときに、メソッドが返されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-378">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="1e58e-379">一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-379">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1e58e-380">配列に重複がある場合、呼び出しは、<xref:System.DuplicateWaitObjectException>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-380">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1e58e-381"><xref:System.Threading.WaitHandle.WaitAll%2A>が含まれるスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-381">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1e58e-382">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="1e58e-382">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1e58e-383">`exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitAll%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-383">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1e58e-384">派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-384">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1e58e-385">派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-385">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1e58e-386">既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-386">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="1e58e-387">呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが完了するとします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-387">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="1e58e-388">これは、便利な場合、コンテキスト バインド クラスには、<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>属性。</span><span class="sxs-lookup"><span data-stu-id="1e58e-388">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="1e58e-389">その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。</span><span class="sxs-lookup"><span data-stu-id="1e58e-389">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1e58e-390">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-390">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1e58e-391">ときに、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-391">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-392">次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループを出力する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-392">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="1e58e-393">個々 の書き込み操作は、作業項目および信号としてキューに登録が完了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-393">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="1e58e-394">メイン スレッドは、すべての項目からの通知の待機し、終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-394">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-395"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-395">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-396">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-396">-or-</span></span> 
<span data-ttu-id="1e58e-397"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-397">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-398">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-398">-or-</span></span> 
 <span data-ttu-id="1e58e-399"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-399"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="1e58e-400"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-400">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-401"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-401">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="1e58e-402">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-402">-or-</span></span> 
<span data-ttu-id="1e58e-403"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-403">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1e58e-404"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-404"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-405"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-405"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-406">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-406">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-407">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-407">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-408"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-408">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; bool" Usage="System.Threading.WaitHandle.WaitAll (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1e58e-409">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="1e58e-409">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="1e58e-410">この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-410">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="1e58e-411">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-411">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1e58e-412">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-412"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1e58e-413">指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-413">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1e58e-414"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-414"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-415">場合`timeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-415">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-416">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-416">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-417"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-417"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1e58e-418">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-418">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1e58e-419">放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-419">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1e58e-420">システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-420">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1e58e-421">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-421">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1e58e-422"><xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了するすべてのハンドルがシグナル状態になることを意味するか、タイムアウトが発生するときに、メソッドが返されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-422">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="1e58e-423">一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-423">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="1e58e-424">配列に重複が含まれている場合、呼び出しは失敗します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-424">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1e58e-425"><xref:System.Threading.WaitHandle.WaitAll%2A>が含まれるスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-425">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="1e58e-426">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-426">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1e58e-427">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="1e58e-427">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1e58e-428">`exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitAll%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-428">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1e58e-429">派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-429">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1e58e-430">派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-430">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1e58e-431">既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-431">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="1e58e-432">呼び出しの後に元の既定以外のコンテキストを返します、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが完了するとします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-432">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="1e58e-433">これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-433">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1e58e-434">その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。</span><span class="sxs-lookup"><span data-stu-id="1e58e-434">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1e58e-435">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-435">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1e58e-436">ときに、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-436">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-437">次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループを出力する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-437">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="1e58e-438">個々 の書き込み操作は、作業項目および信号としてキューに登録が完了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-438">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="1e58e-439">メイン スレッドは、すべての項目からの通知の待機し、終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-439">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-440"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-440">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-441">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-441">-or-</span></span> 
<span data-ttu-id="1e58e-442"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-442">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-443">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-443">-or-</span></span> 
 <span data-ttu-id="1e58e-444"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-444"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="1e58e-445"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-445">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-446"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-446">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
<span data-ttu-id="1e58e-447">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-447">-or-</span></span> 
<span data-ttu-id="1e58e-448"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-448">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1e58e-449"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-449"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-450"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-450"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1e58e-451">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-451">-or-</span></span> 
 <span data-ttu-id="1e58e-452"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-452"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-453">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-453">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-454">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-454">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-455"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-455">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1e58e-456">指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-456">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] -&gt; int" Usage="System.Threading.WaitHandle.WaitAny waitHandles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1e58e-457">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="1e58e-457">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="1e58e-458">指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-458">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="1e58e-459">待機を実行するオブジェクトの配列インデックス。</span><span class="sxs-lookup"><span data-stu-id="1e58e-459">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-460"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-460"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1e58e-461">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスが破棄されたため、待機が終了した場合。</span><span class="sxs-lookup"><span data-stu-id="1e58e-461">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="1e58e-462">放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-462">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1e58e-463">システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-463">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1e58e-464">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-464">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1e58e-465"><xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-465">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1e58e-466">場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号でリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-466">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1e58e-467">.NET Framework バージョン 2.0 では、スレッドが終了するか明示的に解放しないままを中止する場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`は0 ではなく 128 です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-467">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="1e58e-468">このメソッドは、いずれかのハンドルがシグナルを受け取るを返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-468">This method returns when any handle is signaled.</span></span> <span data-ttu-id="1e58e-469">呼び出し中に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-469">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1e58e-470">一部の実装の詳細は 64 ハンドルが渡される場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-470">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1e58e-471">呼び出しと同じですがこのメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定する (または<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) の`millisecondsTimeout`と`true`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-471">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-472">次のコード例は、呼び出し元を示します、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-472">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-473"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-473">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-474">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-474">-or-</span></span> 
<span data-ttu-id="1e58e-475"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-475">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-476"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-476">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1e58e-477">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-477"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-478">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-478">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-479">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-479">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1e58e-480">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-480"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-481"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-481">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1e58e-482">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="1e58e-482">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1e58e-483">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="1e58e-483">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1e58e-484">32 ビット符号付き整数を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-484">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1e58e-485">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-485">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-486">場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-486">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-487">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-487">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-488"><xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-488">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1e58e-489">場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号でリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-489">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="1e58e-490">このメソッドは、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに、待機が終了するときに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-490">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="1e58e-491">呼び出し中に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-491">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1e58e-492">一部の実装の詳細は 64 ハンドルが渡される場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-492">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1e58e-493">呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-493">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-494"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-494">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-495">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-495">-or-</span></span> 
<span data-ttu-id="1e58e-496"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-496">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-497"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-497">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-498"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-498"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-499">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-499">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-500">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-500">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1e58e-501"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-501"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-502"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-502">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1e58e-503">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="1e58e-503">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="1e58e-504">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-504">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1e58e-505"><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-505">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1e58e-506">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-506">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-507">場合`timeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-507">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-508">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-508">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-509"><xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-509">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1e58e-510">場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号でリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-510">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="1e58e-511">このメソッドは、ハンドルのいずれかが通知されるとき、または、タイムアウトが発生したときに、待機が終了するときに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-511">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="1e58e-512">呼び出し中に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-512">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1e58e-513">一部の実装の詳細は 64 ハンドルが渡される場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-513">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1e58e-514">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-514">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1e58e-515">呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-515">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-516"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-516">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-517">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-517">-or-</span></span> 
<span data-ttu-id="1e58e-518"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-518">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-519"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-519">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-520"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-520"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1e58e-521">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-521">-or-</span></span> 
 <span data-ttu-id="1e58e-522"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-522"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-523">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-523">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-524">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-524">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1e58e-525"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-525"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-526"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-526">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * int * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1e58e-527">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="1e58e-527">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="1e58e-528">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="1e58e-528">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1e58e-529">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-529"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1e58e-530">32 ビットの符号付き整数を使用して時間間隔を指定し、待機する前に同期ドメインを終了するかどうかを指定して、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-530">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1e58e-531">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-531">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-532">場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-532">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-533">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-533">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-534"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-534"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1e58e-535">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスが破棄されたため、待機が終了した場合。</span><span class="sxs-lookup"><span data-stu-id="1e58e-535">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="1e58e-536">放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-536">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1e58e-537">システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-537">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1e58e-538">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-538">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1e58e-539"><xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-539">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1e58e-540">場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号でリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-540">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1e58e-541">.NET Framework バージョン 2.0 では、スレッドが終了するか明示的に解放しないままを中止する場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`は0 ではなく 128 です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-541">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="1e58e-542">このメソッドは、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに、待機が終了するときに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-542">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="1e58e-543">呼び出し中に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-543">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1e58e-544">一部の実装の詳細は 64 ハンドルが渡される場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-544">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1e58e-545">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="1e58e-545">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1e58e-546">`exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitAny%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-546">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1e58e-547">派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-547">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1e58e-548">派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-548">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1e58e-549">既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-549">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="1e58e-550">呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが完了するとします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-550">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="1e58e-551">これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-551">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1e58e-552">その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。</span><span class="sxs-lookup"><span data-stu-id="1e58e-552">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1e58e-553">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-553">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1e58e-554">ときに、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-554">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-555">次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-555">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="1e58e-556">領域の考慮事項は、各ディスクのルート ディレクトリのみが検索されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-556">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-557"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-557">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-558">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-558">-or-</span></span> 
<span data-ttu-id="1e58e-559"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-559">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-560"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-560">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1e58e-561">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-561"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-562"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-562"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-563">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-563">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-564">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-564">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1e58e-565">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-565"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-566"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-566">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.WaitHandle[] * TimeSpan * bool -&gt; int" Usage="System.Threading.WaitHandle.WaitAny (waitHandles, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="1e58e-567">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="1e58e-567">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="1e58e-568">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-568">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1e58e-569">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-569"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1e58e-570">指定した配列内のいずれかの要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-570">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1e58e-571">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-571">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-572">場合`timeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-572">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-573">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-573">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-574"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-574"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1e58e-575">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスが破棄されたため、待機が終了した場合。</span><span class="sxs-lookup"><span data-stu-id="1e58e-575">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="1e58e-576">放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-576">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1e58e-577">システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-577">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1e58e-578">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-578">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1e58e-579"><xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-579">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="1e58e-580">場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号でリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-580">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1e58e-581">.NET Framework バージョン 2.0 では、スレッドが終了するか明示的に解放しないままを中止する場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`は0 ではなく 128 です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-581">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="1e58e-582">このメソッドは、ハンドルのいずれかが通知されるとき、または、タイムアウトが発生したときに、待機が終了するときに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-582">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="1e58e-583">呼び出し中に 1 つ以上のオブジェクトがシグナル状態に場合、は、シグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックスを返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-583">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="1e58e-584">一部の実装の詳細は 64 ハンドルが渡される場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-584">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="1e58e-585">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-585">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1e58e-586">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="1e58e-586">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1e58e-587">`exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitAny%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-587">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1e58e-588">派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-588">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1e58e-589">派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-589">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1e58e-590">既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-590">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="1e58e-591">呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが完了するとします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-591">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="1e58e-592">これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-592">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1e58e-593">その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。</span><span class="sxs-lookup"><span data-stu-id="1e58e-593">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1e58e-594">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-594">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1e58e-595">ときに、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-595">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-596">次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-596">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="1e58e-597">領域の考慮事項は、各ディスクのルート ディレクトリのみが検索されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-597">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="1e58e-598"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-598">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
<span data-ttu-id="1e58e-599">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-599">-or-</span></span> 
<span data-ttu-id="1e58e-600"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-600">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="1e58e-601"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-601">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="1e58e-602">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-602"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-603"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-603"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1e58e-604">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-604">-or-</span></span> 
 <span data-ttu-id="1e58e-605"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-605"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-606">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-606">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-607">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-607">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="1e58e-608">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-608"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-609"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-609">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="1e58e-610">現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-610">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : unit -&gt; bool&#xA;override this.WaitOne : unit -&gt; bool" Usage="waitHandle.WaitOne " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1e58e-611">現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-611">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns><span data-ttu-id="1e58e-612">現在のインスタンスがシグナルを受け取った場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-612"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="1e58e-613">現在のインスタンスがシグナルを受け取らない場合は、<see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> はシグナルを受け取るまで待機を続けます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-613">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-614"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-614"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1e58e-615">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-615">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1e58e-616">放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-616">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1e58e-617">システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-617">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1e58e-618">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-618">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1e58e-619">このメソッドは、現在のインスタンスまで無期限にブロックの呼び出し元がシグナルを受信します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-619">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="1e58e-620">このメソッドを使用するまでブロック、<xref:System.Threading.WaitHandle>が別のスレッドからシグナルを受け取る、非同期操作の完了時に、生成がなど。</span><span class="sxs-lookup"><span data-stu-id="1e58e-620">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1e58e-621">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1e58e-621">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1e58e-622">呼び出しと同じですがこのメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定するまたは<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>、最初のパラメーターと`false`2 番目のパラメーター。</span><span class="sxs-lookup"><span data-stu-id="1e58e-622">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="1e58e-623">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-623">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-624">次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機する間に終了してから、プロセスを監視する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-624">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1e58e-625">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-625">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-626">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-627">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-628">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int -&gt; bool&#xA;override this.WaitOne : int -&gt; bool" Usage="waitHandle.WaitOne millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="1e58e-629">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="1e58e-629">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1e58e-630">32 ビット符号付き整数を使用して時間間隔をミリ秒単位で指定し、現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで、現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-630">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="1e58e-631">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-632">場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-632">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-633">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-634">現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元に発生します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1e58e-635">このメソッドを使用するまでブロック、<xref:System.Threading.WaitHandle>が別のスレッドからシグナルを受け取る、非同期操作の完了時に、生成がなど。</span><span class="sxs-lookup"><span data-stu-id="1e58e-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1e58e-636">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1e58e-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1e58e-637">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="1e58e-638">呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-638">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-639">次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機する間に終了してから、プロセスを監視する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-639">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1e58e-640">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-641"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-641"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-642">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-642">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-643">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-643">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-644">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-644">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan -&gt; bool&#xA;override this.WaitOne : TimeSpan -&gt; bool" Usage="waitHandle.WaitOne timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="1e58e-645">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-645">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="1e58e-646"><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-646">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="1e58e-647">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-647"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-648">場合`timeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-648">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-649">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-649">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-650">現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元に発生します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-650">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1e58e-651">このメソッドを使用するまでブロック、<xref:System.Threading.WaitHandle>が別のスレッドからシグナルを受け取る、非同期操作の完了時に、生成がなど。</span><span class="sxs-lookup"><span data-stu-id="1e58e-651">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1e58e-652">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1e58e-652">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1e58e-653">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-653">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="1e58e-654">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-654">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="1e58e-655">呼び出しと同じには、このメソッドのオーバー ロードを呼び出し、<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-655">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1e58e-656">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-656">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-657"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-657"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1e58e-658">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-658">-or-</span></span> 
 <span data-ttu-id="1e58e-659"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-659"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-660">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-660">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-661">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-661">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-662">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-662">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : int * bool -&gt; bool&#xA;override this.WaitOne : int * bool -&gt; bool" Usage="waitHandle.WaitOne (millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="1e58e-663">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="1e58e-663">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1e58e-664">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-664"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1e58e-665">現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで現在のスレッドをブロックします。時間間隔を指定するために 32 ビット符号付き整数を使用し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-665">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1e58e-666">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-666"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-667">場合`millisecondsTimeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-667">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-668">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-668">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-669"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-669"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1e58e-670">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-670">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1e58e-671">放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-671">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1e58e-672">システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-672">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1e58e-673">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-673">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1e58e-674">現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元に発生します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-674">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1e58e-675">このメソッドを使用するまでブロック、<xref:System.Threading.WaitHandle>が別のスレッドからシグナルを受け取る、非同期操作の完了時に、生成がなど。</span><span class="sxs-lookup"><span data-stu-id="1e58e-675">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1e58e-676">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1e58e-676">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1e58e-677">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-677">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1e58e-678">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="1e58e-678">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1e58e-679">`exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitOne%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-679">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1e58e-680">派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-680">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1e58e-681">派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-681">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1e58e-682">既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-682">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="1e58e-683">呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが完了するとします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-683">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="1e58e-684">これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-684">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1e58e-685">その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。</span><span class="sxs-lookup"><span data-stu-id="1e58e-685">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1e58e-686">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-686">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1e58e-687">ときに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-687">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-688">次の例は、どのように<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>同期ドメイン内で呼び出されたときのメソッドのオーバー ロードの動作します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-688">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="1e58e-689">最初に、スレッドが待機する`exitContext`設定`false`し、待機がタイムアウトになるまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-689">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="1e58e-690">2 番目のスレッドを実行後、最初のスレッドを終了し、待つ`exitContext`に設定`true`します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-690">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="1e58e-691">この 2 つ目のスレッドの待機ハンドルの通知への呼び出しがブロックされていないと、印刷待ちタイムアウトする前に、スレッドが完了するとします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-691">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1e58e-692">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-692">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-693"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-693"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-694">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-694">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-695">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-695">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-696">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-696">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="abstract member WaitOne : TimeSpan * bool -&gt; bool&#xA;override this.WaitOne : TimeSpan * bool -&gt; bool" Usage="waitHandle.WaitOne (timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exitContext" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="1e58e-697">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-697">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext"><span data-ttu-id="1e58e-698">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-698"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="1e58e-699">現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-699">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="1e58e-700">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="1e58e-700"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-701">場合`timeout`が 0 の場合、メソッドはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-701">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="1e58e-702">これにより、待機ハンドルの状態をテストし、すぐに返します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-702">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="1e58e-703"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-703"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="1e58e-704">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-704">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="1e58e-705">放棄されたミュー テックスは、多くの場合、深刻なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-705">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="1e58e-706">システム全体のミュー テックスを (たとえば、Windows タスク マネージャーを使用して) して、アプリケーションが突然終了されたことが示している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-706">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="1e58e-707">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-707">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="1e58e-708">現在のインスタンスがシグナルまたはタイムアウトを受信するまでこのメソッドはブロックの呼び出し元に発生します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-708">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="1e58e-709">このメソッドを使用するまでブロック、<xref:System.Threading.WaitHandle>が別のスレッドからシグナルを受け取る、非同期操作の完了時に、生成がなど。</span><span class="sxs-lookup"><span data-stu-id="1e58e-709">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="1e58e-710">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="1e58e-710">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="1e58e-711">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-711">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="1e58e-712">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-712">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="1e58e-713">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="1e58e-713">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="1e58e-714">`exitContext`パラメーターには効果がない場合を除き、<xref:System.Threading.WaitHandle.WaitOne%2A>既定以外の管理対象のコンテキスト内からメソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-714">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="1e58e-715">派生したクラスのインスタンスへの呼び出し、スレッドが場合に生じる<xref:System.ContextBoundObject>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-715">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="1e58e-716">派生していないクラスでメソッドを現在実行している場合でも<xref:System.ContextBoundObject>と同様に、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-716">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="1e58e-717">既定以外のコンテキストでコードを実行しているときに指定する`true`の`exitContext`が原因で、既定以外の管理コンテキストを終了するスレッド (つまり、既定のコンテキストへの移行) 実行する前に、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="1e58e-717">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="1e58e-718">呼び出し後、スレッドが元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが完了するとします。</span><span class="sxs-lookup"><span data-stu-id="1e58e-718">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="1e58e-719">これは、便利な場合、コンテキスト バインド クラスには<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-719">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="1e58e-720">その場合は、クラスのメンバーに対するすべての呼び出しを自動的に同期し、同期ドメインは、クラスのコードの本文全体。</span><span class="sxs-lookup"><span data-stu-id="1e58e-720">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="1e58e-721">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトのすべてのメンバーへの呼び出しでブロックされているスレッドを許可する、同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-721">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="1e58e-722">ときに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが戻る呼び出しを行ったスレッドが同期ドメインを再入力を待つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="1e58e-722">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-723">次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機する間に終了してから、プロセスを監視する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-723">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="1e58e-724">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-724">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="1e58e-725"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-725"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="1e58e-726">または</span><span class="sxs-lookup"><span data-stu-id="1e58e-726">-or-</span></span> 
 <span data-ttu-id="1e58e-727"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="1e58e-727"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="1e58e-728">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="1e58e-728">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="1e58e-729">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="1e58e-729">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="1e58e-730">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="1e58e-730">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberSignature Language="F#" Value="val mutable WaitTimeout : int" Usage="System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="1e58e-731">待機ハンドルがシグナル状態になる前に <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作がタイムアウトになったことを示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-731">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="1e58e-732">このフィールドは定数です。</span><span class="sxs-lookup"><span data-stu-id="1e58e-732">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1e58e-733">このフィールドは戻り値のいずれかの`WaitAny`します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-733">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1e58e-734">次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="1e58e-734">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="1e58e-735">領域の考慮事項は、各ディスクのルート ディレクトリのみが検索されます。</span><span class="sxs-lookup"><span data-stu-id="1e58e-735">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>