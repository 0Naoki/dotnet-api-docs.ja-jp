<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WaitHandle&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WaitHandle abstract : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="26969-101">共有リソースへの排他アクセスの待機に使用するオペレーティング システム固有のオブジェクトをカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="26969-101">Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-102"><xref:System.Threading.WaitHandle>クラスは Win32 同期ハンドルをカプセル化し、複数の待機操作を許可する、ランタイム内のすべての同期オブジェクトを表すために使用します。</span><span class="sxs-lookup"><span data-stu-id="26969-102">The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.</span></span> <span data-ttu-id="26969-103">他の同期オブジェクトと待機ハンドルの比較を参照してください。[同期プリミティブの概要](~/docs/standard/threading/overview-of-synchronization-primitives.md)です。</span><span class="sxs-lookup"><span data-stu-id="26969-103">For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).</span></span>  
  
 <span data-ttu-id="26969-104"><xref:System.Threading.WaitHandle>クラス自体は抽象クラスです。</span><span class="sxs-lookup"><span data-stu-id="26969-104">The <xref:System.Threading.WaitHandle> class itself is abstract.</span></span> <span data-ttu-id="26969-105">派生したクラス<xref:System.Threading.WaitHandle>を取得または解放、共有リソースへのアクセスを示すシグナリング機構を定義しますが、使用、継承された<xref:System.Threading.WaitHandle>メソッドへのアクセスの待機中にブロックする共有リソースです。</span><span class="sxs-lookup"><span data-stu-id="26969-105">Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources.</span></span> <span data-ttu-id="26969-106">派生したクラス<xref:System.Threading.WaitHandle>が含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-106">The classes derived from <xref:System.Threading.WaitHandle> include:</span></span>  
  
-   <span data-ttu-id="26969-107"><xref:System.Threading.Mutex> クラス</span><span class="sxs-lookup"><span data-stu-id="26969-107">The <xref:System.Threading.Mutex> class.</span></span> <span data-ttu-id="26969-108">参照してください[ミュー テックス](~/docs/standard/threading/mutexes.md)です。</span><span class="sxs-lookup"><span data-stu-id="26969-108">See [Mutexes](~/docs/standard/threading/mutexes.md).</span></span>  
  
-   <span data-ttu-id="26969-109"><xref:System.Threading.EventWaitHandle>クラスとその派生クラスでは、<xref:System.Threading.AutoResetEvent>と<xref:System.Threading.ManualResetEvent>です。</span><span class="sxs-lookup"><span data-stu-id="26969-109">The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="26969-110">「[EventWaitHandle、AutoResetEvent、CountdownEvent、ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="26969-110">See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
-   <span data-ttu-id="26969-111"><xref:System.Threading.Semaphore> クラス</span><span class="sxs-lookup"><span data-stu-id="26969-111">The <xref:System.Threading.Semaphore> class.</span></span> <span data-ttu-id="26969-112">参照してください[Semaphore と SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)です。</span><span class="sxs-lookup"><span data-stu-id="26969-112">See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="26969-113">インスタンス メソッドを呼び出してスレッドをブロックできる個々 の待機ハンドル<xref:System.Threading.WaitHandle.WaitOne%2A>、これがから派生したクラスによって継承<xref:System.Threading.WaitHandle>です。</span><span class="sxs-lookup"><span data-stu-id="26969-113">Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.</span></span>  
  
 <span data-ttu-id="26969-114">派生クラス<xref:System.Threading.WaitHandle>のスレッド アフィニティが異なります。</span><span class="sxs-lookup"><span data-stu-id="26969-114">The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity.</span></span> <span data-ttu-id="26969-115">イベント待機ハンドル (<xref:System.Threading.EventWaitHandle>、 <xref:System.Threading.AutoResetEvent>、および<xref:System.Threading.ManualResetEvent>) とスレッドの関係はありません; 任意のスレッドには、イベント待機ハンドルまたはセマフォを通知できます。</span><span class="sxs-lookup"><span data-stu-id="26969-115">Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.</span></span> <span data-ttu-id="26969-116">ミュー テックス、その一方はスレッド アフィニティです。ミュー テックスを所有するスレッドを解放する必要があります、およびスレッドが呼び出す場合、例外がスローされます、<xref:System.Threading.Mutex.ReleaseMutex%2A>ミュー テックスを所有していないメソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-116">Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.</span></span>  
  
 <span data-ttu-id="26969-117"><xref:System.Threading.WaitHandle>クラスから派生<xref:System.MarshalByRefObject>、これらのクラスは、アプリケーション ドメインの境界を越えてスレッドの活動を同期するために使用することができます。</span><span class="sxs-lookup"><span data-stu-id="26969-117">Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="26969-118">その派生クラスだけでなく、<xref:System.Threading.WaitHandle>クラスには多数の 1 つまでスレッドをブロックする静的メソッドまたは複数の同期オブジェクトがシグナルを受信する.</span><span class="sxs-lookup"><span data-stu-id="26969-118">In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..</span></span> <span data-ttu-id="26969-119">次の設定があります。</span><span class="sxs-lookup"><span data-stu-id="26969-119">These include:</span></span>  
  
-   <span data-ttu-id="26969-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>、これにより、スレッドの待機ハンドルの 1 つの通知、および他の場所ですぐに待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-120"><xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.</span></span>  
  
-   <span data-ttu-id="26969-121"><xref:System.Threading.WaitHandle.WaitAll%2A>、これにより、配列内のすべての待機ハンドルがシグナルを受信するまで待機するスレッド。</span><span class="sxs-lookup"><span data-stu-id="26969-121"><xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.</span></span>  
  
-   <span data-ttu-id="26969-122"><xref:System.Threading.WaitHandle.WaitAny%2A>、これにより、待機ハンドルの指定されたセットのいずれかが通知されてするまで待機するスレッド。</span><span class="sxs-lookup"><span data-stu-id="26969-122"><xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .</span></span>  
  
 <span data-ttu-id="26969-123">これらのメソッドのオーバー ロードは、待機、および他のスレッドの同期コンテキストを使用できるようにするまでの待機に入る前に、同期コンテキストを終了する機会を放棄するためのタイムアウト間隔を提供します。</span><span class="sxs-lookup"><span data-stu-id="26969-123">The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="26969-124">この型は、<xref:System.IDisposable>インターフェイスです。</span><span class="sxs-lookup"><span data-stu-id="26969-124">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="26969-125">型またはその派生型を使用してが完了したら、直接的または間接的にそれを破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="26969-125">When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="26969-126">型の直接 dispose を呼び出す、<xref:System.Threading.WaitHandle.Close%2A>メソッドで、 `try` / `catch`ブロックします。</span><span class="sxs-lookup"><span data-stu-id="26969-126">To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="26969-127">直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(C# の場合) または`Using`(Visual Basic で)。</span><span class="sxs-lookup"><span data-stu-id="26969-127">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="26969-128">詳細についてを参照してください"を使用して、オブジェクトを実装する IDisposable"、<xref:System.IDisposable>インターフェイスに関するトピック。</span><span class="sxs-lookup"><span data-stu-id="26969-128">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="26969-129"><xref:System.Threading.WaitHandle> 実装する、<xref:System.IDisposable.Dispose%2A>パターン。</span><span class="sxs-lookup"><span data-stu-id="26969-129"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="26969-130">参照してください[Dispose パターン](~/docs/standard/design-guidelines/dispose-pattern.md)です。</span><span class="sxs-lookup"><span data-stu-id="26969-130">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="26969-131">派生したときに<xref:System.Threading.WaitHandle>を使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>ネイティブ ハンドルのオペレーティング システム ハンドルを格納するプロパティです。</span><span class="sxs-lookup"><span data-stu-id="26969-131">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="26969-132">保護されたをオーバーライドする必要はありません<xref:System.Threading.WaitHandle.Dispose%2A>メソッド追加のアンマネージ リソースを使用する場合を除き、します。</span><span class="sxs-lookup"><span data-stu-id="26969-132">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-133">次のコード例に示す 2 つのスレッドができる方法はメイン中にバック グラウンド タスク スレッド、静的なを使用して完了するタスクを待機<xref:System.Threading.WaitHandle.WaitAny%2A>と<xref:System.Threading.WaitHandle.WaitAll%2A>のメソッド、<xref:System.Threading.WaitHandle>クラスです。</span><span class="sxs-lookup"><span data-stu-id="26969-133">The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="26969-134">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="26969-134">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WaitHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="26969-135"><see cref="T:System.Threading.WaitHandle" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="26969-135">Initializes a new instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="26969-136">現在の <see cref="T:System.Threading.WaitHandle" /> によって保持されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="26969-136">Releases all resources held by the current <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-137">このメソッドは、パブリックな実装の<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>のメソッド、<xref:System.Threading.WaitHandle>クラスとその派生クラス。</span><span class="sxs-lookup"><span data-stu-id="26969-137">This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method for the <xref:System.Threading.WaitHandle> class and its derived classes.</span></span> <span data-ttu-id="26969-138">呼び出す標準的な実装を提供、`Dispose(Boolean)`を持つオーバー ロード、`true`引数を呼び出し、続いて、<xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-138">It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="26969-139">インスタンスによって保持されているすべてのリソースを解放するには、このメソッドを呼び出す`WaitHandle`または派生クラス。</span><span class="sxs-lookup"><span data-stu-id="26969-139">Call this method to release all resources held by an instance of `WaitHandle` or a derived class.</span></span>  
  
 <span data-ttu-id="26969-140">このメソッドが呼び出されると、現在のインスタンスへの参照は、未定義の動作を発生します。</span><span class="sxs-lookup"><span data-stu-id="26969-140">Once this method is called, references to the current instance cause undefined behavior.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26969-141">常に呼び出す<xref:System.Threading.WaitHandle.Close%2A>または<xref:System.Threading.WaitHandle.Dispose>への参照を解放する前に、<xref:System.Threading.WaitHandle>です。</span><span class="sxs-lookup"><span data-stu-id="26969-141">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="26969-142">それ以外の場合、使用されているリソースは解放されません。</span><span class="sxs-lookup"><span data-stu-id="26969-142">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="26969-143">オーバーライドする必要があります、<see langword="Dispose(Boolean)" />で割り当てられているリソースを解放するメソッドがクラスを派生します。</span><span class="sxs-lookup"><span data-stu-id="26969-143">You should override the <see langword="Dispose(Boolean)" /> method to release resources allocated in derived classes.</span></span></para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26969-144"><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="26969-144">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="26969-145"><see cref="T:System.Threading.WaitHandle" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="26969-145">Releases all resources used by the current instance of the <see cref="T:System.Threading.WaitHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-146">このメソッドは、<xref:System.Threading.WaitHandle.Close%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-146">This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26969-147">常に呼び出す<xref:System.Threading.WaitHandle.Close%2A>または<xref:System.Threading.WaitHandle.Dispose>への参照を解放する前に、<xref:System.Threading.WaitHandle>です。</span><span class="sxs-lookup"><span data-stu-id="26969-147">Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="26969-148">それ以外の場合、使用されているリソースは解放されません。</span><span class="sxs-lookup"><span data-stu-id="26969-148">Otherwise, the resources it is using will not be freed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (explicitDisposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool explicitDisposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <span data-ttu-id="26969-149">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-149"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="26969-150">派生クラスでオーバーライドされると、<see cref="T:System.Threading.WaitHandle" /> によって使用されているアンマネージ リソースを解放し、オプションでマネージ リソースも解放します。</span><span class="sxs-lookup"><span data-stu-id="26969-150">When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:System.Threading.WaitHandle" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-151">このメソッドは、<xref:System.Threading.WaitHandle.Close%2A>と<xref:System.Threading.WaitHandle.Dispose>を持つメソッド、`explicitDisposing`パラメーターに設定`true`です。</span><span class="sxs-lookup"><span data-stu-id="26969-151">This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.</span></span>  <span data-ttu-id="26969-152">ときに、`explicitDisposing`パラメーターは`true`、このメソッドは、すべてのマネージ オブジェクトによって保持されているすべてのリソースを解放します。 この<xref:System.Threading.WaitHandle>オブジェクトが参照します。</span><span class="sxs-lookup"><span data-stu-id="26969-152">When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="26969-153">オーバーライドする必要があります、<see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />で割り当てられているリソースを解放するメソッドがクラスを派生します。</span><span class="sxs-lookup"><span data-stu-id="26969-153">You should override the <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> method to release resources allocated in derived classes.</span></span>  
  
 <span data-ttu-id="26969-154"><see cref="M:System.Threading.WaitHandle.Close" />または<see cref="M:System.Threading.WaitHandle.Dispose" />メソッドは、他のオブジェクトから複数回呼び出すことができますされます。</span><span class="sxs-lookup"><span data-stu-id="26969-154">The <see cref="M:System.Threading.WaitHandle.Close" /> or <see cref="M:System.Threading.WaitHandle.Dispose" /> method can be called multiple times by other objects.</span></span> <span data-ttu-id="26969-155">このメソッドをオーバーライドする場合は、事前に呼び出したで既に破棄されているオブジェクトを参照しないように注意する<see langword="Dispose" />または<see langword="Close" />です。</span><span class="sxs-lookup"><span data-stu-id="26969-155">When overriding this method, be careful not to reference objects that have been previously disposed in an earlier call to <see langword="Dispose" /> or <see langword="Close" />.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); void set(IntPtr value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="26969-156">ネイティブ オペレーティング システム ハンドルを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="26969-156">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="26969-157">ネイティブ オペレーティング システム ハンドルを表す <see langword="IntPtr" />。</span><span class="sxs-lookup"><span data-stu-id="26969-157">An <see langword="IntPtr" /> representing the native operating system handle.</span></span> <span data-ttu-id="26969-158">既定値は <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> フィールドの値です。</span><span class="sxs-lookup"><span data-stu-id="26969-158">The default is the value of the <see cref="F:System.Threading.WaitHandle.InvalidHandle" /> field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-159">新しい値を割り当てる、<xref:System.Threading.WaitHandle.Handle%2A>プロパティは、前のハンドルを終了しません。</span><span class="sxs-lookup"><span data-stu-id="26969-159">Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle.</span></span> <span data-ttu-id="26969-160">漏洩したハンドルになります。</span><span class="sxs-lookup"><span data-stu-id="26969-160">This can result in a leaked handle.</span></span>  
  
 <span data-ttu-id="26969-161">.NET framework version 2.0 以降です。 このプロパティは使用しないでください。使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティ代わりにします。</span><span class="sxs-lookup"><span data-stu-id="26969-161">Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead.</span></span> <span data-ttu-id="26969-162">このプロパティの設定が有効なハンドルもセット、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティに設定すると、<xref:System.Threading.WaitHandle.InvalidHandle>漏洩したハンドルになります。</span><span class="sxs-lookup"><span data-stu-id="26969-162">Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="26969-163">プロパティ値を設定する直前の呼び出し元に対する完全な信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="26969-163">Requires full trust for the immediate caller to set the property value.</span></span> <span data-ttu-id="26969-164">このメンバーは、部分的に信頼されているまたは透過的なコードで設定することはできません。</span><span class="sxs-lookup"><span data-stu-id="26969-164">This member cannot be set by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="26969-165">派生型があります<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />プロパティ値を設定します。</span><span class="sxs-lookup"><span data-stu-id="26969-165">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to set the property value.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly InvalidHandle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: static initonly IntPtr InvalidHandle;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="26969-166">無効なネイティブ オペレーティング システム ハンドルを表します。</span><span class="sxs-lookup"><span data-stu-id="26969-166">Represents an invalid native operating system handle.</span></span> <span data-ttu-id="26969-167">このフィールドは読み取り専用です。</span><span class="sxs-lookup"><span data-stu-id="26969-167">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-168">初期化するために内部的に使用される、<xref:System.Threading.WaitHandle.Handle%2A>プロパティです。</span><span class="sxs-lookup"><span data-stu-id="26969-168">Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para><span data-ttu-id="26969-169">この値を使用するかどうか、<see cref="P:System.Threading.WaitHandle.Handle" />プロパティに有効なネイティブ オペレーティング システム ハンドルが含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-169">You can use this value to determine whether the <see cref="P:System.Threading.WaitHandle.Handle" /> property contains a valid native operating system handle.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberSignature Language="VB.NET" Value="Public Property SafeWaitHandle As SafeWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeWaitHandle ^ SafeWaitHandle { Microsoft::Win32::SafeHandles::SafeWaitHandle ^ get(); void set(Microsoft::Win32::SafeHandles::SafeWaitHandle ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="26969-170">ネイティブ オペレーティング システム ハンドルを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="26969-170">Gets or sets the native operating system handle.</span></span></summary>
        <value><span data-ttu-id="26969-171">ネイティブ オペレーティング システム ハンドルを表す <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="26969-171">A <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> representing the native operating system handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-172">新しい値を代入するときに、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>プロパティ、前のハンドルが閉じときに、以前<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>オブジェクトを収集します。</span><span class="sxs-lookup"><span data-stu-id="26969-172">When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected.</span></span> <span data-ttu-id="26969-173">手動でハンドルを終了しないで、この結果であるため、<xref:System.ObjectDisposedException>ときに、<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>ハンドルを終了しようとしています。</span><span class="sxs-lookup"><span data-stu-id="26969-173">Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.</span></span>  
  
 <span data-ttu-id="26969-174"><xref:System.Threading.WaitHandle> 実装する、<xref:System.IDisposable.Dispose%2A>パターン。</span><span class="sxs-lookup"><span data-stu-id="26969-174"><xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern.</span></span> <span data-ttu-id="26969-175">参照してください[Dispose パターン](~/docs/standard/design-guidelines/dispose-pattern.md)です。</span><span class="sxs-lookup"><span data-stu-id="26969-175">See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md).</span></span> <span data-ttu-id="26969-176">派生したときに<xref:System.Threading.WaitHandle>を使用して、<xref:System.Threading.WaitHandle.SafeWaitHandle%2A>ネイティブ ハンドルのオペレーティング システム ハンドルを格納するプロパティです。</span><span class="sxs-lookup"><span data-stu-id="26969-176">When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle.</span></span> <span data-ttu-id="26969-177">保護されたをオーバーライドする必要はありません<xref:System.Threading.WaitHandle.Dispose%2A>メソッド追加のアンマネージ リソースを使用する場合を除き、します。</span><span class="sxs-lookup"><span data-stu-id="26969-177">You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="26969-178">直前の呼び出し元に対する完全な信頼が必要です。</span><span class="sxs-lookup"><span data-stu-id="26969-178">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="26969-179">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="26969-179">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="26969-180">派生型があります<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />をこのメンバーを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="26969-180">Derived types must have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> to call this member.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="SignalAndWait">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26969-181">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-181">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="26969-182">通知対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="26969-182">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="26969-183">待機対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="26969-183">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <summary><span data-ttu-id="26969-184">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-184">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-185">通知と待機の両方が正常に完了した場合は <see langword="true" />。待機が完了しない場合、メソッドから制御は戻りません。</span><span class="sxs-lookup"><span data-stu-id="26969-185"><see langword="true" /> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-186">この操作はアトミックは保証されません。</span><span class="sxs-lookup"><span data-stu-id="26969-186">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="26969-187">現在のスレッド信号後`toSignal`まで待機する前に、 `toWaitOn`、別のプロセッサで実行されているスレッドを示す可能性があります`toWaitOn`待機またはします。</span><span class="sxs-lookup"><span data-stu-id="26969-187">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-188">次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>メイン スレッドをブロックされたスレッドを通知し、スレッドがタスクを完了するまで待機を許可するメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="26969-188">The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</span></span>  
  
 <span data-ttu-id="26969-189">例では、5 つのスレッドを開始をブロックすることができます、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>フラグと、ユーザーが ENTER キーを押したし、リリースの 1 つのスレッド時刻。</span><span class="sxs-lookup"><span data-stu-id="26969-189">The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> flag, and then releases one thread each time the user presses the ENTER key.</span></span> <span data-ttu-id="26969-190">例は、別の 5 つのスレッド キューに配置し、すべてを使用して、解放、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>フラグ。</span><span class="sxs-lookup"><span data-stu-id="26969-190">The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> flag.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26969-191"><paramref name="toSignal" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="26969-191"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-192">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-192">-or-</span></span>  
  
 <span data-ttu-id="26969-193"><paramref name="toWaitOn" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="26969-193"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-194">メソッドは <see cref="T:System.STAThreadAttribute" /> を持つスレッドで呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="26969-194">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="26969-195">このメソッドは、Windows 98 および Windows Millennium Edition ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="26969-195">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="26969-196"><paramref name="toSignal" /> はセマフォで、カウントは既に最大値になっています。</span><span class="sxs-lookup"><span data-stu-id="26969-196"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-197">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-197">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-198">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-198">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="26969-199">通知対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="26969-199">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="26969-200">待機対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="26969-200">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="26969-201">待機する間隔を表す整数。</span><span class="sxs-lookup"><span data-stu-id="26969-201">An integer that represents the interval to wait.</span></span> <span data-ttu-id="26969-202">この値が <see cref="F:System.Threading.Timeout.Infinite" />、つまり -1 の場合、待機は無期限となります。</span><span class="sxs-lookup"><span data-stu-id="26969-202">If the value is <see cref="F:System.Threading.Timeout.Infinite" />, that is, -1, the wait is infinite.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="26969-203">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-203"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="26969-204">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として 32 ビット符号付き整数を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="26969-204">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-205">通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-205"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-206">この操作はアトミックは保証されません。</span><span class="sxs-lookup"><span data-stu-id="26969-206">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="26969-207">現在のスレッド信号後`toSignal`まで待機する前に、 `toWaitOn`、別のプロセッサで実行されているスレッドを示す可能性があります`toWaitOn`待機またはします。</span><span class="sxs-lookup"><span data-stu-id="26969-207">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="26969-208">場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-208">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-209">テストの状態、`toWaitOn`を直ちに返します。</span><span class="sxs-lookup"><span data-stu-id="26969-209">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="26969-210">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="26969-210">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="26969-211">`exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="26969-211">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="26969-212">派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。</span><span class="sxs-lookup"><span data-stu-id="26969-212">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="26969-213">派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="26969-213">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="26969-214">既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-214">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="26969-215">スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-215">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="26969-216">これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-216">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="26969-217">その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。</span><span class="sxs-lookup"><span data-stu-id="26969-217">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="26969-218">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-218">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="26969-219">ときに、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="26969-219">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26969-220"><paramref name="toSignal" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="26969-220"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-221">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-221">-or-</span></span>  
  
 <span data-ttu-id="26969-222"><paramref name="toWaitOn" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="26969-222"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-223">メソッドは <see cref="T:System.STAThreadAttribute" /> を持つスレッドで呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="26969-223">The method is called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="26969-224">このメソッドは、Windows 98 および Windows Millennium Edition ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="26969-224">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-225">カウントの最大値を超えるため、<see cref="T:System.Threading.WaitHandle" /> はシグナル状態にはできません。</span><span class="sxs-lookup"><span data-stu-id="26969-225">The <see cref="T:System.Threading.WaitHandle" /> cannot be signaled because it would exceed its maximum count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-226"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-226"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-227">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-227">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-228">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-228">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SignalAndWait (toSignal As WaitHandle, toWaitOn As WaitHandle, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SignalAndWait(System::Threading::WaitHandle ^ toSignal, System::Threading::WaitHandle ^ toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal"><span data-ttu-id="26969-229">通知対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="26969-229">The <see cref="T:System.Threading.WaitHandle" /> to signal.</span></span></param>
        <param name="toWaitOn"><span data-ttu-id="26969-230">待機対象の <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="26969-230">The <see cref="T:System.Threading.WaitHandle" /> to wait on.</span></span></param>
        <param name="timeout"><span data-ttu-id="26969-231">待機間隔を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="26969-231">A <see cref="T:System.TimeSpan" /> that represents the interval to wait.</span></span> <span data-ttu-id="26969-232">この値が -1 の場合、待機は無期限となります。</span><span class="sxs-lookup"><span data-stu-id="26969-232">If the value is -1, the wait is infinite.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="26969-233">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-233"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="26969-234">1 つの <see cref="T:System.Threading.WaitHandle" /> を通知し、別のハンドルを待機します。タイムアウト間隔として <see cref="T:System.TimeSpan" /> を指定し、待機に入る前にコンテキストの同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="26969-234">Signals one <see cref="T:System.Threading.WaitHandle" /> and waits on another, specifying the time-out interval as a <see cref="T:System.TimeSpan" /> and specifying whether to exit the synchronization domain for the context before entering the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-235">通知および待機の両方が正常に完了した場合は <see langword="true" />。通知は完了したが、待機がタイムアウトになった場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-235"><see langword="true" /> if both the signal and the wait completed successfully, or <see langword="false" /> if the signal completed but the wait timed out.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-236">この操作はアトミックは保証されません。</span><span class="sxs-lookup"><span data-stu-id="26969-236">This operation is not guaranteed to be atomic.</span></span> <span data-ttu-id="26969-237">現在のスレッド信号後`toSignal`まで待機する前に、 `toWaitOn`、別のプロセッサで実行されているスレッドを示す可能性があります`toWaitOn`待機またはします。</span><span class="sxs-lookup"><span data-stu-id="26969-237">After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.</span></span>  
  
 <span data-ttu-id="26969-238">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="26969-238">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="26969-239">場合`timeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-239">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-240">テストの状態、`toWaitOn`を直ちに返します。</span><span class="sxs-lookup"><span data-stu-id="26969-240">It tests the state of the `toWaitOn` and returns immediately.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="26969-241">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="26969-241">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="26969-242">`exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="26969-242">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="26969-243">派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。</span><span class="sxs-lookup"><span data-stu-id="26969-243">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="26969-244">派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="26969-244">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="26969-245">既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-245">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span> <span data-ttu-id="26969-246">スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-246">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.</span></span>  
  
 <span data-ttu-id="26969-247">これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-247">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="26969-248">その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。</span><span class="sxs-lookup"><span data-stu-id="26969-248">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="26969-249">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-249">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="26969-250">ときに、<xref:System.Threading.WaitHandle.SignalAndWait%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="26969-250">When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="26969-251"><paramref name="toSignal" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="26969-251"><paramref name="toSignal" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-252">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-252">-or-</span></span>  
  
 <span data-ttu-id="26969-253"><paramref name="toWaitOn" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="26969-253"><paramref name="toWaitOn" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-254">メソッドは <see cref="T:System.STAThreadAttribute" /> を持つスレッドで呼び出されました。</span><span class="sxs-lookup"><span data-stu-id="26969-254">The method was called on a thread that has <see cref="T:System.STAThreadAttribute" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="26969-255">このメソッドは、Windows 98 および Windows Millennium Edition ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="26969-255">This method is not supported on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="26969-256"><paramref name="toSignal" /> はセマフォで、カウントは既に最大値になっています。</span><span class="sxs-lookup"><span data-stu-id="26969-256"><paramref name="toSignal" /> is a semaphore, and it already has a full count.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-257"><paramref name="timeout" /> は、-1 以外の負のミリ秒値となります。</span><span class="sxs-lookup"><span data-stu-id="26969-257"><paramref name="timeout" /> evaluates to a negative number of milliseconds other than -1.</span></span>  
  
 <span data-ttu-id="26969-258">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-258">-or-</span></span>  
  
 <span data-ttu-id="26969-259"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="26969-259"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-260">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-260">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-261">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-261">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26969-262">指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-262">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="26969-263">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="26969-263">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="26969-264">この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="26969-264">This array cannot contain multiple references to the same object.</span></span></param>
        <summary><span data-ttu-id="26969-265">指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-265">Waits for all the elements in the specified array to receive a signal.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-266"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />。それ以外の場合は、待機を続けます。</span><span class="sxs-lookup"><span data-stu-id="26969-266"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise the method never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-267"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="26969-267"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="26969-268">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="26969-268">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="26969-269">放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-269">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="26969-270">システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-270">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="26969-271">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-271">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="26969-272"><xref:System.Threading.WaitHandle.WaitAll%2A>すべてのハンドルがシグナルを受け取るメソッドが返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-272">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled.</span></span> <span data-ttu-id="26969-273">一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="26969-273">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="26969-274">配列に重複が含まれている場合、呼び出しは、<xref:System.DuplicateWaitObjectException>です。</span><span class="sxs-lookup"><span data-stu-id="26969-274">If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26969-275"><xref:System.Threading.WaitHandle.WaitAll%2A>を持つスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-275">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="26969-276">呼び出すことと同じではこのメソッドのオーバー ロードを呼び出して、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定する (または<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) の`millisecondsTimeout`と`true`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="26969-276">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-277">次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループへの書き込みをする方法を示します。</span><span class="sxs-lookup"><span data-stu-id="26969-277">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="26969-278">個々 の書き込み操作は、作業項目と信号キューに登録が完了するとします。</span><span class="sxs-lookup"><span data-stu-id="26969-278">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="26969-279">メイン スレッドは、すべての項目からの通知を待機しして終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-279">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="26969-280"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-280">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span> <span data-ttu-id="26969-281">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-281">-or-</span></span>  
  
 <span data-ttu-id="26969-282"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-282">One or more of the objects in the <paramref name="waitHandles" /> array are <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-283">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-283">-or-</span></span>  
  
 <span data-ttu-id="26969-284"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</span><span class="sxs-lookup"><span data-stu-id="26969-284"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="26969-285">[Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="26969-285">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="26969-286"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-286">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-287"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="26969-287">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="26969-288">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-288">-or-</span></span>  
  
 <span data-ttu-id="26969-289"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-289">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="26969-290"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</span><span class="sxs-lookup"><span data-stu-id="26969-290"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-291">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-291">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-292">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-292">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-293"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-293">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="26969-294">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="26969-294">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="26969-295">この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="26969-295">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="26969-296">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="26969-296">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="26969-297"><see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-297">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-298"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は
<see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-298"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-299">場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-299">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-300">これにより、待機ハンドルの状態をテストされ、すぐに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-300">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-301"><xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了する、つまりすべてのハンドルがシグナルを受け取るか、またはタイムアウトが発生した場合に、メソッドが返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-301">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="26969-302">一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="26969-302">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="26969-303">配列に重複がある場合、呼び出しは、<xref:System.DuplicateWaitObjectException>です。</span><span class="sxs-lookup"><span data-stu-id="26969-303">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26969-304"><xref:System.Threading.WaitHandle.WaitAll%2A>を持つスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-304">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="26969-305">このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="26969-305">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="26969-306"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-306">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-307">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-307">-or-</span></span>  
  
 <span data-ttu-id="26969-308"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-308">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-309">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-309">-or-</span></span>  
  
 <span data-ttu-id="26969-310"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="26969-310"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="26969-311">[Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="26969-311">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="26969-312"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-312">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-313"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="26969-313">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="26969-314">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-314">-or-</span></span>  
  
 <span data-ttu-id="26969-315"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-315">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-316"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-316"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-317">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-317">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-318">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-318">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-319"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-319">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="26969-320">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="26969-320">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="26969-321">この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="26969-321">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="26969-322">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="26969-322">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="26969-323"><see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、指定した配列内のすべての要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-323">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-324"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は
<see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-324"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-325">場合`timeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-325">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-326">これにより、待機ハンドルの状態をテストされ、すぐに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-326">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-327"><xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了すると、すべてのハンドルがシグナル状態になることを意味するか、タイムアウトが発生したときに、メソッドが返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-327">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="26969-328">一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="26969-328">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="26969-329">配列に重複が含まれている場合、呼び出しは失敗します。</span><span class="sxs-lookup"><span data-stu-id="26969-329">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26969-330"><xref:System.Threading.WaitHandle.WaitAll%2A>を持つスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-330">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="26969-331">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="26969-331">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="26969-332">このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="26969-332">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="26969-333"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-333">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-334">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-334">-or-</span></span>  
  
 <span data-ttu-id="26969-335"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-335">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-336">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-336">-or-</span></span>  
  
 <span data-ttu-id="26969-337"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="26969-337"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 <span data-ttu-id="26969-338">[Windows ストア アプリ用 .NET](http://go.microsoft.com/fwlink/?LinkID=247912) または[ポータブル クラス ライブラリ](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)では、基本クラスの例外である <see cref="T:System.ArgumentException" /> を代わりにキャッチします。</span><span class="sxs-lookup"><span data-stu-id="26969-338">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.ArgumentException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="26969-339"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-339">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-340"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="26969-340">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="26969-341">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-341">-or-</span></span>  
  
 <span data-ttu-id="26969-342"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-342">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-343"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-343"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="26969-344">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-344">-or-</span></span>  
  
 <span data-ttu-id="26969-345"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="26969-345"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-346">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-346">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-347">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-347">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-348"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-348">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="26969-349">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="26969-349">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="26969-350">この配列には、同一オブジェクトに対する複数の参照 (重複) を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="26969-350">This array cannot contain multiple references to the same object (duplicates).</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="26969-351">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="26969-351">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="26969-352">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-352"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="26969-353">指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.Int32" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="26969-353">Waits for all the elements in the specified array to receive a signal, using an <see cref="T:System.Int32" /> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-354"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は
<see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-354"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-355">場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-355">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-356">これにより、待機ハンドルの状態をテストされ、すぐに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-356">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-357"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="26969-357"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="26969-358">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="26969-358">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="26969-359">放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-359">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="26969-360">システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-360">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="26969-361">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-361">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="26969-362"><xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了する、つまりすべてのハンドルがシグナルを受け取るか、またはタイムアウトが発生した場合に、メソッドが返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-362">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.</span></span> <span data-ttu-id="26969-363">一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="26969-363">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="26969-364">配列に重複がある場合、呼び出しは、<xref:System.DuplicateWaitObjectException>です。</span><span class="sxs-lookup"><span data-stu-id="26969-364">If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26969-365"><xref:System.Threading.WaitHandle.WaitAll%2A>を持つスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-365">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="26969-366">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="26969-366">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="26969-367">`exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="26969-367">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="26969-368">派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。</span><span class="sxs-lookup"><span data-stu-id="26969-368">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="26969-369">派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="26969-369">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="26969-370">既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-370">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="26969-371">スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-371">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="26969-372">これを利用するときに、コンテキスト バインド クラスには、<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>属性。</span><span class="sxs-lookup"><span data-stu-id="26969-372">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute.</span></span> <span data-ttu-id="26969-373">その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。</span><span class="sxs-lookup"><span data-stu-id="26969-373">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="26969-374">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-374">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="26969-375">ときに、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="26969-375">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-376">次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループへの書き込みをする方法を示します。</span><span class="sxs-lookup"><span data-stu-id="26969-376">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="26969-377">個々 の書き込み操作は、作業項目と信号キューに登録が完了するとします。</span><span class="sxs-lookup"><span data-stu-id="26969-377">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="26969-378">メイン スレッドは、すべての項目からの通知を待機しして終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-378">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="26969-379"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-379">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-380">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-380">-or-</span></span>  
  
 <span data-ttu-id="26969-381"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-381">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-382">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-382">-or-</span></span>  
  
 <span data-ttu-id="26969-383"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</span><span class="sxs-lookup"><span data-stu-id="26969-383"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="26969-384"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-384">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-385"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="26969-385">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="26969-386">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-386">-or-</span></span>  
  
 <span data-ttu-id="26969-387"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-387">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="26969-388"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</span><span class="sxs-lookup"><span data-stu-id="26969-388"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-389"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-389"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-390">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-390">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-391">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-391">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-392"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-392">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="26969-393">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="26969-393">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span> <span data-ttu-id="26969-394">この配列には、同一オブジェクトに対する複数の参照を含めることはできません。</span><span class="sxs-lookup"><span data-stu-id="26969-394">This array cannot contain multiple references to the same object.</span></span></param>
        <param name="timeout"><span data-ttu-id="26969-395">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="26969-395">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds, to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="26969-396">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-396"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="26969-397">指定した配列内のすべての要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> 値を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="26969-397">Waits for all the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-398"><paramref name="waitHandles" /> 内のすべての要素がシグナルを受信した場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-398"><see langword="true" /> when every element in <paramref name="waitHandles" /> has received a signal; otherwise <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-399">場合`timeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-399">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-400">これにより、待機ハンドルの状態をテストされ、すぐに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-400">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-401"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="26969-401"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="26969-402">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="26969-402">In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="26969-403">放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-403">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="26969-404">システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-404">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="26969-405">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-405">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="26969-406"><xref:System.Threading.WaitHandle.WaitAll%2A>待機が終了すると、すべてのハンドルがシグナル状態になることを意味するか、タイムアウトが発生したときに、メソッドが返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-406">The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.</span></span> <span data-ttu-id="26969-407">一部の実装では、64 を超えるハンドルが渡された場合に、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="26969-407">On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span> <span data-ttu-id="26969-408">配列に重複が含まれている場合、呼び出しは失敗します。</span><span class="sxs-lookup"><span data-stu-id="26969-408">If the array contains duplicates, the call will fail.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26969-409"><xref:System.Threading.WaitHandle.WaitAll%2A>を持つスレッドでメソッドがサポートされていません<xref:System.STAThreadAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-409">The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.</span></span>  
  
 <span data-ttu-id="26969-410">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="26969-410">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="26969-411">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="26969-411">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="26969-412">`exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="26969-412">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="26969-413">派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。</span><span class="sxs-lookup"><span data-stu-id="26969-413">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="26969-414">派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="26969-414">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="26969-415">既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-415">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method.</span></span> <span data-ttu-id="26969-416">呼び出しの後に元の既定以外のコンテキストを返します、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-416">It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.</span></span>  
  
 <span data-ttu-id="26969-417">これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-417">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="26969-418">その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。</span><span class="sxs-lookup"><span data-stu-id="26969-418">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="26969-419">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-419">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="26969-420">ときに、<xref:System.Threading.WaitHandle.WaitAll%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="26969-420">When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-421">次のコード例では、スレッド プールを使用して非同期的に作成し、ファイルのグループへの書き込みをする方法を示します。</span><span class="sxs-lookup"><span data-stu-id="26969-421">The following code example shows how to use the thread pool to asynchronously create and write to a group of files.</span></span> <span data-ttu-id="26969-422">個々 の書き込み操作は、作業項目と信号キューに登録が完了するとします。</span><span class="sxs-lookup"><span data-stu-id="26969-422">Each write operation is queued as a work item and signals when it is finished.</span></span> <span data-ttu-id="26969-423">メイン スレッドは、すべての項目からの通知を待機しして終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-423">The main thread waits for all the items to signal and then exits.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="26969-424"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-424">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-425">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-425">-or-</span></span>  
  
 <span data-ttu-id="26969-426"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-426">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-427">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-427">-or-</span></span>  
  
 <span data-ttu-id="26969-428"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 2.0 以降です。</span><span class="sxs-lookup"><span data-stu-id="26969-428"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.DuplicateWaitObjectException"><span data-ttu-id="26969-429"><paramref name="waitHandles" /> 配列に、重複する要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-429">The <paramref name="waitHandles" /> array contains elements that are duplicates.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-430"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="26969-430">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span>  
  
 <span data-ttu-id="26969-431">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-431">-or-</span></span>  
  
 <span data-ttu-id="26969-432"><see cref="T:System.STAThreadAttribute" /> 属性は、現在のスレッドのスレッド プロシージャに適用されており、<paramref name="waitHandles" /> には複数の要素が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-432">The <see cref="T:System.STAThreadAttribute" /> attribute is applied to the thread procedure for the current thread, and <paramref name="waitHandles" /> contains more than one element.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="26969-433"><paramref name="waitHandles" /> は要素を持たない配列で、.NET Framework のバージョンが 1.0 または 1.1 です。</span><span class="sxs-lookup"><span data-stu-id="26969-433"><paramref name="waitHandles" /> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-434"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-434"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="26969-435">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-435">-or-</span></span>  
  
 <span data-ttu-id="26969-436"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="26969-436"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-437">スレッドがミューテックスを解放せずに終了したため、待機が終了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-437">The wait terminated because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-438">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-438">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-439"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-439">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26969-440">指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-440">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="26969-441">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="26969-441">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <summary><span data-ttu-id="26969-442">指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-442">Waits for any of the elements in the specified array to receive a signal.</span></span></summary>
        <returns><span data-ttu-id="26969-443">待機を実行するオブジェクトの配列インデックス。</span><span class="sxs-lookup"><span data-stu-id="26969-443">The array index of the object that satisfied the wait.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-444"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="26969-444"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="26969-445">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスを破棄するために、待機が終了した場合。</span><span class="sxs-lookup"><span data-stu-id="26969-445">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="26969-446">放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-446">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="26969-447">システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-447">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="26969-448">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-448">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="26969-449"><xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。</span><span class="sxs-lookup"><span data-stu-id="26969-449">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="26969-450">場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-450">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26969-451">.NET Framework バージョン 2.0 では、スレッドが終了したり、明示的に解放せず中止したりする場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`0 ではなく 128 です。</span><span class="sxs-lookup"><span data-stu-id="26969-451">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="26969-452">このメソッドは、いずれかのハンドルがシグナルを受け取るを返します。</span><span class="sxs-lookup"><span data-stu-id="26969-452">This method returns when any handle is signaled.</span></span> <span data-ttu-id="26969-453">1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。</span><span class="sxs-lookup"><span data-stu-id="26969-453">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="26969-454">一部の実装では、64 のハンドルが渡される、複数の場合で、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="26969-454">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="26969-455">呼び出すことと同じではこのメソッドのオーバー ロードを呼び出して、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定する (または<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) の`millisecondsTimeout`と`true`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="26969-455">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) for `millisecondsTimeout` and `true` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-456">次のコード例を呼び出すことを示しています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-456">The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span>  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="26969-457"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-457">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-458">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-458">-or-</span></span>  
  
 <span data-ttu-id="26969-459"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-459">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-460"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="26969-460">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="26969-461">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="26969-461"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-462">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-462">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-463">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-463">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26969-464">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="26969-464"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-465"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-465">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="26969-466">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="26969-466">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="26969-467">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="26969-467">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="26969-468">32 ビット符号付き整数を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-468">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="26969-469">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="26969-469">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-470">場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-470">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-471">これにより、待機ハンドルの状態をテストされ、すぐに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-471">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-472"><xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。</span><span class="sxs-lookup"><span data-stu-id="26969-472">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="26969-473">場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-473">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="26969-474">このメソッドは、待機が終了すると、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに返します。</span><span class="sxs-lookup"><span data-stu-id="26969-474">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="26969-475">1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。</span><span class="sxs-lookup"><span data-stu-id="26969-475">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="26969-476">一部の実装では、64 のハンドルが渡される、複数の場合で、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="26969-476">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="26969-477">このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="26969-477">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="26969-478"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-478">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-479">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-479">-or-</span></span>  
  
 <span data-ttu-id="26969-480"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-480">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-481"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="26969-481">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-482"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-482"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-483">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-483">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-484">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-484">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26969-485"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="26969-485"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-486"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-486">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="26969-487">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="26969-487">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="26969-488">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="26969-488">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="26969-489"><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-489">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns><span data-ttu-id="26969-490">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="26969-490">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-491">場合`timeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-491">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-492">これにより、待機ハンドルの状態をテストされ、すぐに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-492">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-493"><xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。</span><span class="sxs-lookup"><span data-stu-id="26969-493">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="26969-494">場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-494">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
 <span data-ttu-id="26969-495">このメソッドは、待機が終了すると、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに返します。</span><span class="sxs-lookup"><span data-stu-id="26969-495">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="26969-496">1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。</span><span class="sxs-lookup"><span data-stu-id="26969-496">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="26969-497">一部の実装では、64 のハンドルが渡される、複数の場合で、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="26969-497">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="26969-498">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="26969-498">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="26969-499">このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="26969-499">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="26969-500"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-500">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-501">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-501">-or-</span></span>  
  
 <span data-ttu-id="26969-502"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-502">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-503"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="26969-503">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-504"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-504"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="26969-505">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-505">-or-</span></span>  
  
 <span data-ttu-id="26969-506"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="26969-506"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-507">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-507">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-508">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-508">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26969-509"><paramref name="waitHandles" /> は、要素を持たない配列です。</span><span class="sxs-lookup"><span data-stu-id="26969-509"><paramref name="waitHandles" /> is an array with no elements.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-510"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-510">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), millisecondsTimeout As Integer, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="26969-511">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="26969-511">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="26969-512">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="26969-512">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="26969-513">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-513"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="26969-514">32 ビットの符号付き整数を使用して時間間隔を指定し、待機する前に同期ドメインを終了するかどうかを指定して、指定した配列内のいずれかの要素がシグナルを受信するまで待機します。</span><span class="sxs-lookup"><span data-stu-id="26969-514">Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="26969-515">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="millisecondsTimeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="26969-515">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="millisecondsTimeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-516">場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-516">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-517">これにより、待機ハンドルの状態をテストされ、すぐに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-517">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-518"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="26969-518"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="26969-519">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスを破棄するために、待機が終了した場合。</span><span class="sxs-lookup"><span data-stu-id="26969-519">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="26969-520">放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-520">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="26969-521">システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-521">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="26969-522">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-522">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="26969-523"><xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。</span><span class="sxs-lookup"><span data-stu-id="26969-523">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="26969-524">場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-524">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26969-525">.NET Framework バージョン 2.0 では、スレッドが終了したり、明示的に解放せず中止したりする場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`0 ではなく 128 です。</span><span class="sxs-lookup"><span data-stu-id="26969-525">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="26969-526">このメソッドは、待機が終了すると、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに返します。</span><span class="sxs-lookup"><span data-stu-id="26969-526">This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.</span></span> <span data-ttu-id="26969-527">1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。</span><span class="sxs-lookup"><span data-stu-id="26969-527">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="26969-528">一部の実装では、64 のハンドルが渡される、複数の場合で、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="26969-528">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="26969-529">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="26969-529">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="26969-530">`exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="26969-530">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="26969-531">派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。</span><span class="sxs-lookup"><span data-stu-id="26969-531">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="26969-532">派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="26969-532">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="26969-533">既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-533">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="26969-534">スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-534">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="26969-535">これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-535">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="26969-536">その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。</span><span class="sxs-lookup"><span data-stu-id="26969-536">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="26969-537">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-537">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="26969-538">ときに、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="26969-538">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-539">次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="26969-539">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="26969-540">容量に関する考慮事項については、各ディスクのルート ディレクトリだけが検索されます。</span><span class="sxs-lookup"><span data-stu-id="26969-540">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="26969-541"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-541">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-542">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-542">-or-</span></span>  
  
 <span data-ttu-id="26969-543"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-543">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-544"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="26969-544">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="26969-545">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="26969-545"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-546"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-546"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-547">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-547">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-548">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-548">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26969-549">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="26969-549"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-550"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-550">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (waitHandles As WaitHandle(), timeout As TimeSpan, exitContext As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::WaitHandle ^&gt; ^ waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles"><span data-ttu-id="26969-551">現在のインスタンスが待機する対象のオブジェクトを格納している <see langword="WaitHandle" /> 配列。</span><span class="sxs-lookup"><span data-stu-id="26969-551">A <see langword="WaitHandle" /> array containing the objects for which the current instance will wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="26969-552">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="26969-552">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="26969-553">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-553"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="26969-554">指定した配列内のいずれかの要素がシグナルを受信するまで待機します。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="26969-554">Waits for any of the elements in the specified array to receive a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns><span data-ttu-id="26969-555">待機を実行したオブジェクトの配列インデックス。または、待機を実行したオブジェクトがなく <paramref name="timeout" /> に等しい時間間隔が経過した場合は <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> となります。</span><span class="sxs-lookup"><span data-stu-id="26969-555">The array index of the object that satisfied the wait, or <see cref="F:System.Threading.WaitHandle.WaitTimeout" /> if no object satisfied the wait and a time interval equivalent to <paramref name="timeout" /> has passed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-556">場合`timeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-556">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-557">これにより、待機ハンドルの状態をテストされ、すぐに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-557">It tests the state of the wait handles and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-558"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="26969-558"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="26969-559">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを返します。`true`ミュー テックスを破棄するために、待機が終了した場合。</span><span class="sxs-lookup"><span data-stu-id="26969-559">In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned.</span></span> <span data-ttu-id="26969-560">放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-560">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="26969-561">システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-561">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="26969-562">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-562">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="26969-563"><xref:System.Threading.WaitHandle.WaitAny%2A>メソッドがスローされます、<xref:System.Threading.AbandonedMutexException>放棄されたミュー テックスのため、待機が完了したときにのみです。</span><span class="sxs-lookup"><span data-stu-id="26969-563">The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex.</span></span> <span data-ttu-id="26969-564">場合`waitHandles`放棄されたミュー テックスよりも低いインデックス番号を持つリリースされたミュー テックスが含まれています、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが正常に完了して、例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-564">If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26969-565">.NET Framework バージョン 2.0 では、スレッドが終了したり、明示的に解放せず中止したりする場合よりも前のバージョンで、 <xref:System.Threading.Mutex>、および`Mutex`で 0 (ゼロ) のインデックス位置にある、`WaitAny`別のスレッドによって返されるインデックスで配列`WaitAny`0 ではなく 128 です。</span><span class="sxs-lookup"><span data-stu-id="26969-565">In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.</span></span>  
  
 <span data-ttu-id="26969-566">このメソッドは、待機が終了すると、ハンドルのいずれかが通知されるとき、またはタイムアウトが発生したときに返します。</span><span class="sxs-lookup"><span data-stu-id="26969-566">This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.</span></span> <span data-ttu-id="26969-567">1 つ以上のオブジェクトは、呼び出し時にシグナル状態になります、戻り値がシグナル状態のすべてのオブジェクトの最小のインデックス値を含むシグナル状態のオブジェクトの配列インデックス。</span><span class="sxs-lookup"><span data-stu-id="26969-567">If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.</span></span> <span data-ttu-id="26969-568">一部の実装では、64 のハンドルが渡される、複数の場合で、<xref:System.NotSupportedException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="26969-568">On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.</span></span>  
  
 <span data-ttu-id="26969-569">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="26969-569">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="26969-570">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="26969-570">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="26969-571">`exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="26969-571">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="26969-572">派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。</span><span class="sxs-lookup"><span data-stu-id="26969-572">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="26969-573">派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="26969-573">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="26969-574">既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-574">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method.</span></span> <span data-ttu-id="26969-575">スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-575">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.</span></span>  
  
 <span data-ttu-id="26969-576">これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-576">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="26969-577">その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。</span><span class="sxs-lookup"><span data-stu-id="26969-577">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="26969-578">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-578">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="26969-579">ときに、<xref:System.Threading.WaitHandle.WaitAny%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="26969-579">When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-580">次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="26969-580">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="26969-581">容量に関する考慮事項については、各ディスクのルート ディレクトリだけが検索されます。</span><span class="sxs-lookup"><span data-stu-id="26969-581">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="26969-582"><paramref name="waitHandles" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-582">The <paramref name="waitHandles" /> parameter is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="26969-583">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-583">-or-</span></span>  
  
 <span data-ttu-id="26969-584"><paramref name="waitHandles" /> 配列内の 1 つ以上のオブジェクトが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="26969-584">One or more of the objects in the <paramref name="waitHandles" /> array is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="26969-585"><paramref name="waitHandles" /> のオブジェクトの数が、システムで許可されている範囲を超えています。</span><span class="sxs-lookup"><span data-stu-id="26969-585">The number of objects in <paramref name="waitHandles" /> is greater than the system permits.</span></span></exception>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="26969-586">.NET Framework のバージョンが 1.0 または 1.1 であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="26969-586"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-587"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-587"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="26969-588">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-588">-or-</span></span>  
  
 <span data-ttu-id="26969-589"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="26969-589"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-590">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-590">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-591">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-591">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="26969-592">.NET Framework のバージョンが 2.0 以降であるにもかかわらず、<paramref name="waitHandles" /> が要素のない配列です。</span><span class="sxs-lookup"><span data-stu-id="26969-592"><paramref name="waitHandles" /> is an array with no elements, and the .NET Framework version is 2.0 or later.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-593"><paramref name="waitHandles" /> 配列には、別のアプリケーション ドメインの<see cref="T:System.Threading.WaitHandle" /> の透過プロキシが含まれます。</span><span class="sxs-lookup"><span data-stu-id="26969-593">The <paramref name="waitHandles" /> array contains a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitOne">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="26969-594">現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="26969-594">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="26969-595">現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受け取るまで、現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="26969-595">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-596">現在のインスタンスがシグナルを受け取った場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="26969-596"><see langword="true" /> if the current instance receives a signal.</span></span> <span data-ttu-id="26969-597">現在のインスタンスがシグナルを受け取らない場合は、<see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> はシグナルを受け取るまで待機を続けます。</span><span class="sxs-lookup"><span data-stu-id="26969-597">If the current instance is never signaled, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> never returns.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-598"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="26969-598"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="26969-599">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="26969-599">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="26969-600">放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-600">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="26969-601">システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-601">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="26969-602">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-602">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="26969-603">このメソッドは、現在のインスタンスまで、無期限にブロックの呼び出し元がシグナルを受信します。</span><span class="sxs-lookup"><span data-stu-id="26969-603">The caller of this method blocks indefinitely until the current instance receives a signal.</span></span> <span data-ttu-id="26969-604">このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。</span><span class="sxs-lookup"><span data-stu-id="26969-604">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="26969-605">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="26969-605">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="26969-606">呼び出すことと同じではこのメソッドのオーバー ロードを呼び出して、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは、-1 を指定するまたは<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>、最初のパラメーターと`false`2 番目のパラメーターです。</span><span class="sxs-lookup"><span data-stu-id="26969-606">Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the first parameter and `false` for the second parameter.</span></span>  
  
 <span data-ttu-id="26969-607">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="26969-607">Override this method to customize the behavior of derived classes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-608">次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機するときに終了してから、プロセスの状態を保持する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="26969-608">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="26969-609">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="26969-609">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-610">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-610">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-611">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-611">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-612">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="26969-612">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="26969-613">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="26969-613">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="26969-614">32 ビット符号付き整数を使用して時間間隔をミリ秒単位で指定し、現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで、現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="26969-614">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-615">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-615"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-616">場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-616">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-617">待機ハンドルの状態をテストし、直ちに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-617">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-618">このメソッドはブロック、現在のインスタンス シグナルを受け取るか、タイムアウトまでの呼び出し元が発生します。</span><span class="sxs-lookup"><span data-stu-id="26969-618">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="26969-619">このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。</span><span class="sxs-lookup"><span data-stu-id="26969-619">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="26969-620">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="26969-620">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="26969-621">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="26969-621">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="26969-622">このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="26969-622">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-623">次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機するときに終了してから、プロセスの状態を保持する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="26969-623">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="26969-624">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="26969-624">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-625"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-625"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-626">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-626">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-627">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-627">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-628">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="26969-628">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="26969-629">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="26969-629">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="26969-630"><see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。</span><span class="sxs-lookup"><span data-stu-id="26969-630">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-631">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-631"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-632">場合`timeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-632">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-633">待機ハンドルの状態をテストし、直ちに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-633">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-634">このメソッドはブロック、現在のインスタンス シグナルを受け取るか、タイムアウトまでの呼び出し元が発生します。</span><span class="sxs-lookup"><span data-stu-id="26969-634">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="26969-635">このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。</span><span class="sxs-lookup"><span data-stu-id="26969-635">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="26969-636">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="26969-636">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="26969-637">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="26969-637">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="26969-638">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="26969-638">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="26969-639">このメソッドのオーバー ロードを呼び出すことは、呼び出し元と同じ、<xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29>オーバー ロードを指定して`false`の`exitContext`します。</span><span class="sxs-lookup"><span data-stu-id="26969-639">Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="26969-640">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="26969-640">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-641"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-641"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="26969-642">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-642">-or-</span></span>  
  
 <span data-ttu-id="26969-643"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="26969-643"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-644">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-644">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-645">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-645">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-646">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="26969-646">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(int millisecondsTimeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="26969-647">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="26969-647">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="26969-648">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-648"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="26969-649">現在の <see cref="T:System.Threading.WaitHandle" /> がシグナルを受信するまで現在のスレッドをブロックします。時間間隔を指定するために 32 ビット符号付き整数を使用し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="26969-649">Blocks the current thread until the current <see cref="T:System.Threading.WaitHandle" /> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-650">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-650"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-651">場合`millisecondsTimeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-651">If `millisecondsTimeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-652">待機ハンドルの状態をテストし、直ちに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-652">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-653"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="26969-653"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="26969-654">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="26969-654">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="26969-655">放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-655">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="26969-656">システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-656">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="26969-657">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-657">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="26969-658">このメソッドはブロック、現在のインスタンス シグナルを受け取るか、タイムアウトまでの呼び出し元が発生します。</span><span class="sxs-lookup"><span data-stu-id="26969-658">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="26969-659">このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。</span><span class="sxs-lookup"><span data-stu-id="26969-659">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="26969-660">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="26969-660">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="26969-661">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="26969-661">Override this method to customize the behavior of derived classes.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="26969-662">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="26969-662">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="26969-663">`exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="26969-663">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="26969-664">派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。</span><span class="sxs-lookup"><span data-stu-id="26969-664">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="26969-665">派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="26969-665">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="26969-666">既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-666">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="26969-667">スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-667">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="26969-668">これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-668">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="26969-669">その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。</span><span class="sxs-lookup"><span data-stu-id="26969-669">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="26969-670">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-670">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="26969-671">ときに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="26969-671">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-672">例を次にどのように<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29>メソッドのオーバー ロードは同期ドメイン内で呼び出された場合に動作します。</span><span class="sxs-lookup"><span data-stu-id="26969-672">The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain.</span></span> <span data-ttu-id="26969-673">最初に、スレッドが待機する`exitContext`'éý'`false`し、待機のタイムアウト時間が経過するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="26969-673">First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires.</span></span> <span data-ttu-id="26969-674">最初のスレッドが終了しで待機した後、2 番目のスレッドが実行される`exitContext`'éý'`true`です。</span><span class="sxs-lookup"><span data-stu-id="26969-674">A second thread executes after the first thread terminates and waits with `exitContext` set to `true`.</span></span> <span data-ttu-id="26969-675">この 2 番目のスレッドの待機ハンドルの通知への呼び出しがブロックされていないと、印刷待ちタイムアウトする前に、スレッドが完了するとします。</span><span class="sxs-lookup"><span data-stu-id="26969-675">The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="26969-676">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="26969-676">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-677"><paramref name="millisecondsTimeout" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-677"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-678">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-678">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-679">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-679">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-680">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="26969-680">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WaitOne (timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool WaitOne(TimeSpan timeout, bool exitContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="26969-681">待機するミリ秒数を表す <see cref="T:System.TimeSpan" />。無制限に待機する場合は、-1 ミリ秒を表す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="26969-681">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <param name="exitContext">
          <span data-ttu-id="26969-682">待機する前にコンテキストの同期ドメインを終了し (同期されたコンテキスト内にいる場合)、後で再取得する場合は、<see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-682"><see langword="true" /> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="26969-683">現在のインスタンスがシグナルを受信するまで現在のスレッドをブロックします。<see cref="T:System.TimeSpan" /> を使用して時間間隔を指定し、待機の前でも同期ドメインを終了するかどうかを指定します。</span><span class="sxs-lookup"><span data-stu-id="26969-683">Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" /> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</span></span></summary>
        <returns>
          <span data-ttu-id="26969-684">現在のインスタンスがシグナルを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="26969-684"><see langword="true" /> if the current instance receives a signal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-685">場合`timeout`が 0 の場合、メソッドをブロックしません。</span><span class="sxs-lookup"><span data-stu-id="26969-685">If `timeout` is zero, the method does not block.</span></span> <span data-ttu-id="26969-686">待機ハンドルの状態をテストし、直ちに返されます。</span><span class="sxs-lookup"><span data-stu-id="26969-686">It tests the state of the wait handle and returns immediately.</span></span>  
  
 <span data-ttu-id="26969-687"><xref:System.Threading.AbandonedMutexException> .NET Framework version 2.0 の新機能です。</span><span class="sxs-lookup"><span data-stu-id="26969-687"><xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0.</span></span> <span data-ttu-id="26969-688">以前のバージョンで、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。`true`ミュー テックスが破棄されます。</span><span class="sxs-lookup"><span data-stu-id="26969-688">In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned.</span></span> <span data-ttu-id="26969-689">放棄されたミュー テックスは、多くの場合、重大なコーディング エラーを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-689">An abandoned mutex often indicates a serious coding error.</span></span> <span data-ttu-id="26969-690">システム全体のミュー テックス、可能性があります (たとえば、Windows タスク マネージャーを使用) して、アプリケーションが突然終了されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-690">In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span> <span data-ttu-id="26969-691">例外には、デバッグに役立つ情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="26969-691">The exception contains information useful for debugging.</span></span>  
  
 <span data-ttu-id="26969-692">このメソッドはブロック、現在のインスタンス シグナルを受け取るか、タイムアウトまでの呼び出し元が発生します。</span><span class="sxs-lookup"><span data-stu-id="26969-692">The caller of this method blocks until the current instance receives a signal or a time-out occurs.</span></span> <span data-ttu-id="26969-693">このメソッドのブロックを使用して、<xref:System.Threading.WaitHandle>別のスレッドからがシグナルを受け取る、非同期操作が完了したときに、生成されるなどです。</span><span class="sxs-lookup"><span data-stu-id="26969-693">Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes.</span></span> <span data-ttu-id="26969-694">詳細については、<xref:System.IAsyncResult> インターフェイスのトピックを参照してください。</span><span class="sxs-lookup"><span data-stu-id="26969-694">For more information, see the <xref:System.IAsyncResult> interface.</span></span>  
  
 <span data-ttu-id="26969-695">派生クラスの動作をカスタマイズするには、このメソッドをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="26969-695">Override this method to customize the behavior of derived classes.</span></span>  
  
 <span data-ttu-id="26969-696">最大値`timeout`は<xref:System.Int32.MaxValue?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="26969-696">The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="26969-697">コンテキストの終了時の注意</span><span class="sxs-lookup"><span data-stu-id="26969-697">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="26969-698">`exitContext`パラメーター影響を及ぼしませんしない限り、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが既定以外のマネージ コンテキスト内から呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="26969-698">The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="26969-699">派生したクラスのインスタンスへの呼び出し内部に、スレッドがある場合に発生<xref:System.ContextBoundObject>です。</span><span class="sxs-lookup"><span data-stu-id="26969-699">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="26969-700">派生していないクラスのメソッドを実行されている場合でも<xref:System.ContextBoundObject>と同様、 <xref:System.String>、既定以外のコンテキストであることができる場合、<xref:System.ContextBoundObject>が現在のアプリケーション ドメインで、スタック上にします。</span><span class="sxs-lookup"><span data-stu-id="26969-700">Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="26969-701">既定以外のコンテキストでコードを実行するとときに、指定する`true`の`exitContext`既定以外のマネージ コンテキストを終了するスレッド (つまり、既定のコンテキストに遷移する) 実行する前に、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="26969-701">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="26969-702">スレッドが呼び出しの後に元の既定以外のコンテキストに戻る、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-702">The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.</span></span>  
  
 <span data-ttu-id="26969-703">これを利用する場合、コンテキスト バインド クラス<xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>です。</span><span class="sxs-lookup"><span data-stu-id="26969-703">This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>.</span></span> <span data-ttu-id="26969-704">その場合は、クラスのメンバーに対するすべての呼び出しが自動的に同期され、同期ドメインは、クラスのコードの本文全体です。</span><span class="sxs-lookup"><span data-stu-id="26969-704">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="26969-705">メンバーの呼び出し履歴内のコードを呼び出すかどうか、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを指定して`true`の`exitContext`スレッドが続行する、オブジェクトの任意のメンバーへの呼び出しでブロックされているスレッドの同期ドメインを終了します。</span><span class="sxs-lookup"><span data-stu-id="26969-705">If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="26969-706">ときに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドが戻る同期ドメインを再入力する呼び出しを行ったスレッドを待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="26969-706">When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-707">次のコード例では、待機ハンドルを使用して、バック グラウンド スレッドの実行が完了するまで待機するときに終了してから、プロセスの状態を保持する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="26969-707">The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="26969-708">現在のインスタンスは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="26969-708">The current instance has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="26969-709"><paramref name="timeout" /> は無限のタイムアウトを表す -1 ミリ秒以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="26969-709"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span>  
  
 <span data-ttu-id="26969-710">- または -</span><span class="sxs-lookup"><span data-stu-id="26969-710">-or-</span></span>  
  
 <span data-ttu-id="26969-711"><paramref name="timeout" /> が <see cref="F:System.Int32.MaxValue" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="26969-711"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.AbandonedMutexException"><span data-ttu-id="26969-712">スレッドがミューテックスを解放せずに終了したため、待機が完了しました。</span><span class="sxs-lookup"><span data-stu-id="26969-712">The wait completed because a thread exited without releasing a mutex.</span></span> <span data-ttu-id="26969-713">Windows 98 または Windows Millennium Edition では、この例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="26969-713">This exception is not thrown on Windows 98 or Windows Millennium Edition.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="26969-714">別のアプリケーション ドメインでは、現在のインスタンスは <see cref="T:System.Threading.WaitHandle" /> の透過プロキシです。</span><span class="sxs-lookup"><span data-stu-id="26969-714">The current instance is a transparent proxy for a <see cref="T:System.Threading.WaitHandle" /> in another application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const WaitTimeout As Integer  = 258" />
      <MemberSignature Language="C++ CLI" Value="public: int WaitTimeout = 258;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary><span data-ttu-id="26969-715">待機ハンドルがシグナル状態になる前に <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> 操作がタイムアウトになったことを示します。</span><span class="sxs-lookup"><span data-stu-id="26969-715">Indicates that a <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> operation timed out before any of the wait handles were signaled.</span></span> <span data-ttu-id="26969-716">このフィールドは定数です。</span><span class="sxs-lookup"><span data-stu-id="26969-716">This field is constant.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="26969-717">このフィールドは、の戻り値のいずれかの`WaitAny`します。</span><span class="sxs-lookup"><span data-stu-id="26969-717">This field is one of the possible return values of `WaitAny`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="26969-718">次のコード例では、同時に複数のディスク上のファイルを検索するスレッド プールを使用する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="26969-718">The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks.</span></span> <span data-ttu-id="26969-719">容量に関する考慮事項については、各ディスクのルート ディレクトリだけが検索されます。</span><span class="sxs-lookup"><span data-stu-id="26969-719">For space considerations, only the root directory of each disk is searched.</span></span>  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>