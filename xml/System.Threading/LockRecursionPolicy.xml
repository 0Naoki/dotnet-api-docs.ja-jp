<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="LockRecursionPolicy.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52aaae222fcf2f023007bf6b87e2bf7c7bb83adaa.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2aaae222fcf2f023007bf6b87e2bf7c7bb83adaa</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.LockRecursionPolicy">
          <source>Specifies whether a lock can be entered multiple times by the same thread.</source>
          <target state="translated">同じスレッドが複数回ロックに入ることができるかどうかを指定します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>The default recursion policy depends on the type of lock.</source>
          <target state="translated">既定の再帰ポリシーは、ロックの種類によって異なります。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For the default policy and the precise behavior of lock recursion for any given lock type, see the documentation for the type.</source>
          <target state="translated">既定のポリシーと、指定されたロックの種類のロックの再帰の正確な動作は、型のドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For example, the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class does not allow a thread to enter the lock in write mode if it already entered the lock in read mode, regardless of the lock policy setting, in order to reduce the chance of deadlocks.</source>
          <target state="translated">たとえば、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスには、スレッドが既に入力した場合、ロック、ロックのポリシー設定に関係なく、読み取りモードでデッドロックの可能性を低減するために書き込みモードでロックに入ることはできません。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>Currently only one lock uses this enumeration:</source>
          <target state="translated">現在、だけが 1 つのロックは、この列挙体を使用します。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property.</source>
          <target state="translated">詳細については、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> プロパティを参照してください。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>The following example shows two exception scenarios, one that depends on the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> setting and one that does not.</source>
          <target state="translated">次の例は、いずれかに依存している 2 つの例外シナリオ、<ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph>設定としない種類です。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>In the first scenario, the thread enters the lock in read mode and then tries to enter read mode recursively.</source>
          <target state="translated">最初のシナリオでは、スレッドは、読み取りモードでロックに入ったで、読み取りモードの再帰的を入力しようとします。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is created by using the default constructor, which sets recursion policy to NoRecursion, an exception is thrown.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>が作成される再帰ポリシーを設定すると、NoRecursion に、既定のコンス トラクターを使用して、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>If SupportsRecursion is used to create the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, no exception is thrown.</source>
          <target state="translated">SupportsRecursion を使用して作成する場合、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>例外はスローされません。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source>In the second scenario, the thread enters the lock in read mode and then tries to enter the lock in write mode.</source>
          <target state="translated">2 番目のシナリオでは、スレッドは、読み取りモードでロックに入ったで、書き込みモードでロックに入るしようとします。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.LockRecursionPolicy">
          <source><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown regardless of the lock recursion policy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> ロック再帰ポリシーに関係なくがスローされます。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.NoRecursion">
          <source>If a thread tries to enter a lock recursively, an exception is thrown.</source>
          <target state="translated">スレッドが、再帰的にロックに入ろうとすると、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.NoRecursion">
          <source>Some classes may allow certain recursions when this setting is in effect.</source>
          <target state="translated">クラスによっては、この設定が適用されている場合に、特定の再帰が認められることがあります。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
          <source>A thread can enter a lock recursively.</source>
          <target state="translated">スレッドが再帰的にロックに入ることができます。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="F:System.Threading.LockRecursionPolicy.SupportsRecursion">
          <source>Some classes may restrict this capability.</source>
          <target state="translated">クラスによっては、この機能が制限されていることがあります。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>