<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="50ab23464dfb39568b212b158b072363ca378da6" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37754733" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <TypeSignature Language="VB.NET" Value="Public Class EventWaitHandle&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventWaitHandle : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type EventWaitHandle = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a thread synchronization event.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle>クラスはスレッドに通知することによって相互通信を使用できます。 通常、1 つまたは複数のスレッドをブロック、 <xref:System.Threading.EventWaitHandle> 、ブロック解除スレッドを呼び出すまで、<xref:System.Threading.EventWaitHandle.Set%2A>メソッド、1 つまたは複数のブロックされたスレッドを解放します。 スレッドをシグナル状態に、<xref:System.Threading.EventWaitHandle>し、呼び出すことによって、ブロック、 `static` (`Shared` Visual Basic で)<xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>メソッド。  
  
> [!NOTE]
>  <xref:System.Threading.EventWaitHandle>クラスが名前付きシステム同期イベントへのアクセスを提供します。  
  
 動作、<xref:System.Threading.EventWaitHandle>をシグナル状態になった状態によって異なります。 <xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>シグナルを受け取ると、単一の待機スレッドを解放した後に、フラグが自動的にリセットされます。 <xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>フラグはまでシグナル状態のままその<xref:System.Threading.EventWaitHandle.Reset%2A>メソッドが呼び出されます。  
  
 自動リセット イベントは、リソースへの排他アクセスを提供します。 自動リセット イベントが通知を受けたとき、待機中のスレッドがない場合は、スレッドが待機中になるまでシグナル状態のままです。 イベントはスレッドを解放してすぐにリセットされ、以降のスレッドをブロックします。  
  
 ゲートのようなイベントは、手動リセットします。 イベントがシグナル状態ではない場合は、待機しているスレッドがブロックされます。 イベントがシグナル状態に、すべての待機中のスレッドがリリースされたら、およびイベント シグナル状態のままと (後続の待機がならない) になるまでその<xref:System.Threading.EventWaitHandle.Reset%2A>メソッドが呼び出されます。 手動リセット イベントは他のスレッドを続行する前に、1 つのスレッドは、アクティビティを完了する必要がある場合に役立ちます。  
  
 <xref:System.Threading.EventWaitHandle> オブジェクトで使用できる、 `static`(`Shared` Visual Basic で)<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>と<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>メソッド。  
  
 スレッドの同期機構の詳細については、次を参照してください。 [EventWaitHandle、AutoResetEvent、CountdownEvent、ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>ブロックされたスレッドのシグナルを待ってから、スレッドがタスクを完了するまでメイン スレッドを許可するメソッドのオーバー ロードします。  
  
 例では、5 つのスレッドを開始し、ブロックすることができます、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>フラグ、ユーザーが ENTER キーを押したリリース 1 つのスレッドの時間。 例では、別の 5 つのスレッドのキューし、すべてを使用して、解放、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>フラグ。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.AutoResetEvent" />
    <altmember cref="T:System.Threading.ManualResetEvent" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの初期状態が非シグナル状態の場合は、イベントを待機しているスレッドがブロックされます。 初期状態をシグナル状態の場合、<xref:System.Threading.EventResetMode.ManualReset>フラグが指定されて`mode`イベントを待機しているスレッドはブロックされません。 初期状態はシグナル状態になる場合と`mode`は<xref:System.Threading.EventResetMode.AutoReset>イベントで待機する最初のスレッドがすぐに解放される、その後、イベントがリセットされ、その後のスレッドがブロックされます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>ブロックされたスレッドのシグナルを待ってから、スレッドがタスクを完了するまでメイン スレッドを許可するメソッドのオーバー ロードします。  
  
 例では、5 つのスレッドを開始し、ブロックすることができます、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>フラグ、し、ENTER キーを押すリリース 1 つのスレッドの時間。 例では、別の 5 つのスレッドのキューし、すべてを使用して、解放、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>フラグ。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <param name="name">The name of a system-wide synchronization event.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`name`は`null`または空の文字列、ローカル<xref:System.Threading.EventWaitHandle>が作成されます。  
  
 場合に指定された名前のシステム イベント、`name`パラメーターが既に存在する、`initialState`パラメーターは無視されます。  
  
> [!IMPORTANT]
>  このコンス トラクターの名前付きシステム イベントを使用する場合は、指定`false`の`initialState`します。 このコンス トラクターには、名前付きイベントの状態を想定することはできませんので、名前付きシステム イベントが作成されたかどうかを判断する方法が用意されていません。 名前付きイベントが作成されたかどうかを調べるには、<xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29>コンス トラクターまたは<xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29>コンス トラクター。  
  
 イベントの初期状態が非シグナル状態の場合は、イベントを待機しているスレッドがブロックされます。 初期状態をシグナル状態の場合、<xref:System.Threading.EventResetMode.ManualReset>フラグが指定されて`mode`イベントを待機しているスレッドはブロックされません。 初期状態はシグナル状態になる場合と`mode`は<xref:System.Threading.EventResetMode.AutoReset>イベントで待機する最初のスレッドがすぐに解放される、その後、イベントがリセットされ、その後のスレッドがブロックされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <param name="name">The name of a system-wide synchronization event.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed. This parameter is passed uninitialized.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合に指定された名前のシステム イベント、`name`パラメーターが既に存在する、`initialState`パラメーターは無視されます。 このコンス トラクターを呼び出した後に指定された変数の値を使用して、`ref`パラメーター (`ByRef` Visual Basic でのパラメーター)`createdNew`を名前付きシステム イベントが既に存在していたか、作成されたかどうかを判断します。  
  
 イベントの初期状態が非シグナル状態の場合は、イベントを待機しているスレッドがブロックされます。 初期状態をシグナル状態の場合、<xref:System.Threading.EventResetMode.ManualReset>フラグが指定されて`mode`イベントを待機しているスレッドはブロックされません。 初期状態はシグナル状態になる場合と`mode`は<xref:System.Threading.EventResetMode.AutoReset>イベントで待機する最初のスレッドがすぐに解放される、その後、イベントがリセットされ、その後のスレッドがブロックされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean, eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventWaitHandle(bool initialState, System::Threading::EventResetMode mode, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.EventWaitHandle : bool * System.Threading.EventResetMode * string *  * System.Security.AccessControl.EventWaitHandleSecurity -&gt; System.Threading.EventWaitHandle" Usage="new System.Threading.EventWaitHandle (initialState, mode, name, createdNew, eventSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> to set the initial state to signaled if the named event is created as a result of this call; <see langword="false" /> to set it to nonsignaled.</param>
        <param name="mode">One of the <see cref="T:System.Threading.EventResetMode" /> values that determines whether the event resets automatically or manually.</param>
        <param name="name">The name of a system-wide synchronization event.</param>
        <param name="createdNew">When this method returns, contains <see langword="true" /> if a local event was created (that is, if <c>name</c> is <see langword="null" /> or an empty string) or if the specified named system event was created; <see langword="false" /> if the specified named system event already existed. This parameter is passed uninitialized.</param>
        <param name="eventSecurity">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Threading.EventWaitHandle" /> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターを使用すると、名前付きシステム イベントが作成されると、他のコードがイベントを乗っ取ることを防止するのにアクセス制御セキュリティを適用できます。  
  
 このコンス トラクターの初期化、<xref:System.Threading.EventWaitHandle>システム イベントを表すオブジェクト。 複数作成できます<xref:System.Threading.EventWaitHandle>同じシステム イベントを表すオブジェクト。  
  
 システム イベントが存在しない場合は、指定したアクセス制御セキュリティで作成されます。 イベントが存在する場合は、指定したアクセス制御セキュリティが無視されます。  
  
> [!NOTE]
>  呼び出し元が新しく作成された完全な制御<xref:System.Threading.EventWaitHandle>オブジェクトいて`eventSecurity`拒否するか、現在のユーザーへのいくつかのアクセス権の付与に失敗しました。 ただし場合は、現在のユーザーが別の取得を試みます<xref:System.Threading.EventWaitHandle>オブジェクトを表す、同じという名前を使用して、イベント、コンス トラクターまたは<xref:System.Threading.EventWaitHandle.OpenExisting%2A>メソッドでは、Windows アクセス制御セキュリティを適用します。  
  
 場合に指定された名前のシステム イベント、`name`パラメーターが既に存在する、`initialState`パラメーターは無視されます。 このコンス トラクターを呼び出した後に指定された変数の値を使用して、`ref`パラメーター (`ByRef` Visual Basic でのパラメーター)`createdNew`を名前付きシステム イベントが既に存在していたか、作成されたかどうかを判断します。  
  
 イベントの初期状態が非シグナル状態の場合は、イベントを待機しているスレッドがブロックされます。 初期状態をシグナル状態の場合、<xref:System.Threading.EventResetMode.ManualReset>フラグが指定されて`mode`イベントを待機しているスレッドはブロックされません。 初期状態はシグナル状態になる場合と`mode`は<xref:System.Threading.EventResetMode.AutoReset>イベントで待機する最初のスレッドがすぐに解放される、その後、イベントがリセットされ、その後のスレッドがブロックされます。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを名前付きシステム イベントのプロセス間の動作を示します。 この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>名前付きイベントの存在をテストするメソッドのオーバー ロードします。  
  
 イベントが存在しない場合は、初期所有権と現在のユーザーに、イベントを使用する権限を拒否の読み取りし、イベントのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>します。 例外がキャッチされ、例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つイベントを待機します。  
  
 アクセス許可が変更された後、イベントは、待機し、シグナル通知に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して例が実行されます。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named event cannot be created, perhaps because a wait handle of a different type has the same name.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is longer than 260 characters.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As EventWaitHandleSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::EventWaitHandleSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.EventWaitHandleSecurity" Usage="eventWaitHandle.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event represented by the current <see cref="T:System.Threading.EventWaitHandle" /> object.</summary>
        <returns>An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security for the named system event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.GetAccessControl%2A>メソッドは次のフラグ (ビットごとの OR 演算を使用して結合) の組み合わせを使用してアクセス許可を検索する: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>、 <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>、および<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>します。  
  
 ユーザーがいる必要があります<xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>で、このメソッドとイベントを呼び出す権限が開かれている必要があります、<xref:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions?displayProperty=nameWithType>フラグ。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを名前付きシステム イベントのプロセス間の動作を示します。 この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>名前付きイベントの存在をテストするメソッドのオーバー ロードします。  
  
 イベントが存在しない場合は、初期所有権と現在のユーザーに、イベントを使用する権限を拒否の読み取りし、イベントのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>します。 例外がキャッチされ、例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つイベントを待機します。  
  
 使用して、アクセス許可を読み取られたした後、<xref:System.Threading.EventWaitHandle.GetAccessControl%2A>メソッド、待機し、シグナル通知に必要な権限を変更するには、イベントで開くとします。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して例が実行されます。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and the user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  -or-  The current <see cref="T:System.Threading.EventWaitHandle" /> object represents a named system event, and was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Not supported for Windows 98 or Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named synchronization event, if it already exists.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <summary>Opens the specified named synchronization event, if it already exists.</summary>
        <returns>An  object that represents the named system event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A>メソッドが、指定した名前付きシステム イベントを開こうとします。 システム イベントが存在しない場合、このメソッドは、システム イベントを作成する代わりに、例外をスローします。 存在しない場合は、システム イベントを作成するには、いずれかを使用、<xref:System.Threading.EventWaitHandle.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。  
  
 このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.EventWaitHandle>場合でも、返されるオブジェクトが同じ名前付きシステム イベントを表すオブジェクトします。  
  
 このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>メソッドのオーバー ロードを指定して<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>と<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>権限、ビットごとの OR 演算を使用して結合します。  
  
 指定する、<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>フラグによって、名前付きシステム イベントで待機するスレッドを指定して、<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>フラグによって、スレッドを呼び出す、<xref:System.Threading.EventWaitHandle.Set%2A>と<xref:System.Threading.EventWaitHandle.Reset%2A>メソッド。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを名前付きシステム イベントのプロセス間の動作を示します。 この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>名前付きイベントの存在をテストするメソッドのオーバー ロードします。  
  
 イベントが存在しない場合は、初期所有権と現在のユーザーに、イベントを使用する権限を拒否の読み取りし、イベントのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>します。 例外がキャッチされ、例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つイベントを待機します。  
  
 アクセス許可が変更された後、イベントは、待機し、シグナル通知に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して例が実行されます。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named system event does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the security access required to use it.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As EventWaitHandleRights) As EventWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::EventWaitHandle ^ OpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.EventWaitHandleRights -&gt; System.Threading.EventWaitHandle" Usage="System.Threading.EventWaitHandle.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <summary>Opens the specified named synchronization event, if it already exists, with the desired security access.</summary>
        <returns>An object that represents the named system event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights`パラメーターを含める必要があります、<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>イベントで待機するスレッドを許可するフラグ、<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>を呼び出すスレッドを許可するフラグ、<xref:System.Threading.EventWaitHandle.Set%2A>と<xref:System.Threading.EventWaitHandle.Reset%2A>メソッド。  
  
 <xref:System.Threading.EventWaitHandle.OpenExisting%2A>メソッドが既存の名前付きシステム イベントを開こうとします。 システム イベントが存在しない場合、このメソッドは、システム イベントを作成する代わりに、例外をスローします。 存在しない場合は、システム イベントを作成するには、いずれかを使用、<xref:System.Threading.EventWaitHandle.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。  
  
 このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.EventWaitHandle>場合でも、返されるオブジェクトが同じ名前付きシステム イベントを表すオブジェクトします。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを名前付きシステム イベントのプロセス間の動作を示します。 この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>名前付きイベントの存在をテストするメソッドのオーバー ロードします。  
  
 イベントが存在しない場合は、初期所有権と現在のユーザーに、イベントを使用する権限を拒否の読み取りし、イベントのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>します。 例外がキャッチされ、例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つイベントを待機します。  
  
 アクセス許可が変更された後、イベントは、待機し、シグナル通知に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して例が実行されます。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">The named system event does not exist.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Function Reset () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Reset();" />
      <MemberSignature Language="F#" Value="member this.Reset : unit -&gt; bool" Usage="eventWaitHandle.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the state of the event to nonsignaled, causing threads to block.</summary>
        <returns>
          <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberSignature Language="VB.NET" Value="Public Function Set () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Set();" />
      <MemberSignature Language="F#" Value="member this.Set : unit -&gt; bool" Usage="eventWaitHandle.Set " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</summary>
        <returns>
          <see langword="true" /> if the operation succeeds; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.EventWaitHandle>で<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>(含む<xref:System.Threading.AutoResetEvent>)、<xref:System.Threading.EventWaitHandle.Set%2A>メソッドは、1 つのスレッドを解放します。 待機中のスレッドがない場合は、待機ハンドル シグナル状態のままスレッドが、まで、または待機しようとするまでその<xref:System.Threading.EventWaitHandle.Reset%2A>メソッドが呼び出されます。  
  
> [!IMPORTANT]
>  保証はありませんが、呼び出すたび、<xref:System.Threading.EventWaitHandle.Set%2A>メソッドからのスレッドを解放、<xref:System.Threading.EventWaitHandle>がリセット モードは<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>。 2 つの呼び出しが近すぎる、スレッドが解放される前に 2 番目の呼び出しが行われるように、1 つのスレッドが解放されます。 2 番目の呼び出しが発生しなかったかのようになります。 また場合、<xref:System.Threading.EventWaitHandle.Set%2A>待機しているスレッドがないときに呼び出されると、<xref:System.Threading.EventWaitHandle>が既にシグナル、呼び出しが影響を与えません。  
  
 <xref:System.Threading.EventWaitHandle>で<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>(を含む<xref:System.Threading.ManualResetEvent>) を呼び出すと、<xref:System.Threading.EventWaitHandle.Set%2A>メソッドでは、待機ハンドルを離れるまでシグナル状態でその<xref:System.Threading.EventWaitHandle.Reset%2A>メソッドが呼び出されます。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29>ブロックされたスレッドのシグナルを待ってから、スレッドがタスクを完了するまでメイン スレッドを許可するメソッドのオーバー ロードします。  
  
 例では、5 つのスレッドを開始し、ブロックすることができます、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>フラグ、ユーザーが ENTER キーを押したリリース 1 つのスレッドの時間。 例では、別の 5 つのスレッドのキューし、すべてを使用して、解放、<xref:System.Threading.EventWaitHandle>で作成された、<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>フラグ。  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAccessControl (eventSecurity As EventWaitHandleSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::EventWaitHandleSecurity ^ eventSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.EventWaitHandleSecurity -&gt; unit" Usage="eventWaitHandle.SetAccessControl eventSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">An <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> object that represents the access control security to be applied to the named system event.</param>
        <summary>Sets the access control security for a named system event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーがいる必要があります<xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>で、このメソッドとイベントを呼び出す権限が開かれている必要があります、<xref:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions?displayProperty=nameWithType>フラグ。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを名前付きシステム イベントのプロセス間の動作を示します。 この例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>名前付きイベントの存在をテストするメソッドのオーバー ロードします。  
  
 イベントが存在しない場合は、初期所有権と現在のユーザーに、イベントを使用する権限を拒否の読み取りし、イベントのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>します。 例外がキャッチされ、例では、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つイベントを待機します。  
  
 使用して、アクセス許可が変更した後、<xref:System.Threading.EventWaitHandle.SetAccessControl%2A>待機し、シグナル通知するために必要な権限を持つメソッド、イベントが開きます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用して例が実行されます。  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> is <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The user does not have <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  -or-  The event was not opened with <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">The current <see cref="T:System.Threading.EventWaitHandle" /> object does not represent a named system event.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="M:System.Threading.WaitHandle.Close" /> method was previously called on this <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Opens a specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前付き同期イベントが存在しない場合このメソッドはいない作成しません。 存在しない場合は、システム イベントを作成するには、いずれかを使用、<xref:System.Threading.EventWaitHandle.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。  
  
 名前付き同期イベントが存在するかどうかが不明な場合は、代わりにこのメソッドのオーバー ロードを使用して、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>メソッド オーバー ロードで、同期イベントが存在しない場合は、例外をスローします。  
  
 このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29>メソッドのオーバー ロードを指定して<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>と<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>権限、ビットごとの OR 演算を使用して結合します。 指定する、<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>フラグによって、名前付きシステム イベントで待機するスレッドを指定して、<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>フラグによって、スレッドを呼び出す、<xref:System.Threading.EventWaitHandle.Set%2A>と<xref:System.Threading.EventWaitHandle.Reset%2A>メソッド。  
  
 このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.EventWaitHandle>場合でも、返されるオブジェクトが同じ名前付きシステム イベントを表すオブジェクトします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As EventWaitHandleRights, ByRef result As EventWaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::EventWaitHandleRights rights, [Runtime::InteropServices::Out] System::Threading::EventWaitHandle ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.EventWaitHandleRights *  -&gt; bool" Usage="System.Threading.EventWaitHandle.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">The name of the system synchronization event to open.</param>
        <param name="rights">A bitwise combination of the enumeration values that represent the desired security access.</param>
        <param name="result">When this method returns, contains a <see cref="T:System.Threading.EventWaitHandle" /> object that represents the named synchronization event if the call succeeded, or <see langword="null" /> if the call failed. This parameter is treated as uninitialized.</param>
        <summary>Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</summary>
        <returns>
          <see langword="true" /> if the named synchronization event was opened successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前付き同期イベントが存在しない場合このメソッドはいない作成しません。 存在しない場合は、システム イベントを作成するには、いずれかを使用、<xref:System.Threading.EventWaitHandle.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。  
  
 名前付き同期イベントが存在するかどうかが不明な場合は、代わりにこのメソッドのオーバー ロードを使用して、<xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29>メソッド オーバー ロードで、同期イベントが存在しない場合は、例外をスローします。  
  
 `rights`パラメーターを含める必要があります、<xref:System.Security.AccessControl.EventWaitHandleRights.Synchronize?displayProperty=nameWithType>イベントで待機するスレッドを許可するフラグ、<xref:System.Security.AccessControl.EventWaitHandleRights.Modify?displayProperty=nameWithType>を呼び出すスレッドを許可するフラグ、<xref:System.Threading.EventWaitHandle.Set%2A>と<xref:System.Threading.EventWaitHandle.Reset%2A>メソッド。  
  
 このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.EventWaitHandle>場合でも、返されるオブジェクトが同じ名前付きシステム イベントを表すオブジェクトします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> is an empty string.  -or-  <paramref name="name" /> is longer than 260 characters.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A Win32 error occurred.</exception>
        <exception cref="T:System.UnauthorizedAccessException">The named event exists, but the user does not have the desired security access.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
  </Members>
</Type>