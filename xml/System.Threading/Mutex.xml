<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="75309784a7f2ba45e91d42b9f73bf62285725b43" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52200781" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>同期プリミティブは、プロセス間の同期にも使用できます。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 2 つまたは複数のスレッドは、同時に共有リソースにアクセスする必要があります、システム同期メカニズム、一度に 1 つのスレッドが、リソースを使用することを確認する必要があります。 <xref:System.Threading.Mutex> 同期は 1 つのスレッドを共有リソースへの排他アクセスを付与するプリミティブです。 スレッドがミュー テックス、最初のスレッドがミュー テックスを解放するまで、ミュー テックスを取得しようとする 2 番目のスレッドが中断されます。  
  
> [!IMPORTANT]
>  この型は、<xref:System.IDisposable>インターフェイス。 型の使用が完了したら、直接的または間接的にそれを破棄する必要があります。 型の直接 dispose を呼び出してその<xref:System.IDisposable.Dispose%2A>メソッド、 `try` / `catch`ブロックします。 直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(で C# の場合) または`Using`(Visual Basic) でします。 詳細については、"を使用して、オブジェクトを実装する IDisposable"のセクションを参照してください、<xref:System.IDisposable>インターフェイスに関するトピック。  
  
 使用することができます、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>ミュー テックスの所有権を要求するメソッド。 呼び出し元のスレッド、次のいずれかが発生するまでをブロックします。  
  
-   所有されていないことを示す、ミュー テックスが通知されます。 この場合、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。 `true`、呼び出し元のスレッドにミュー テックスの所有権を前提として、ミュー テックスで保護されているリソースにアクセスするとします。 リソースへのアクセスが完了したら、スレッドを呼び出す必要があります、<xref:System.Threading.Mutex.ReleaseMutex%2A>ミュー テックスの所有権を解放します。 「例」最初の例では、このパターンをを示します。  
  
-   呼び出しで指定されたタイムアウト間隔、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを持つ、`millisecondsTimeout`または`timeout`パラメーターが経過しました。 この場合、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを返します。 `false`、呼び出し元のスレッドにミュー テックスの所有権を取得しようがないとします。 この場合、コードの構造は、呼び出し元のスレッドにミュー テックスによって保護されているリソースへのアクセスが拒否されたようにする必要があります。 呼び出す必要がありますいないスレッドがミュー テックスの所有権を取得することはありませんので、<xref:System.Threading.Mutex.ReleaseMutex%2A>メソッド。 「例」の 2 番目の例では、このパターンを示します。  
  
 <xref:System.Threading.Mutex>クラスを取得したスレッドでのみ、ミュー テックスを解放できるようにスレッドの id を適用します。 これに対し、<xref:System.Threading.Semaphore>クラスでは、スレッド id は強制されません。 ミュー テックスは、アプリケーション ドメイン境界を越えて渡すこともできます。  
  
 ミュー テックスを所有するスレッドが繰り返しの呼び出しで同じミュー テックスを要求できる<xref:System.Threading.WaitHandle.WaitOne%2A>せず、実行をブロックします。 ただし、スレッドを呼び出す必要があります、<xref:System.Threading.Mutex.ReleaseMutex%2A>メソッドと同じ回数、ミュー テックスの所有権を解放します。  
  
 <xref:System.Threading.Mutex>クラスから継承<xref:System.Threading.WaitHandle>、静的なを呼び出すこともできます<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>と<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>保護されたリソースへのアクセスを同期する方法。  
  
 ミュー テックスを所有しているスレッドが終了する場合、ミュー テックスを破棄するメンバーといいます。 ミュー テックスの状態は、シグナル状態に設定して、次の待機スレッドが所有権を取得します。 .NET Framework のバージョン 2.0 以降では、<xref:System.Threading.AbandonedMutexException>が放棄されたミュー テックスを取得する次のスレッドでスローされます。 .NET Framework version 2.0 の前に例外がスローされません。  
  
> [!CAUTION]
>  ミュー テックスの破棄には、重大なエラー コードの多くの場合を示します。 ミュー テックスを解放しないままスレッドが終了すると、ミュー テックスで保護されているデータ構造が一貫した状態でできません。 次のスレッドにミュー テックスの所有権を要求するでは、この例外を処理でき、データ構造の整合性を検証できる場合、続行することができます。  
  
 システム全体でミューテックスが有効な場合にミューテックスが破棄されたときは、アプリケーションが強制終了されたことを示している可能性があります (たとえば、Windows タスク マネージャを使用した終了)。  
  
 ミュー テックスは次の 2 つの種類: と、名前付きシステム ミュー テックスをローカル ミュー テックスです。 ローカル ミューテックスは、現在のプロセス内にのみ存在します。 参照しているプロセス内のすべてのスレッドから使用できます、<xref:System.Threading.Mutex>ミュー テックスを表すオブジェクト。 名前のない各<xref:System.Threading.Mutex>オブジェクトは、別のローカル ミュー テックスを表します。  
  
 名前付きシステム ミュー テックスは、オペレーティング システム全体から参照でき、プロセスの動作を同期するために使用できます。 作成することができます、<xref:System.Threading.Mutex>名前を受け入れるコンス トラクターを使用して名前付きシステム ミュー テックスを表すオブジェクト。 か、同時にオペレーティング システム オブジェクトを作成できます。 を作成する前に存在する可能性が、<xref:System.Threading.Mutex>オブジェクト。 同じ名前付きシステム ミューテックスを表す複数の <xref:System.Threading.Mutex> オブジェクトを作成できます。また、<xref:System.Threading.Mutex.OpenExisting%2A> メソッドを使用して、既存の名前付きシステム ミューテックスを開くことができます。  
  
> [!NOTE]
>  ターミナル サービスを実行しているサーバーで名前付きシステム ミュー テックスには 2 つのレベルの可視性のことができます。 その名前がプレフィックスで始まる場合は、"Global\\"、ミュー テックスはすべてのターミナル サーバー セッションに表示されます。 その名前がプレフィックスで始まる場合は、"ローカル\\"、ミュー テックスが作成されたにターミナル サーバー セッションでのみ表示されます。 その場合は、同じ名前の別のミュー テックスは、それぞれのサーバー上の他のターミナル サーバー セッションに存在できます。 プレフィックスがかかる場合、名前付きミュー テックスを作成するときに、プレフィックスを指定しないと、"ローカル\\"。 ターミナル サーバー セッション内で名前のプレフィックスのみが異なる 2 つのミュー テックスは別のミュー テックス、および両方は、ターミナル サーバー セッションですべてのプロセスを表示します。 プレフィックスの名前は、"Global\\"と"ローカル\\"ミュー テックスの名前のプロセスは、ターミナル サーバー セッションを基準のスコープについて説明します。  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 この例は、ローカルの方法では<xref:System.Threading.Mutex>オブジェクトは、保護されたリソースへのアクセスを同期するために使用します。 呼び出す必要がありますが、ミュー テックスの所有権を取得するまでに各呼び出し元のスレッドがブロックされるため、<xref:System.Threading.Mutex.ReleaseMutex%2A>スレッドの所有権を解放するメソッド。  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 次の例では、各スレッドの呼び出し、<xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29>メソッドはミュー テックスを取得します。 かどうか、タイムアウト間隔が経過すると、メソッドを返します`false`、およびスレッドでミュー テックスを獲得も、ミュー テックスが保護リソースにアクセスできます。 <xref:System.Threading.Mutex.ReleaseMutex%2A>メソッドはミュー テックスを獲得するスレッドによってのみ呼び出されます。  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを、既定のプロパティを使用して初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しと同じには、このコンス トラクター オーバー ロードを呼び出し、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>コンス トラクター オーバー ロードを指定して`false`ミュー テックスの初期所有権をします。 つまり、呼び出し元のスレッドがミュー テックスを所有していません。  
  
   
  
## Examples  
 次のコード例に示す方法ローカル<xref:System.Threading.Mutex>オブジェクトは、保護されたリソースへのアクセスを同期するために使用します。 ミュー テックスを作成するスレッドが所有していない、最初に。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">呼び出し元スレッドにミューテックスの初期所有権を与える場合は<see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値を使用して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例に示す方法ローカル<xref:System.Threading.Mutex>オブジェクトは、保護されたリソースへのアクセスを同期するために使用します。 作成するスレッド、<xref:System.Threading.Mutex>最初に所有しています。  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="name"><see cref="T:System.Threading.Mutex" /> の名前。 値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値と、ミューテックスの名前を表す文字列を使用して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`name`ない`null`と`initiallyOwned`は`true`、この呼び出しの結果として、名前付きシステム ミュー テックスが作成された場合にのみ、呼び出し元のスレッドがミュー テックスを所有します。 指定することをお勧め、名前付きシステム ミュー テックスが作成されたかどうかを決定するためのメカニズムがないため、`false`の`initiallyOwned`このコンス トラクター オーバー ロードを呼び出すときにします。 使用することができます、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29>コンス トラクターの初期所有権を確認する必要がある場合。  
  
 このコンス トラクターの初期化を<xref:System.Threading.Mutex>名前付きシステム ミュー テックスを表すオブジェクト。 複数作成できます<xref:System.Threading.Mutex>名前付きシステム ミュー テックスを同じを表すオブジェクト。  
  
 アクセス制御のセキュリティでは、名前付きミュー テックスが既に作成されていて、呼び出し元が持たない<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>例外がスローされます。 既存のスレッドのアクティビティを同期するために必要なアクセス許可のみを持つ名前付きミュー テックスを開くを参照してください。、<xref:System.Threading.Mutex.OpenExisting%2A>メソッド。  
  
 指定した場合`null`または空の文字列の`name`、ローカル ミュー テックスが作成されたことを呼び出した場合と、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>コンス トラクター。 この場合、`createdNew`は常に`true`します。  
  
 これらは、システム全体であるために、プロセスの境界間でリソースの使用を調整する名前付きミュー テックスを使用できます。  
  
> [!NOTE]
>  ターミナル サービスを実行しているサーバーで名前付きシステム ミュー テックスには 2 つのレベルの可視性のことができます。 その名前がプレフィックスで始まる場合は、"Global\\"、ミュー テックスはすべてのターミナル サーバー セッションに表示されます。 その名前がプレフィックスで始まる場合は、"ローカル\\"、ミュー テックスが作成されたにターミナル サーバー セッションでのみ表示されます。 その場合は、同じ名前の別のミュー テックスは、それぞれのサーバー上の他のターミナル サーバー セッションに存在できます。 プレフィックスがかかる場合、名前付きミュー テックスを作成するときに、プレフィックスを指定しないと、"ローカル\\"。 ターミナル サーバー セッション内で名前のプレフィックスのみが異なる 2 つのミュー テックスは別のミュー テックス、および両方は、ターミナル サーバー セッションですべてのプロセスを表示します。 プレフィックスの名前は、"Global\\"と"ローカル\\"ミュー テックスの名前のプロセスは、ターミナル サーバー セッションを基準のスコープについて説明します。  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 次の例では、名前付きミュー テックスを使用して 2 つの個別のプロセスで実行中のスレッド間で通知する方法を示します。  
  
 このプログラムは、2 つ以上のコマンド ウィンドウから実行します。 各プロセスの作成、<xref:System.Threading.Mutex>名前付きミュー テックスを表すオブジェクトを`MyMutex`します。 名前付きミュー テックスがシステム オブジェクトの有効期間の有効期間に制限されます、<xref:System.Threading.Mutex>を表すオブジェクト。 最初のプロセスを作成するときに、名前付きミュー テックスが作成されたその<xref:System.Threading.Mutex>オブジェクト。 この例で、名前付きミュー テックスがプログラムを実行する最初のプロセスが所有します。 名前付きミュー テックスが破棄されるときにすべて、<xref:System.Threading.Mutex>リリースされたことを表すオブジェクト。  
  
 この例で使用されるコンス トラクターのオーバー ロードは、名前付きミュー テックスの初期所有権が付与されたかどうかを呼び出し元のスレッドに見分けることはできません。 スレッドが名前付きミュー テックスを作成することを確認できますしない限り、初期所有権を要求するのにこのコンス トラクターを使用しないでください。  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="name"><see cref="T:System.Threading.Mutex" /> の名前。 値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</param>
        <param name="createdNew">このメソッドから制御が戻るとき、ローカル ミューテックスが作成された場合 (つまり <paramref name="name" /> が <see langword="null" /> または空の文字列の場合) または指定した名前付きシステム ミューテックスが作成された場合は、ブール値 <see langword="true" /> が格納されます。指定した名前付きシステム ミューテックスが既に存在する場合は <see langword="false" /> が格納されます。 このパラメーターは初期化せずに渡されます。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値、ミューテックスの名前を表す文字列、およびメソッドから戻るときにミューテックスの初期所有権が呼び出し元のスレッドに付与されたかどうかを示すブール値を指定して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`name`ない`null`と`initiallyOwned`は`true`、呼び出し元のスレッドが場合にのみ、名前付きミュー テックスを所有している`createdNew`は`true`呼び出しの後にします。 呼び出すことによって、スレッドがミュー テックスを要求するそれ以外の場合、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド。  
  
 このコンス トラクターの初期化を<xref:System.Threading.Mutex>名前付きシステム ミュー テックスを表すオブジェクト。 複数作成できます<xref:System.Threading.Mutex>名前付きシステム ミュー テックスを同じを表すオブジェクト。  
  
 アクセス制御のセキュリティでは、名前付きミュー テックスが既に作成されていて、呼び出し元が持たない<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>権限、例外がスローされます。 既存のスレッドのアクティビティを同期するために必要なアクセス許可のみを持つ名前付きミュー テックスを開くを参照してください。、<xref:System.Threading.Mutex.OpenExisting%2A>メソッド。  
  
 指定した場合`null`または空の文字列の`name`、ローカル ミュー テックスが作成されたことを呼び出した場合と、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>コンス トラクター。 この場合、`createdNew`は常に`true`します。  
  
 これらは、システム全体であるために、プロセスの境界間でリソースの使用を調整する名前付きミュー テックスを使用できます。  
  
> [!NOTE]
>  ターミナル サービスを実行しているサーバーで名前付きシステム ミュー テックスには 2 つのレベルの可視性のことができます。 その名前がプレフィックスで始まる場合は、"Global\\"、ミュー テックスはすべてのターミナル サーバー セッションに表示されます。 その名前がプレフィックスで始まる場合は、"ローカル\\"、ミュー テックスが作成されたにターミナル サーバー セッションでのみ表示されます。 その場合は、同じ名前の別のミュー テックスは、それぞれのサーバー上の他のターミナル サーバー セッションに存在できます。 プレフィックスがかかる場合、名前付きミュー テックスを作成するときに、プレフィックスを指定しないと、"ローカル\\"。 ターミナル サーバー セッション内で名前のプレフィックスのみが異なる 2 つのミュー テックスは別のミュー テックス、および両方は、ターミナル サーバー セッションですべてのプロセスを表示します。 プレフィックスの名前は、"Global\\"と"ローカル\\"ミュー テックスの名前のプロセスは、ターミナル サーバー セッションを基準のスコープについて説明します。  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 次のコード例では、名前付きミュー テックスを使用してプロセスまたはスレッド間で通知する方法を示します。 このプログラムは、2 つ以上のコマンド ウィンドウから実行します。 各プロセスの作成、 <xref:System.Threading.Mutex> 「で」の名前付きミュー テックスを表すオブジェクト。 名前付きミュー テックスは、システム オブジェクトです。 この例では、その有効期間はの有効期間によって制限、<xref:System.Threading.Mutex>を表すオブジェクト。 最初のプロセスは、ローカルを作成するときに、名前付きミュー テックスが作成された<xref:System.Threading.Mutex>オブジェクト、および破棄されるときにすべて、<xref:System.Threading.Mutex>リリースされたことを表すオブジェクト。 名前付きミュー テックスは最初のプロセスで最初に所有されています。 名前付きミュー テックスを解放する以前のプロセスの 2 番目のプロセスおよび後続のプロセスを待ちます。  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned">この呼び出しの結果として名前付きシステム ミューテックスが作成された場合に、呼び出し元スレッドに名前付きシステム ミューテックスの初期所有権を付与する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="name">システム ミューテックスの名前。 値が <see langword="null" /> の場合、<see cref="T:System.Threading.Mutex" /> は無名になります。</param>
        <param name="createdNew">このメソッドから制御が戻るとき、ローカル ミューテックスが作成された場合 (つまり <paramref name="name" /> が <see langword="null" /> または空の文字列の場合) または指定した名前付きシステム ミューテックスが作成された場合は、ブール値 <see langword="true" /> が格納されます。指定した名前付きシステム ミューテックスが既に存在する場合は <see langword="false" /> が格納されます。 このパラメーターは初期化せずに渡されます。</param>
        <param name="mutexSecurity">名前付きシステム ミューテックスに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</param>
        <summary>呼び出し元のスレッドにミューテックスの初期所有権があるかどうかを示すブール値、ミューテックスの名前を表す文字列、メソッドが戻るときにミューテックスの初期所有権が呼び出し元のスレッドに付与されたかどうかを示すブール値変数、および名前付きミューテックスに適用するアクセス制御セキュリティを指定して、<see cref="T:System.Threading.Mutex" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`name`ない`null`と`initiallyOwned`は`true`、呼び出し元のスレッドが場合にのみ、名前付きミュー テックスを所有している`createdNew`は`true`呼び出しの後にします。 呼び出すことによって、スレッドがミュー テックスを要求するそれ以外の場合、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド。  
  
 このコンス トラクターを使用するが作成されると、他のコードが、ミュー テックスを乗っ取ることを防止、アクセス制御セキュリティを名前付きシステム ミュー テックスに適用できます。  
  
 このコンス トラクターの初期化を<xref:System.Threading.Mutex>名前付きシステム ミュー テックスを表すオブジェクト。 複数作成できます<xref:System.Threading.Mutex>名前付きシステム ミュー テックスを同じを表すオブジェクト。  
  
 名前付きシステム ミュー テックスが存在しない場合は、指定したアクセス制御セキュリティで作成されます。 名前付きミュー テックスが存在する場合は、指定したアクセス制御セキュリティが無視されます。  
  
> [!NOTE]
>  呼び出し元が新しく作成された完全な制御<xref:System.Threading.Mutex>オブジェクトいて`mutexSecurity`拒否するか、現在のユーザーへのいくつかのアクセス権の付与に失敗しました。 ただし場合は、現在のユーザーが別の取得を試みます<xref:System.Threading.Mutex>オブジェクトを表す、同じ名前付きミュー テックス、いずれかを使用して、コンス トラクターまたは<xref:System.Threading.Mutex.OpenExisting%2A>メソッドでは、Windows アクセス制御セキュリティを適用します。  
  
 アクセス制御のセキュリティでは、名前付きミュー テックスが既に作成されていて、呼び出し元が持たない<xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>例外がスローされます。 既存のスレッドのアクティビティを同期するために必要なアクセス許可のみを持つ名前付きミュー テックスを開くを参照してください。、<xref:System.Threading.Mutex.OpenExisting%2A>メソッド。  
  
 指定した場合`null`または空の文字列の`name`、ローカル ミュー テックスが作成されたことを呼び出した場合と、<xref:System.Threading.Mutex.%23ctor%28System.Boolean%29>コンス トラクター。 この場合、`createdNew`は常に`true`します。  
  
 これらは、システム全体であるために、プロセスの境界間でリソースの使用を調整する名前付きミュー テックスを使用できます。  
  
> [!NOTE]
>  ターミナル サービスを実行しているサーバーで名前付きシステム ミュー テックスには 2 つのレベルの可視性のことができます。 その名前がプレフィックスで始まる場合は、"Global\\"、ミュー テックスはすべてのターミナル サーバー セッションに表示されます。 その名前がプレフィックスで始まる場合は、"ローカル\\"、ミュー テックスが作成されたにターミナル サーバー セッションでのみ表示されます。 その場合は、同じ名前の別のミュー テックスは、それぞれのサーバー上の他のターミナル サーバー セッションに存在できます。 プレフィックスがかかる場合、名前付きミュー テックスを作成するときに、プレフィックスを指定しないと、"ローカル\\"。 ターミナル サーバー セッション内で名前のプレフィックスのみが異なる 2 つのミュー テックスは別のミュー テックス、および両方は、ターミナル サーバー セッションですべてのプロセスを表示します。 プレフィックスの名前は、"Global\\"と"ローカル\\"ミュー テックスの名前のプロセスは、ターミナル サーバー セッションを基準のスコープについて説明します。  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを名前付きミュー テックスのプロセス間の動作を示します。 この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29>名前付きミュー テックスの存在をテストするメソッドのオーバー ロードします。  
  
 ミュー テックスが存在しない場合は、初期所有権と、ミュー テックスを使用する権利を現在のユーザーに拒否の読み取りし、ミュー テックスのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます<xref:System.Threading.Mutex.OpenExisting%28System.String%29>します。 例外がキャッチされ、例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つ、ミュー テックスを開きます。  
  
 アクセス許可が変更された後、ミュー テックスは、入力し、解放に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用してを実行します。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスが存在し、それにアクセス制御セキュリティがありますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.FullControl" /> がありません。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が 260 文字を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>名前付きミューテックスのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクトを取得します。</summary>
        <returns>名前付きミューテックスのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.GetAccessControl%2A>メソッドは次のフラグ (ビットごとの OR 演算を使用して結合) の組み合わせを使用してアクセス許可を検索する: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>、 <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>、および<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>します。  
  
 ユーザーがいる必要があります<xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>をこのメソッドをおよび、ミュー テックスを呼び出す必要がありますが開かれていると<xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを名前付きミュー テックスのプロセス間の動作を示します。 この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29>名前付きミュー テックスの存在をテストするメソッドのオーバー ロードします。  
  
 ミュー テックスが存在しない場合は、初期所有権と、ミュー テックスを使用する権利を現在のユーザーに拒否の読み取りし、ミュー テックスのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます<xref:System.Threading.Mutex.OpenExisting%28System.String%29>します。 例外がキャッチされ、例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>メソッドのオーバー ロードを読み取ってを使用して、アクセス許可を変更するために必要な権限を持つ、ミュー テックスを開き、<xref:System.Threading.Mutex.GetAccessControl%2A>と<xref:System.Threading.Mutex.SetAccessControl%2A>メソッド。  
  
 アクセス許可が変更された後、ミュー テックスは、入力し、解放に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用してを実行します。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">現在の <see cref="T:System.Threading.Mutex" /> オブジェクトは名前付きシステム ミューテックスを表していますが、ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> がありません。  
  
- または - 
現在の <see cref="T:System.Threading.Mutex" /> オブジェクトは名前付きシステム ミューテックスを表しており、<see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" /> で開かれませんでした。</exception>
        <exception cref="T:System.NotSupportedException">Windows 98 または Windows Millennium Edition はサポートされていません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開きます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開きます。</summary>
        <returns>名前付きシステム ミューテックスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Mutex.OpenExisting%2A>メソッドを開こうと指定した名前付きシステム ミュー テックスです。 システム ミュー テックスが存在しない場合、このメソッドは、システム オブジェクトを作成する代わりに、例外をスローします。 既に存在しない場合にシステム ミュー テックスを作成するには、いずれかを使用、<xref:System.Threading.Mutex.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。  
  
 このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.Mutex>場合でも、返されるオブジェクトが同じ名前付きシステム ミュー テックスを表すオブジェクトします。  
  
 このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>メソッドのオーバー ロードを指定して<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>と<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>権限、ビットごとの OR 演算を使用して結合します。  
  
 指定する、<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>フラグによって、スレッドにミュー テックスの待機を指定して、<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>フラグによって、スレッドを呼び出す、<xref:System.Threading.Mutex.ReleaseMutex%2A>メソッド。  
  
 このメソッドは、ミュー テックスの所有権を要求しません。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを名前付きミュー テックスのプロセス間の動作を示します。 この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29>名前付きミュー テックスの存在をテストするメソッドのオーバー ロードします。  
  
 ミュー テックスが存在しない場合は、初期所有権と、ミュー テックスを使用する権利を現在のユーザーに拒否の読み取りし、ミュー テックスのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます<xref:System.Threading.Mutex.OpenExisting%28System.String%29>します。 例外がキャッチされ、例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つ、ミュー テックスを開きます。  
  
 アクセス許可が変更された後、ミュー テックスは、入力し、解放に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用してを実行します。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が空の文字列です。  
  
- または - 
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスが存在しません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <param name="rights">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</param>
        <summary>既に存在する場合は、必要なセキュリティ アクセスで指定した名前付きミューテックスを開きます。</summary>
        <returns>名前付きシステム ミューテックスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `rights`パラメーターを含める必要があります、 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 、ミュー テックスを待機するスレッドを許可するフラグ、<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>を呼び出すスレッドを許可するフラグ、<xref:System.Threading.Mutex.ReleaseMutex%2A>メソッド。  
  
 <xref:System.Threading.Mutex.OpenExisting%2A>メソッドが、既存の名前付きミュー テックスを開こうとします。 システム ミュー テックスが存在しない場合、このメソッドは、システム オブジェクトを作成する代わりに、例外をスローします。 既に存在しない場合にシステム ミュー テックスを作成するには、いずれかを使用、<xref:System.Threading.Mutex.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。  
  
 このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.Mutex>場合でも、返されるオブジェクトが同じ名前付きシステム ミュー テックスを表すオブジェクトします。  
  
 このメソッドは、ミュー テックスの所有権を要求しません。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを名前付きミュー テックスのプロセス間の動作を示します。 この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29>名前付きミュー テックスの存在をテストするメソッドのオーバー ロードします。  
  
 ミュー テックスが存在しない場合は、初期所有権と、ミュー テックスを使用する権利を現在のユーザーに拒否の読み取りし、ミュー テックスのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます<xref:System.Threading.Mutex.OpenExisting%28System.String%29>します。 例外がキャッチされ、例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つ、ミュー テックスを開きます。  
  
 アクセス許可が変更された後、ミュー テックスは、入力し、解放に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用してを実行します。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が空の文字列です。  
  
- または - 
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">名前付きミューテックスが存在しません。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスは存在しますが、必要なセキュリティ アクセスがユーザーにありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Mutex" /> を一度解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドがミュー テックスを取得するたびに (など、呼び出すことによってその<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド)、後で呼び出す必要があります<xref:System.Threading.Mutex.ReleaseMutex%2A>ミュー テックスの所有権を放棄して、ミュー テックスの所有権を取得しようとしている他のスレッドのブロックを解除します。 ミュー テックスの所有権の取得に失敗したが失敗したかどうか (への呼び出し時などに、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッドを`millisecondsTimeout`または`timeout`パラメーターを返します`false`要求がタイムアウトになるため)、スレッドを呼び出すことはできません<xref:System.Threading.Mutex.ReleaseMutex%2A>、この場合も、スレッドもできませんとして次の例は、ミュー テックスで保護されているリソースにアクセスします。  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ミュー テックスを所有するスレッドは、その実行をブロックすることがなく、繰り返される関数呼び出しで同じミュー テックスを指定できます。 呼び出しの数は、共通言語ランタイムで保持されます。 スレッドを呼び出す必要があります<xref:System.Threading.Mutex.ReleaseMutex%2A>ミュー テックスの所有権を解放するのと同じ回数。  
  
 ミュー テックスを所有しているスレッドが終了する場合、ミュー テックスを破棄するメンバーといいます。 ミュー テックスの状態がシグナル状態に設定して、次の待機スレッドが所有権を取得します。 ミュー テックスを所有していない場合、ミュー テックスの状態が通知されます。 .NET Framework のバージョン 2.0 以降では、<xref:System.Threading.AbandonedMutexException>がミュー テックスを獲得する次のスレッドでスローされます。 .NET Framework version 2.0 の前に例外がスローされません。  
  
> [!CAUTION]
>  ミュー テックスの破棄には、重大なエラー コードの多くの場合を示します。 ミュー テックスを解放しないままスレッドが終了すると、ミュー テックスで保護されているデータ構造が一貫した状態でできません。 次のスレッドにミュー テックスの所有権を要求するでは、この例外を処理でき、データ構造の整合性を検証できる場合、続行することができます。  
  
 システム全体でミューテックスが有効な場合にミューテックスが破棄されたときは、アプリケーションが強制終了されたことを示している可能性があります (たとえば、Windows タスク マネージャを使用した終了)。  
  
   
  
## Examples  
 次の例は、どのローカル<xref:System.Threading.Mutex>オブジェクトは、保護されたリソースへのアクセスを同期するために使用します。 ミュー テックスを作成するスレッドが所有していない、最初に。 <xref:System.Threading.Mutex.ReleaseMutex%2A>不要になったときにミュー テックスを解放するメソッドを使用します。  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">呼び出しスレッドに独自のミューテックスがありません。</exception>
        <exception cref="T:System.ObjectDisposedException">現在のインスタンスは既に破棄されています。</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">マネージド スレッド処理</related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md">ミューテックス</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity">名前付きシステム ミューテックスに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.MutexSecurity" /> オブジェクト。</param>
        <summary>名前付きシステム ミューテックスのアクセス制御セキュリティを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーがいる必要があります<xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>で、このメソッドと、ミュー テックスを呼び出す権限が開かれている必要があります<xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>します。  
  
   
  
## Examples  
 次のコード例では、アクセス制御セキュリティを名前付きミュー テックスのプロセス間の動作を示します。 この例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%29>名前付きミュー テックスの存在をテストするメソッドのオーバー ロードします。  
  
 ミュー テックスが存在しない場合は、初期所有権と、ミュー テックスを使用する権利を現在のユーザーに拒否の読み取りし、ミュー テックスのアクセス許可を変更する権限を付与するアクセス制御セキュリティで作成されます。  
  
 2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます<xref:System.Threading.Mutex.OpenExisting%28System.String%29>します。 例外がキャッチされ、例では、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>メソッドのオーバー ロードを読み取ってを使用して、アクセス許可を変更するために必要な権限を持つ、ミュー テックスを開き、<xref:System.Threading.Mutex.GetAccessControl%2A>と<xref:System.Threading.Mutex.SetAccessControl%2A>メソッド。  
  
 アクセス許可が変更された後、ミュー テックスは、入力し、解放に必要な権限で開かれます。 3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用してを実行します。  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="mutexSecurity" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.UnauthorizedAccessException">ユーザーに <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> がありません。  
  
- または - 
ミューテックスは <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" /> で開かれませんでした。</exception>
        <exception cref="T:System.SystemException">現在の <see cref="T:System.Threading.Mutex" /> オブジェクトは名前付きシステム ミューテックスを表していません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開き操作が成功したかどうかを示す値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <param name="result">このメソッドから戻るときに、呼び出しに成功した場合は名前付きミューテックスを表す <see cref="T:System.Threading.Mutex" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。 このパラメーターは初期化前として処理されます。</param>
        <summary>既に存在する場合は、指定した名前付きミューテックスを開き操作が成功したかどうかを示す値を返します。</summary>
        <returns>名前付きミューテックスが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前付きミュー テックスが存在しない場合このメソッドはいない作成しません。 既に存在しない場合にシステム ミュー テックスを作成するには、いずれかを使用、<xref:System.Threading.Mutex.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。  
  
 名前付きミュー テックスが存在するかどうかが不明な場合は、代わりにこのメソッドのオーバー ロードを使用して、<xref:System.Threading.Mutex.OpenExisting%28System.String%29>メソッド オーバー ロードで、ミュー テックスが存在しない場合は、例外をスローします。  
  
 このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.Mutex>場合でも、返されるオブジェクトが同じ名前付きシステム ミュー テックスを表すオブジェクトします。  
  
 このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29>メソッドのオーバー ロードを指定して<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>と<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>権限、ビットごとの OR 演算を使用して結合します。 指定する、<xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType>フラグによって、スレッドにミュー テックスの待機を指定して、<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>フラグによって、スレッドを呼び出す、<xref:System.Threading.Mutex.ReleaseMutex%2A>メソッド。  
  
 このメソッドは、ミュー テックスの所有権を要求しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が空の文字列です。  
  
- または - 
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">開くシステム ミューテックスの名前。</param>
        <param name="rights">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</param>
        <param name="result">このメソッドから戻るときに、呼び出しに成功した場合は名前付きミューテックスを表す <see cref="T:System.Threading.Mutex" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。 このパラメーターは初期化前として処理されます。</param>
        <summary>既に存在する場合は、必要なセキュリティ アクセスを使用して指定した名前付きミューテックスを開き、操作が成功したかどうかを示す値を返します。</summary>
        <returns>名前付きミューテックスが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前付きミュー テックスが存在しない場合このメソッドはいない作成しません。 既に存在しない場合にシステム ミュー テックスを作成するには、いずれかを使用、<xref:System.Threading.Mutex.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。  
  
 名前付きミュー テックスが存在するかどうかが不明な場合は、代わりにこのメソッドのオーバー ロードを使用して、<xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29>メソッド オーバー ロードで、ミュー テックスが存在しない場合は、例外をスローします。  
  
 `rights`パラメーターを含める必要があります、 <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> 、ミュー テックスを待機するスレッドを許可するフラグ、<xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType>を呼び出すスレッドを許可するフラグ、<xref:System.Threading.Mutex.ReleaseMutex%2A>メソッド。  
  
 このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.Mutex>場合でも、返されるオブジェクトが同じ名前付きシステム ミュー テックスを表すオブジェクトします。  
  
 このメソッドは、ミュー テックスの所有権を要求しません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> が空の文字列です。  
  
- または - 
 <paramref name="name" /> が 260 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.IOException">Win32 エラーが発生しました。</exception>
        <exception cref="T:System.UnauthorizedAccessException">名前付きミューテックスは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
  </Members>
</Type>