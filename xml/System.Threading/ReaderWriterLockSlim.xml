<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3464038fcf06fcd6ab722a9c4b6f82b812141c99" /><Meta Name="ms.sourcegitcommit" Value="84c54c0c7d64827a5637d1f05e74e1f0598606a1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="08/27/2018" /><Meta Name="ms.locfileid" Value="42942854" /></Metadata><TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="d0e27-101">リソースへのアクセス管理に使用するロックを表し、複数のスレッドによる読み取りや排他アクセスでの書き込みを許可します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-101">Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-102">使用<xref:System.Threading.ReaderWriterLockSlim>複数のスレッドによって読み取られ、一度に 1 つのスレッドによって書き込むされるリソースを保護します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-102">Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time.</span></span> <span data-ttu-id="d0e27-103"><xref:System.Threading.ReaderWriterLockSlim> 読み取りモードに設定する複数のスレッドは、1 つのスレッドのロックの排他的所有権を書き込みモードであるできにより、元のスレッドが解放することがなく書き込みモードにアップグレードできます、アップグレード可能読み取りモードに設定する読み取りアクセス権を持つ 1 つのスレッドリソースへの読み取りアクセス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-103"><xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-104"><xref:System.Threading.ReaderWriterLockSlim> は <xref:System.Threading.ReaderWriterLock> と似ていますが、再帰の規則や、ロック状態のアップグレードおよびダウングレードの規則が簡素化されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="d0e27-105"><xref:System.Threading.ReaderWriterLockSlim> は、デッドロックの可能性を大幅に回避します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="d0e27-106">さらに、<xref:System.Threading.ReaderWriterLockSlim> のパフォーマンスは <xref:System.Threading.ReaderWriterLock> と比較して格段に優れています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="d0e27-107">すべての新規開発で、<xref:System.Threading.ReaderWriterLockSlim> を使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-107"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span>  
  
 <span data-ttu-id="d0e27-108">既定での新しいインスタンス<xref:System.Threading.ReaderWriterLockSlim>で作成された、<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>フラグを設定し、再帰ではできません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-108">By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> flag and do not allow recursion.</span></span> <span data-ttu-id="d0e27-109">再帰が不要な複雑さを紹介し、により、コードのデッドロックが発生しやすいため、すべての新しい開発では、この既定のポリシーお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-109">This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</span></span> <span data-ttu-id="d0e27-110">既存のファイルからの移行を簡略化するプロジェクトを使用する<xref:System.Threading.Monitor>または<xref:System.Threading.ReaderWriterLock>、使用することができます、<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>フラグのインスタンスを作成する<xref:System.Threading.ReaderWriterLockSlim>再帰を使用できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-110">To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.</span></span>  
  
 <span data-ttu-id="d0e27-111">スレッドは 3 つのモードでロックに入ることができます。 読み取りモード、書き込みモード、およびアップグレード可能読み取りモード。</span><span class="sxs-lookup"><span data-stu-id="d0e27-111">A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</span></span> <span data-ttu-id="d0e27-112">(このトピックの残りの部分に「アップグレード可能読み取りモード」を参照「アップグレード可能モード」と"入力`x`モード"長い語句方が優先的に使用されます"でロックに入る`x`モード".)</span><span class="sxs-lookup"><span data-stu-id="d0e27-112">(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter `x` mode" is used in preference to the longer phrase "enter the lock in `x` mode".)</span></span>  
  
 <span data-ttu-id="d0e27-113">再帰ポリシーに関係なく 1 つのスレッドが書き込みモードで、いつでもすることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-113">Regardless of recursion policy, only one thread can be in write mode at any time.</span></span> <span data-ttu-id="d0e27-114">スレッドは書き込みモードでは、他のスレッドできますなしでロックに入るのモード。</span><span class="sxs-lookup"><span data-stu-id="d0e27-114">When a thread is in write mode, no other thread can enter the lock in any mode.</span></span> <span data-ttu-id="d0e27-115">1 つのスレッドをいつでもアップグレード可能モードでできます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-115">Only one thread can be in upgradeable mode at any time.</span></span> <span data-ttu-id="d0e27-116">任意の数のスレッドが読み取りモードであることができますが 1 つのスレッドでありアップグレード可能モードの他のスレッドが読み取りモードでは。</span><span class="sxs-lookup"><span data-stu-id="d0e27-116">Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d0e27-117">この型は、<xref:System.IDisposable>インターフェイス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-117">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="d0e27-118">型の使用が完了したら、直接的または間接的にそれを破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-118">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="d0e27-119">型の直接 dispose を呼び出してその<xref:System.IDisposable.Dispose%2A>メソッド、 `try` / `catch`ブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-119">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="d0e27-120">直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(で C# の場合) または`Using`(Visual Basic) でします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-120">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="d0e27-121">詳細については、"を使用して、オブジェクトを実装する IDisposable"のセクションを参照してください、<xref:System.IDisposable>インターフェイスに関するトピック。</span><span class="sxs-lookup"><span data-stu-id="d0e27-121">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="d0e27-122"><xref:System.Threading.ReaderWriterLockSlim> マネージ スレッドの関係が設定されました。つまり、各<xref:System.Threading.Thread>オブジェクトを入力し、ロック モードを終了する独自のメソッド呼び出しを行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-122"><xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes.</span></span> <span data-ttu-id="d0e27-123">スレッドが別のスレッドのモードを変更できるはありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-123">No thread can change the mode of another thread.</span></span>  
  
 <span data-ttu-id="d0e27-124">場合、<xref:System.Threading.ReaderWriterLockSlim>再帰では、スレッド ロックを試行のいくつかの理由からブロックされる可能性はできません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-124">If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</span></span>  
  
-   <span data-ttu-id="d0e27-125">スレッドが書き込みモードまたは書き込みモードで 1 つのスレッドがあるかどうかに入力を待機しているブロックの読み取りモードに入ろうとするスレッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-125">A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d0e27-126">書き込みを優先するロックの公平性ポリシーは、ライターがキューに置かれたときに、新しいリーダーをブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-126">Blocking new readers when writers are queued is a lock fairness policy that favors writers.</span></span> <span data-ttu-id="d0e27-127">現在の公平性ポリシーは、最も一般的なシナリオでのスループットを昇格するには、リーダーとライターに公平性を分散します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-127">The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</span></span> <span data-ttu-id="d0e27-128">将来のバージョン、[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]公平性の新しいポリシーを生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-128">Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.</span></span>  
  
-   <span data-ttu-id="d0e27-129">既にある場合、スレッドでアップグレード可能モードでは、スレッドが書き込みモードに入るを待機している場合、または 1 つのスレッドが書き込みモードである場合は、アップグレード可能モードのブロックを入力しようとするスレッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-129">A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</span></span>  
  
-   <span data-ttu-id="d0e27-130">3 つのモードのいずれかのスレッドがある場合、書き込みモードのブロックを入力しようとするスレッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-130">A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</span></span>  
  
## <a name="upgrading-and-downgrading-locks"></a><span data-ttu-id="d0e27-131">アップグレードおよびダウン グレードをロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-131">Upgrading and Downgrading Locks</span></span>  
 <span data-ttu-id="d0e27-132">場合、スレッドは、通常は、保護されたリソースから読み取ります。 アップグレード可能モードが対象としていますが、いくつかの条件が満たされた場合は、書き込みを行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-132">Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</span></span> <span data-ttu-id="d0e27-133">入力したスレッドを<xref:System.Threading.ReaderWriterLockSlim>アップグレード可能モードでは、保護されたリソースへの読み取りアクセスと、呼び出すことによって書き込みモードにアップグレードできます、<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>または<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-133">A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods.</span></span> <span data-ttu-id="d0e27-134">再帰は許可されていない場合、これは、既定のポリシーは、存在できますが、1 つのスレッド アップグレード可能モードで、一度にためにデッドロック書き込みモードにアップグレードすることはできません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-134">Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d0e27-135">再帰ポリシーに関係なくは、最初に入ったスレッドはアップグレード可能モードまたは書き込みのモードにアップグレードするには、そのパターンがデッドロックの可能性を作成するため、モードは使用できませんを読み取る。</span><span class="sxs-lookup"><span data-stu-id="d0e27-135">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span> <span data-ttu-id="d0e27-136">たとえば、両方を入力しようとして読み取りモードでの 2 つのスレッドは書き込みモード場合がデッドロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-136">For example, if two threads in read mode both try to enter write mode, they will deadlock.</span></span> <span data-ttu-id="d0e27-137">アップグレード可能モードは、このようなデッドロックを回避するために設計されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-137">Upgradeable mode is designed to avoid such deadlocks.</span></span>  
  
 <span data-ttu-id="d0e27-138">読み取りモード、ブロックがアップグレード中のスレッドで他のスレッドがある場合です。</span><span class="sxs-lookup"><span data-stu-id="d0e27-138">If there are other threads in read mode, the thread that is upgrading blocks.</span></span> <span data-ttu-id="d0e27-139">スレッドがブロックされている間に読み取りモードに入ろうとする他のスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-139">While the thread is blocked, other threads that try to enter read mode are blocked.</span></span> <span data-ttu-id="d0e27-140">読み取りモードからすべてのスレッドが終了したときにブロックされているアップグレード可能なスレッドは書き込みモードになります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-140">When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</span></span> <span data-ttu-id="d0e27-141">入力を待機している他のスレッドは書き込みモードは、アップグレード可能モードでは、1 つのスレッドがそのリソースに排他アクセスできないため、引き続きブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-141">If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</span></span>  
  
 <span data-ttu-id="d0e27-142">アップグレード可能モードでのスレッドが書き込みモードを終了すると、入力を待機しているスレッドが書き込みモードがないため、読み取りモードに入るを待機している他のスレッドが実行できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-142">When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</span></span> <span data-ttu-id="d0e27-143">アップグレード可能モードでのスレッドがアップグレードし、保護されたリソースへの書き込みを唯一のスレッドがある限り、無期限にダウン グレードできます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-143">The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d0e27-144">入力に複数のスレッドを許可する場合は、書き込みモードまたはアップグレード可能モードでは、1 つのスレッドがアップグレード可能モードを独占できないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-144">If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</span></span> <span data-ttu-id="d0e27-145">それ以外の場合、モード直接は無限にブロック、および他のスレッドが読み取りモードに入ることなりますがブロックされているときに入力しようとするスレッドを記述します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-145">Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</span></span>  
  
 <span data-ttu-id="d0e27-146">アップグレード可能モードでのスレッドは、最初の呼び出しで、読み取りモードにダウン グレードできますが、<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>メソッドを呼び出して、<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-146">A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method.</span></span> <span data-ttu-id="d0e27-147">このダウン グレード パターンが、すべてのロック再帰ポリシーも許可されている<xref:System.Threading.LockRecursionPolicy.NoRecursion>します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-147">This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.</span></span>  
  
 <span data-ttu-id="d0e27-148">読み取りモードにダウン グレードする場合、スレッドことはできませんを再入力モードに入る読み取りモードを終了するまでです。</span><span class="sxs-lookup"><span data-stu-id="d0e27-148">After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</span></span>  
  
## <a name="entering-the-lock-recursively"></a><span data-ttu-id="d0e27-149">再帰的にロックを入力します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-149">Entering the Lock Recursively</span></span>  
 <span data-ttu-id="d0e27-150">作成することができます、<xref:System.Threading.ReaderWriterLockSlim>を使用して再帰的なロックのエントリをサポートする、<xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29>ロックのポリシーと指定することを指定するコンス トラクター<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-150">You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-151">再帰の使用は、不要な複雑さを紹介し、により、コードのデッドロックが発生しやすいため、新規開発では推奨されません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-151">The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</span></span>  
  
 <span data-ttu-id="d0e27-152"><xref:System.Threading.ReaderWriterLockSlim>再帰を利用できる、スレッドが入力できるモードについて、次と言えます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-152">For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:</span></span>  
  
-   <span data-ttu-id="d0e27-153">読み取りモードでのスレッドは読み取りモードを再帰的を入力できますが、書き込みモードやアップグレード可能モードを入力することはできません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-153">A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</span></span> <span data-ttu-id="d0e27-154">これを行うにしようとすると、<xref:System.Threading.LockRecursionException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-154">If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown.</span></span> <span data-ttu-id="d0e27-155">入力モードと入力し、書き込みモードか、許可されていないために、アップグレード可能モードは、デッドロックの確率が厳密なパターンを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-155">Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</span></span> <span data-ttu-id="d0e27-156">前述のように、アップグレード可能モードは、ロックをアップグレードする必要がある場合に提供されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-156">As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</span></span>  
  
-   <span data-ttu-id="d0e27-157">アップグレード可能モードでのスレッドでは、書き込みモードまたは読み取りモードに入力して、3 つのモードの再帰的のいずれかを入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-157">A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</span></span> <span data-ttu-id="d0e27-158">ただし、入力しようとすると、書き込みモードのブロック読み取りモードに他のスレッドがあるかどうか。</span><span class="sxs-lookup"><span data-stu-id="d0e27-158">However, an attempt to enter write mode blocks if there are other threads in read mode.</span></span>  
  
-   <span data-ttu-id="d0e27-159">書き込みモードでのスレッドでは、読み取りモードやアップグレード可能モードに入力して、3 つのモードの再帰的のいずれかを入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-159">A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</span></span>  
  
-   <span data-ttu-id="d0e27-160">ロックに入っていませんが、スレッドは、どのモードを入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-160">A thread that has not entered the lock can enter any mode.</span></span> <span data-ttu-id="d0e27-161">この試行は、非再帰的なロックを入力しようと同じ理由でブロックできます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-161">This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</span></span>  
  
 <span data-ttu-id="d0e27-162">スレッドは、何度でも、そのモードに入ったこととまったく同じには、各モードを終了している限り、任意の順序で入力がモードを終了できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-162">A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</span></span> <span data-ttu-id="d0e27-163">スレッドの試行回数が多すぎますモードを終了するかは入っていませんモードを終了する場合、<xref:System.Threading.SynchronizationLockException>がスローされます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-163">If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.</span></span>  
  
## <a name="lock-states"></a><span data-ttu-id="d0e27-164">ロックの状態</span><span class="sxs-lookup"><span data-stu-id="d0e27-164">Lock States</span></span>  
 <span data-ttu-id="d0e27-165">その状態の用語では、ロックを考えると便利です。</span><span class="sxs-lookup"><span data-stu-id="d0e27-165">You may find it useful to think of the lock in terms of its states.</span></span> <span data-ttu-id="d0e27-166">A <xref:System.Threading.ReaderWriterLockSlim> 4 つの状態のいずれかであることができます。 入力されていません、読み取り、アップグレード、および記述します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-166">A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.</span></span>  
  
-   <span data-ttu-id="d0e27-167">入力されていません。 この状態でスレッドがロックに入ってない (またはすべてのスレッドがロックを終了)。</span><span class="sxs-lookup"><span data-stu-id="d0e27-167">Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</span></span>  
  
-   <span data-ttu-id="d0e27-168">読む: この状態で、1 つまたは複数のスレッド ロックに入った読み取りアクセスの保護されたリソースにします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-168">Read: In this state, one or more threads have entered the lock for read access to the protected resource.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="d0e27-169">スレッドを使用して読み取りモードでロックを入力することができます、<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>または<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>メソッド、またはアップグレード可能モードからダウン グレードします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-169">A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.</span></span>  
  
-   <span data-ttu-id="d0e27-170">アップグレード: この状態で、1 つのスレッドがロックに入った書き込みアクセスにアップグレードするオプションを使用して読み取りアクセス用 (つまり、アップグレード可能モードで)、読み取りアクセス用に 0 個以上のスレッドがロックに入っているとします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-170">Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</span></span> <span data-ttu-id="d0e27-171">一度に複数のスレッドは; をアップグレードするオプションを使用してロックを入力できます。アップグレード可能モードを開始しようとする追加のスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-171">No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</span></span>  
  
-   <span data-ttu-id="d0e27-172">書き込み: この状態で、1 つのスレッドがロックに入った書き込みアクセス権の保護されたリソースに。</span><span class="sxs-lookup"><span data-stu-id="d0e27-172">Write: In this state, one thread has entered the lock for write access to the protected resource.</span></span> <span data-ttu-id="d0e27-173">そのスレッドは、ロックを所有している排他的です。</span><span class="sxs-lookup"><span data-stu-id="d0e27-173">That thread has exclusive possession of the lock.</span></span> <span data-ttu-id="d0e27-174">何らかの理由でロックに入ろうとするその他のスレッドがブロックされます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-174">Any other thread that tries to enter the lock for any reason is blocked.</span></span>  
  
 <span data-ttu-id="d0e27-175">次の表に、再帰では、ときにスレッドを許可しないロックのロックの状態間の遷移`t`左端の列で説明されているアクションを実行します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-175">The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column.</span></span> <span data-ttu-id="d0e27-176">時に、その操作を行う`t`モードがありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-176">At the time it takes the action, `t` has no mode.</span></span> <span data-ttu-id="d0e27-177">(特殊なケース場所`t`では、アップグレード可能モードは、表の脚注に記載されています)。一番上の行では、ロックの開始時の状態について説明します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-177">(The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</span></span> <span data-ttu-id="d0e27-178">セルは、スレッドの処理について説明し、かっこで囲まれたロック状態の変更を表示します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-178">The cells describe what happens to the thread, and show changes to the lock state in parentheses.</span></span>  
  
||<span data-ttu-id="d0e27-179">入っていない (N)</span><span class="sxs-lookup"><span data-stu-id="d0e27-179">Not entered (N)</span></span>|<span data-ttu-id="d0e27-180">Read (R)</span><span class="sxs-lookup"><span data-stu-id="d0e27-180">Read (R)</span></span>|<span data-ttu-id="d0e27-181">アップグレード (U)</span><span class="sxs-lookup"><span data-stu-id="d0e27-181">Upgrade (U)</span></span>|<span data-ttu-id="d0e27-182">書き込み (W)</span><span class="sxs-lookup"><span data-stu-id="d0e27-182">Write (W)</span></span>|  
|-|-----------------------|----------------|-------------------|-----------------|  
|<span data-ttu-id="d0e27-183">`t` 読み取りモードに入ります</span><span class="sxs-lookup"><span data-stu-id="d0e27-183">`t` enters read mode</span></span>|<span data-ttu-id="d0e27-184">`t` (R) を入力します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-184">`t` enters (R).</span></span>|<span data-ttu-id="d0e27-185">`t` スレッドが書き込みモードを待機している場合それ以外の場合、`t`を入力します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-185">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.</span></span>|<span data-ttu-id="d0e27-186">`t` スレッドが書き込みモードを待機している場合それ以外の場合、`t`を入力します<sup>。1</sup></span><span class="sxs-lookup"><span data-stu-id="d0e27-186">`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup></span></span>|<span data-ttu-id="d0e27-187">`t` ブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-187">`t` blocks.</span></span>|  
|<span data-ttu-id="d0e27-188">`t` アップグレード可能モードに入る</span><span class="sxs-lookup"><span data-stu-id="d0e27-188">`t` enters upgradeable mode</span></span>|<span data-ttu-id="d0e27-189">`t` (U) を入力します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-189">`t` enters (U).</span></span>|<span data-ttu-id="d0e27-190">`t` スレッドが待機している場合は書き込みモードまたはアップグレード モードです。それ以外の場合、 `t` (U) を入力します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-190">`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).</span></span>|<span data-ttu-id="d0e27-191">`t` ブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-191">`t` blocks.</span></span>|<span data-ttu-id="d0e27-192">`t` ブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-192">`t` blocks.</span></span>|  
|<span data-ttu-id="d0e27-193">`t` 書き込みモードに入ります</span><span class="sxs-lookup"><span data-stu-id="d0e27-193">`t` enters write mode</span></span>|<span data-ttu-id="d0e27-194">`t` 入力 (W)。</span><span class="sxs-lookup"><span data-stu-id="d0e27-194">`t` enters (W).</span></span>|<span data-ttu-id="d0e27-195">`t` ブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-195">`t` blocks.</span></span>|<span data-ttu-id="d0e27-196">`t` ブロックします。<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="d0e27-196">`t` blocks.<sup>2</sup></span></span>|<span data-ttu-id="d0e27-197">`t` ブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-197">`t` blocks.</span></span>|  
  
 <span data-ttu-id="d0e27-198"><sup>1</sup>場合`t`開始がアップグレード可能モードで読み取りモードに入ります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-198"><sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode.</span></span> <span data-ttu-id="d0e27-199">この操作を決してをブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-199">This action never blocks.</span></span> <span data-ttu-id="d0e27-200">ロックの状態は変更されません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-200">The lock state does not change.</span></span> <span data-ttu-id="d0e27-201">(スレッドは、アップグレード可能モードを終了することによって読み取りモードにダウン グレードを完了できますし、)。</span><span class="sxs-lookup"><span data-stu-id="d0e27-201">(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</span></span>  
  
 <span data-ttu-id="d0e27-202"><sup>2</sup>場合`t`スレッドが読み取りモードである場合、ブロックするアップグレード可能モードで起動します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-202"><sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode.</span></span> <span data-ttu-id="d0e27-203">それ以外の場合、これは書き込みモードにアップグレードします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-203">Otherwise it upgrades to write mode.</span></span> <span data-ttu-id="d0e27-204">ロック状態の変化に書き込み (W)。</span><span class="sxs-lookup"><span data-stu-id="d0e27-204">The lock state changes to Write (W).</span></span> <span data-ttu-id="d0e27-205">場合`t`スレッドが読み取りモードであるため、ブロックが最後のスレッドが読み取りモードを終了するとすぐに書き込みモードに入る、入力を待機しているスレッドが書き込みモードである場合でもです。</span><span class="sxs-lookup"><span data-stu-id="d0e27-205">If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="d0e27-206">スレッドがロックを終了したため、状態の変更が発生したときに解除するのには、次のスレッドとしては、次のように選択されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-206">When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</span></span>  
  
-   <span data-ttu-id="d0e27-207">最初に、待機しているスレッドは書き込みモードと、(あります多くてこのような 1 つのスレッド) アップグレード可能モードでは既にします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-207">First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</span></span>  
  
-   <span data-ttu-id="d0e27-208">それがない場合は、書き込みモードを待機しているスレッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-208">Failing that, a thread that is waiting for write mode.</span></span>  
  
-   <span data-ttu-id="d0e27-209">それがない場合は、アップグレード可能モードを待機しているスレッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-209">Failing that, a thread that is waiting for upgradeable mode.</span></span>  
  
-   <span data-ttu-id="d0e27-210">読み取りモードを待機しているすべてのスレッドが、失敗します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-210">Failing that, all threads that are waiting for read mode.</span></span>  
  
 <span data-ttu-id="d0e27-211">ロックの後続の状態は常に書き込み (W)、最初の 2 つのケースとアップグレード (U) ロック状態の変更がトリガーされると、既存のスレッドの状態に関係なく、3 番目のケースで。</span><span class="sxs-lookup"><span data-stu-id="d0e27-211">The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</span></span> <span data-ttu-id="d0e27-212">最後の場合は、ロックの状態はアップグレード (U) 場合は、スレッドはアップグレード可能モードで、状態の変化と Read (R) 後それ以外の場合、以前の状態に関係なく。</span><span class="sxs-lookup"><span data-stu-id="d0e27-212">In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-213">次の例は、整数キーを持つ文字列を保持するための単純な同期キャッシュです。</span><span class="sxs-lookup"><span data-stu-id="d0e27-213">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="d0e27-214">インスタンス<xref:System.Threading.ReaderWriterLockSlim>へのアクセスを同期するため、<xref:System.Collections.Generic.Dictionary%602>内部キャッシュとして機能します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-214">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span>  
  
 <span data-ttu-id="d0e27-215">この例には、キャッシュに追加、キャッシュから削除し、キャッシュから読み取られた単純なメソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-215">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="d0e27-216">タイムアウトを示すためには、例には、指定されたタイムアウト内で行うことができる場合にのみをキャッシュに追加するメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-216">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="d0e27-217">アップグレード可能モードを示すためには、例は、キーに関連付けられた値を取得するメソッドが含まれています、新しい値を比較します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-217">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="d0e27-218">値が変更されていない場合、メソッドは、変更がないことを示すステータスを返します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-218">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="d0e27-219">キーの値が見つからない場合は、キー/値ペアが挿入されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-219">If no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="d0e27-220">値が変更された場合は更新されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-220">If the value has changed, it is updated.</span></span> <span data-ttu-id="d0e27-221">アップグレード可能モード スレッドのデッドロックのリスクを負うことがなく、必要に応じて、書き込みアクセス権への読み取りアクセスからアップグレードすることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-221">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="d0e27-222">この例には、アップグレード可能モードを示すメソッドの戻り値を指定する入れ子になった列挙が含まれています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-222">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="d0e27-223">例では、既定のコンス トラクターを使用して、再帰は許可されていませんので、ロックを作成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-223">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="d0e27-224">プログラミング、<xref:System.Threading.ReaderWriterLockSlim>ロックで再帰が許可されていない場合は、エラーの間違いを犯しにくい。</span><span class="sxs-lookup"><span data-stu-id="d0e27-224">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="d0e27-225">次のコードの使用、`SynchronizedCache`野菜名のディクショナリを格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="d0e27-225">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="d0e27-226">3 つのタスクを作成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-226">It creates three tasks.</span></span> <span data-ttu-id="d0e27-227">最初の配列に格納されている野菜の名前を書き込みます、`SynchronizedCache`インスタンス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-227">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="d0e27-228">2 番目と 3 番目のタスクでは、野菜、昇順 (不足インデックスから最も大きいインデックス)、降順で、2 つ目の最初の名前を表示します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-228">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="d0e27-229">最後のタスクは、文字列"cucumber"を検索し、それを見つけたときに呼び出す、 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> "緑 bean"文字列を置換するメソッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-229">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="d0e27-230">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="d0e27-230">This type is thread safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d0e27-231"><see cref="T:System.Threading.ReaderWriterLockSlim" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-231">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d0e27-232"><see cref="T:System.Threading.ReaderWriterLockSlim" /> クラスの新しいインスタンスを既定のプロパティ値で初期化します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-232">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-233">A<xref:System.Threading.ReaderWriterLockSlim>これで初期化されるコンス トラクターでは、再帰することはできません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-233">A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion.</span></span> <span data-ttu-id="d0e27-234">つまり、<xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> プロパティが <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> を返します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-234">That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d0e27-235">再帰ポリシーとその影響の詳細については、次を参照してください。、<xref:System.Threading.LockRecursionPolicy>列挙と<xref:System.Threading.ReaderWriterLockSlim>クラス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-235">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-236">次の例は、整数キーを持つ文字列を保持するための単純な同期キャッシュです。</span><span class="sxs-lookup"><span data-stu-id="d0e27-236">The following example shows a simple synchronized cache that holds strings with integer keys.</span></span> <span data-ttu-id="d0e27-237">インスタンス<xref:System.Threading.ReaderWriterLockSlim>へのアクセスを同期するため、<xref:System.Collections.Generic.Dictionary%602>内部キャッシュとして機能します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-237">An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.</span></span> <span data-ttu-id="d0e27-238">パラメーターなしのコンス トラクターは、ロックの作成に使用されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-238">The parameterless constructor is used to create the lock.</span></span>  
  
 <span data-ttu-id="d0e27-239">この例には、キャッシュに追加、キャッシュから削除し、キャッシュから読み取られた単純なメソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-239">The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</span></span> <span data-ttu-id="d0e27-240">タイムアウトを示すためには、例には、指定されたタイムアウト内で行うことができる場合にのみをキャッシュに追加するメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-240">To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</span></span>  
  
 <span data-ttu-id="d0e27-241">アップグレード可能モードを示すためには、例は、キーに関連付けられた値を取得するメソッドが含まれています、新しい値を比較します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-241">To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="d0e27-242">値が変更されていない場合、メソッドは、変更がないことを示すステータスを返します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-242">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="d0e27-243">これは、値が見つからない場合、キー、キー/値ペアが挿入されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-243">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="d0e27-244">値が変更された場合は更新されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-244">If the value has changed, it is updated.</span></span> <span data-ttu-id="d0e27-245">アップグレード可能モード スレッドのデッドロックのリスクを負うことがなく、必要に応じて、書き込みアクセス権への読み取りアクセスからアップグレードすることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-245">Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</span></span>  
  
 <span data-ttu-id="d0e27-246">この例には、アップグレード可能モードを示すメソッドの戻り値を指定する入れ子になった列挙が含まれています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-246">The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</span></span>  
  
 <span data-ttu-id="d0e27-247">例では、既定のコンス トラクターを使用して、再帰は許可されていませんので、ロックを作成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-247">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="d0e27-248">プログラミング、<xref:System.Threading.ReaderWriterLockSlim>ロックで再帰が許可されていない場合は、エラーの間違いを犯しにくい。</span><span class="sxs-lookup"><span data-stu-id="d0e27-248">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 <span data-ttu-id="d0e27-249">次のコードの使用、`SynchronizedCache`野菜名のディクショナリを格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="d0e27-249">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="d0e27-250">3 つのタスクを作成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-250">It creates three tasks.</span></span> <span data-ttu-id="d0e27-251">最初の配列に格納されている野菜の名前を書き込みます、`SynchronizedCache`インスタンス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-251">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="d0e27-252">2 番目と 3 番目のタスクでは、野菜、昇順 (不足インデックスから最も大きいインデックス)、降順で、2 つ目の最初の名前を表示します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-252">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="d0e27-253">最後のタスクは、文字列"cucumber"を検索し、それを見つけたときに呼び出す、 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> "緑 bean"文字列を置換するメソッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-253">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy"><span data-ttu-id="d0e27-254">ロック再帰ポリシーを指定する列挙値のいずれか。</span><span class="sxs-lookup"><span data-stu-id="d0e27-254">One of the enumeration values that specifies the lock recursion policy.</span></span></param>
        <summary><span data-ttu-id="d0e27-255">ロック再帰ポリシーを指定して、<see cref="T:System.Threading.ReaderWriterLockSlim" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-255">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-256">再帰ポリシーでは、複数回ロックに入るスレッドに関する制限事項を決定します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-256">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="d0e27-257">たとえば、ロックを使用して作成されました<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>スレッドは読み取りモードでロックに入ってと<xref:System.Threading.LockRecursionException>スレッド読み取りモードでロックを再入力しようとする場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-257">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span> <span data-ttu-id="d0e27-258">同様に、スレッドが書き込みモードでロックに入った場合は、<xref:System.Threading.LockRecursionException>スレッド モードでロックを再入力しようとする場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-258">Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-259">アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りロック再帰ポリシーの設定に関係なくモードにダウン グレードすることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-259">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="d0e27-260">再帰ポリシーに関係なくは、最初に入ったスレッドはアップグレード可能モードまたは書き込みのモードにアップグレードするには、そのパターンがデッドロックの可能性を作成するため、モードは使用できませんを読み取る。</span><span class="sxs-lookup"><span data-stu-id="d0e27-260">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="d0e27-261">再帰ポリシーとその影響の詳細については、次を参照してください。、<xref:System.Threading.LockRecursionPolicy>列挙と<xref:System.Threading.ReaderWriterLockSlim>クラス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-261">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-262">次の例は、いずれかに依存している 2 つの例外シナリオ、<xref:System.Threading.LockRecursionPolicy>設定し、1 つにはないです。</span><span class="sxs-lookup"><span data-stu-id="d0e27-262">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="d0e27-263">最初のシナリオでは、スレッドは読み取りモードに入り、再帰的に読み取りモードに入ろいます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-263">In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="d0e27-264">場合、<xref:System.Threading.ReaderWriterLockSlim>再帰ポリシーを設定の既定のコンス トラクターを使用して作成<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-264">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="d0e27-265">場合<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>を作成するために使用、<xref:System.Threading.ReaderWriterLockSlim>例外はスローされません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-265">If <xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="d0e27-266">2 番目のシナリオでは、スレッドが読み取りモードになり、入力しようモードを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-266">In the second scenario, the thread enters read mode and then tries to enter write mode.</span></span> <span data-ttu-id="d0e27-267"><xref:System.Threading.LockRecursionException> ロック再帰ポリシーに関係なくがスローされます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-267"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 <span data-ttu-id="d0e27-268">次のコードの使用、`SynchronizedCache`野菜名のディクショナリを格納するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="d0e27-268">The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names.</span></span> <span data-ttu-id="d0e27-269">3 つのタスクを作成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-269">It creates three tasks.</span></span> <span data-ttu-id="d0e27-270">最初の配列に格納されている野菜の名前を書き込みます、`SynchronizedCache`インスタンス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-270">The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance.</span></span> <span data-ttu-id="d0e27-271">2 番目と 3 番目のタスクでは、野菜、昇順 (不足インデックスから最も大きいインデックス)、降順で、2 つ目の最初の名前を表示します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-271">The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</span></span> <span data-ttu-id="d0e27-272">最後のタスクは、文字列"cucumber"を検索し、それを見つけたときに呼び出す、 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> "緑 bean"文字列を置換するメソッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-272">The final task searches for the string "cucumber" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string "green bean".</span></span>  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-273">読み取りモードでロックに入った一意のスレッドの総数を取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-273">Gets the total number of unique threads that have entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="d0e27-274">読み取りモードでロックに入った一意のスレッドの数。</span><span class="sxs-lookup"><span data-stu-id="d0e27-274">The number of unique threads that have entered the lock in read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-275">スレッドは 1 回だけカウントされます、場合でも、ロックにより、再帰と、スレッドが読み取りモードを複数回入力します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-275">A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</span></span>  
  
 <span data-ttu-id="d0e27-276">このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-276">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="d0e27-277">結果は、計算が完了すると、すぐに変更できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-277">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="d0e27-278">そのため、このプロパティに基づいた決定を行う安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-278">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-279">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A>プロパティを読み取りモードでのスレッドの数がしきい値を超えた場合に、イベント ログ エントリを生成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-279">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d0e27-280"><see cref="T:System.Threading.ReaderWriterLockSlim" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-280">Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-281"><xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> を使い終わったら <xref:System.Threading.ReaderWriterLockSlim> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-281">Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="d0e27-282"><xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> メソッドによって、<xref:System.Threading.ReaderWriterLockSlim> は使用不可の状態になります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-282">The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state.</span></span> <span data-ttu-id="d0e27-283">呼び出した後<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>へのすべての参照を解放する必要があります、<xref:System.Threading.ReaderWriterLockSlim>ガベージ コレクターがメモリをクリアできるようにする、<xref:System.Threading.ReaderWriterLockSlim>によって占有されていた。</span><span class="sxs-lookup"><span data-stu-id="d0e27-283">After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying.</span></span> <span data-ttu-id="d0e27-284">詳細については、次を参照してください。[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)と[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-284">For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-285">常に呼び出す<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>への参照を解放する前に、<xref:System.Threading.ReaderWriterLockSlim>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="d0e27-285">Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="d0e27-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> が 0 より大きい値です。</span><span class="sxs-lookup"><span data-stu-id="d0e27-286"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="d0e27-287">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-287">-or-</span></span> 
 <span data-ttu-id="d0e27-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> が 0 より大きい値です。</span><span class="sxs-lookup"><span data-stu-id="d0e27-288"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero.</span></span>  
  
<span data-ttu-id="d0e27-289">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-289">-or-</span></span> 
 <span data-ttu-id="d0e27-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> が 0 より大きい値です。</span><span class="sxs-lookup"><span data-stu-id="d0e27-290"><see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d0e27-291">読み取りモードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-291">Tries to enter the lock in read mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-292">このメソッドはブロックされるまで、呼び出し元のスレッドがロックに入るし、しない可能性がありますが返されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-292">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="d0e27-293">使用して、<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>時間中に読み取りモードを指定した間隔でブロックして、呼び出し元のスレッドは入っていませんを返すメソッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-293">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</span></span>  
  
 <span data-ttu-id="d0e27-294">複数のスレッドと同時に読み取りモードに入ることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-294">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="d0e27-295">1 つまたは複数のスレッドが書き込みモードに待機している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>メソッドは、これらのスレッドがいずれかのブロックは、タイムアウトしたため、または書き込みモードに入ったから、その後に終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-295">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-296">ロックが再帰を許可する場合は、読み取りモードでロックに入ったスレッドは読み取りモードの再帰的に、書き込みモードに入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-296">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="d0e27-297">他のスレッドが読み取りモードでは、最大で 1 つのスレッドはアップグレード可能モードにできます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-297">At most one thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="d0e27-298">追加のスレッドがアップグレード可能モードの入力を待機している書き込みモードに入るを待機しているスレッドがない場合は、スレッドの呼び出し、<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>メソッドは、すぐに読み取りモードに入るしはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-298">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-299">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>読み取りモードでロックに入るするメソッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-299">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode.</span></span> <span data-ttu-id="d0e27-300">例に示したメソッドは、キーに関連付けられている値を取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-300">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="d0e27-301">キーが見つかったしないかどうかは、内部でスローされる例外<xref:System.Collections.Generic.Dictionary%602>を許可するメソッドを終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-301">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="d0e27-302">A`finally`ブロックを使用して実行を<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>メソッドを呼び出し元が読み取りモードを終了することを確認します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-302">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span>  
  
 <span data-ttu-id="d0e27-303">このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-303">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="d0e27-304"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティは <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> です。現在のスレッドは、読み取りロックを保持しながら読み取りロックを取得しようとしました。</span><span class="sxs-lookup"><span data-stu-id="d0e27-304">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock.</span></span>  
  
<span data-ttu-id="d0e27-305">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-305">-or-</span></span> 
<span data-ttu-id="d0e27-306"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティは <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> です。現在のスレッドは、書き込みロックを保持しながら読み取りロックを取得しようとしました。</span><span class="sxs-lookup"><span data-stu-id="d0e27-306">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock.</span></span>  
  
<span data-ttu-id="d0e27-307">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-307">-or-</span></span> 
<span data-ttu-id="d0e27-308">再帰の回数は、カウンターの容量を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-308">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="d0e27-309">この制限は非常に大きいため、アプリケーションで、この例外が発生することはないはずです。</span><span class="sxs-lookup"><span data-stu-id="d0e27-309">This limit is so large that applications should never encounter this exception.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d0e27-310"><see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-310">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d0e27-311">アップグレード可能モードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-311">Tries to enter the lock in upgradeable mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-312">このメソッドはブロックされるまで、呼び出し元のスレッドがロックに入るし、しない可能性がありますが返されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-312">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="d0e27-313">使用して、 <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> 、一定の間隔をブロックして、呼び出し元のスレッドがその期間中にアップグレード可能モードを入力しないかどうかを返すメソッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-313">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</span></span>  
  
 <span data-ttu-id="d0e27-314">スレッドは、通常によって保護されているリソースにアクセスするときにアップグレード可能モードを使用して、<xref:System.Threading.ReaderWriterLockSlim>で読み取りモードには、特定の条件が満たされた場合は、書き込みモードを入力する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-314">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="d0e27-315">アップグレード可能モードでのスレッドでは、読み取りモードにダウン グレードしたり、書き込みモードにアップグレードすることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-315">A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</span></span>  
  
 <span data-ttu-id="d0e27-316">1 つのスレッドは、任意の時点でアップグレード可能モードを入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-316">Only one thread can enter upgradeable mode at any given time.</span></span> <span data-ttu-id="d0e27-317">スレッドがアップグレード可能モードでは、書き込みモードに入るを待機しているスレッドがない場合は、任意の数の他のスレッドはアップグレード可能モードを待機しているスレッドがある場合でも、読み取りモードを入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-317">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="d0e27-318">1 つまたは複数のスレッドが書き込みモードに待機している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>メソッドは、これらのスレッドがいずれかのブロックは、タイムアウトしたため、または書き込みモードに入ったから、その後に終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-318">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-319">ロックが再帰を許可する場合は、アップグレード可能モードでロックに入ったスレッドはアップグレード可能モードの再帰的に、書き込みモードに入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-319">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-320">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>アップグレード可能モードでロックに入るするメソッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-320">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode.</span></span> <span data-ttu-id="d0e27-321">A`finally`ブロックを使用して実行を<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>メソッドを呼び出し元がアップグレード可能モードを終了することを確認します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-321">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="d0e27-322">例に示したメソッドは、キーに関連付けられている値を取得し、新しい値を比較します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-322">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="d0e27-323">値が変更されていない場合、メソッドは、変更がないことを示すステータスを返します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-323">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="d0e27-324">これは、値が見つからない場合、キー、キー/値ペアが挿入されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-324">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="d0e27-325">値が変更された場合は更新されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-325">If the value has changed, it is updated.</span></span> <span data-ttu-id="d0e27-326">アップグレード可能モード スレッドのデッドロックのリスクを負うことがなく、必要に応じて、読み取りロックをアップグレードすることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-326">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="d0e27-327">例では、既定のコンス トラクターを使用して、再帰は許可されていませんので、ロックを作成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-327">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="d0e27-328">プログラミング、<xref:System.Threading.ReaderWriterLockSlim>ロックで再帰が許可されていない場合は、エラーの間違いを犯しにくい。</span><span class="sxs-lookup"><span data-stu-id="d0e27-328">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="d0e27-329">このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-329">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="d0e27-330"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にいずれかのモードでロックに入っています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-330">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="d0e27-331">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-331">-or-</span></span> 
<span data-ttu-id="d0e27-332">現在のスレッドは既に読み取りモードに入っているため、アップグレード可能モードに入ろうとするとデッドロックの可能性が生じます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-332">The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="d0e27-333">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-333">-or-</span></span> 
<span data-ttu-id="d0e27-334">再帰の回数は、カウンターの容量を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-334">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="d0e27-335">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-335">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d0e27-336"><see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-336">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d0e27-337">書き込みモードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-337">Tries to enter the lock in write mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-338">このメソッドはブロックされるまで、呼び出し元のスレッドがロックに入るし、しない可能性がありますが返されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-338">This method blocks until the calling thread enters the lock, and therefore might never return.</span></span> <span data-ttu-id="d0e27-339">使用して、 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 、一定の間隔をブロックして、呼び出し元のスレッドがその期間中に書き込みモードを入力しないかどうかを返すメソッド。</span><span class="sxs-lookup"><span data-stu-id="d0e27-339">Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</span></span>  
  
 <span data-ttu-id="d0e27-340">他のスレッドが、読み取りモードでロックに入っている場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>読み取りモードにメソッドは、これらのスレッドが終了するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-340">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode.</span></span> <span data-ttu-id="d0e27-341">書き込みモードに入るを待機しているスレッドが存在する場合、書き込みモードに入るを待機しているすべてのスレッドがあるかになるまで、読み取りモードまたはアップグレード可能モードのブロックを入力しようとする追加のスレッドがタイムアウトまたは書き込みモードに入ったし、その後に終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-341">When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-342">ロックが再帰を許可する場合は、書き込みモードでロックに入ったスレッドは書き込みモードの再帰的に、書き込みモードに入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-342">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-343">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>メソッドを書き込みモードでロックを入力します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-343">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode.</span></span> <span data-ttu-id="d0e27-344">例に示したメソッドは、キャッシュを同期する新しいキー/値ペアを追加します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-344">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="d0e27-345">場合は、キーが内部でスローされる例外は、キャッシュに既に<xref:System.Collections.Generic.Dictionary%602>を許可するメソッドを終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-345">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="d0e27-346">A`finally`ブロックを使用して実行を<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>メソッドを呼び出し元が書き込みモードを終了することを確認します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-346">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span>  
  
 <span data-ttu-id="d0e27-347">このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-347">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="d0e27-348"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にいずれかのモードでロックに入っています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-348">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode.</span></span>  
  
<span data-ttu-id="d0e27-349">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-349">-or-</span></span> 
<span data-ttu-id="d0e27-350">現在のスレッドは読み取りモードに入っており、まだ書き込みロックを持っていないため、書き込みモードでロックに入ろうとするとデッドロックの可能性が生じます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-350">The current thread has entered read mode and doesn't already own a write lock, so trying to enter the lock in write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="d0e27-351">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-351">-or-</span></span> 
<span data-ttu-id="d0e27-352">再帰の回数は、カウンターの容量を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-352">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="d0e27-353">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-353">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d0e27-354"><see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-354">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d0e27-355">読み取りモードの再帰カウントを減らし、結果のカウントが 0 (ゼロ) の場合には読み取りモードを終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-355">Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-356">このメソッドでは、再帰の順序に区別されません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-356">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="d0e27-357">たとえば、スレッドがアップグレード可能モードでロックに入り、読み取りモードでロックに入ったし場合、スレッドが 2 つのモードを終了する順序は関係ありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-357">For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="d0e27-358">ロックが再帰を許可する場合、スレッドできます書き込みモードでロックに入るし、入力を再帰的に読み取りモードでスレッドが終了する順序は、読み取りモードと、書き込みモードは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-358">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="d0e27-359">ロックを終了すると、他の待機中のスレッドがシグナル可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-359">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-360">次の例は、使用する方法を示します、`finally`ブロックが実行、<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>メソッドを呼び出し元が読み取りモードを終了することを確認します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-360">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.</span></span> <span data-ttu-id="d0e27-361">例に示したメソッドは、キーに関連付けられている値を取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-361">The method shown in the example retrieves the value associated with a key.</span></span> <span data-ttu-id="d0e27-362">キーが見つかったしないかどうかは、内部でスローされる例外<xref:System.Collections.Generic.Dictionary%602>を許可するメソッドを終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-362">If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="d0e27-363"><xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>メソッドを使用して、読み取りモードを入力します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-363">The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.</span></span>  
  
 <span data-ttu-id="d0e27-364">このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-364">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="d0e27-365">現在のスレッドは読み取りモードでロックに入っていません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-365">The current thread has not entered the lock in read mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d0e27-366">アップグレード可能モードの再帰カウントを減らし、結果のカウントが 0 (ゼロ) の場合にはアップグレード可能モードを終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-366">Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-367">このメソッドでは、再帰の順序に区別されません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-367">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="d0e27-368">たとえば、スレッドがアップグレード可能モードでロックに入った 書き込みモードでロックに入った場合、スレッドが 2 つのモードを終了する順序は関係ありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-368">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="d0e27-369">ロックが再帰を許可する場合、スレッドできます書き込みモードでロックに入るし、入力を再帰的にアップグレード可能モードでスレッドがアップグレード可能モードと書き込みのモードを終了する順序は重要ではありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-369">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="d0e27-370">ロックを終了すると、他の待機中のスレッドがシグナル可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-370">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-371">次の例は、使用する方法を示します、`finally`ブロックが実行、<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>メソッドを呼び出し元がアップグレード可能モードを終了することを確認します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-371">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.</span></span>  
  
 <span data-ttu-id="d0e27-372">例に示したメソッドは、キーに関連付けられている値を取得し、新しい値を比較します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-372">The method shown in the example retrieves the value associated with a key and compares it with a new value.</span></span> <span data-ttu-id="d0e27-373">値が変更されていない場合、メソッドは、変更がないことを示すステータスを返します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-373">If the value is unchanged, the method returns a status indicating no change.</span></span> <span data-ttu-id="d0e27-374">これは、値が見つからない場合、キー、キー/値ペアが挿入されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-374">It no value is found for the key, the key/value pair is inserted.</span></span> <span data-ttu-id="d0e27-375">値が変更された場合は更新されます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-375">If the value has changed, it is updated.</span></span> <span data-ttu-id="d0e27-376">アップグレード可能モード スレッドのデッドロックのリスクを負うことがなく、必要に応じて、読み取りロックをアップグレードすることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-376">Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</span></span>  
  
 <span data-ttu-id="d0e27-377">例では、既定のコンス トラクターを使用して、再帰は許可されていませんので、ロックを作成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-377">The example uses the default constructor to create the lock, so recursion is not allowed.</span></span> <span data-ttu-id="d0e27-378">プログラミング、<xref:System.Threading.ReaderWriterLockSlim>ロックで再帰が許可されていない場合は、エラーの間違いを犯しにくい。</span><span class="sxs-lookup"><span data-stu-id="d0e27-378">Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.</span></span>  
  
 <span data-ttu-id="d0e27-379">このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-379">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="d0e27-380">現在のスレッドはアップグレード可能モードでロックに入っていません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-380">The current thread has not entered the lock in upgradeable mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d0e27-381">書き込みモードの再帰カウントを減らし、結果のカウントが 0 (ゼロ) の場合には書き込みモードを終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-381">Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-382">このメソッドでは、再帰の順序に区別されません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-382">This method is not sensitive to recursion order.</span></span> <span data-ttu-id="d0e27-383">たとえば、スレッドがアップグレード可能モードでロックに入った 書き込みモードでロックに入った場合、スレッドが 2 つのモードを終了する順序は関係ありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-383">For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</span></span> <span data-ttu-id="d0e27-384">ロックが再帰を許可する場合、スレッドできます書き込みモードでロックに入るし、入力を再帰的に読み取りモードでスレッドが終了する順序は、読み取りモードと、書き込みモードは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-384">If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</span></span>  
  
 <span data-ttu-id="d0e27-385">ロックを終了すると、他の待機中のスレッドがシグナル可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-385">Exiting the lock might signal other waiting threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-386">次の例は、使用する方法を示します、`finally`ブロックが実行、<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>メソッドを呼び出し元が書き込みモードを終了することを確認します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-386">The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.</span></span> <span data-ttu-id="d0e27-387">例に示したメソッドは、キャッシュを同期する新しいキー/値ペアを追加します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-387">The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="d0e27-388">場合は、キーが内部でスローされる例外は、キャッシュに既に<xref:System.Collections.Generic.Dictionary%602>を許可するメソッドを終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-388">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="d0e27-389"><xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>メソッドを使用して、書き込みモードでロックを入力します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-389">The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.</span></span>  
  
 <span data-ttu-id="d0e27-390">このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-390">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException"><span data-ttu-id="d0e27-391">現在のスレッドは書き込みモードでロックに入っていません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-391">The current thread has not entered the lock in write mode.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-392">現在のスレッドが読み取りモードでロックに入ったかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-392">Gets a value that indicates whether the current thread has entered the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="d0e27-393">現在のスレッドが読み取りモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d0e27-393"><see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-394">アサートで使用またはその他のデバッグの目的では、このプロパティを対象としています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-394">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="d0e27-395">プログラムの実行フローを制御するため使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="d0e27-395">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-396">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A>読み取りモードに予期せず、現在のスレッドが入力した場合、アサートを生成するプロパティ。</span><span class="sxs-lookup"><span data-stu-id="d0e27-396">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-397">現在のスレッドがアップグレード可能モードでロックに入ったかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-397">Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="d0e27-398">現在のスレッドがアップグレード可能モードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d0e27-398"><see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-399">アサートで使用またはその他のデバッグの目的では、このプロパティを対象としています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-399">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="d0e27-400">プログラムの実行フローを制御するため使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="d0e27-400">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-401">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A>プロパティを現在のスレッドがアップグレード可能モードを予期せずに入った場合は、アサートを生成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-401">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-402">現在のスレッドが書き込みモードでロックに入ったかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-402">Gets a value that indicates whether the current thread has entered the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="d0e27-403">現在のスレッドが書き込みモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d0e27-403"><see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-404">アサートで使用またはその他のデバッグの目的では、このプロパティを対象としています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-404">This property is intended for use in asserts or for other debugging purposes.</span></span> <span data-ttu-id="d0e27-405">プログラムの実行フローを制御するため使用しないでください。</span><span class="sxs-lookup"><span data-stu-id="d0e27-405">Do not use it to control the flow of program execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-406">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A>プロパティを現在のスレッドが書き込みモードを予期せずに入った場合は、アサートを生成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-406">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-407">現在の <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトの再帰ポリシーを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-407">Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</span></span></summary>
        <value><span data-ttu-id="d0e27-408">ロック再帰ポリシーを指定する列挙値のいずれか。</span><span class="sxs-lookup"><span data-stu-id="d0e27-408">One of the enumeration values that specifies the lock recursion policy.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-409">再帰ポリシーでは、複数回ロックに入るスレッドに関する制限事項を決定します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-409">Recursion policy determines the restrictions on threads that enter the lock more than once.</span></span> <span data-ttu-id="d0e27-410">たとえば、ロックを使用して作成されました<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>スレッドは読み取りモードでロックに入ってと<xref:System.Threading.LockRecursionException>スレッド読み取りモードでロックを再入力しようとする場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-410">For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-411">アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りロック再帰ポリシーの設定に関係なくモードにダウン グレードすることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-411">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</span></span>  
  
 <span data-ttu-id="d0e27-412">再帰ポリシーに関係なくは、最初に入ったスレッドはアップグレード可能モードまたは書き込みのモードにアップグレードするには、そのパターンがデッドロックの可能性を作成するため、モードは使用できませんを読み取る。</span><span class="sxs-lookup"><span data-stu-id="d0e27-412">Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</span></span>  
  
 <span data-ttu-id="d0e27-413">再帰ポリシーとその影響の詳細については、次を参照してください。、<xref:System.Threading.LockRecursionPolicy>列挙と<xref:System.Threading.ReaderWriterLockSlim>クラス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-413">For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-414">現在のスレッドが読み取りモードでロックに入った回数を、再帰を示す値として取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-414">Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="d0e27-415">0 (ゼロ) に、現在のスレッドが入力されていない場合は、モードを読み取り、スレッドが読み取りモードに入ったが、されていない場合は 1 を入力して、再帰的にまたは*n* 、スレッドが再帰的にロックに入った場合*n* - 1 回です。</span><span class="sxs-lookup"><span data-stu-id="d0e27-415">0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-416">このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-416">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="d0e27-417">結果は、計算が完了すると、すぐに変更できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-417">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="d0e27-418">そのため、このプロパティに基づいた決定を行う安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-418">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-419">現在のスレッドがアップグレード可能モードでロックに入った回数を、再帰を示す値として取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-419">Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="d0e27-420">現在のスレッドがアップグレード可能モードの場合は、スレッドがアップグレード可能モードに入ったがない、再帰的に、1 を入力していない場合は 0 または*n* 、スレッドが再帰的にアップグレード可能モードに入った場合*n* - 1時間。</span><span class="sxs-lookup"><span data-stu-id="d0e27-420">0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-421">このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-421">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="d0e27-422">結果は、計算が完了すると、すぐに変更できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-422">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="d0e27-423">そのため、このプロパティに基づいた決定を行う安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-423">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-424">現在のスレッドが書き込みモードでロックに入った回数を、再帰を示す値として取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-424">Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</span></span></summary>
        <value><span data-ttu-id="d0e27-425">現在のスレッドが入力されていない場合は 0 書き込みモードでは、1 スレッドが書き込みモードに入ったが、されていない場合、再帰的に、または*n* 、スレッドが再帰的に書き込みモードに入った場合*n* - 1 回です。</span><span class="sxs-lookup"><span data-stu-id="d0e27-425">0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-426">このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-426">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="d0e27-427">結果は、計算が完了すると、すぐに変更できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-427">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="d0e27-428">そのため、このプロパティに基づいた決定を行う安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-428">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d0e27-429">オプションのタイムアウトを指定して、読み取りモードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-429">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="d0e27-430">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="d0e27-430">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d0e27-431">オプションのタイムアウトを表す整数を指定して、読み取りモードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-431">Tries to enter the lock in read mode, with an optional integer time-out.</span></span></summary>
        <returns><span data-ttu-id="d0e27-432">呼び出し元のスレッドが読み取りモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d0e27-432"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-433">場合`millisecondsTimeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-433">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="d0e27-434">複数のスレッドと同時に読み取りモードに入ることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-434">Multiple threads can enter read mode at the same time.</span></span>  
  
 <span data-ttu-id="d0e27-435">1 つまたは複数のスレッドが書き込みモードに待機している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>メソッドは、これらのスレッドが、タイムアウトまたは書き込みモードに入ったし、その後に終了するまで、または呼び出し元スレッド独自のタイムアウト期間が経過するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-435">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-436">ロックが再帰を許可する場合は、読み取りモードでロックに入ったスレッドは読み取りモードの再帰的に、書き込みモードに入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-436">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="d0e27-437">他のスレッドが読み取りモードでは、1 つのスレッドはアップグレード可能モードにできます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-437">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="d0e27-438">追加のスレッドがアップグレード可能モードの入力を待機している書き込みモードに入るを待機しているスレッドがない場合は、スレッドの呼び出し、<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>メソッドは、すぐに読み取りモードに入るしはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-438">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="d0e27-439"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-439">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="d0e27-440">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-440">-or-</span></span> 
<span data-ttu-id="d0e27-441">再帰の回数は、カウンターの容量を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-441">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="d0e27-442">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-442">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d0e27-443"><paramref name="millisecondsTimeout" /> の値が負ですが、指定できる唯一の負の値である <see cref="F:System.Threading.Timeout.Infinite" /> (-1) と等しくありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-443">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d0e27-444"><see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-444">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="d0e27-445">待機する間隔。無制限に待機する場合は -1 ミリ秒。</span><span class="sxs-lookup"><span data-stu-id="d0e27-445">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d0e27-446">オプションのタイムアウトを指定して、読み取りモードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-446">Tries to enter the lock in read mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="d0e27-447">呼び出し元のスレッドが読み取りモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d0e27-447"><see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-448">場合`timeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-448">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="d0e27-449">複数のスレッドは同時に、読み取りモードでロックに入ることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-449">Multiple threads can enter the lock in read mode at the same time.</span></span>  
  
 <span data-ttu-id="d0e27-450">1 つまたは複数のスレッドが書き込みモードにキューに格納している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>メソッドは、これらのスレッドが、タイムアウトまたは書き込みモードに入ったし、その後に終了するまで、または呼び出し元スレッド独自のタイムアウト期間が経過するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-450">If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-451">ロックが再帰を許可する場合は、読み取りモードでロックに入ったスレッドは読み取りモードの再帰的に、書き込みモードに入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-451">If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 <span data-ttu-id="d0e27-452">他のスレッドが読み取りモードでは、1 つのスレッドはアップグレード可能モードにできます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-452">One thread can be in upgradeable mode while other threads are in read mode.</span></span> <span data-ttu-id="d0e27-453">追加のスレッドがアップグレード可能モードの入力を待機している書き込みモードに入るを待機しているスレッドがない場合は、スレッドの呼び出し、<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>メソッドは、すぐに読み取りモードに入るしはブロックしません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-453">If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="d0e27-454"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-454">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="d0e27-455">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-455">-or-</span></span> 
<span data-ttu-id="d0e27-456">再帰の回数は、カウンターの容量を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-456">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="d0e27-457">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-457">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d0e27-458"><paramref name="timeout" /> の値が負ですが、指定できる唯一の負の値である -1 ミリ秒と等しくありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-458">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="d0e27-459">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-459">-or-</span></span> 
<span data-ttu-id="d0e27-460"><paramref name="timeout" /> の値が <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-460">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d0e27-461"><see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-461">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d0e27-462">オプションのタイムアウトを指定して、アップグレード可能モードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-462">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="d0e27-463">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="d0e27-463">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d0e27-464">オプションのタイムアウトを指定して、アップグレード可能モードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-464">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="d0e27-465">呼び出し元のスレッドがアップグレード可能モードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d0e27-465"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-466">場合`millisecondsTimeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-466">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="d0e27-467">スレッドは、通常によって保護されているリソースにアクセスするときにアップグレード可能モードを使用して、<xref:System.Threading.ReaderWriterLockSlim>で読み取りモードには、特定の条件が満たされた場合は、書き込みモードを入力する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-467">Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="d0e27-468">アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りモードにダウン グレードすることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-468">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="d0e27-469">1 つのスレッドは、任意の時点で、アップグレード可能モードでロックを入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-469">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="d0e27-470">スレッドがアップグレード可能モードでは、書き込みモードに入るを待機しているスレッドがない場合は、任意の数の他のスレッドはアップグレード可能モードを待機しているスレッドがある場合でも、読み取りモードを入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-470">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="d0e27-471">1 つまたは複数のスレッドが書き込みモードに待機している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>メソッドは、これらのスレッドが、タイムアウトまたは書き込みモードに入ったし、その後に終了するまで、または呼び出し元スレッド独自のタイムアウト期間が経過するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-471">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-472">ロックが再帰を許可する場合は、アップグレード可能モードでロックに入ったスレッドはアップグレード可能モードの再帰的に、書き込みモードに入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-472">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="d0e27-473"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-473">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="d0e27-474">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-474">-or-</span></span> 
<span data-ttu-id="d0e27-475">現在のスレッドは最初に読み取りモードでロックに入ったため、アップグレード可能モードに入ろうとするとデッドロックの可能性が生じます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-475">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="d0e27-476">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-476">-or-</span></span> 
<span data-ttu-id="d0e27-477">再帰の回数は、カウンターの容量を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-477">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="d0e27-478">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-478">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d0e27-479"><paramref name="millisecondsTimeout" /> の値が負ですが、指定できる唯一の負の値である <see cref="F:System.Threading.Timeout.Infinite" /> (-1) と等しくありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-479">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d0e27-480"><see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-480">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="d0e27-481">待機する間隔。無制限に待機する場合は -1 ミリ秒。</span><span class="sxs-lookup"><span data-stu-id="d0e27-481">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d0e27-482">オプションのタイムアウトを指定して、アップグレード可能モードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-482">Tries to enter the lock in upgradeable mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="d0e27-483">呼び出し元のスレッドがアップグレード可能モードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d0e27-483"><see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-484">場合`timeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-484">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="d0e27-485">スレッドは、通常によって保護されているリソースにアクセスするときにアップグレード可能モードを使用して、<xref:System.Threading.ReaderWriterLockSlim>で読み取りモードには、特定の条件が満たされた場合は、書き込みモードを入力する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-485">Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met.</span></span> <span data-ttu-id="d0e27-486">アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りモードにダウン グレードすることができます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-486">A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</span></span>  
  
 <span data-ttu-id="d0e27-487">1 つのスレッドは、任意の時点で、アップグレード可能モードでロックを入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-487">Only one thread can enter a lock in upgradeable mode at any given time.</span></span> <span data-ttu-id="d0e27-488">スレッドがアップグレード可能モードでは、書き込みモードに入るを待機しているスレッドがない場合は、任意の数の他のスレッドはアップグレード可能モードを待機しているスレッドがある場合でも、読み取りモードを入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-488">If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</span></span>  
  
 <span data-ttu-id="d0e27-489">1 つまたは複数のスレッドが書き込みモードに待機している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>メソッドは、これらのスレッドが、タイムアウトまたは書き込みモードに入ったし、その後に終了するまで、または呼び出し元スレッド独自のタイムアウト期間が経過するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-489">If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-490">ロックが再帰を許可する場合は、アップグレード可能モードでロックに入ったスレッドはアップグレード可能モードの再帰的に、書き込みモードに入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-490">If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="d0e27-491"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-491">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="d0e27-492">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-492">-or-</span></span> 
<span data-ttu-id="d0e27-493">現在のスレッドは最初に読み取りモードでロックに入ったため、アップグレード可能モードに入ろうとするとデッドロックの可能性が生じます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-493">The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="d0e27-494">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-494">-or-</span></span> 
<span data-ttu-id="d0e27-495">再帰の回数は、カウンターの容量を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-495">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="d0e27-496">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-496">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d0e27-497"><paramref name="timeout" /> の値が負ですが、指定できる唯一の負の値である -1 ミリ秒と等しくありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-497">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="d0e27-498">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-498">-or-</span></span> 
<span data-ttu-id="d0e27-499"><paramref name="timeout" /> の値が <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-499">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d0e27-500"><see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-500">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d0e27-501">オプションのタイムアウトを指定して、書き込みモードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-501">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="d0e27-502">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</span><span class="sxs-lookup"><span data-stu-id="d0e27-502">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d0e27-503">オプションのタイムアウトを指定して、書き込みモードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-503">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="d0e27-504">呼び出し元のスレッドが書き込みモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d0e27-504"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-505">場合`millisecondsTimeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-505">If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="d0e27-506">他のスレッドが、読み取りモードでロックに入っている場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>メソッドは、これらのスレッドが読み取りモードを終了するまで、またはタイムアウト間隔が経過するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-506">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="d0e27-507">書き込みモードに入るを待機しているスレッドがブロックされているときに、入力を待機しているすべてのスレッド 書き込みモードかタイムアウトまたは書き込みモードに入ったになり、終了するまで、読み取りモードまたはアップグレード可能モードに入ろうとする追加のスレッドがブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-507">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-508">ロックが再帰を許可する場合は、書き込みモードでロックに入ったスレッドは書き込みモードの再帰的に、書き込みモードに入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-508">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-509">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>メソッドのタイムアウトの書き込みモードでロックに入るをします。例に示したメソッドは、キャッシュを同期する新しいキー/値ペアを追加します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-509">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</span></span> <span data-ttu-id="d0e27-510">かどうか、スレッドがロックに入る前に指定されたタイムアウト期間が経過する、メソッドを返します`false`します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-510">If the specified time-out interval elapses before the thread enters the lock, the method returns `false`.</span></span> <span data-ttu-id="d0e27-511">メソッドを返します`true`キー/値ペアが追加された場合。</span><span class="sxs-lookup"><span data-stu-id="d0e27-511">The method returns `true` if the key/value pair is added.</span></span>  
  
 <span data-ttu-id="d0e27-512">場合は、キーが内部でスローされる例外は、キャッシュに既に<xref:System.Collections.Generic.Dictionary%602>を許可するメソッドを終了します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-512">If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method.</span></span> <span data-ttu-id="d0e27-513">A`finally`ブロックを使用して実行を<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>メソッドを呼び出し元がロックを終了したことを確認します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-513">A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.</span></span>  
  
 <span data-ttu-id="d0e27-514">このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。</span><span class="sxs-lookup"><span data-stu-id="d0e27-514">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="d0e27-515"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-515">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="d0e27-516">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-516">-or-</span></span> 
<span data-ttu-id="d0e27-517">現在のスレッドは最初に読み取りモードでロックに入ったため、書き込みモードに入ろうとするとデッドロックの可能性が生じます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-517">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="d0e27-518">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-518">-or-</span></span> 
<span data-ttu-id="d0e27-519">再帰の回数は、カウンターの容量を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-519">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="d0e27-520">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-520">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d0e27-521"><paramref name="millisecondsTimeout" /> の値が負ですが、指定できる唯一の負の値である <see cref="F:System.Threading.Timeout.Infinite" /> (-1) と等しくありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-521">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d0e27-522"><see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-522">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="d0e27-523">待機する間隔。無制限に待機する場合は -1 ミリ秒。</span><span class="sxs-lookup"><span data-stu-id="d0e27-523">The interval to wait, or -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="d0e27-524">オプションのタイムアウトを指定して、書き込みモードでロックに入ることを試みます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-524">Tries to enter the lock in write mode, with an optional time-out.</span></span></summary>
        <returns><span data-ttu-id="d0e27-525">呼び出し元のスレッドが書き込みモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="d0e27-525"><see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-526">場合`timeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-526">If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.</span></span>  
  
 <span data-ttu-id="d0e27-527">他のスレッドが、読み取りモードでロックに入っている場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>メソッドは、これらのスレッドが読み取りモードを終了するまで、またはタイムアウト間隔が経過するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-527">If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</span></span> <span data-ttu-id="d0e27-528">書き込みモードに入るを待機しているスレッドがブロックされているときに、入力を待機しているすべてのスレッド 書き込みモードかタイムアウトまたは書き込みモードに入ったになり、終了するまで、読み取りモードまたはアップグレード可能モードに入ろうとする追加のスレッドがブロックします。</span><span class="sxs-lookup"><span data-stu-id="d0e27-528">While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d0e27-529">ロックが再帰を許可する場合は、書き込みモードでロックに入ったスレッドは書き込みモードの再帰的に、書き込みモードに入力できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-529">If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException"><span data-ttu-id="d0e27-530"><see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-530">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock.</span></span>  
  
<span data-ttu-id="d0e27-531">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-531">-or-</span></span> 
<span data-ttu-id="d0e27-532">現在のスレッドは最初に読み取りモードでロックに入ったため、書き込みモードに入ろうとするとデッドロックの可能性が生じます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-532">The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</span></span>  
  
<span data-ttu-id="d0e27-533">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-533">-or-</span></span> 
<span data-ttu-id="d0e27-534">再帰の回数は、カウンターの容量を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d0e27-534">The recursion number would exceed the capacity of the counter.</span></span> <span data-ttu-id="d0e27-535">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-535">The limit is so large that applications should never encounter it.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d0e27-536"><paramref name="timeout" /> の値が負ですが、指定できる唯一の負の値である -1 ミリ秒と等しくありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-536">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</span></span>  
  
<span data-ttu-id="d0e27-537">- または -</span><span class="sxs-lookup"><span data-stu-id="d0e27-537">-or-</span></span> 
<span data-ttu-id="d0e27-538"><paramref name="timeout" /> の値が <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-538">The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d0e27-539"><see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</span><span class="sxs-lookup"><span data-stu-id="d0e27-539">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-540">読み取りモードでロックに入るのを待機しているスレッドの総数を取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-540">Gets the total number of threads that are waiting to enter the lock in read mode.</span></span></summary>
        <value><span data-ttu-id="d0e27-541">読み取りモードに入るのを待機しているスレッドの総数。</span><span class="sxs-lookup"><span data-stu-id="d0e27-541">The total number of threads that are waiting to enter read mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-542">このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-542">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="d0e27-543">結果は、計算が完了すると、すぐに変更できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-543">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="d0e27-544">そのため、このプロパティに基づいた決定を行う安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-544">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-545">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A>プロパティを読み取りモードに入るを待機している、ブロックされているスレッドの数がしきい値を超えた場合に、イベント ログ エントリを生成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-545">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-546">アップグレード可能モードでロックに入るのを待機しているスレッドの総数を取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-546">Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</span></span></summary>
        <value><span data-ttu-id="d0e27-547">アップグレード可能モードに入るのを待機しているスレッドの総数。</span><span class="sxs-lookup"><span data-stu-id="d0e27-547">The total number of threads that are waiting to enter upgradeable mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-548">このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-548">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="d0e27-549">結果は、計算が完了すると、すぐに変更できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-549">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="d0e27-550">そのため、このプロパティに基づいた決定を行う安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-550">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-551">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A>プロパティ ブロックされると、アップグレード可能モードの入力を待機しているスレッドの数がしきい値を超えた場合、イベント ログ エントリを生成します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-551">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d0e27-552">書き込みモードでロックに入るのを待機しているスレッドの総数を取得します。</span><span class="sxs-lookup"><span data-stu-id="d0e27-552">Gets the total number of threads that are waiting to enter the lock in write mode.</span></span></summary>
        <value><span data-ttu-id="d0e27-553">書き込みモードに入るのを待機しているスレッドの総数。</span><span class="sxs-lookup"><span data-stu-id="d0e27-553">The total number of threads that are waiting to enter write mode.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d0e27-554">このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-554">Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</span></span> <span data-ttu-id="d0e27-555">結果は、計算が完了すると、すぐに変更できます。</span><span class="sxs-lookup"><span data-stu-id="d0e27-555">The results can change as soon as they have been calculated.</span></span> <span data-ttu-id="d0e27-556">そのため、このプロパティに基づいた決定を行う安全ではありません。</span><span class="sxs-lookup"><span data-stu-id="d0e27-556">Therefore, it is not safe to make decisions based on this property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d0e27-557">次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A>書き込みモードに入るを待機している、ブロックされているスレッドの数がしきい値を超えた場合に、イベント ログ エントリを生成するプロパティ。</span><span class="sxs-lookup"><span data-stu-id="d0e27-557">The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</span></span>  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>