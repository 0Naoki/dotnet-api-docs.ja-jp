<Type Name="ReaderWriterLockSlim" FullName="System.Threading.ReaderWriterLockSlim">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3464038fcf06fcd6ab722a9c4b6f82b812141c99" />
    <Meta Name="ms.sourcegitcommit" Value="84c54c0c7d64827a5637d1f05e74e1f0598606a1" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="08/27/2018" />
    <Meta Name="ms.locfileid" Value="42942854" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReaderWriterLockSlim extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLockSlim" />
  <TypeSignature Language="VB.NET" Value="Public Class ReaderWriterLockSlim&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLockSlim : IDisposable" />
  <TypeSignature Language="F#" Value="type ReaderWriterLockSlim = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>リソースへのアクセス管理に使用するロックを表し、複数のスレッドによる読み取りや排他アクセスでの書き込みを許可します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.ReaderWriterLockSlim>複数のスレッドによって読み取られ、一度に 1 つのスレッドによって書き込むされるリソースを保護します。 <xref:System.Threading.ReaderWriterLockSlim> 読み取りモードに設定する複数のスレッドは、1 つのスレッドのロックの排他的所有権を書き込みモードであるできにより、元のスレッドが解放することがなく書き込みモードにアップグレードできます、アップグレード可能読み取りモードに設定する読み取りアクセス権を持つ 1 つのスレッドリソースへの読み取りアクセス。  
  
> [!NOTE]
>  <xref:System.Threading.ReaderWriterLockSlim> は <xref:System.Threading.ReaderWriterLock> と似ていますが、再帰の規則や、ロック状態のアップグレードおよびダウングレードの規則が簡素化されています。 <xref:System.Threading.ReaderWriterLockSlim> は、デッドロックの可能性を大幅に回避します。 さらに、<xref:System.Threading.ReaderWriterLockSlim> のパフォーマンスは <xref:System.Threading.ReaderWriterLock> と比較して格段に優れています。 すべての新規開発で、<xref:System.Threading.ReaderWriterLockSlim> を使用することをお勧めします。  
  
 既定での新しいインスタンス<xref:System.Threading.ReaderWriterLockSlim>で作成された、<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>フラグを設定し、再帰ではできません。 再帰が不要な複雑さを紹介し、により、コードのデッドロックが発生しやすいため、すべての新しい開発では、この既定のポリシーお勧めします。 既存のファイルからの移行を簡略化するプロジェクトを使用する<xref:System.Threading.Monitor>または<xref:System.Threading.ReaderWriterLock>、使用することができます、<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>フラグのインスタンスを作成する<xref:System.Threading.ReaderWriterLockSlim>再帰を使用できます。  
  
 スレッドは 3 つのモードでロックに入ることができます。 読み取りモード、書き込みモード、およびアップグレード可能読み取りモード。 (このトピックの残りの部分に「アップグレード可能読み取りモード」を参照「アップグレード可能モード」と"入力`x`モード"長い語句方が優先的に使用されます"でロックに入る`x`モード".)  
  
 再帰ポリシーに関係なく 1 つのスレッドが書き込みモードで、いつでもすることができます。 スレッドは書き込みモードでは、他のスレッドできますなしでロックに入るのモード。 1 つのスレッドをいつでもアップグレード可能モードでできます。 任意の数のスレッドが読み取りモードであることができますが 1 つのスレッドでありアップグレード可能モードの他のスレッドが読み取りモードでは。  
  
> [!IMPORTANT]
>  この型は、<xref:System.IDisposable>インターフェイス。 型の使用が完了したら、直接的または間接的にそれを破棄する必要があります。 型の直接 dispose を呼び出してその<xref:System.IDisposable.Dispose%2A>メソッド、 `try` / `catch`ブロックします。 直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(で C# の場合) または`Using`(Visual Basic) でします。 詳細については、"を使用して、オブジェクトを実装する IDisposable"のセクションを参照してください、<xref:System.IDisposable>インターフェイスに関するトピック。  
  
 <xref:System.Threading.ReaderWriterLockSlim> マネージ スレッドの関係が設定されました。つまり、各<xref:System.Threading.Thread>オブジェクトを入力し、ロック モードを終了する独自のメソッド呼び出しを行う必要があります。 スレッドが別のスレッドのモードを変更できるはありません。  
  
 場合、<xref:System.Threading.ReaderWriterLockSlim>再帰では、スレッド ロックを試行のいくつかの理由からブロックされる可能性はできません。  
  
-   スレッドが書き込みモードまたは書き込みモードで 1 つのスレッドがあるかどうかに入力を待機しているブロックの読み取りモードに入ろうとするスレッド。  
  
    > [!NOTE]
    >  書き込みを優先するロックの公平性ポリシーは、ライターがキューに置かれたときに、新しいリーダーをブロックします。 現在の公平性ポリシーは、最も一般的なシナリオでのスループットを昇格するには、リーダーとライターに公平性を分散します。 将来のバージョン、[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]公平性の新しいポリシーを生じる可能性があります。  
  
-   既にある場合、スレッドでアップグレード可能モードでは、スレッドが書き込みモードに入るを待機している場合、または 1 つのスレッドが書き込みモードである場合は、アップグレード可能モードのブロックを入力しようとするスレッド。  
  
-   3 つのモードのいずれかのスレッドがある場合、書き込みモードのブロックを入力しようとするスレッド。  
  
## <a name="upgrading-and-downgrading-locks"></a>アップグレードおよびダウン グレードをロックします。  
 場合、スレッドは、通常は、保護されたリソースから読み取ります。 アップグレード可能モードが対象としていますが、いくつかの条件が満たされた場合は、書き込みを行う必要があります。 入力したスレッドを<xref:System.Threading.ReaderWriterLockSlim>アップグレード可能モードでは、保護されたリソースへの読み取りアクセスと、呼び出すことによって書き込みモードにアップグレードできます、<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>または<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>メソッド。 再帰は許可されていない場合、これは、既定のポリシーは、存在できますが、1 つのスレッド アップグレード可能モードで、一度にためにデッドロック書き込みモードにアップグレードすることはできません。  
  
> [!IMPORTANT]
>  再帰ポリシーに関係なくは、最初に入ったスレッドはアップグレード可能モードまたは書き込みのモードにアップグレードするには、そのパターンがデッドロックの可能性を作成するため、モードは使用できませんを読み取る。 たとえば、両方を入力しようとして読み取りモードでの 2 つのスレッドは書き込みモード場合がデッドロックします。 アップグレード可能モードは、このようなデッドロックを回避するために設計されています。  
  
 読み取りモード、ブロックがアップグレード中のスレッドで他のスレッドがある場合です。 スレッドがブロックされている間に読み取りモードに入ろうとする他のスレッドがブロックされます。 読み取りモードからすべてのスレッドが終了したときにブロックされているアップグレード可能なスレッドは書き込みモードになります。 入力を待機している他のスレッドは書き込みモードは、アップグレード可能モードでは、1 つのスレッドがそのリソースに排他アクセスできないため、引き続きブロックします。  
  
 アップグレード可能モードでのスレッドが書き込みモードを終了すると、入力を待機しているスレッドが書き込みモードがないため、読み取りモードに入るを待機している他のスレッドが実行できます。 アップグレード可能モードでのスレッドがアップグレードし、保護されたリソースへの書き込みを唯一のスレッドがある限り、無期限にダウン グレードできます。  
  
> [!IMPORTANT]
>  入力に複数のスレッドを許可する場合は、書き込みモードまたはアップグレード可能モードでは、1 つのスレッドがアップグレード可能モードを独占できないようにする必要があります。 それ以外の場合、モード直接は無限にブロック、および他のスレッドが読み取りモードに入ることなりますがブロックされているときに入力しようとするスレッドを記述します。  
  
 アップグレード可能モードでのスレッドは、最初の呼び出しで、読み取りモードにダウン グレードできますが、<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>メソッドを呼び出して、<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>メソッド。 このダウン グレード パターンが、すべてのロック再帰ポリシーも許可されている<xref:System.Threading.LockRecursionPolicy.NoRecursion>します。  
  
 読み取りモードにダウン グレードする場合、スレッドことはできませんを再入力モードに入る読み取りモードを終了するまでです。  
  
## <a name="entering-the-lock-recursively"></a>再帰的にロックを入力します。  
 作成することができます、<xref:System.Threading.ReaderWriterLockSlim>を使用して再帰的なロックのエントリをサポートする、<xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29>ロックのポリシーと指定することを指定するコンス トラクター<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>します。  
  
> [!NOTE]
>  再帰の使用は、不要な複雑さを紹介し、により、コードのデッドロックが発生しやすいため、新規開発では推奨されません。  
  
 <xref:System.Threading.ReaderWriterLockSlim>再帰を利用できる、スレッドが入力できるモードについて、次と言えます。  
  
-   読み取りモードでのスレッドは読み取りモードを再帰的を入力できますが、書き込みモードやアップグレード可能モードを入力することはできません。 これを行うにしようとすると、<xref:System.Threading.LockRecursionException>がスローされます。 入力モードと入力し、書き込みモードか、許可されていないために、アップグレード可能モードは、デッドロックの確率が厳密なパターンを読み取ります。 前述のように、アップグレード可能モードは、ロックをアップグレードする必要がある場合に提供されます。  
  
-   アップグレード可能モードでのスレッドでは、書き込みモードまたは読み取りモードに入力して、3 つのモードの再帰的のいずれかを入力できます。 ただし、入力しようとすると、書き込みモードのブロック読み取りモードに他のスレッドがあるかどうか。  
  
-   書き込みモードでのスレッドでは、読み取りモードやアップグレード可能モードに入力して、3 つのモードの再帰的のいずれかを入力できます。  
  
-   ロックに入っていませんが、スレッドは、どのモードを入力できます。 この試行は、非再帰的なロックを入力しようと同じ理由でブロックできます。  
  
 スレッドは、何度でも、そのモードに入ったこととまったく同じには、各モードを終了している限り、任意の順序で入力がモードを終了できます。 スレッドの試行回数が多すぎますモードを終了するかは入っていませんモードを終了する場合、<xref:System.Threading.SynchronizationLockException>がスローされます。  
  
## <a name="lock-states"></a>ロックの状態  
 その状態の用語では、ロックを考えると便利です。 A <xref:System.Threading.ReaderWriterLockSlim> 4 つの状態のいずれかであることができます。 入力されていません、読み取り、アップグレード、および記述します。  
  
-   入力されていません。 この状態でスレッドがロックに入ってない (またはすべてのスレッドがロックを終了)。  
  
-   読む: この状態で、1 つまたは複数のスレッド ロックに入った読み取りアクセスの保護されたリソースにします。  
  
    > [!NOTE]
    >  スレッドを使用して読み取りモードでロックを入力することができます、<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>または<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>メソッド、またはアップグレード可能モードからダウン グレードします。  
  
-   アップグレード: この状態で、1 つのスレッドがロックに入った書き込みアクセスにアップグレードするオプションを使用して読み取りアクセス用 (つまり、アップグレード可能モードで)、読み取りアクセス用に 0 個以上のスレッドがロックに入っているとします。 一度に複数のスレッドは; をアップグレードするオプションを使用してロックを入力できます。アップグレード可能モードを開始しようとする追加のスレッドがブロックされます。  
  
-   書き込み: この状態で、1 つのスレッドがロックに入った書き込みアクセス権の保護されたリソースに。 そのスレッドは、ロックを所有している排他的です。 何らかの理由でロックに入ろうとするその他のスレッドがブロックされます。  
  
 次の表に、再帰では、ときにスレッドを許可しないロックのロックの状態間の遷移`t`左端の列で説明されているアクションを実行します。 時に、その操作を行う`t`モードがありません。 (特殊なケース場所`t`では、アップグレード可能モードは、表の脚注に記載されています)。一番上の行では、ロックの開始時の状態について説明します。 セルは、スレッドの処理について説明し、かっこで囲まれたロック状態の変更を表示します。  
  
||入っていない (N)|Read (R)|アップグレード (U)|書き込み (W)|  
|-|-----------------------|----------------|-------------------|-----------------|  
|`t` 読み取りモードに入ります|`t` (R) を入力します。|`t` スレッドが書き込みモードを待機している場合それ以外の場合、`t`を入力します。|`t` スレッドが書き込みモードを待機している場合それ以外の場合、`t`を入力します<sup>。1</sup>|`t` ブロックします。|  
|`t` アップグレード可能モードに入る|`t` (U) を入力します。|`t` スレッドが待機している場合は書き込みモードまたはアップグレード モードです。それ以外の場合、 `t` (U) を入力します。|`t` ブロックします。|`t` ブロックします。|  
|`t` 書き込みモードに入ります|`t` 入力 (W)。|`t` ブロックします。|`t` ブロックします。<sup>2</sup>|`t` ブロックします。|  
  
 <sup>1</sup>場合`t`開始がアップグレード可能モードで読み取りモードに入ります。 この操作を決してをブロックします。 ロックの状態は変更されません。 (スレッドは、アップグレード可能モードを終了することによって読み取りモードにダウン グレードを完了できますし、)。  
  
 <sup>2</sup>場合`t`スレッドが読み取りモードである場合、ブロックするアップグレード可能モードで起動します。 それ以外の場合、これは書き込みモードにアップグレードします。 ロック状態の変化に書き込み (W)。 場合`t`スレッドが読み取りモードであるため、ブロックが最後のスレッドが読み取りモードを終了するとすぐに書き込みモードに入る、入力を待機しているスレッドが書き込みモードである場合でもです。  
  
 スレッドがロックを終了したため、状態の変更が発生したときに解除するのには、次のスレッドとしては、次のように選択されます。  
  
-   最初に、待機しているスレッドは書き込みモードと、(あります多くてこのような 1 つのスレッド) アップグレード可能モードでは既にします。  
  
-   それがない場合は、書き込みモードを待機しているスレッド。  
  
-   それがない場合は、アップグレード可能モードを待機しているスレッド。  
  
-   読み取りモードを待機しているすべてのスレッドが、失敗します。  
  
 ロックの後続の状態は常に書き込み (W)、最初の 2 つのケースとアップグレード (U) ロック状態の変更がトリガーされると、既存のスレッドの状態に関係なく、3 番目のケースで。 最後の場合は、ロックの状態はアップグレード (U) 場合は、スレッドはアップグレード可能モードで、状態の変化と Read (R) 後それ以外の場合、以前の状態に関係なく。  
  
   
  
## Examples  
 次の例は、整数キーを持つ文字列を保持するための単純な同期キャッシュです。 インスタンス<xref:System.Threading.ReaderWriterLockSlim>へのアクセスを同期するため、<xref:System.Collections.Generic.Dictionary%602>内部キャッシュとして機能します。  
  
 この例には、キャッシュに追加、キャッシュから削除し、キャッシュから読み取られた単純なメソッドが含まれます。 タイムアウトを示すためには、例には、指定されたタイムアウト内で行うことができる場合にのみをキャッシュに追加するメソッドが含まれています。  
  
 アップグレード可能モードを示すためには、例は、キーに関連付けられた値を取得するメソッドが含まれています、新しい値を比較します。 値が変更されていない場合、メソッドは、変更がないことを示すステータスを返します。 キーの値が見つからない場合は、キー/値ペアが挿入されます。 値が変更された場合は更新されます。 アップグレード可能モード スレッドのデッドロックのリスクを負うことがなく、必要に応じて、書き込みアクセス権への読み取りアクセスからアップグレードすることができます。  
  
 この例には、アップグレード可能モードを示すメソッドの戻り値を指定する入れ子になった列挙が含まれています。  
  
 例では、既定のコンス トラクターを使用して、再帰は許可されていませんので、ロックを作成します。 プログラミング、<xref:System.Threading.ReaderWriterLockSlim>ロックで再帰が許可されていない場合は、エラーの間違いを犯しにくい。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 次のコードの使用、`SynchronizedCache`野菜名のディクショナリを格納するオブジェクト。 3 つのタスクを作成します。 最初の配列に格納されている野菜の名前を書き込みます、`SynchronizedCache`インスタンス。 2 番目と 3 番目のタスクでは、野菜、昇順 (不足インデックスから最も大きいインデックス)、降順で、2 つ目の最初の名前を表示します。 最後のタスクは、文字列"cucumber"を検索し、それを見つけたときに呼び出す、 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> "緑 bean"文字列を置換するメソッド。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> クラスの新しいインスタンスを既定のプロパティ値で初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Threading.ReaderWriterLockSlim>これで初期化されるコンス トラクターでは、再帰することはできません。 つまり、<xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> プロパティが <xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType> を返します。  
  
 再帰ポリシーとその影響の詳細については、次を参照してください。、<xref:System.Threading.LockRecursionPolicy>列挙と<xref:System.Threading.ReaderWriterLockSlim>クラス。  
  
   
  
## Examples  
 次の例は、整数キーを持つ文字列を保持するための単純な同期キャッシュです。 インスタンス<xref:System.Threading.ReaderWriterLockSlim>へのアクセスを同期するため、<xref:System.Collections.Generic.Dictionary%602>内部キャッシュとして機能します。 パラメーターなしのコンス トラクターは、ロックの作成に使用されます。  
  
 この例には、キャッシュに追加、キャッシュから削除し、キャッシュから読み取られた単純なメソッドが含まれます。 タイムアウトを示すためには、例には、指定されたタイムアウト内で行うことができる場合にのみをキャッシュに追加するメソッドが含まれています。  
  
 アップグレード可能モードを示すためには、例は、キーに関連付けられた値を取得するメソッドが含まれています、新しい値を比較します。 値が変更されていない場合、メソッドは、変更がないことを示すステータスを返します。 これは、値が見つからない場合、キー、キー/値ペアが挿入されます。 値が変更された場合は更新されます。 アップグレード可能モード スレッドのデッドロックのリスクを負うことがなく、必要に応じて、書き込みアクセス権への読み取りアクセスからアップグレードすることができます。  
  
 この例には、アップグレード可能モードを示すメソッドの戻り値を指定する入れ子になった列挙が含まれています。  
  
 例では、既定のコンス トラクターを使用して、再帰は許可されていませんので、ロックを作成します。 プログラミング、<xref:System.Threading.ReaderWriterLockSlim>ロックで再帰が許可されていない場合は、エラーの間違いを犯しにくい。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  
  
 次のコードの使用、`SynchronizedCache`野菜名のディクショナリを格納するオブジェクト。 3 つのタスクを作成します。 最初の配列に格納されている野菜の名前を書き込みます、`SynchronizedCache`インスタンス。 2 番目と 3 番目のタスクでは、野菜、昇順 (不足インデックスから最も大きいインデックス)、降順で、2 つ目の最初の名前を表示します。 最後のタスクは、文字列"cucumber"を検索し、それを見つけたときに呼び出す、 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> "緑 bean"文字列を置換するメソッド。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LockRecursionPolicy recursionPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (recursionPolicy As LockRecursionPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLockSlim(System::Threading::LockRecursionPolicy recursionPolicy);" />
      <MemberSignature Language="F#" Value="new System.Threading.ReaderWriterLockSlim : System.Threading.LockRecursionPolicy -&gt; System.Threading.ReaderWriterLockSlim" Usage="new System.Threading.ReaderWriterLockSlim recursionPolicy" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="recursionPolicy" Type="System.Threading.LockRecursionPolicy" />
      </Parameters>
      <Docs>
        <param name="recursionPolicy">ロック再帰ポリシーを指定する列挙値のいずれか。</param>
        <summary>ロック再帰ポリシーを指定して、<see cref="T:System.Threading.ReaderWriterLockSlim" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再帰ポリシーでは、複数回ロックに入るスレッドに関する制限事項を決定します。 たとえば、ロックを使用して作成されました<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>スレッドは読み取りモードでロックに入ってと<xref:System.Threading.LockRecursionException>スレッド読み取りモードでロックを再入力しようとする場合にスローされます。 同様に、スレッドが書き込みモードでロックに入った場合は、<xref:System.Threading.LockRecursionException>スレッド モードでロックを再入力しようとする場合にスローされます。  
  
> [!NOTE]
>  アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りロック再帰ポリシーの設定に関係なくモードにダウン グレードすることができます。  
  
 再帰ポリシーに関係なくは、最初に入ったスレッドはアップグレード可能モードまたは書き込みのモードにアップグレードするには、そのパターンがデッドロックの可能性を作成するため、モードは使用できませんを読み取る。  
  
 再帰ポリシーとその影響の詳細については、次を参照してください。、<xref:System.Threading.LockRecursionPolicy>列挙と<xref:System.Threading.ReaderWriterLockSlim>クラス。  
  
   
  
## Examples  
 次の例は、いずれかに依存している 2 つの例外シナリオ、<xref:System.Threading.LockRecursionPolicy>設定し、1 つにはないです。  
  
 最初のシナリオでは、スレッドは読み取りモードに入り、再帰的に読み取りモードに入ろいます。 場合、<xref:System.Threading.ReaderWriterLockSlim>再帰ポリシーを設定の既定のコンス トラクターを使用して作成<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>例外がスローされます。 場合<xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType>を作成するために使用、<xref:System.Threading.ReaderWriterLockSlim>例外はスローされません。  
  
 2 番目のシナリオでは、スレッドが読み取りモードになり、入力しようモードを書き込みます。 <xref:System.Threading.LockRecursionException> ロック再帰ポリシーに関係なくがスローされます。  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] 
[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  
  
 次のコードの使用、`SynchronizedCache`野菜名のディクショナリを格納するオブジェクト。 3 つのタスクを作成します。 最初の配列に格納されている野菜の名前を書き込みます、`SynchronizedCache`インスタンス。 2 番目と 3 番目のタスクでは、野菜、昇順 (不足インデックスから最も大きいインデックス)、降順で、2 つ目の最初の名前を表示します。 最後のタスクは、文字列"cucumber"を検索し、それを見つけたときに呼び出す、 <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> "緑 bean"文字列を置換するメソッド。  
  
[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] 
[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   
[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] 
[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionPolicy" />
        <altmember cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      </Docs>
    </Member>
    <Member MemberName="CurrentReadCount">
      <MemberSignature Language="C#" Value="public int CurrentReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.CurrentReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み取りモードでロックに入った一意のスレッドの総数を取得します。</summary>
        <value>読み取りモードでロックに入った一意のスレッドの数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは 1 回だけカウントされます、場合でも、ロックにより、再帰と、スレッドが読み取りモードを複数回入力します。  
  
 このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。 結果は、計算が完了すると、すぐに変更できます。 そのため、このプロパティに基づいた決定を行う安全ではありません。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A>プロパティを読み取りモードでのスレッドの数がしきい値を超えた場合に、イベント ログ エントリを生成します。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="readerWriterLockSlim.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> を使い終わったら <xref:System.Threading.ReaderWriterLockSlim> を呼び出します。 <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> メソッドによって、<xref:System.Threading.ReaderWriterLockSlim> は使用不可の状態になります。 呼び出した後<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>へのすべての参照を解放する必要があります、<xref:System.Threading.ReaderWriterLockSlim>ガベージ コレクターがメモリをクリアできるようにする、<xref:System.Threading.ReaderWriterLockSlim>によって占有されていた。 詳細については、次を参照してください。[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)と[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)します。  
  
> [!NOTE]
>  常に呼び出す<xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>への参照を解放する前に、<xref:System.Threading.ReaderWriterLockSlim>オブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> が 0 より大きい値です。  
  
- または - 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> が 0 より大きい値です。  
  
- または - 
 <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> が 0 より大きい値です。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterReadLock">
      <MemberSignature Language="C#" Value="public void EnterReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>読み取りモードでロックに入ることを試みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはブロックされるまで、呼び出し元のスレッドがロックに入るし、しない可能性がありますが返されます。 使用して、<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>時間中に読み取りモードを指定した間隔でブロックして、呼び出し元のスレッドは入っていませんを返すメソッド。  
  
 複数のスレッドと同時に読み取りモードに入ることができます。  
  
 1 つまたは複数のスレッドが書き込みモードに待機している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>メソッドは、これらのスレッドがいずれかのブロックは、タイムアウトしたため、または書き込みモードに入ったから、その後に終了します。  
  
> [!NOTE]
>  ロックが再帰を許可する場合は、読み取りモードでロックに入ったスレッドは読み取りモードの再帰的に、書き込みモードに入力できます。  
  
 他のスレッドが読み取りモードでは、最大で 1 つのスレッドはアップグレード可能モードにできます。 追加のスレッドがアップグレード可能モードの入力を待機している書き込みモードに入るを待機しているスレッドがない場合は、スレッドの呼び出し、<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>メソッドは、すぐに読み取りモードに入るしはブロックしません。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>読み取りモードでロックに入るするメソッド。 例に示したメソッドは、キーに関連付けられている値を取得します。 キーが見つかったしないかどうかは、内部でスローされる例外<xref:System.Collections.Generic.Dictionary%602>を許可するメソッドを終了します。 A`finally`ブロックを使用して実行を<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>メソッドを呼び出し元が読み取りモードを終了することを確認します。  
  
 このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティは <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> です。現在のスレッドは、読み取りロックを保持しながら読み取りロックを取得しようとしました。  
  
- または - 
<see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティは <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> です。現在のスレッドは、書き込みロックを保持しながら読み取りロックを取得しようとしました。  
  
- または - 
再帰の回数は、カウンターの容量を超える可能性があります。 この制限は非常に大きいため、アプリケーションで、この例外が発生することはないはずです。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void EnterUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.EnterUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アップグレード可能モードでロックに入ることを試みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはブロックされるまで、呼び出し元のスレッドがロックに入るし、しない可能性がありますが返されます。 使用して、 <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> 、一定の間隔をブロックして、呼び出し元のスレッドがその期間中にアップグレード可能モードを入力しないかどうかを返すメソッド。  
  
 スレッドは、通常によって保護されているリソースにアクセスするときにアップグレード可能モードを使用して、<xref:System.Threading.ReaderWriterLockSlim>で読み取りモードには、特定の条件が満たされた場合は、書き込みモードを入力する必要があります。 アップグレード可能モードでのスレッドでは、読み取りモードにダウン グレードしたり、書き込みモードにアップグレードすることができます。  
  
 1 つのスレッドは、任意の時点でアップグレード可能モードを入力できます。 スレッドがアップグレード可能モードでは、書き込みモードに入るを待機しているスレッドがない場合は、任意の数の他のスレッドはアップグレード可能モードを待機しているスレッドがある場合でも、読み取りモードを入力できます。  
  
 1 つまたは複数のスレッドが書き込みモードに待機している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>メソッドは、これらのスレッドがいずれかのブロックは、タイムアウトしたため、または書き込みモードに入ったから、その後に終了します。  
  
> [!NOTE]
>  ロックが再帰を許可する場合は、アップグレード可能モードでロックに入ったスレッドはアップグレード可能モードの再帰的に、書き込みモードに入力できます。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A>アップグレード可能モードでロックに入るするメソッド。 A`finally`ブロックを使用して実行を<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>メソッドを呼び出し元がアップグレード可能モードを終了することを確認します。  
  
 例に示したメソッドは、キーに関連付けられている値を取得し、新しい値を比較します。 値が変更されていない場合、メソッドは、変更がないことを示すステータスを返します。 これは、値が見つからない場合、キー、キー/値ペアが挿入されます。 値が変更された場合は更新されます。 アップグレード可能モード スレッドのデッドロックのリスクを負うことがなく、必要に応じて、読み取りロックをアップグレードすることができます。  
  
 例では、既定のコンス トラクターを使用して、再帰は許可されていませんので、ロックを作成します。 プログラミング、<xref:System.Threading.ReaderWriterLockSlim>ロックで再帰が許可されていない場合は、エラーの間違いを犯しにくい。  
  
 このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にいずれかのモードでロックに入っています。  
  
- または - 
現在のスレッドは既に読み取りモードに入っているため、アップグレード可能モードに入ろうとするとデッドロックの可能性が生じます。  
  
- または - 
再帰の回数は、カウンターの容量を超える可能性があります。 この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnterWriteLock">
      <MemberSignature Language="C#" Value="public void EnterWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EnterWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub EnterWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EnterWriteLock();" />
      <MemberSignature Language="F#" Value="member this.EnterWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.EnterWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>書き込みモードでロックに入ることを試みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはブロックされるまで、呼び出し元のスレッドがロックに入るし、しない可能性がありますが返されます。 使用して、 <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> 、一定の間隔をブロックして、呼び出し元のスレッドがその期間中に書き込みモードを入力しないかどうかを返すメソッド。  
  
 他のスレッドが、読み取りモードでロックに入っている場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>読み取りモードにメソッドは、これらのスレッドが終了するまでブロックします。 書き込みモードに入るを待機しているスレッドが存在する場合、書き込みモードに入るを待機しているすべてのスレッドがあるかになるまで、読み取りモードまたはアップグレード可能モードのブロックを入力しようとする追加のスレッドがタイムアウトまたは書き込みモードに入ったし、その後に終了します。  
  
> [!NOTE]
>  ロックが再帰を許可する場合は、書き込みモードでロックに入ったスレッドは書き込みモードの再帰的に、書き込みモードに入力できます。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>メソッドを書き込みモードでロックを入力します。 例に示したメソッドは、キャッシュを同期する新しいキー/値ペアを追加します。 場合は、キーが内部でスローされる例外は、キャッシュに既に<xref:System.Collections.Generic.Dictionary%602>を許可するメソッドを終了します。 A`finally`ブロックを使用して実行を<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>メソッドを呼び出し元が書き込みモードを終了することを確認します。  
  
 このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にいずれかのモードでロックに入っています。  
  
- または - 
現在のスレッドは読み取りモードに入っており、まだ書き込みロックを持っていないため、書き込みモードでロックに入ろうとするとデッドロックの可能性が生じます。  
  
- または - 
再帰の回数は、カウンターの容量を超える可能性があります。 この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitReadLock">
      <MemberSignature Language="C#" Value="public void ExitReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>読み取りモードの再帰カウントを減らし、結果のカウントが 0 (ゼロ) の場合には読み取りモードを終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、再帰の順序に区別されません。 たとえば、スレッドがアップグレード可能モードでロックに入り、読み取りモードでロックに入ったし場合、スレッドが 2 つのモードを終了する順序は関係ありません。 ロックが再帰を許可する場合、スレッドできます書き込みモードでロックに入るし、入力を再帰的に読み取りモードでスレッドが終了する順序は、読み取りモードと、書き込みモードは必要ありません。  
  
 ロックを終了すると、他の待機中のスレッドがシグナル可能性があります。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、`finally`ブロックが実行、<xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A>メソッドを呼び出し元が読み取りモードを終了することを確認します。 例に示したメソッドは、キーに関連付けられている値を取得します。 キーが見つかったしないかどうかは、内部でスローされる例外<xref:System.Collections.Generic.Dictionary%602>を許可するメソッドを終了します。 <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>メソッドを使用して、読み取りモードを入力します。  
  
 このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">現在のスレッドは読み取りモードでロックに入っていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public void ExitUpgradeableReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitUpgradeableReadLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitUpgradeableReadLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitUpgradeableReadLock();" />
      <MemberSignature Language="F#" Value="member this.ExitUpgradeableReadLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitUpgradeableReadLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アップグレード可能モードの再帰カウントを減らし、結果のカウントが 0 (ゼロ) の場合にはアップグレード可能モードを終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、再帰の順序に区別されません。 たとえば、スレッドがアップグレード可能モードでロックに入った 書き込みモードでロックに入った場合、スレッドが 2 つのモードを終了する順序は関係ありません。 ロックが再帰を許可する場合、スレッドできます書き込みモードでロックに入るし、入力を再帰的にアップグレード可能モードでスレッドがアップグレード可能モードと書き込みのモードを終了する順序は重要ではありません。  
  
 ロックを終了すると、他の待機中のスレッドがシグナル可能性があります。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、`finally`ブロックが実行、<xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A>メソッドを呼び出し元がアップグレード可能モードを終了することを確認します。  
  
 例に示したメソッドは、キーに関連付けられている値を取得し、新しい値を比較します。 値が変更されていない場合、メソッドは、変更がないことを示すステータスを返します。 これは、値が見つからない場合、キー、キー/値ペアが挿入されます。 値が変更された場合は更新されます。 アップグレード可能モード スレッドのデッドロックのリスクを負うことがなく、必要に応じて、読み取りロックをアップグレードすることができます。  
  
 例では、既定のコンス トラクターを使用して、再帰は許可されていませんので、ロックを作成します。 プログラミング、<xref:System.Threading.ReaderWriterLockSlim>ロックで再帰が許可されていない場合は、エラーの間違いを犯しにくい。  
  
 このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">現在のスレッドはアップグレード可能モードでロックに入っていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExitWriteLock">
      <MemberSignature Language="C#" Value="public void ExitWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExitWriteLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExitWriteLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExitWriteLock();" />
      <MemberSignature Language="F#" Value="member this.ExitWriteLock : unit -&gt; unit" Usage="readerWriterLockSlim.ExitWriteLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>書き込みモードの再帰カウントを減らし、結果のカウントが 0 (ゼロ) の場合には書き込みモードを終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドでは、再帰の順序に区別されません。 たとえば、スレッドがアップグレード可能モードでロックに入った 書き込みモードでロックに入った場合、スレッドが 2 つのモードを終了する順序は関係ありません。 ロックが再帰を許可する場合、スレッドできます書き込みモードでロックに入るし、入力を再帰的に読み取りモードでスレッドが終了する順序は、読み取りモードと、書き込みモードは必要ありません。  
  
 ロックを終了すると、他の待機中のスレッドがシグナル可能性があります。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、`finally`ブロックが実行、<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>メソッドを呼び出し元が書き込みモードを終了することを確認します。 例に示したメソッドは、キャッシュを同期する新しいキー/値ペアを追加します。 場合は、キーが内部でスローされる例外は、キャッシュに既に<xref:System.Collections.Generic.Dictionary%602>を許可するメソッドを終了します。 <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>メソッドを使用して、書き込みモードでロックを入力します。  
  
 このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SynchronizationLockException">現在のスレッドは書き込みモードでロックに入っていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドが読み取りモードでロックに入ったかどうかを示す値を取得します。</summary>
        <value>現在のスレッドが読み取りモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アサートで使用またはその他のデバッグの目的では、このプロパティを対象としています。 プログラムの実行フローを制御するため使用しないでください。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A>読み取りモードに予期せず、現在のスレッドが入力した場合、アサートを生成するプロパティ。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUpgradeableReadLockHeld">
      <MemberSignature Language="C#" Value="public bool IsUpgradeableReadLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUpgradeableReadLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUpgradeableReadLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUpgradeableReadLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドがアップグレード可能モードでロックに入ったかどうかを示す値を取得します。</summary>
        <value>現在のスレッドがアップグレード可能モードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アサートで使用またはその他のデバッグの目的では、このプロパティを対象としています。 プログラムの実行フローを制御するため使用しないでください。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A>プロパティを現在のスレッドがアップグレード可能モードを予期せずに入った場合は、アサートを生成します。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriteLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteLockHeld : bool" Usage="System.Threading.ReaderWriterLockSlim.IsWriteLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドが書き込みモードでロックに入ったかどうかを示す値を取得します。</summary>
        <value>現在のスレッドが書き込みモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アサートで使用またはその他のデバッグの目的では、このプロパティを対象としています。 プログラムの実行フローを制御するため使用しないでください。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A>プロパティを現在のスレッドが書き込みモードを予期せずに入った場合は、アサートを生成します。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursionPolicy">
      <MemberSignature Language="C#" Value="public System.Threading.LockRecursionPolicy RecursionPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.LockRecursionPolicy RecursionPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursionPolicy As LockRecursionPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::LockRecursionPolicy RecursionPolicy { System::Threading::LockRecursionPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursionPolicy : System.Threading.LockRecursionPolicy" Usage="System.Threading.ReaderWriterLockSlim.RecursionPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトの再帰ポリシーを示す値を取得します。</summary>
        <value>ロック再帰ポリシーを指定する列挙値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 再帰ポリシーでは、複数回ロックに入るスレッドに関する制限事項を決定します。 たとえば、ロックを使用して作成されました<xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType>スレッドは読み取りモードでロックに入ってと<xref:System.Threading.LockRecursionException>スレッド読み取りモードでロックを再入力しようとする場合にスローされます。  
  
> [!NOTE]
>  アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りロック再帰ポリシーの設定に関係なくモードにダウン グレードすることができます。  
  
 再帰ポリシーに関係なくは、最初に入ったスレッドはアップグレード可能モードまたは書き込みのモードにアップグレードするには、そのパターンがデッドロックの可能性を作成するため、モードは使用できませんを読み取る。  
  
 再帰ポリシーとその影響の詳細については、次を参照してください。、<xref:System.Threading.LockRecursionPolicy>列挙と<xref:System.Threading.ReaderWriterLockSlim>クラス。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LockRecursionException" />
      </Docs>
    </Member>
    <Member MemberName="RecursiveReadCount">
      <MemberSignature Language="C#" Value="public int RecursiveReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドが読み取りモードでロックに入った回数を、再帰を示す値として取得します。</summary>
        <value>0 (ゼロ) に、現在のスレッドが入力されていない場合は、モードを読み取り、スレッドが読み取りモードに入ったが、されていない場合は 1 を入力して、再帰的にまたは*n* 、スレッドが再帰的にロックに入った場合*n* - 1 回です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。 結果は、計算が完了すると、すぐに変更できます。 そのため、このプロパティに基づいた決定を行う安全ではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveUpgradeCount">
      <MemberSignature Language="C#" Value="public int RecursiveUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドがアップグレード可能モードでロックに入った回数を、再帰を示す値として取得します。</summary>
        <value>現在のスレッドがアップグレード可能モードの場合は、スレッドがアップグレード可能モードに入ったがない、再帰的に、1 を入力していない場合は 0 または*n* 、スレッドが再帰的にアップグレード可能モードに入った場合*n* - 1時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。 結果は、計算が完了すると、すぐに変更できます。 そのため、このプロパティに基づいた決定を行う安全ではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RecursiveWriteCount">
      <MemberSignature Language="C#" Value="public int RecursiveWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecursiveWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecursiveWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RecursiveWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecursiveWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.RecursiveWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドが書き込みモードでロックに入った回数を、再帰を示す値として取得します。</summary>
        <value>現在のスレッドが入力されていない場合は 0 書き込みモードでは、1 スレッドが書き込みモードに入ったが、されていない場合、再帰的に、または*n* 、スレッドが再帰的に書き込みモードに入った場合*n* - 1 回です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。 結果は、計算が完了すると、すぐに変更できます。 そのため、このプロパティに基づいた決定を行う安全ではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>オプションのタイムアウトを指定して、読み取りモードでロックに入ることを試みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>オプションのタイムアウトを表す整数を指定して、読み取りモードでロックに入ることを試みます。</summary>
        <returns>呼び出し元のスレッドが読み取りモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。  
  
 複数のスレッドと同時に読み取りモードに入ることができます。  
  
 1 つまたは複数のスレッドが書き込みモードに待機している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>メソッドは、これらのスレッドが、タイムアウトまたは書き込みモードに入ったし、その後に終了するまで、または呼び出し元スレッド独自のタイムアウト期間が経過するまでブロックします。  
  
> [!NOTE]
>  ロックが再帰を許可する場合は、読み取りモードでロックに入ったスレッドは読み取りモードの再帰的に、書き込みモードに入力できます。  
  
 他のスレッドが読み取りモードでは、1 つのスレッドはアップグレード可能モードにできます。 追加のスレッドがアップグレード可能モードの入力を待機している書き込みモードに入るを待機しているスレッドがない場合は、スレッドの呼び出し、<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>メソッドは、すぐに読み取りモードに入るしはブロックしません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。  
  
- または - 
再帰の回数は、カウンターの容量を超える可能性があります。 この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> の値が負ですが、指定できる唯一の負の値である <see cref="F:System.Threading.Timeout.Infinite" /> (-1) と等しくありません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">待機する間隔。無制限に待機する場合は -1 ミリ秒。</param>
        <summary>オプションのタイムアウトを指定して、読み取りモードでロックに入ることを試みます。</summary>
        <returns>呼び出し元のスレッドが読み取りモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。  
  
 複数のスレッドは同時に、読み取りモードでロックに入ることができます。  
  
 1 つまたは複数のスレッドが書き込みモードにキューに格納している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>メソッドは、これらのスレッドが、タイムアウトまたは書き込みモードに入ったし、その後に終了するまで、または呼び出し元スレッド独自のタイムアウト期間が経過するまでブロックします。  
  
> [!NOTE]
>  ロックが再帰を許可する場合は、読み取りモードでロックに入ったスレッドは読み取りモードの再帰的に、書き込みモードに入力できます。  
  
 他のスレッドが読み取りモードでは、1 つのスレッドはアップグレード可能モードにできます。 追加のスレッドがアップグレード可能モードの入力を待機している書き込みモードに入るを待機しているスレッドがない場合は、スレッドの呼び出し、<xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A>メソッドは、すぐに読み取りモードに入るしはブロックしません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。  
  
- または - 
再帰の回数は、カウンターの容量を超える可能性があります。 この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> の値が負ですが、指定できる唯一の負の値である -1 ミリ秒と等しくありません。  
  
- または - 
<paramref name="timeout" /> の値が <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterUpgradeableReadLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>オプションのタイムアウトを指定して、アップグレード可能モードでロックに入ることを試みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>オプションのタイムアウトを指定して、アップグレード可能モードでロックに入ることを試みます。</summary>
        <returns>呼び出し元のスレッドがアップグレード可能モードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。  
  
 スレッドは、通常によって保護されているリソースにアクセスするときにアップグレード可能モードを使用して、<xref:System.Threading.ReaderWriterLockSlim>で読み取りモードには、特定の条件が満たされた場合は、書き込みモードを入力する必要があります。 アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りモードにダウン グレードすることができます。  
  
 1 つのスレッドは、任意の時点で、アップグレード可能モードでロックを入力できます。 スレッドがアップグレード可能モードでは、書き込みモードに入るを待機しているスレッドがない場合は、任意の数の他のスレッドはアップグレード可能モードを待機しているスレッドがある場合でも、読み取りモードを入力できます。  
  
 1 つまたは複数のスレッドが書き込みモードに待機している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>メソッドは、これらのスレッドが、タイムアウトまたは書き込みモードに入ったし、その後に終了するまで、または呼び出し元スレッド独自のタイムアウト期間が経過するまでブロックします。  
  
> [!NOTE]
>  ロックが再帰を許可する場合は、アップグレード可能モードでロックに入ったスレッドはアップグレード可能モードの再帰的に、書き込みモードに入力できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。  
  
- または - 
現在のスレッドは最初に読み取りモードでロックに入ったため、アップグレード可能モードに入ろうとするとデッドロックの可能性が生じます。  
  
- または - 
再帰の回数は、カウンターの容量を超える可能性があります。 この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> の値が負ですが、指定できる唯一の負の値である <see cref="F:System.Threading.Timeout.Infinite" /> (-1) と等しくありません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterUpgradeableReadLock">
      <MemberSignature Language="C#" Value="public bool TryEnterUpgradeableReadLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterUpgradeableReadLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterUpgradeableReadLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterUpgradeableReadLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterUpgradeableReadLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterUpgradeableReadLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">待機する間隔。無制限に待機する場合は -1 ミリ秒。</param>
        <summary>オプションのタイムアウトを指定して、アップグレード可能モードでロックに入ることを試みます。</summary>
        <returns>呼び出し元のスレッドがアップグレード可能モードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。  
  
 スレッドは、通常によって保護されているリソースにアクセスするときにアップグレード可能モードを使用して、<xref:System.Threading.ReaderWriterLockSlim>で読み取りモードには、特定の条件が満たされた場合は、書き込みモードを入力する必要があります。 アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りモードにダウン グレードすることができます。  
  
 1 つのスレッドは、任意の時点で、アップグレード可能モードでロックを入力できます。 スレッドがアップグレード可能モードでは、書き込みモードに入るを待機しているスレッドがない場合は、任意の数の他のスレッドはアップグレード可能モードを待機しているスレッドがある場合でも、読み取りモードを入力できます。  
  
 1 つまたは複数のスレッドが書き込みモードに待機している場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A>メソッドは、これらのスレッドが、タイムアウトまたは書き込みモードに入ったし、その後に終了するまで、または呼び出し元スレッド独自のタイムアウト期間が経過するまでブロックします。  
  
> [!NOTE]
>  ロックが再帰を許可する場合は、アップグレード可能モードでロックに入ったスレッドはアップグレード可能モードの再帰的に、書き込みモードに入力できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。  
  
- または - 
現在のスレッドは最初に読み取りモードでロックに入ったため、アップグレード可能モードに入ろうとするとデッドロックの可能性が生じます。  
  
- または - 
再帰の回数は、カウンターの容量を超える可能性があります。 この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> の値が負ですが、指定できる唯一の負の値である -1 ミリ秒と等しくありません。  
  
- または - 
<paramref name="timeout" /> の値が <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnterWriteLock">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>オプションのタイムアウトを指定して、書き込みモードでロックに入ることを試みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : int -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">待機するミリ秒数。無制限に待機する場合は <see cref="F:System.Threading.Timeout.Infinite" /> (-1)。</param>
        <summary>オプションのタイムアウトを指定して、書き込みモードでロックに入ることを試みます。</summary>
        <returns>呼び出し元のスレッドが書き込みモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`millisecondsTimeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。  
  
 他のスレッドが、読み取りモードでロックに入っている場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>メソッドは、これらのスレッドが読み取りモードを終了するまで、またはタイムアウト間隔が経過するまでブロックします。 書き込みモードに入るを待機しているスレッドがブロックされているときに、入力を待機しているすべてのスレッド 書き込みモードかタイムアウトまたは書き込みモードに入ったになり、終了するまで、読み取りモードまたはアップグレード可能モードに入ろうとする追加のスレッドがブロックします。  
  
> [!NOTE]
>  ロックが再帰を許可する場合は、書き込みモードでロックに入ったスレッドは書き込みモードの再帰的に、書き込みモードに入力できます。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>メソッドのタイムアウトの書き込みモードでロックに入るをします。例に示したメソッドは、キャッシュを同期する新しいキー/値ペアを追加します。 かどうか、スレッドがロックに入る前に指定されたタイムアウト期間が経過する、メソッドを返します`false`します。 メソッドを返します`true`キー/値ペアが追加された場合。  
  
 場合は、キーが内部でスローされる例外は、キャッシュに既に<xref:System.Collections.Generic.Dictionary%602>を許可するメソッドを終了します。 A`finally`ブロックを使用して実行を<xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A>メソッドを呼び出し元がロックを終了したことを確認します。  
  
 このコードは示されている例の一部、<xref:System.Threading.ReaderWriterLockSlim>クラス。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。  
  
- または - 
現在のスレッドは最初に読み取りモードでロックに入ったため、書き込みモードに入ろうとするとデッドロックの可能性が生じます。  
  
- または - 
再帰の回数は、カウンターの容量を超える可能性があります。 この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> の値が負ですが、指定できる唯一の負の値である <see cref="F:System.Threading.Timeout.Infinite" /> (-1) と等しくありません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnterWriteLock">
      <MemberSignature Language="C#" Value="public bool TryEnterWriteLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEnterWriteLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEnterWriteLock (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEnterWriteLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryEnterWriteLock : TimeSpan -&gt; bool" Usage="readerWriterLockSlim.TryEnterWriteLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">待機する間隔。無制限に待機する場合は -1 ミリ秒。</param>
        <summary>オプションのタイムアウトを指定して、書き込みモードでロックに入ることを試みます。</summary>
        <returns>呼び出し元のスレッドが書き込みモードに入った場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`timeout`0 (ゼロ) には、このメソッドはロック状態をチェックし、返します`false`目的の状態が使用できない場合にすぐにします。  
  
 他のスレッドが、読み取りモードでロックに入っている場合、スレッドを呼び出す、<xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A>メソッドは、これらのスレッドが読み取りモードを終了するまで、またはタイムアウト間隔が経過するまでブロックします。 書き込みモードに入るを待機しているスレッドがブロックされているときに、入力を待機しているすべてのスレッド 書き込みモードかタイムアウトまたは書き込みモードに入ったになり、終了するまで、読み取りモードまたはアップグレード可能モードに入ろうとする追加のスレッドがブロックします。  
  
> [!NOTE]
>  ロックが再帰を許可する場合は、書き込みモードでロックに入ったスレッドは書き込みモードの再帰的に、書き込みモードに入力できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.LockRecursionException">
          <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> プロパティが <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> で、現在のスレッドは既にロックに入っています。  
  
- または - 
現在のスレッドは最初に読み取りモードでロックに入ったため、書き込みモードに入ろうとするとデッドロックの可能性が生じます。  
  
- または - 
再帰の回数は、カウンターの容量を超える可能性があります。 この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> の値が負ですが、指定できる唯一の負の値である -1 ミリ秒と等しくありません。  
  
- または - 
<paramref name="timeout" /> の値が <see cref="F:System.Int32.MaxValue" /> ミリ秒を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.ReaderWriterLockSlim" /> オブジェクトは破棄されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitingReadCount">
      <MemberSignature Language="C#" Value="public int WaitingReadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingReadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingReadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingReadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingReadCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingReadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>読み取りモードでロックに入るのを待機しているスレッドの総数を取得します。</summary>
        <value>読み取りモードに入るのを待機しているスレッドの総数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。 結果は、計算が完了すると、すぐに変更できます。 そのため、このプロパティに基づいた決定を行う安全ではありません。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A>プロパティを読み取りモードに入るを待機している、ブロックされているスレッドの数がしきい値を超えた場合に、イベント ログ エントリを生成します。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingUpgradeCount">
      <MemberSignature Language="C#" Value="public int WaitingUpgradeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingUpgradeCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingUpgradeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingUpgradeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingUpgradeCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アップグレード可能モードでロックに入るのを待機しているスレッドの総数を取得します。</summary>
        <value>アップグレード可能モードに入るのを待機しているスレッドの総数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。 結果は、計算が完了すると、すぐに変更できます。 そのため、このプロパティに基づいた決定を行う安全ではありません。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A>プロパティ ブロックされると、アップグレード可能モードの入力を待機しているスレッドの数がしきい値を超えた場合、イベント ログ エントリを生成します。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WaitingWriteCount">
      <MemberSignature Language="C#" Value="public int WaitingWriteCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WaitingWriteCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitingWriteCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WaitingWriteCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitingWriteCount : int" Usage="System.Threading.ReaderWriterLockSlim.WaitingWriteCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>書き込みモードでロックに入るのを待機しているスレッドの総数を取得します。</summary>
        <value>書き込みモードに入るのを待機しているスレッドの総数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用してのみのログ記録の目的、およびデバッグ、プロファイリング、およびアルゴリズムの動作を制御するされません。 結果は、計算が完了すると、すぐに変更できます。 そのため、このプロパティに基づいた決定を行う安全ではありません。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A>書き込みモードに入るを待機している、ブロックされているスレッドの数がしきい値を超えた場合に、イベント ログ エントリを生成するプロパティ。  
  
 [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  
[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]
[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>