<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ReaderWriterLockSlim.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac52ff770bb9446d6ebe71649784ebe115f60734cc0.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2ff770bb9446d6ebe71649784ebe115f60734cc0</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</source>
          <target state="translated">リソースへのアクセス管理に使用するロックを表し、複数のスレッドによる読み取りや排他アクセスでの書き込みを許可します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Use <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> to protect a resource that is read by multiple threads and written to by one thread at a time.</source>
          <target state="translated">使用して<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>を複数のスレッドによって読み取られ、一度に 1 つのスレッドによって書き込まれるされるリソースを保護します。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> 複数のスレッドが読み取りモードである、1 つのスレッドで、ロックの排他的所有権書き込みモードに設定することができますできれたり、元のスレッドが解放することがなく 書き込みモードにアップグレードできます内にある読み取りアクセス権を持つ 1 つのスレッドs は、リソースへのアクセスを読み取る。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is similar to <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> は <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> と似ていますが、再帰の規則や、ロック状態のアップグレードおよびダウングレードの規則が簡素化されています。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> avoids many cases of potential deadlock.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> は、デッドロックの可能性を大幅に回避します。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>In addition, the performance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is significantly better than <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.</source>
          <target state="translated">さらに、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> のパフォーマンスは <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph> と比較して格段に優れています。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is recommended for all new development.</source>
          <target state="translated">すべての新規開発で、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> を使用することをお勧めします。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>By default, new instances of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> are created with the <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> flag and do not allow recursion.</source>
          <target state="translated">既定では、新しいインスタンス<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>で作成された、<ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>フラグ、再帰はできません。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.</source>
          <target state="translated">再帰が不要な複雑さの一部を紹介し、により、コードのデッドロックを受けやすいために、すべての新しい開発では、この既定のポリシーがお勧めします。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To simplify migration from existing projects that use <ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, you can use the <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> flag to create instances of <ph id="ph4">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allow recursion.</source>
          <target state="translated">既存のファイルからの移行が簡単に使用するをプロジェクト<ph id="ph1">&lt;xref:System.Threading.Monitor&gt;</ph>または<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>、使用することができます、<ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>のインスタンスを作成フラグ<ph id="ph4">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>再帰可能にします。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.</source>
          <target state="translated">スレッドは 3 つのモードでロックに入ることができます。 モード、書き込みモードでは、読み取りモードに入るを読み込みます。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(In the rest of this topic, "upgradeable read mode" is referred to as "upgradeable mode", and the phrase "enter <ph id="ph1">`x`</ph> mode" is used in preference to the longer phrase "enter the lock in <ph id="ph2">`x`</ph> mode".)</source>
          <target state="translated">(このトピックの残りの部分で「アップグレード可能な読み取りモード」と呼びます「アップグレード可能モード」と"入力<ph id="ph1">`x`</ph>モード"長い語句が %nd2 に関して使用"でロックに入る<ph id="ph2">`x`</ph>モード"です)。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Regardless of recursion policy, only one thread can be in write mode at any time.</source>
          <target state="translated">再帰ポリシーに関係なく 1 つだけことができるスレッド書き込みモードでいつでもできます。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When a thread is in write mode, no other thread can enter the lock in any mode.</source>
          <target state="translated">スレッドが書き込みモードでは、他のスレッドできますなしでロックに入るいずれかのモード。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Only one thread can be in upgradeable mode at any time.</source>
          <target state="translated">1 つのスレッドをいつでもアップグレード可能モードにできます。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">任意の数のスレッドのことができます、読み取りモードでできが 1 つのスレッド アップグレード可能モードで他のスレッドが読み取りモードでします。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This type implements the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">この型は、<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>インターフェイスです。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When you have finished using the type, you should dispose of it either directly or indirectly.</source>
          <target state="translated">型を使用してが完了したらを直接的または間接的にその破棄する必要があります。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To dispose of the type directly, call its <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`catch`</ph> block.</source>
          <target state="translated">型の直接 dispose を呼び出す、<ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>メソッドで、 <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`catch`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To dispose of it indirectly, use a language construct such as <ph id="ph1">`using`</ph> (in C#) or <ph id="ph2">`Using`</ph> (in Visual Basic).</source>
          <target state="translated">直接ことのない破棄する場合など、言語コンストラクトを使用して<ph id="ph1">`using`</ph>(C# の場合) または<ph id="ph2">`Using`</ph>(Visual Basic で)。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For more information, see the "Using an Object that Implements IDisposable" section in the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface topic.</source>
          <target state="translated">詳細についてを参照してください"を使用して、オブジェクトを実装する IDisposable"、<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>インターフェイスに関するトピック。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> has managed thread affinity; that is, each <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> object must make its own method calls to enter and exit lock modes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> スレッド アフィニティを管理します。つまり、各<ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph>オブジェクトを入力し、ロック モードを終了する独自のメソッド呼び出しを行う必要があります。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>No thread can change the mode of another thread.</source>
          <target state="translated">別のスレッドのモードに変更できますスレッドはありません。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>再帰では、ロックに入るしようがいくつかの理由をブロックできますスレッドではできません。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</source>
          <target state="translated">スレッドが書き込みモードまたは書き込みモードで 1 つのスレッドがあるかどうかの入力を待機している場合は、読み取りモードのブロックを入力しようとするスレッド。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Blocking new readers when writers are queued is a lock fairness policy that favors writers.</source>
          <target state="translated">ライターがキューに置かれたときに、新しいリーダーをブロックは、書き込みを優先するロックの公平性ポリシーです。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.</source>
          <target state="translated">現在の公平性ポリシーは、最も一般的なシナリオでのスループットを昇格するには、リーダーとライターに公平性を分散します。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Future versions of the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> may introduce new fairness policies.</source>
          <target state="translated">将来のバージョン、<ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>公平性の新しいポリシーを引き起こす可能性があります。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.</source>
          <target state="translated">既にある場合、スレッド アップグレード可能モードでスレッドが書き込みモードに入るを待機している場合、または 1 つのスレッドが書き込みモードである場合、アップグレード可能モードのブロックを入力しようとするスレッド。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that tries to enter write mode blocks if there is a thread in any of the three modes.</source>
          <target state="translated">3 つのモードのいずれかのスレッドがある場合は、書き込みモードのブロックを入力しようとするスレッド。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrading and Downgrading Locks</source>
          <target state="translated">アップグレードとダウン グレードのロックします。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.</source>
          <target state="translated">アップグレード可能モードは、ここで、スレッドは、通常、保護されたリソースから読み取ります。 ケースが、いくつかの条件が満たされた場合は、書き込みをする必要があります。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that has entered a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> methods.</source>
          <target state="translated">入力した、スレッド、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>アップグレード可能モードでは、保護されたリソースへの読み取りアクセスと書き込みを呼び出してモードにアップグレードできます、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.</source>
          <target state="translated">存在できないためだけに 1 つのスレッド アップグレード可能モードで、一度に、書き込みモードにアップグレードすることはできませんデッドロックの再帰が許可されていない場合、これは、既定のポリシー。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">再帰ポリシーに関係なく、最初に入力した読み取りスレッド パターンでは、デッドロックの可能性が作成されるため、アップグレード可能モードまたは、書き込みモードにアップグレードするモードが使用できません。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For example, if two threads in read mode both try to enter write mode, they will deadlock.</source>
          <target state="translated">たとえば、両方を入力しよう読み取りモードで 2 つのスレッドは書き込みモード場合、デッドロックは発生します。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode is designed to avoid such deadlocks.</source>
          <target state="translated">アップグレード可能モードは、このようなデッドロックを回避するよう設計されています。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If there are other threads in read mode, the thread that is upgrading blocks.</source>
          <target state="translated">ブロックのアップグレードは、スレッド、読み取りモードに他のスレッドがある場合です。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>While the thread is blocked, other threads that try to enter read mode are blocked.</source>
          <target state="translated">スレッドがブロックされている間は、読み取りモードに入るしようとする他のスレッドがブロックされます。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When all threads have exited from read mode, the blocked upgradeable thread enters write mode.</source>
          <target state="translated">終了するとすべてのスレッドが読み取りモードから、ブロックされているアップグレード可能なスレッドが書き込みモードに入ります。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.</source>
          <target state="translated">入力を待機している他のスレッドが書き込みモードがある場合、ブロックされたまま、アップグレード可能モードでは、1 つのスレッドが原因で、リソースへの排他アクセスを防ぐためです。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.</source>
          <target state="translated">アップグレード可能モードでスレッドが書き込みモードを終了したときに、ので、入力を待機しているスレッドが書き込みモードである場合を除き、読み取りモードに入るを待機している他のスレッドが実行できます。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.</source>
          <target state="translated">アップグレード可能モードでのスレッドでは、アップグレードでき、保護されたリソースを書き込み、唯一のスレッドである限り、無期限にダウン グレードすることができます。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.</source>
          <target state="translated">入力に複数のスレッドを許可する場合は、書き込みモードまたはアップグレード可能モードは、1 つのスレッドがアップグレード可能モードを独占できないようにする必要があります。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.</source>
          <target state="translated">それ以外の場合、モード直接が無限にブロック、および他のスレッドが読み取りモードに入ることされますがブロックされた入力しようとするスレッドを記述します。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in upgradeable mode can downgrade to read mode by first calling the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method and then calling the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method.</source>
          <target state="translated">アップグレード可能モードでのスレッドは、最初の呼び出しで、読み取りモードにダウン グレードできますが、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph>メソッドを呼び出すことで、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This downgrade pattern is allowed for all lock recursion policies, even <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>.</source>
          <target state="translated">このダウン グレード パターンがすべてのロック再帰ポリシーも許可されている<ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.</source>
          <target state="translated">、読み取りモードにダウン グレードした後、スレッドできません再入力アップグレード可能モード読み取りモードを終了するまでします。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Entering the Lock Recursively</source>
          <target state="translated">再帰的にロックを入力します。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>You can create a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that supports recursive lock entry by using the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph> constructor that specifies lock policy, and specifying <ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">作成することができます、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>を使用して再帰的なロックのエントリをサポートする、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph>ロック ポリシーを指定することを指定するコンス トラクター<ph id="ph3">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.</source>
          <target state="translated">新規の開発では、不要な複雑さの一部を紹介し、により、コードのデッドロックを受けやすいために、再帰の使用はお勧めできません。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>For a <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allows recursion, the following can be said about the modes a thread can enter:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>再帰を利用できる、スレッドが入力できるモードは、次と言えます。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.</source>
          <target state="translated">読み取りモードでのスレッドは読み取りモードを再帰的を入力できますが、書き込みモードか、アップグレード可能モードを入力することはできません。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If it tries to do this, a <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown.</source>
          <target state="translated">これを行うしようとすると、<ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.</source>
          <target state="translated">入力を読み取るモード」と入力して、書き込みモード アップグレード可能モードには、デッドロックの確率が厳密なパターンがあるため、許可されていません。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.</source>
          <target state="translated">既に説明したように、アップグレード可能モードのロックをアップグレードする必要がある場合は指定できます。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.</source>
          <target state="translated">アップグレード可能モードでのスレッドは、書き込みモードまたは読み取りモードは、入力できの 3 つのモードの再帰的に入力できます。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>However, an attempt to enter write mode blocks if there are other threads in read mode.</source>
          <target state="translated">ただしに入ろうとする、書き込みモード ブロック読み取りモードで他のスレッドがあるかどうか。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.</source>
          <target state="translated">書き込みモードでのスレッドは読み取りモードやアップグレード可能モードを入力しの 3 つのモードの再帰的に入力できます。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread that has not entered the lock can enter any mode.</source>
          <target state="translated">ロックに入ったがないことをスレッドには、どのモードを入力できます。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This attempt can block for the same reasons as an attempt to enter a non-recursive lock.</source>
          <target state="translated">この試行は、非再帰的なロックに入ろうとすると同じ理由でブロックできます。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.</source>
          <target state="translated">スレッドは、何度でも、そのモードに入ったこととまったく同じように各モードを終了する限り、任意の順序でが入ったモードを終了できます。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> is thrown.</source>
          <target state="translated">スレッドの試行回数が多すぎますモードを終了するかがない入力モードを終了する場合、<ph id="ph1">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Lock States</source>
          <target state="translated">ロックの状態</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>You may find it useful to think of the lock in terms of its states.</source>
          <target state="translated">ロックの状態の観点で考えるとわかりやすくすることもあります。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> can be in one of four states: not entered, read, upgrade, and write.</source>
          <target state="translated">A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> 4 つの状態のいずれかになります: 入力されていない、読み取り、アップグレード、および記述します。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).</source>
          <target state="translated">入力されていません。 この状態で、スレッド ロックに入ったありません (またはすべてのスレッドがロックを終了)。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Read: In this state, one or more threads have entered the lock for read access to the protected resource.</source>
          <target state="translated">お読みください: この状態で、1 つまたは複数のスレッド ロックに入った読み取りアクセスで保護されたリソースにします。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>A thread can enter the lock in read mode by using the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> methods, or by downgrading from upgradeable mode.</source>
          <target state="translated">スレッドを使用して読み取りモードでロックを入力することができます、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph>メソッド、またはアップグレード可能モードからダウン グレードしています。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.</source>
          <target state="translated">アップグレード: この状態で、1 つのスレッドがロックに入った書き込みのアクセス許可にアップグレードするオプションを使用して、読み取りアクセス用 (つまり、アップグレード可能モードで)、読み取りアクセスでロックに入った 0 個以上のスレッドとします。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.</source>
          <target state="translated">一度に 2 つ以上のスレッドが; にアップグレードするオプションでロックに入ることができます。アップグレード可能モードに切り替わるしようとする追加のスレッドがブロックされます。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Write: In this state, one thread has entered the lock for write access to the protected resource.</source>
          <target state="translated">書き込み: この状態で、1 つのスレッドがロックに入った書き込みアクセスの保護されたリソースにします。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>That thread has exclusive possession of the lock.</source>
          <target state="translated">そのスレッドは、ロックを所有している排他を持っています。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Any other thread that tries to enter the lock for any reason is blocked.</source>
          <target state="translated">何らかの理由でロックに入るしようとする他のスレッドがブロックされます。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread <ph id="ph1">`t`</ph> takes the action described in the leftmost column.</source>
          <target state="translated">次の表の場合、スレッドは再帰を許可されていないロックのロックの状態間の遷移<ph id="ph1">`t`</ph>左端の列に説明されているアクションを実行します。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>At the time it takes the action, <ph id="ph1">`t`</ph> has no mode.</source>
          <target state="translated">時に、その操作を行う<ph id="ph1">`t`</ph>モードがありません。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(The special case where <ph id="ph1">`t`</ph> is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.</source>
          <target state="translated">(という特殊なケース場所<ph id="ph1">`t`</ph>では、アップグレード可能モードは、表の脚注に記載されています)。一番上の行では、ロックの開始時の状態について説明します。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The cells describe what happens to the thread, and show changes to the lock state in parentheses.</source>
          <target state="translated">セルは、スレッドの処理を説明し、かっこ内にロック状態の変更を表示します。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Not entered (N)</source>
          <target state="translated">入っていない (N)</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Read (R)</source>
          <target state="translated">Read (R)</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgrade (U)</source>
          <target state="translated">アップグレード (U)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Write (W)</source>
          <target state="translated">書き込み (W)</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters read mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> 読み取りモードに入ります</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (R).</source>
          <target state="translated"><ph id="ph1">`t`</ph> (R) を入力します。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id="ph2">`t`</ph> enters.</source>
          <target state="translated"><ph id="ph1">`t`</ph> スレッドが書き込みモードです。 を待機している場合それ以外の場合、<ph id="ph2">`t`</ph>を入力します。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id="ph2">`t`</ph> enters.<bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept></source>
          <target state="translated"><ph id="ph1">`t`</ph> スレッドが書き込みモードです。 を待機している場合それ以外の場合、<ph id="ph2">`t`</ph>を入力します<bpt id="p1">&lt;sup&gt;</bpt>。1<ept id="p1">&lt;/sup&gt;</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> ブロックです。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters upgradeable mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> アップグレード可能モードに入ります</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (U).</source>
          <target state="translated"><ph id="ph1">`t`</ph> (U) を入力します。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks if threads are waiting for write mode or upgrade mode; otherwise, <ph id="ph2">`t`</ph> enters (U).</source>
          <target state="translated"><ph id="ph1">`t`</ph> スレッドが待機している場合は書き込みモードまたはアップグレード モードです。それ以外の場合、 <ph id="ph2">`t`</ph> (U) を入力します。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> ブロックです。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> ブロックです。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters write mode</source>
          <target state="translated"><ph id="ph1">`t`</ph> 書き込みモードに入ります</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> enters (W).</source>
          <target state="translated"><ph id="ph1">`t`</ph> 入力 (W)。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> ブロックです。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept></source>
          <target state="translated"><ph id="ph1">`t`</ph> ブロックです。<bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept></target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><ph id="ph1">`t`</ph> blocks.</source>
          <target state="translated"><ph id="ph1">`t`</ph> ブロックです。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept> If <ph id="ph1">`t`</ph> starts out in upgradeable mode, it enters read mode.</source>
          <target state="translated"><bpt id="p1">&lt;sup&gt;</bpt>1<ept id="p1">&lt;/sup&gt;</ept>場合<ph id="ph1">`t`</ph>開始アウト アップグレード可能モードで読み取りモードに入ります。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This action never blocks.</source>
          <target state="translated">このアクションを決してをブロックします。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The lock state does not change.</source>
          <target state="translated">ロックの状態は変更されません。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)</source>
          <target state="translated">(スレッドは、アップグレード可能モードを終了することによって読み取りモードにダウン グレードを完了できますし、)。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source><bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept> If <ph id="ph1">`t`</ph> starts out in upgradeable mode, it blocks if there are threads in read mode.</source>
          <target state="translated"><bpt id="p1">&lt;sup&gt;</bpt>2<ept id="p1">&lt;/sup&gt;</ept>場合<ph id="ph1">`t`</ph>アップグレード可能モードで開始、ブロックのスレッドが読み取りモードである場合。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Otherwise it upgrades to write mode.</source>
          <target state="translated">それ以外の場合、これは書き込みモードにアップグレードします。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The lock state changes to Write (W).</source>
          <target state="translated">ロック状態の変更に書き込み (W)。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If <ph id="ph1">`t`</ph> blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.</source>
          <target state="translated">場合<ph id="ph1">`t`</ph>、読み取りモードでスレッドがブロックの最後のスレッドが読み取りモードを終了するとすぐに書き込みモードに入りますが、入力を待機しているスレッドが書き込みモードである場合でもです。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:</source>
          <target state="translated">スレッドがロックを終了したため、状態の変更が発生したときに起動される次のスレッドがとおりに選択します。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).</source>
          <target state="translated">最初を待機しているスレッドは書き込みモードとが既に (あります多くてこのような 1 つのスレッド) アップグレード可能モードでします。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, a thread that is waiting for write mode.</source>
          <target state="translated">それがない場合は、書き込みモードを待機しているスレッド。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, a thread that is waiting for upgradeable mode.</source>
          <target state="translated">それがない場合は、アップグレード可能モードを待機しているスレッド。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Failing that, all threads that are waiting for read mode.</source>
          <target state="translated">読み取りモードを待機しているすべてのスレッドを失敗しています。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.</source>
          <target state="translated">ロックの後続の状態は常に書き込み (W)、最初の 2 つのケースとアップグレード (U) スレッドの終了に伴って状態の変更をトリガーされたときに、ロックの状態に関係なく、3 番目のケースでします。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.</source>
          <target state="translated">最後の場合、ロックの状態アップグレード (U) ある場合がスレッド アップグレード可能モードで、状態の変更、および Read (R) 後にそれ以外の場合、以前の状態に関係なく。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following example shows a simple synchronized cache that holds strings with integer keys.</source>
          <target state="translated">次の例では、整数キーを持つ文字列を保持する単純な同期されたキャッシュを示します。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>An instance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> that serves as the inner cache.</source>
          <target state="translated">インスタンス<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>へのアクセスを同期するために使用される、<ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>内部キャッシュとして機能します。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</source>
          <target state="translated">例では、単純なキャッシュへの追加、およびメソッド、キャッシュから削除するキャッシュからの読み取りにはが含まれています。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</source>
          <target state="translated">タイムアウトを示すためには、例には、指定したタイムアウト内で実行可能であれば、キャッシュに追加するメソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">アップグレード可能モードを示すためは、この例は、キーに関連付けられている値を取得する方法を説明し、新しい値を持つ比較します。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">値が変更されていない場合は、変更がないことを示すステータスを返します。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">これは、値が見つからないため、キー、キー/値ペアが挿入されます。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">値が変更された場合は更新されます。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</source>
          <target state="translated">アップグレード可能モードでは、スレッドの書き込みアクセスを必要に応じて、デッドロックの危険を回避への読み取りアクセスからのアップグレードを許可します。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</source>
          <target state="translated">この例には、アップグレード可能モードを示すメソッドの戻り値を指定する入れ子になった列挙体が含まれています。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">例では、既定のコンス トラクターを使用して、ロックを作成して、再帰は許可されません。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">プログラミング、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>はロックで再帰が許可されない場合は、簡単かつエラーが発生しにくくなりました。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">次のコードで使用して、<ph id="ph1">`SynchronizedCache`</ph>野菜名の辞書を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>It creates three tasks.</source>
          <target state="translated">3 つのタスクを作成します。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">最初の配列に格納されている野菜の名前を書き込みます、<ph id="ph1">`SynchronizedCache`</ph>インスタンス。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">2 番目と 3 番目のタスクは、野菜、昇順 (低インデックスから最も大きいインデックス)、降順で、2 つ目の最初の名前を表示します。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">最後のタスクは、文字列「したきゅうり」を検索し、発見された場合を呼び出して、 <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> "緑 bean"文字列を置換するメソッド。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>This type is thread safe.</source>
          <target state="translated">この型はスレッド セーフです。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class with default property values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> クラスの新しいインスタンスを既定のプロパティ値で初期化します。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>A <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that is initialized with this constructor does not allow recursion.</source>
          <target state="translated">A<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>これを初期化するコンス トラクターでは、再帰することはできません。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>That is, the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property returns <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">つまり、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> プロパティが <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">再帰ポリシーとその影響の詳細については、次を参照してください。、<ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph>列挙型、および<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The following example shows a simple synchronized cache that holds strings with integer keys.</source>
          <target state="translated">次の例では、整数キーを持つ文字列を保持する単純な同期されたキャッシュを示します。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>An instance of <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> that serves as the inner cache.</source>
          <target state="translated">インスタンス<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>へのアクセスを同期するために使用される、<ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>内部キャッシュとして機能します。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The parameterless constructor is used to create the lock.</source>
          <target state="translated">パラメーターなしのコンス トラクターを使用して、ロックを作成できます。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example includes simple methods to add to the cache, delete from the cache, and read from the cache.</source>
          <target state="translated">例では、単純なキャッシュへの追加、およびメソッド、キャッシュから削除するキャッシュからの読み取りにはが含まれています。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.</source>
          <target state="translated">タイムアウトを示すためには、例には、指定したタイムアウト内で実行可能であれば、キャッシュに追加するメソッドが含まれています。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">アップグレード可能モードを示すためは、この例は、キーに関連付けられている値を取得する方法を説明し、新しい値を持つ比較します。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">値が変更されていない場合は、変更がないことを示すステータスを返します。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">これは、値が見つからないため、キー、キー/値ペアが挿入されます。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">値が変更された場合は更新されます。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.</source>
          <target state="translated">アップグレード可能モードでは、スレッドの書き込みアクセスを必要に応じて、デッドロックの危険を回避への読み取りアクセスからのアップグレードを許可します。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.</source>
          <target state="translated">この例には、アップグレード可能モードを示すメソッドの戻り値を指定する入れ子になった列挙体が含まれています。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">例では、既定のコンス トラクターを使用して、ロックを作成して、再帰は許可されません。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">プログラミング、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>はロックで再帰が許可されない場合は、簡単かつエラーが発生しにくくなりました。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">次のコードで使用して、<ph id="ph1">`SynchronizedCache`</ph>野菜名の辞書を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>It creates three tasks.</source>
          <target state="translated">3 つのタスクを作成します。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">最初の配列に格納されている野菜の名前を書き込みます、<ph id="ph1">`SynchronizedCache`</ph>インスタンス。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">2 番目と 3 番目のタスクは、野菜、昇順 (低インデックスから最も大きいインデックス)、降順で、2 つ目の最初の名前を表示します。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">最後のタスクは、文字列「したきゅうり」を検索し、発見された場合を呼び出して、 <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> "緑 bean"文字列を置換するメソッド。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>One of the enumeration values that specifies the lock recursion policy.</source>
          <target state="translated">ロック再帰ポリシーを指定する列挙値のいずれか。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class, specifying the lock recursion policy.</source>
          <target state="translated">ロック再帰ポリシーを指定して、<ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Recursion policy determines the restrictions on threads that enter the lock more than once.</source>
          <target state="translated">再帰ポリシーでは、複数回ロックに入るスレッドに関する制限事項を決定します。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>For example, if a lock was created with <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> and a thread has entered the lock in read mode, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.</source>
          <target state="translated">たとえば、ロックの作成時の<ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>スレッドが、読み取りモードでロックに入ったと<ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph>スレッドが読み取りモードでロックを再入力しようとした場合にスローされます。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Similarly, if a thread has entered the lock in write mode, <ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in any mode.</source>
          <target state="translated">同様に、スレッドが書き込みモードでロックに入った場合は、<ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph>が、スレッドは、いずれかのモードでロックを再入力しようとした場合にスローされます。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</source>
          <target state="translated">アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りロック再帰ポリシー設定に関係なくモードにダウン グレードすることができます。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">再帰ポリシーに関係なく、最初に入力した読み取りスレッド パターンでは、デッドロックの可能性が作成されるため、アップグレード可能モードまたは、書き込みモードにアップグレードするモードが使用できません。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">再帰ポリシーとその影響の詳細については、次を参照してください。、<ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph>列挙型、および<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The following example shows two exception scenarios, one that depends on the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> setting and one that does not.</source>
          <target state="translated">次の例は、いずれかに依存している 2 つの例外シナリオ、<ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph>設定としない種類です。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>In the first scenario, the thread enters read mode and then tries to enter read mode recursively.</source>
          <target state="translated">最初のシナリオでは、スレッドは、読み取りモードに入りますで、読み取りモードの再帰的を入力しようとします。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>If the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is created by using the default constructor, which sets recursion policy to <ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>, an exception is thrown.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>再帰ポリシーを設定の既定のコンス トラクターを使用して作成された<ph id="ph2">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>例外がスローされます。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>If <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph> is used to create the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>, no exception is thrown.</source>
          <target state="translated">場合<ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.SupportsRecursion?displayProperty=nameWithType&gt;</ph>作成に使用される、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>例外はスローされません。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>In the second scenario, the thread enters read mode and then tries to enter write mode.</source>
          <target state="translated">2 番目のシナリオでは、スレッドが読み取りモードに入ったし、入ろう書き込みますモード。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown regardless of the lock recursion policy.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.LockRecursionException&gt;</ph> ロック再帰ポリシーに関係なくがスローされます。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The following code then uses the <ph id="ph1">`SynchronizedCache`</ph> object to store a dictionary of vegetable names.</source>
          <target state="translated">次のコードで使用して、<ph id="ph1">`SynchronizedCache`</ph>野菜名の辞書を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>It creates three tasks.</source>
          <target state="translated">3 つのタスクを作成します。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The first writes the names of vegetables stored in an array to a <ph id="ph1">`SynchronizedCache`</ph> instance.</source>
          <target state="translated">最初の配列に格納されている野菜の名前を書き込みます、<ph id="ph1">`SynchronizedCache`</ph>インスタンス。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order.</source>
          <target state="translated">2 番目と 3 番目のタスクは、野菜、昇順 (低インデックスから最も大きいインデックス)、降順で、2 つ目の最初の名前を表示します。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
          <source>The final task searches for the string "cucumber" and, when it finds it, calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method  to substitute the string "green bean".</source>
          <target state="translated">最後のタスクは、文字列「したきゅうり」を検索し、発見された場合を呼び出して、 <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> "緑 bean"文字列を置換するメソッド。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Gets the total number of unique threads that have entered the lock in read mode.</source>
          <target state="translated">読み取りモードでロックに入った一意のスレッドの総数を取得します。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The number of unique threads that have entered the lock in read mode.</source>
          <target state="translated">読み取りモードでロックに入った一意のスレッドの数。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</source>
          <target state="translated">スレッドは 1 回だけカウントされますが、場合でも、再帰とスレッドを許可する、ロックがモードに入った読み取り複数回。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">このプロパティを使用して、デバッグ、プロファイリング、およびログ記録の目的、に対してのみを除く、アルゴリズムの動作を制御します。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">結果は、計算が完了するとすぐに変更できます。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">そのため、このプロパティに基づいた意思決定を行う安全ではありません。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A&gt;</ph> property to generate an event log entry if the number of threads in read mode exceeds a threshold.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A&gt;</ph>読み取りモードでのスレッドの数がしきい値を超えた場合に、イベント ログ エントリを生成するプロパティです。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> を使い終わったら <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> を呼び出します。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> method leaves the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in an unusable state.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> メソッドによって、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> は使用不可の状態になります。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>After calling <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> was occupying.</source>
          <target state="translated">呼び出した後<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>へのすべての参照を解放する必要があります、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>ガベージ コレクターがメモリを再利用できるようにする、<ph id="ph3">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>占有されていた。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。<bpt id="p1">[</bpt>アンマネージ リソースのクリーンアップ<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>と<bpt id="p2">[</bpt>Dispose メソッドの実装<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>Always call <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> object.</source>
          <target state="translated">常に呼び出す<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>への参照を解放する前に、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /&gt;</ph> が 0 より大きい値です。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /&gt;</ph> が 0 より大きい値です。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.Dispose">
          <source><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /&gt;</ph> が 0 より大きい値です。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Tries to enter the lock in read mode.</source>
          <target state="translated">読み取りモードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">このメソッドはブロックされるまで、呼び出し元のスレッドがロックに入るし、しない可能性がありますを返します。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph>その間隔の間に読み取りモードに指定した時間をブロックし、呼び出し元のスレッドが入力がないかどうかを返すメソッド。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>Multiple threads can enter read mode at the same time.</source>
          <target state="translated">複数のスレッドは、同時に読み取りモードに入ることができます。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">1 つまたは複数のスレッドが書き込みモードに入るを待機している場合、スレッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph>メソッドは、これらのスレッドがいずれかのブロックは、タイムアウトしたため、または書き込みモードに入ったからそれを終了します。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">ロックは、再帰を許可する場合は、読み取りモードでロックに入ったスレッドは読み取りモードを再帰的に、書き込みモードに入る入力できます。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>At most one thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">他のスレッドが読み取りモードでは、最大で 1 つのスレッドはアップグレード可能モードでできます。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">追加のスレッドがアップグレード可能モードに切り替わるを待機している書き込みモードに入るを待機しているスレッドが存在しない場合は、スレッドの呼び出し、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph>メソッドが読み取りモードをすぐに入力し、ブロックされません。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method to enter the lock in read mode.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph>読み取りモードでロックに入ることメソッドです。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The method shown in the example retrieves the value associated with a key.</source>
          <target state="translated">この例に示すようにメソッドでは、キーに関連付けられている値を取得します。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>If the key is not found, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">キーが見つからなかったかどうか、内部によってスローされる例外<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>terminate、メソッドを許可します。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> method, ensuring that the caller exits read mode.</source>
          <target state="translated">A<ph id="ph1">`finally`</ph>ブロックの実行を使用して、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph>メソッドを呼び出し元が読み取りモードを終了することを確認します。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">このコードに示されている例の一部である、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The current thread cannot acquire the write lock when it holds the read lock.</source>
          <target state="translated">現在のスレッドは、読み込みロックを保持しながら書き込みロックを取得することはできません。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the read lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> プロパティは <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> です。現在のスレッドは、読み取りロックを保持しながら読み取りロックを取得しようとしました。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the write lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> プロパティは <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> です。現在のスレッドは、書き込みロックを保持しながら読み取りロックを取得しようとしました。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">再帰の回数は、カウンターの容量を超える可能性があります。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>This limit is so large that applications should never encounter this exception.</source>
          <target state="translated">この制限は非常に大きいため、アプリケーションで、この例外が発生することはないはずです。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> オブジェクトは破棄されています。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Tries to enter the lock in upgradeable mode.</source>
          <target state="translated">アップグレード可能モードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">このメソッドはブロックされるまで、呼び出し元のスレッドがロックに入るし、しない可能性がありますを返します。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph>メソッドは、指定した時間のブロックをかどうか、呼び出し元スレッドがないモードに入ったアップグレード可能な時間中に返されます。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">スレッド通常によって保護されているリソースにアクセスするときにアップグレード可能モードを使用して、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>に読み取りモードには、特定の条件が満たされた場合は、書き込みモードを入力する必要があります。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</source>
          <target state="translated">アップグレード可能モードでのスレッドでは、読み取りモードにダウン グレードしたり、書き込みモードにアップグレードすることができます。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Only one thread can enter upgradeable mode at any given time.</source>
          <target state="translated">1 つのスレッドは、特定の時点でアップグレード可能モードを入力できます。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">アップグレード可能モードに、スレッドが書き込みモードに入るを待機しているスレッドが存在しない場合は、任意の数の他のスレッドはアップグレード可能モードに切り替わるを待機しているスレッドがある場合でも、読み取りモードを入力できます。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">1 つまたは複数のスレッドが書き込みモードに入るを待機している場合、スレッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph>メソッドは、これらのスレッドがいずれかのブロックは、タイムアウトしたため、または書き込みモードに入ったからそれを終了します。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">ロックは、再帰を許可する場合は、アップグレード可能モードでロックに入ったスレッドはアップグレード可能モードの再帰的に、書き込みモードに入る入力できます。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method to enter the lock in upgradeable mode.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph>アップグレード可能モードでロックに入ることメソッドです。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method, ensuring that the caller exits upgradeable mode.</source>
          <target state="translated">A<ph id="ph1">`finally`</ph>ブロックの実行を使用して、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph>メソッドを呼び出し元がアップグレード可能モードを終了することを確認します。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The method shown in the example retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">例に示されたメソッドは、キーに関連付けられている値を取得し、新しい値と比較します。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">値が変更されていない場合は、変更がないことを示すステータスを返します。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">これは、値が見つからないため、キー、キー/値ペアが挿入されます。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">値が変更された場合は更新されます。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</source>
          <target state="translated">アップグレード可能モードでは、スレッドなく必要に応じて、デッドロックの危険性は、読み取りロックをアップグレードします。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">例では、既定のコンス トラクターを使用して、ロックを作成して、再帰は許可されません。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">プログラミング、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>はロックで再帰が許可されない場合は、簡単かつエラーが発生しにくくなりました。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">このコードに示されている例の一部である、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock in any mode.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> プロパティが <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> で、現在のスレッドは既にいずれかのモードでロックに入っています。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">現在のスレッドは既に読み取りモードに入っているため、アップグレード可能モードに入ろうとするとデッドロックの可能性が生じます。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">再帰の回数は、カウンターの容量を超える可能性があります。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> オブジェクトは破棄されています。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>Tries to enter the lock in write mode.</source>
          <target state="translated">書き込みモードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>This method blocks until the calling thread enters the lock, and therefore might never return.</source>
          <target state="translated">このメソッドはブロックされるまで、呼び出し元のスレッドがロックに入るし、しない可能性がありますを返します。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>Use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph>メソッドは、指定した時間のブロックをかどうか、呼び出し元スレッドがないモードに入った書き込み時間中に返されます。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode.</source>
          <target state="translated">他のスレッドは、読み取りモードでロックに入ったが場合、スレッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph>読み取りモードにメソッドは、これらのスレッドが終了するまでブロックします。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">書き込みモードに入るを待機しているスレッドが存在する場合、書き込みモードに入るを待機しているすべてのスレッドがあるかになるまで、読み取りモードまたはアップグレード可能モードのブロックを入力しようとする追加のスレッドはタイムアウトまたは書き込みモードに入ったし、そこから、終了しました。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">ロックは、再帰を許可する、他のスレッドが書き込みモードに入るを待機している場合でも、書き込みモードでロックに入ったスレッドは書き込みモードを入力できます。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method to enter the lock in write mode.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph>書き込みモードでロックに入ることメソッドです。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">例に示すメソッドは、同期、キャッシュに新しいキー/値ペアを追加します。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">場合は、キーが、キャッシュでは、内部によってスローされる例外に既に<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>terminate、メソッドを許可します。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits write mode.</source>
          <target state="translated">A<ph id="ph1">`finally`</ph>ブロックの実行を使用して、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph>メソッドを呼び出し元が書き込みモードを終了することを確認します。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">このコードに示されている例の一部である、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock in any mode.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> プロパティが <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> で、現在のスレッドは既にいずれかのモードでロックに入っています。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.</source>
          <target state="translated">現在のスレッドは読み取りモードに入っているため、書き込みモードでロックに入ろうとするとデッドロックの可能性が生じます。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">再帰の回数は、カウンターの容量を超える可能性があります。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> オブジェクトは破棄されています。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</source>
          <target state="translated">読み取りモードの再帰カウントを減らし、結果のカウントが 0 (ゼロ) の場合には読み取りモードを終了します。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">このメソッドは、再帰の順序に影響はありません。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">たとえば、スレッドがアップグレード可能モードでロックに入った、読み取りモードでロックに入った場合、スレッドが 2 つのモードを終了する順序は関係ありません。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</source>
          <target state="translated">ロックは、再帰を許可する場合、スレッドできます書き込みモードでロックに入るし、入力を再帰的に読み取りモードであります。スレッドが終了する順序は、読み取りモードと、書き込みモードは関係ありません。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">ロックを終了すると、その他の待機中のスレッドがシグナル可能性があります。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph> method, ensuring that the caller exits read mode.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">`finally`</ph>ブロックが実行、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A&gt;</ph>メソッドを呼び出し元が読み取りモードを終了することを確認します。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The method shown in the example retrieves the value associated with a key.</source>
          <target state="translated">この例に示すようにメソッドでは、キーに関連付けられている値を取得します。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>If the key is not found, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">キーが見つからなかったかどうか、内部によってスローされる例外<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>terminate、メソッドを許可します。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method is used to enter read mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph>メソッドを使用して、読み取りモードを入力します。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">このコードに示されている例の一部である、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
          <source>The current thread has not entered the lock in read mode.</source>
          <target state="translated">現在のスレッドは読み取りモードでロックに入っていません。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</source>
          <target state="translated">アップグレード可能モードの再帰カウントを減らし、結果のカウントが 0 (ゼロ) の場合にはアップグレード可能モードを終了します。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">このメソッドは、再帰の順序に影響はありません。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">たとえば、スレッドがアップグレード可能モードでロックに入ったし、書き込みモードでロックに入った場合、スレッドが 2 つのモードを終了する順序は関係ありません。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.</source>
          <target state="translated">ロックは、再帰を許可する場合、スレッドできます書き込みモードでロックに入るし、入力を再帰的にアップグレード可能モードであります。スレッドがアップグレード可能モードと書き込みのモードを終了する順序は重要ではありません。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">ロックを終了すると、その他の待機中のスレッドがシグナル可能性があります。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method, ensuring that the caller exits upgradeable mode.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">`finally`</ph>ブロックが実行、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph>メソッドを呼び出し元がアップグレード可能モードを終了することを確認します。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The method shown in the example retrieves the value associated with a key and compares it with a new value.</source>
          <target state="translated">例に示されたメソッドは、キーに関連付けられている値を取得し、新しい値と比較します。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If the value is unchanged, the method returns a status indicating no change.</source>
          <target state="translated">値が変更されていない場合は、変更がないことを示すステータスを返します。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>It no value is found for the key, the key/value pair is inserted.</source>
          <target state="translated">これは、値が見つからないため、キー、キー/値ペアが挿入されます。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>If the value has changed, it is updated.</source>
          <target state="translated">値が変更された場合は更新されます。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.</source>
          <target state="translated">アップグレード可能モードでは、スレッドなく必要に応じて、デッドロックの危険性は、読み取りロックをアップグレードします。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The example uses the default constructor to create the lock, so recursion is not allowed.</source>
          <target state="translated">例では、既定のコンス トラクターを使用して、ロックを作成して、再帰は許可されません。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>Programming the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is simpler and less prone to error when the lock does not allow recursion.</source>
          <target state="translated">プログラミング、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>はロックで再帰が許可されない場合は、簡単かつエラーが発生しにくくなりました。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">このコードに示されている例の一部である、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
          <source>The current thread has not entered the lock in upgradeable mode.</source>
          <target state="translated">現在のスレッドはアップグレード可能モードでロックに入っていません。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</source>
          <target state="translated">書き込みモードの再帰カウントを減らし、結果のカウントが 0 (ゼロ) の場合には書き込みモードを終了します。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>This method is not sensitive to recursion order.</source>
          <target state="translated">このメソッドは、再帰の順序に影響はありません。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.</source>
          <target state="translated">たとえば、スレッドがアップグレード可能モードでロックに入ったし、書き込みモードでロックに入った場合、スレッドが 2 つのモードを終了する順序は関係ありません。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.</source>
          <target state="translated">ロックは、再帰を許可する場合、スレッドできます書き込みモードでロックに入るし、入力を再帰的に読み取りモードであります。スレッドが終了する順序は、読み取りモードと、書き込みモードは関係ありません。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>Exiting the lock might signal other waiting threads.</source>
          <target state="translated">ロックを終了すると、その他の待機中のスレッドがシグナル可能性があります。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The following example shows how to use a <ph id="ph1">`finally`</ph> block to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits write mode.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">`finally`</ph>ブロックが実行、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph>メソッドを呼び出し元が書き込みモードを終了することを確認します。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">例に示すメソッドは、同期、キャッシュに新しいキー/値ペアを追加します。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">場合は、キーが、キャッシュでは、内部によってスローされる例外に既に<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>terminate、メソッドを許可します。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method is used to enter the lock in write mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph>メソッドは書き込みモードでロックに入るに使用します。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">このコードに示されている例の一部である、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
          <source>The current thread has not entered the lock in write mode.</source>
          <target state="translated">現在のスレッドは書き込みモードでロックに入っていません。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in read mode.</source>
          <target state="translated">現在のスレッドが読み取りモードでロックに入ったかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered read mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在のスレッドが読み取りモードに入った場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>、それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">使用するアサートまたはその他のデバッグの目的では、このプロパティを目的としています。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">プログラム実行のフローを制御するのには使用しないでください。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered read mode unexpectedly.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A&gt;</ph>読み取りモードに予期せず、現在のスレッドが入力した場合は、アサートを生成するプロパティです。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.</source>
          <target state="translated">現在のスレッドがアップグレード可能モードでロックに入ったかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered upgradeable mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在のスレッドがアップグレード可能モードに入った場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>、それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">使用するアサートまたはその他のデバッグの目的では、このプロパティを目的としています。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">プログラム実行のフローを制御するのには使用しないでください。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A&gt;</ph>プロパティを現在のスレッドがアップグレード可能モードを予期せずに入った場合は、アサートを生成します。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>Gets a value that indicates whether the current thread has entered the lock in write mode.</source>
          <target state="translated">現在のスレッドが書き込みモードでロックに入ったかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current thread has entered write mode; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在のスレッドが書き込みモードに入った場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>、それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>This property is intended for use in asserts or for other debugging purposes.</source>
          <target state="translated">使用するアサートまたはその他のデバッグの目的では、このプロパティを目的としています。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>Do not use it to control the flow of program execution.</source>
          <target state="translated">プログラム実行のフローを制御するのには使用しないでください。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A&gt;</ph> property to generate an assert if the current thread has entered write mode unexpectedly.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A&gt;</ph>プロパティを現在のスレッドが書き込みモードを予期せずに入った場合は、アサートを生成します。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Gets a value that indicates the recursion policy for the current <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> オブジェクトの再帰ポリシーを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>One of the enumeration values that specifies the lock recursion policy.</source>
          <target state="translated">ロック再帰ポリシーを指定する列挙値のいずれか。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Recursion policy determines the restrictions on threads that enter the lock more than once.</source>
          <target state="translated">再帰ポリシーでは、複数回ロックに入るスレッドに関する制限事項を決定します。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>For example, if a lock was created with <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph> and a thread has entered the lock in read mode, <ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.</source>
          <target state="translated">たとえば、ロックの作成時の<ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion?displayProperty=nameWithType&gt;</ph>スレッドが、読み取りモードでロックに入ったと<ph id="ph2">&lt;xref:System.Threading.LockRecursionException&gt;</ph>スレッドが読み取りモードでロックを再入力しようとした場合にスローされます。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.</source>
          <target state="translated">アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りロック再帰ポリシー設定に関係なくモードにダウン グレードすることができます。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.</source>
          <target state="translated">再帰ポリシーに関係なく、最初に入力した読み取りスレッド パターンでは、デッドロックの可能性が作成されるため、アップグレード可能モードまたは、書き込みモードにアップグレードするモードが使用できません。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy">
          <source>For more information about recursion policy and its effects, see the <ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">再帰ポリシーとその影響の詳細については、次を参照してください。、<ph id="ph1">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph>列挙型、および<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</source>
          <target state="translated">現在のスレッドが読み取りモードでロックに入った回数を、再帰を示す値として取得します。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered the lock recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">0 (ゼロ) に、現在のスレッドが入力されていない場合は、モードを読み取り、スレッドが読み取りモードに入ったが、されていない場合は 1 を入力して、再帰的にまたは<bpt id="p1">*</bpt>n<ept id="p1">*</ept> 、スレッドが再帰的にロックに入った場合<bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 回です。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">このプロパティを使用して、デバッグ、プロファイリング、およびログ記録の目的、に対してのみを除く、アルゴリズムの動作を制御します。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">結果は、計算が完了するとすぐに変更できます。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">そのため、このプロパティに基づいた意思決定を行う安全ではありません。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</source>
          <target state="translated">現在のスレッドがアップグレード可能モードでロックに入った回数を、再帰を示す値として取得します。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered upgradeable mode recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">現在のスレッドがアップグレード可能モードの場合は、スレッドがアップグレード可能モードに入ったがいない再帰的に、1 を入力していない場合は 0 または<bpt id="p1">*</bpt>n<ept id="p1">*</ept> 、スレッドが再帰的にアップグレード可能モードに入った場合<bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1時間。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">このプロパティを使用して、デバッグ、プロファイリング、およびログ記録の目的、に対してのみを除く、アルゴリズムの動作を制御します。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">結果は、計算が完了するとすぐに変更できます。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">そのため、このプロパティに基づいた意思決定を行う安全ではありません。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</source>
          <target state="translated">現在のスレッドが書き込みモードでロックに入った回数を、再帰を示す値として取得します。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or <bpt id="p1">*</bpt>n<ept id="p1">*</ept> if the thread has entered write mode recursively <bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 times.</source>
          <target state="translated">現在のスレッドが入力されていない場合は 0 を書き込みモードでは、1 スレッドが書き込みモードに入ったが、されていない場合、再帰的にまたは<bpt id="p1">*</bpt>n<ept id="p1">*</ept> 、スレッドが書き込みモードに入った場合<bpt id="p2">*</bpt>n<ept id="p2">*</ept> - 1 回です。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">このプロパティを使用して、デバッグ、プロファイリング、およびログ記録の目的、に対してのみを除く、アルゴリズムの動作を制御します。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">結果は、計算が完了するとすぐに変更できます。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">そのため、このプロパティに基づいた意思決定を行う安全ではありません。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in read mode, with an optional time-out.</source>
          <target state="translated">オプションのタイムアウトを指定して、読み取りモードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">待機するミリ秒数。無制限に待機する場合は <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1)。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>Tries to enter the lock in read mode, with an optional integer time-out.</source>
          <target state="translated">オプションのタイムアウトを表す整数を指定して、読み取りモードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered read mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">呼び出し元のスレッドが読み取りモードに入った場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>、それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">場合<ph id="ph1">`millisecondsTimeout`</ph>0 (ゼロ) は、このメソッドはロック状態を確認し、返します<ph id="ph2">`false`</ph>目的の状態が使用できない場合にすぐにします。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>Multiple threads can enter read mode at the same time.</source>
          <target state="translated">複数のスレッドは、同時に読み取りモードに入ることができます。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">1 つまたは複数のスレッドが書き込みモードに入るを待機している場合、スレッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph>メソッドは、呼び出し元スレッド独自のタイムアウト期限が切れたかそれらのスレッドか、タイムアウトまたは書き込みモードに入ったになりからを終了するまでブロックします。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">ロックは、再帰を許可する場合は、読み取りモードでロックに入ったスレッドは読み取りモードを再帰的に、書き込みモードに入る入力できます。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>One thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">他のスレッドが読み取りモードでは、1 つのスレッドはアップグレード可能モードにできます。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">追加のスレッドがアップグレード可能モードに切り替わるを待機している書き込みモードに入るを待機しているスレッドが存在しない場合は、スレッドの呼び出し、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph>メソッドが読み取りモードをすぐに入力し、ブロックされません。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> プロパティが <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> で、現在のスレッドは既にロックに入っています。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">再帰の回数は、カウンターの容量を超える可能性があります。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> の値が負ですが、指定できる唯一の負の値である <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) と等しくありません。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> オブジェクトは破棄されています。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">待機する間隔。無制限に待機する場合は -1 ミリ秒。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>Tries to enter the lock in read mode, with an optional time-out.</source>
          <target state="translated">オプションのタイムアウトを指定して、読み取りモードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered read mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">呼び出し元のスレッドが読み取りモードに入った場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>、それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">場合<ph id="ph1">`timeout`</ph>0 (ゼロ) は、このメソッドはロック状態を確認し、返します<ph id="ph2">`false`</ph>目的の状態が使用できない場合にすぐにします。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>Multiple threads can enter the lock in read mode at the same time.</source>
          <target state="translated">複数のスレッドは、同時に、読み取りモードでロックに入ることができます。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If one or more threads are queued to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">1 つまたは複数のスレッドが書き込みモードに入るキューに格納している場合、スレッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph>メソッドは、呼び出し元スレッド独自のタイムアウト期限が切れたかそれらのスレッドか、タイムアウトまたは書き込みモードに入ったになりからを終了するまでブロックします。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">ロックは、再帰を許可する場合は、読み取りモードでロックに入ったスレッドは読み取りモードを再帰的に、書き込みモードに入る入力できます。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>One thread can be in upgradeable mode while other threads are in read mode.</source>
          <target state="translated">他のスレッドが読み取りモードでは、1 つのスレッドはアップグレード可能モードにできます。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.</source>
          <target state="translated">追加のスレッドがアップグレード可能モードに切り替わるを待機している書き込みモードに入るを待機しているスレッドが存在しない場合は、スレッドの呼び出し、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph>メソッドが読み取りモードをすぐに入力し、ブロックされません。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> プロパティが <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> で、現在のスレッドは既にロックに入っています。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">再帰の回数は、カウンターの容量を超える可能性があります。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> の値が負ですが、指定できる唯一の負の値である -1 ミリ秒と等しくありません。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> の値が <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> ミリ秒を超えています。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> オブジェクトは破棄されています。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">オプションのタイムアウトを指定して、アップグレード可能モードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">待機するミリ秒数。無制限に待機する場合は <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1)。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">オプションのタイムアウトを指定して、アップグレード可能モードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered upgradeable mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">呼び出し元のスレッドがアップグレード可能モードに入った場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>、それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">場合<ph id="ph1">`millisecondsTimeout`</ph>0 (ゼロ) は、このメソッドはロック状態を確認し、返します<ph id="ph2">`false`</ph>目的の状態が使用できない場合にすぐにします。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">スレッド通常によって保護されているリソースにアクセスするときにアップグレード可能モードを使用して、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>に読み取りモードには、特定の条件が満たされた場合は、書き込みモードを入力する必要があります。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</source>
          <target state="translated">アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りモードにダウン グレードすることができます。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>Only one thread can enter a lock in upgradeable mode at any given time.</source>
          <target state="translated">1 つのスレッドは特定の時点で、アップグレード可能モードでロックに入ることができます。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">アップグレード可能モードに、スレッドが書き込みモードに入るを待機しているスレッドが存在しない場合は、任意の数の他のスレッドはアップグレード可能モードに切り替わるを待機しているスレッドがある場合でも、読み取りモードを入力できます。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">1 つまたは複数のスレッドが書き込みモードに入るを待機している場合、スレッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph>メソッドは、呼び出し元スレッド独自のタイムアウト期限が切れたかそれらのスレッドか、タイムアウトまたは書き込みモードに入ったになりからを終了するまでブロックします。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">ロックは、再帰を許可する場合は、アップグレード可能モードでロックに入ったスレッドはアップグレード可能モードの再帰的に、書き込みモードに入る入力できます。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> プロパティが <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> で、現在のスレッドは既にロックに入っています。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">現在のスレッドは最初に読み取りモードでロックに入ったため、アップグレード可能モードに入ろうとするとデッドロックの可能性が生じます。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">再帰の回数は、カウンターの容量を超える可能性があります。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> の値が負ですが、指定できる唯一の負の値である <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) と等しくありません。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> オブジェクトは破棄されています。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">待機する間隔。無制限に待機する場合は -1 ミリ秒。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Tries to enter the lock in upgradeable mode, with an optional time-out.</source>
          <target state="translated">オプションのタイムアウトを指定して、アップグレード可能モードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered upgradeable mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">呼び出し元のスレッドがアップグレード可能モードに入った場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>、それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">場合<ph id="ph1">`timeout`</ph>0 (ゼロ) は、このメソッドはロック状態を確認し、返します<ph id="ph2">`false`</ph>目的の状態が使用できない場合にすぐにします。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Use upgradeable mode when a thread usually accesses the resource protected by the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.</source>
          <target state="translated">スレッド通常によって保護されているリソースにアクセスするときにアップグレード可能モードを使用して、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>に読み取りモードには、特定の条件が満たされた場合は、書き込みモードを入力する必要があります。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.</source>
          <target state="translated">アップグレード可能モードでのスレッドでは、書き込みモードにアップグレードしたり、読み取りモードにダウン グレードすることができます。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>Only one thread can enter a lock in upgradeable mode at any given time.</source>
          <target state="translated">1 つのスレッドは特定の時点で、アップグレード可能モードでロックに入ることができます。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</source>
          <target state="translated">アップグレード可能モードに、スレッドが書き込みモードに入るを待機しているスレッドが存在しない場合は、任意の数の他のスレッドはアップグレード可能モードに切り替わるを待機しているスレッドがある場合でも、読み取りモードを入力できます。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If one or more threads are waiting to enter write mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</source>
          <target state="translated">1 つまたは複数のスレッドが書き込みモードに入るを待機している場合、スレッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph>メソッドは、呼び出し元スレッド独自のタイムアウト期限が切れたかそれらのスレッドか、タイムアウトまたは書き込みモードに入ったになりからを終了するまでブロックします。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">ロックは、再帰を許可する場合は、アップグレード可能モードでロックに入ったスレッドはアップグレード可能モードの再帰的に、書き込みモードに入る入力できます。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> プロパティが <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> で、現在のスレッドは既にロックに入っています。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.</source>
          <target state="translated">現在のスレッドは最初に読み取りモードでロックに入ったため、アップグレード可能モードに入ろうとするとデッドロックの可能性が生じます。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">再帰の回数は、カウンターの容量を超える可能性があります。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> の値が負ですが、指定できる唯一の負の値である -1 ミリ秒と等しくありません。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> の値が <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> ミリ秒を超えています。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> オブジェクトは破棄されています。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="T:System.Threading.ReaderWriterLockSlim">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">オプションのタイムアウトを指定して、書き込みモードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The number of milliseconds to wait, or -1 (<ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph>) to wait indefinitely.</source>
          <target state="translated">待機するミリ秒数。無制限に待機する場合は <ph id="ph1">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1)。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">オプションのタイムアウトを指定して、書き込みモードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered write mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">呼び出し元のスレッドが書き込みモードに入った場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>、それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If <ph id="ph1">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">場合<ph id="ph1">`millisecondsTimeout`</ph>0 (ゼロ) は、このメソッドはロック状態を確認し、返します<ph id="ph2">`false`</ph>目的の状態が使用できない場合にすぐにします。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</source>
          <target state="translated">他のスレッドは、読み取りモードでロックに入ったが場合、スレッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph>メソッドは、これらのスレッドが読み取りモードを終了するまで、またはタイムアウト間隔が経過するまでブロックします。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">書き込みモードに入るを待機しているスレッドがブロックされるときに、読み取りモードまたはアップグレード可能モードを入力しようとする追加のスレッドは、入力を待機しているすべてのスレッドがタイムアウト、または書き込みモードに入ったし、そこから終了し、書き込みモードになるまでをブロックします。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">ロックは、再帰を許可する、他のスレッドが書き込みモードに入るを待機している場合でも、書き込みモードでロックに入ったスレッドは書き込みモードを入力できます。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph>メソッドに、タイムアウトで、書き込みモードでロックに入ることです。例に示すメソッドは、同期、キャッシュに新しいキー/値ペアを追加します。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If the specified time-out interval elapses before the thread enters the lock, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">このメソッドを返しますのかどうかは、スレッド ロックに入る前に指定されたタイムアウト期間を過ぎると、<ph id="ph1">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The method returns <ph id="ph1">`true`</ph> if the key/value pair is added.</source>
          <target state="translated">このメソッドを返します<ph id="ph1">`true`</ph>場合は、キー/値ペアを追加します。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>If the key is already in the cache, the exception thrown by the inner <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> is allowed to terminate the method.</source>
          <target state="translated">場合は、キーが、キャッシュでは、内部によってスローされる例外に既に<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>terminate、メソッドを許可します。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>A <ph id="ph1">`finally`</ph> block is used to execute the <ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph> method, ensuring that the caller exits the lock.</source>
          <target state="translated">A<ph id="ph1">`finally`</ph>ブロックの実行を使用して、<ph id="ph2">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A&gt;</ph>メソッドを呼び出し元がロックを終了したことを確認します。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>This code is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.</source>
          <target state="translated">このコードに示されている例の一部である、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> プロパティが <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> で、現在のスレッドは既にロックに入っています。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</source>
          <target state="translated">現在のスレッドは最初に読み取りモードでロックに入ったため、書き込みモードに入ろうとするとデッドロックの可能性が生じます。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">再帰の回数は、カウンターの容量を超える可能性があります。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The value of <ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> is negative, but it is not equal to <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1), which is the only negative value allowed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="millisecondsTimeout" /&gt;</ph> の値が負ですが、指定できる唯一の負の値である <ph id="ph2">&lt;see cref="F:System.Threading.Timeout.Infinite" /&gt;</ph> (-1) と等しくありません。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> オブジェクトは破棄されています。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The interval to wait, or -1 milliseconds to wait indefinitely.</source>
          <target state="translated">待機する間隔。無制限に待機する場合は -1 ミリ秒。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>Tries to enter the lock in write mode, with an optional time-out.</source>
          <target state="translated">オプションのタイムアウトを指定して、書き込みモードでロックに入ることを試みます。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the calling thread entered write mode, otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">呼び出し元のスレッドが書き込みモードに入った場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>、それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If <ph id="ph1">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id="ph2">`false`</ph> immediately if the desired state is unavailable.</source>
          <target state="translated">場合<ph id="ph1">`timeout`</ph>0 (ゼロ) は、このメソッドはロック状態を確認し、返します<ph id="ph2">`false`</ph>目的の状態が使用できない場合にすぐにします。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If other threads have entered the lock in read mode, a thread that calls the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.</source>
          <target state="translated">他のスレッドは、読み取りモードでロックに入ったが場合、スレッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph>メソッドは、これらのスレッドが読み取りモードを終了するまで、またはタイムアウト間隔が経過するまでブロックします。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</source>
          <target state="translated">書き込みモードに入るを待機しているスレッドがブロックされるときに、読み取りモードまたはアップグレード可能モードを入力しようとする追加のスレッドは、入力を待機しているすべてのスレッドがタイムアウト、または書き込みモードに入ったし、そこから終了し、書き込みモードになるまでをブロックします。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.</source>
          <target state="translated">ロックは、再帰を許可する、他のスレッドが書き込みモードに入るを待機している場合でも、書き込みモードでロックに入ったスレッドは書き込みモードを入力できます。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> property is <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> and the current thread has already entered the lock.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /&gt;</ph> プロパティが <ph id="ph2">&lt;see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /&gt;</ph> で、現在のスレッドは既にロックに入っています。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.</source>
          <target state="translated">現在のスレッドは最初に読み取りモードでロックに入ったため、書き込みモードに入ろうとするとデッドロックの可能性が生じます。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The recursion number would exceed the capacity of the counter.</source>
          <target state="translated">再帰の回数は、カウンターの容量を超える可能性があります。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The limit is so large that applications should never encounter it.</source>
          <target state="translated">この容量は非常に大きいので、アプリケーションでこの状況が発生することは通常はありません。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> の値が負ですが、指定できる唯一の負の値である -1 ミリ秒と等しくありません。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The value of <ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> is greater than <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> milliseconds.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="timeout" /&gt;</ph> の値が <ph id="ph2">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph> ミリ秒を超えています。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> object has been disposed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Threading.ReaderWriterLockSlim" /&gt;</ph> オブジェクトは破棄されています。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Gets the total number of threads that are waiting to enter the lock in read mode.</source>
          <target state="translated">読み取りモードでロックに入るのを待機しているスレッドの総数を取得します。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The total number of threads that are waiting to enter read mode.</source>
          <target state="translated">読み取りモードに入るのを待機しているスレッドの総数。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">このプロパティを使用して、デバッグ、プロファイリング、およびログ記録の目的、に対してのみを除く、アルゴリズムの動作を制御します。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">結果は、計算が完了するとすぐに変更できます。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">そのため、このプロパティに基づいた意思決定を行う安全ではありません。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A&gt;</ph>読み取りモードに入るを待機している、ブロックされているスレッドの数がしきい値を超えた場合に、イベント ログ エントリを生成するプロパティです。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</source>
          <target state="translated">アップグレード可能モードでロックに入るのを待機しているスレッドの総数を取得します。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The total number of threads that are waiting to enter upgradeable mode.</source>
          <target state="translated">アップグレード可能モードに入るのを待機しているスレッドの総数。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">このプロパティを使用して、デバッグ、プロファイリング、およびログ記録の目的、に対してのみを除く、アルゴリズムの動作を制御します。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">結果は、計算が完了するとすぐに変更できます。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">そのため、このプロパティに基づいた意思決定を行う安全ではありません。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A&gt;</ph>アップグレード可能モードに切り替わるを待機している、ブロックされているスレッドの数がしきい値を超えた場合に、イベント ログ エントリを生成するプロパティです。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Gets the total number of threads that are waiting to enter the lock in write mode.</source>
          <target state="translated">書き込みモードでロックに入るのを待機しているスレッドの総数を取得します。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The total number of threads that are waiting to enter write mode.</source>
          <target state="translated">書き込みモードに入るのを待機しているスレッドの総数。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.</source>
          <target state="translated">このプロパティを使用して、デバッグ、プロファイリング、およびログ記録の目的、に対してのみを除く、アルゴリズムの動作を制御します。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The results can change as soon as they have been calculated.</source>
          <target state="translated">結果は、計算が完了するとすぐに変更できます。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>Therefore, it is not safe to make decisions based on this property.</source>
          <target state="translated">そのため、このプロパティに基づいた意思決定を行う安全ではありません。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount">
          <source>The following example shows how to use the <ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A&gt;</ph> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.</source>
          <target state="translated">次の例を使用する方法を示しています、<ph id="ph1">&lt;xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A&gt;</ph>書き込みモードに入るを待機している、ブロックされているスレッドの数がしきい値を超えた場合に、イベント ログ エントリを生成するプロパティです。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>