<Type Name="Registry" FullName="Microsoft.Win32.Registry">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7f305c4ddd19e71fb1c769c3f0ba41404d364554" /><Meta Name="ms.sourcegitcommit" Value="bc24a3ba616ee1df8b858f9400cae4f058ea3a7e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="06/19/2019" /><Meta Name="ms.locfileid" Value="67238676" /></Metadata><TypeSignature Language="C#" Value="public static class Registry" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Registry extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Win32.Registry" />
  <TypeSignature Language="VB.NET" Value="Public Class Registry" />
  <TypeSignature Language="C++ CLI" Value="public ref class Registry abstract sealed" />
  <TypeSignature Language="F#" Value="type Registry = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Windows レジストリのルート キーを表す <see cref="T:Microsoft.Win32.RegistryKey" /> オブジェクト、およびキー/値ペアにアクセスするための <see langword="static" /> メソッドを提供します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスは、Windows を実行しているコンピューターでのレジストリで見つかった標準のルート キーのセットを提供します。 レジストリは、アプリケーション、ユーザー、および既定のシステム設定に関する情報を格納する機能です。 たとえば、アプリケーションは、レジストリを使用して、アプリケーションの終了後も保持する必要がある情報を格納して、アプリケーションが再読み込み時に同じ情報にアクセスします。 たとえば、色の設定、画面の位置、またはウィンドウのサイズを格納できます。 レジストリ内の別の場所に情報を格納することにより、ユーザーごとにこのデータを制御できます。  
  
 ベース、またはルート<xref:Microsoft.Win32.RegistryKey>インスタンスによって公開されている、`Registry`クラスは、レジストリのサブキーと値の基本的なストレージ メカニズムを記述します。 すべてのキーは、レジストリがの存在に依存しているためには読み取り専用です。 によって公開されるキー`Registry`は。  
  
 <xref:Microsoft.Win32.Registry.CurrentUser>  
 ユーザー設定に関する情報を格納します。  
  
 <xref:Microsoft.Win32.Registry.LocalMachine>  
 ローカル コンピューターの構成情報を格納します。  
  
 <xref:Microsoft.Win32.Registry.ClassesRoot>  
 型 (およびクラス) に関する情報とそのプロパティを格納します。  
  
 <xref:Microsoft.Win32.Registry.Users>  
 既定のユーザーの構成に関する情報を格納します。  
  
 <xref:Microsoft.Win32.Registry.PerformanceData>  
 ソフトウェア コンポーネントのパフォーマンスに関する情報を格納します。  
  
 <xref:Microsoft.Win32.Registry.CurrentConfig>  
 ユーザー固有のハードウェア情報を格納します。  
  
 <xref:Microsoft.Win32.Registry.DynData>  
 動的なデータを格納します。  
  
 使用することができます、レジストリからの情報の保存/取得に使用するルート キーを識別した後、<xref:Microsoft.Win32.RegistryKey>クラスの追加またはサブキーを削除して、指定されたキーの値を操作します。  
  
 ハードウェア デバイスでは、プラグ アンド プレイ インターフェイスを使用して自動的にレジストリに情報を配置できます。 デバイス ドライバーをインストールするためのソフトウェアは、標準的な Api を記述することで、レジストリに情報を配置できます。  
  
## <a name="static-methods-for-getting-and-setting-values"></a>取得して、値を設定するための静的メソッド  
 .NET Framework version 2.0 で、<xref:Microsoft.Win32.Registry>クラスも含まれています。 `static` <xref:Microsoft.Win32.Registry.GetValue%2A>と<xref:Microsoft.Win32.Registry.SetValue%2A>設定およびレジストリ キーから値を取得するためのメソッド。 これらのメソッドを開き、閉じるレジストリ キーの各実行しないように、使用するときだけでなく類似のメソッド、<xref:Microsoft.Win32.RegistryKey>クラスは、多数の値にアクセスします。  
  
 <xref:Microsoft.Win32.RegistryKey>クラスでは、レジストリ キー、それを取得する前に、値のデータ型をテストし、キーを削除するは、Windows アクセス制御セキュリティを設定するためのメソッドも提供します。  
  
   
  
## Examples  
 このセクションには、2 つのコード例が含まれています。 最初の例では、ルート キー、および 2 番目の例を示します、 `static` <xref:Microsoft.Win32.Registry.GetValue%2A>と<xref:Microsoft.Win32.Registry.SetValue%2A>メソッド。  
  
 例 1  
  
 次のコード例では、HKEY_USERS キーのサブキーを取得し、その名前を画面の印刷方法を示します。 使用して、<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>関心のある特定のサブキーのインスタンスを作成します。 その他の操作を使用することができますし、`RegistryKey`そのキーを操作します。  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 例 2  
  
 次のコード例では、サンプル キーとを取得し、値が表示されます、キーを作成でいくつかのデータ型の値を格納します。 例を示しますの格納と取得の既定の (名前のない) の名前と値のペアと、使用して`defaultValue`名前/値ペアが存在しない場合。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.RegistryHive" />
    <altmember cref="T:Microsoft.Win32.RegistryKey" />
  </Docs>
  <Members>
    <Member MemberName="ClassesRoot">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey ClassesRoot;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey ClassesRoot" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.ClassesRoot" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClassesRoot As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ ClassesRoot;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClassesRoot : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.ClassesRoot" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドキュメントの型 (またはクラス) と、これらの型に関連付けられるプロパティを定義します。 このフィールドには、Windows レジストリの基本キー HKEY_CLASSES_ROOT が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 従来のアプリケーションと OLE アプリケーションは、このキーの下に格納されているデータを使用します。 このキーは、DDE および OLE サポートの情報を格納することで、Windows 3.1 登録情報データベースとの下位互換性も提供します。 ファイル ビューアーとユーザー インターフェイスの拡張機能は、このキーは、OLE クラス識別子を格納し、処理サーバーは、このキーに登録されます。  
  
   
  
## Examples  
 次の例では、このキーのサブキーを取得する方法について説明し、画面に名前を出力します。 使用して、<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>関心のある特定のサブキーのインスタンスを作成します。 その他の操作を使用することができますし、<xref:Microsoft.Win32.RegistryKey>そのキーを操作します。  
  
 [!code-cpp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.ClassesRoot Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.ClassesRoot Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.ClassesRoot Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentConfig">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentConfig;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentConfig" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentConfig" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentConfig As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentConfig;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentConfig : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentConfig" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>各ユーザーに共通のハードウェアに関する構成情報を格納します。 このフィールドには、Windows レジストリの基本キー HKEY_CURRENT_CONFIG が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーが内のサブキーにマップされている<xref:Microsoft.Win32.Registry.LocalMachine>します。  
  
 このメンバーを使用する例は、システムがネットワークに接続されているかどうかに応じて、そのデータに対して別のサーバー名を格納するアプリケーションです。  
  
   
  
## Examples  
 次の例では、このキーのサブキーを取得する方法について説明し、画面に名前を出力します。 使用して、<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>関心のある特定のサブキーのインスタンスを作成します。 その他の操作を使用することができますし、<xref:Microsoft.Win32.RegistryKey>そのキーを操作します。  
  
 [!code-cpp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentConfig Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentConfig Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentConfig Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUser">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey CurrentUser;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey CurrentUser" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.CurrentUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CurrentUser As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ CurrentUser;" />
      <MemberSignature Language="F#" Value=" staticval mutable CurrentUser : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.CurrentUser" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のユーザー設定に関する情報が格納されます。 このフィールドには、Windows レジストリの基本キー HKEY_CURRENT_USER が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このキーに格納されている情報には、プログラムのグループ、色、プリンター、ネットワーク接続、およびアプリケーションの設定に関するデータと環境変数の設定が含まれます。 このキーでは、現在のユーザーの設定を確立するためにやすくなります。 このキーは、ソフトウェア ベンダーは、アプリケーション内で使用する現在のユーザーに固有の設定を格納します。 Microsoft には、たとえば、Microsoft キーの下で、独自のサブキーを作成する各アプリケーションで、使用するには、そのアプリケーションの hkey_current_user \software\microsoft キーが作成されます。  
  
   
  
## Examples  
 次の例では、このキーのサブキーを取得する方法について説明し、画面に名前を出力します。 使用して、<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>関心のある特定のサブキーのインスタンスを作成します。 その他の操作を使用することができますし、<xref:Microsoft.Win32.RegistryKey>そのキーを操作します。  
  
 [!code-cpp[Classic Registry.CurrentUser Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.CurrentUser Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.CurrentUser Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.CurrentUser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey DynData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey DynData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.DynData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DynData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ DynData;" />
      <MemberSignature Language="F#" Value=" staticval mutable DynData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.DynData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PerformanceData instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The DynData registry key only works on Win9x, which is no longer supported by the CLR.  On NT-based operating systems, use the PerformanceData registry key instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的レジストリ データを格納します。 このフィールドには、Windows レジストリの基本キー HKEY_DYN_DATA が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 98/Windows Me のレジストリでは、静的 (レジストリ内のディスクに保存されます) データと動的 (パフォーマンスの統計情報など、頻繁に変更) データの両方をサポートします。 この動的なデータ領域は、リモートおよびローカルに実行できる Win32 アプリケーションへの仮想デバイス ドライバー (Vxd) を使用してリアルタイムのデータを提供できるようにするメカニズムです。 また、システム モニターでリモートの Windows 98/Windows Me システム パフォーマンスの統計情報を提供することもできます。  
  
 Vxd はパフォーマンス データに限定されません。 リング 0 からせずに渡すリング 3 効率的に CPU を占有するすべてのデータができるようになります。 レジストリ値 (または多くの値) を返す関数へのポインターを格納することによって動的なデータをサポートします。 ときに、レジストリ呼び出しクエリに関連付けられた値動的なキーでは、目的の値または値を返す関数を呼び出すことです。  
  
> [!NOTE]
>  動的なキー動的レジストリ データを処理するために Microsoft Windows 95 で導入されました。 Windows 98/Windows me でのみサポートされています。  
  
   
  
## Examples  
 次の例では、このキーのサブキーを取得する方法について説明し、画面に名前を出力します。 使用して、<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>関心のある特定のサブキーのインスタンスを作成します。 その他の操作を使用することができますし、<xref:Microsoft.Win32.RegistryKey>そのキーを操作します。 この例は結果を返すありません、存在できない可能性があります動的データ、またはが実行されていない Windows 98/me. このキーを使用すると、他のシステムでエラーが発生する可能性があります。  
  
 [!code-cpp[Classic Registry.DynData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.DynData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.DynData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.DynData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.DynData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">そのオペレーティング システムは動的データをサポートしていません。つまり、それは Windows 98、Windows 98 Second Edition、または Windows Millennium Edition (Windows Me) ではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public static object GetValue (string keyName, string valueName, object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetValue(string keyName, string valueName, object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetValue (keyName As String, valueName As String, defaultValue As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="static member GetValue : string * string * obj -&gt; obj" Usage="Microsoft.Win32.Registry.GetValue (keyName, valueName, defaultValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="defaultValue" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">有効なレジストリ ルート ("HKEY_CURRENT_USER" など) から始まるキーの完全なレジストリ パス。</param>
        <param name="valueName">名前/値ペアの名前。</param>
        <param name="defaultValue"><paramref name="valueName" /> が存在しない場合に返す値。</param>
        <summary>指定したレジストリ キーに含まれる、指定した名前に関連付けられた値を取得します。 指定したキーに該当する名前が見つからない場合は、設定している既定値が返されます。指定したキーが存在しない場合は、<see langword="null" /> が返されます。</summary>
        <returns><paramref name="keyName" /> で指定したサブキーが存在しない場合は、<see langword="null" />。それ以外の場合は、<paramref name="valueName" /> に関連付けられた値。<paramref name="defaultValue" /> が見つからない場合は、<paramref name="valueName" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 文字列`valueName`小文字は区別されません。  
  
> [!NOTE]
>  レジストリ キーは、任意の名前に関連付けられていない 1 つの値を含めることができます。 レジストリ エディターでこの無名の値が表示されたら、名の代わりに文字列「(既定値)」が表示されます。 この無名の値を取得するには、いずれかを指定`null`または空の文字列 ("") の`valueName`します。  
  
 有効なルート名には、HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG、および hkey_dyn_data が読み込まれますが。 たとえば、Visual Basic で文字列"HKEY_CURRENT_USER\MyTestKey"では、HKEY_CURRENT_USER のルートにサブキー"MyTestKey"のキー/値ペアにアクセスします。  
  
 ときに、<xref:Microsoft.Win32.RegistryKey.GetValue%2A>メソッドを展開可能な文字列値を取得します (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)、ローカル環境からデータを使用して環境文字列を展開します。 環境変数への展開可能な参照を格納している値が文字列として格納されている場合 (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)、展開可能な文字列としてではなく (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)、<xref:Microsoft.Win32.RegistryKey.GetValue%2A>展開しません。 このような文字列を展開するには、呼び出すことによって取得された後、<xref:System.Environment.ExpandEnvironmentVariables%2A?displayProperty=nameWithType>メソッド。  
  
> [!NOTE]
>  HKEY_PERFORMANCE_DATA からデータを取得することをお勧めの方法は使用する、<xref:System.Diagnostics.PerformanceCounter>クラスではなく、<xref:Microsoft.Win32.RegistryKey.GetValue%2A?displayProperty=nameWithType>メソッド。  
  
 <xref:Microsoft.Win32.Registry.GetValue%2A>と<xref:Microsoft.Win32.Registry.SetValue%2A>メソッドを開き、閉じるレジストリ キーのメソッドと同様に実行しないように、使用するたびに、<xref:Microsoft.Win32.RegistryKey>クラスの多数の値にアクセスする場合。  
  
 <xref:Microsoft.Win32.RegistryKey> また、取得する前に、値のデータ型をテストし、キーを削除するレジストリ キーにアクセス制御リスト (ACL) を追加するためのメソッドを提供します。  
  
   
  
## Examples  
 次のコード例では、サンプル キーとを取得し、値が表示されます、キーを作成でいくつかのデータ型の値を格納します。 例を示しますの格納と取得の既定の (名前のない) の名前と値のペアと、使用して`defaultValue`名前/値ペアが存在しない場合。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">ユーザーに、レジストリ キーからの読み取りに必要なアクセス許可がありません。</exception>
        <exception cref="T:System.IO.IOException">指定された値を格納する <see cref="T:Microsoft.Win32.RegistryKey" /> は、削除対象としてマークされています。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> が有効なレジストリ ルートから始まっていません。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">レジストリから読み取る。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">REG_EXPAND_SZ の種類のレジストリ キーの読み取り。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LocalMachine">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey LocalMachine;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey LocalMachine" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.LocalMachine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LocalMachine As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ LocalMachine;" />
      <MemberSignature Language="F#" Value=" staticval mutable LocalMachine : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.LocalMachine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル コンピューターの構成データが格納されます。 このフィールドには、Windows レジストリの基本キー HKEY_LOCAL_MACHINE が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LocalMachine` 5 つのキーが含まれます。  
  
 ハードウェア  
 コンピューターで、物理ハードウェア デバイス ドライバーは、そのハードウェア、およびマッピングおよびユーザー モード コードとカーネル モード ドライバーをリンクする関連データを使用する方法について説明します。 このキーのすべてのデータが、システムを起動するたびに再作成されます。 説明のサブキーには、実際のコンピューターのハードウェアについて説明します。 DeviceMap サブキーには、特定のドライバー クラスに固有の形式でその他のデータが含まれています。 ResourceMap サブキーは、デバイス ドライバーをどのハードウェア リソースの要求について説明します。 Windows NT 診断プログラム (Winmsdp.exe) は、その内容を読みやすい形式で報告できます。  
  
 SAM  
 セキュリティ情報と、ユーザーとグループ アカウント、および Windows 2000 server ドメインのディレクトリ サービス データベース (SAM はセキュリティ アカウント マネージャーは、ディレクトリ サービス データベースと呼ばれます)。  
  
 セキュリティ  
 特定のユーザー権限などのローカル セキュリティ ポリシーが含まれています。 このキーは、Windows 2000 セキュリティ サブシステムによってのみ使用されます。  
  
 ソフトウェア  
 コンピューター単位のソフトウェアのデータベースです。 このキーには、その他の構成データのさまざまな項目と共に、ローカル コンピューターにインストールされているソフトウェアに関するデータが含まれています。  
  
 システム  
 システムの起動時、デバイス ドライバーの読み込み、Windows 2000 サービス、およびオペレーティング システムの動作を制御します。  
  
 下のようなデータが存在する場合は、慣例により<xref:Microsoft.Win32.Registry.CurrentUser> <xref:Microsoft.Win32.Registry.LocalMachine>、内のデータ<xref:Microsoft.Win32.Registry.CurrentUser>が優先されます。 ただし、このキーの値も拡張 (なくできます置換) Registry.LocalMachine 内のデータ。 また、(デバイス ドライバーがエントリの読み込み) などのいくつかの項目は Registry.LocalMachine の外部で発生した場合、無意味です。  
  
   
  
## Examples  
 次の例では、このキーのサブキーを取得する方法について説明し、画面に名前を出力します。 使用して、<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>関心のある特定のサブキーのインスタンスを作成します。 その他の操作を使用することができますし、<xref:Microsoft.Win32.RegistryKey>そのキーを操作します。  
  
 [!code-cpp[Classic Registry.LocalMachine Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.LocalMachine Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.LocalMachine Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.LocalMachine Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformanceData">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey PerformanceData;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey PerformanceData" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.PerformanceData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PerformanceData As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ PerformanceData;" />
      <MemberSignature Language="F#" Value=" staticval mutable PerformanceData : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.PerformanceData" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソフトウェア コンポーネントのパフォーマンス情報が含まれます。 このフィールドには、Windows レジストリの基本キー HKEY_PERFORMANCE_DATA が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 各ソフトウェア コンポーネントは、カウンターがインストールされているが実行中に、カウンター データを書き込むときに、そのオブジェクトのキーを作成します。 使用して、その他のレジストリ データをアクセスは、このデータにアクセスすることができます、<xref:Microsoft.Win32.RegistryKey>関数。  
  
 パフォーマンス データを収集するレジストリを使用すると、データがレジストリのデータベースに格納されません。 代わりに、このキーを持つレジストリへのアクセスは、適切なシステム オブジェクト マネージャーからデータを収集するシステムです。  
  
 ローカル システムからパフォーマンス データを取得する、 <xref:Microsoft.Win32.RegistryKey.GetValue%2A> Registry.PerformanceData キーを持つメソッド。 最初の呼び出しでは、キー (最初のキーを明示的に開く必要はありません) を開きます。 ただし、必ず使用して、<xref:Microsoft.Win32.RegistryKey.Close%2A>パフォーマンス データの取得が完了したら、キーを識別するハンドルを閉じます。 ユーザーは、インストールか、パフォーマンス データを使用中に、ソフトウェア コンポーネントを削除することはできません。  
  
 使用する必要があります、リモート システムからパフォーマンス データを取得する、<xref:Microsoft.Win32.RegistryKey.OpenRemoteBaseKey%2A>と Registry.PerformanceData キーのリモート システムのコンピューター名でのメソッド。 この呼び出しは、リモート システムのパフォーマンス データを表すキーを取得します。 データを取得する<xref:Microsoft.Win32.RegistryKey.GetValue%2A>Registry.PerformanceData キーではなく、このキーを使用します。  
  
> [!NOTE]
>  Windows Server 2003 でユーザー属する必要があります少なくとも Performance Monitor Users グループにこの基本キーのサブキーにアクセスするためにします。  
  
   
  
## Examples  
 次の例では、このキーのサブキーを取得する方法について説明し、画面に名前を出力します。 使用して、<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>関心のある特定のサブキーのインスタンスを作成します。 その他の操作を使用することができますし、<xref:Microsoft.Win32.RegistryKey>そのキーを操作します。 この例は多くの場合、結果が返されない、パフォーマンス データがないために注意してください。  
  
 [!code-cpp[Classic Registry.PerformanceData Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.PerformanceData Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.PerformanceData Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.PerformanceData Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>レジストリ キーに名前/値ペアの値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、サンプル キーとを取得し、値が表示されます、キーを作成でいくつかのデータ型の値を格納します。 例を示しますの格納と取得の既定の (名前のない) の名前と値のペアと、使用して`defaultValue`名前/値ペアが存在しない場合。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">有効なレジストリ ルート ("HKEY_CURRENT_USER" など) から始まるキーの完全なレジストリ パス。</param>
        <param name="valueName">名前/値ペアの名前。</param>
        <param name="value">格納される値。</param>
        <summary>指定したレジストリ キーに、指定した名前/値ペアを設定します。 指定したキーが存在しない場合は、キーが作成されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、`valueName`パラメーターが 255 文字の最大数に制限されなくただし、`keyName`パラメーターは引き続きに、255 文字に制限します。  
  
 多くの値をレジストリ内の各キーに格納できるため、使用、`valueName`パラメーターを設定する特定の値を指定します。  
  
> [!NOTE]
>  レジストリ キーは、任意の名前に関連付けられていない 1 つの値を含めることができます。 レジストリ エディターでこの無名の値が表示されたら、名の代わりに文字列「(既定値)」が表示されます。 この無名の値を設定するには、いずれかを指定`null`または空の文字列 ("") の`valueName`します。  
  
 場合`valueName`が存在しないキーが作成され、関連付けられている値に設定されて`value`します。  
  
 場合`keyName`存在しない場合、サブキーを指定して、サブキーが指定したルートに作成されます。 たとえば、Visual Basic で文字列"HKEY_CURRENT_USER\MyTestKey"は HKEY_CURRENT_USER のルートにサブキー"MyTestKey"を作成します。 文字列"HKEY_CURRENT_USER\MyTestKey\Key2\Key3"は、"MyTestKey"、"MyTestKey\Key2"および"MyTestKey\Key2\Key3"は、入れ子になったサブキーを作成します。  
  
 有効なルート名には、HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG、および HKEY_DYN_DATA が含まれます。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A>メソッド レジストリ キーを開きの値を設定およびそれが呼び出されるたびに、キーを閉じます。 大規模な数の値を変更する必要がある場合、<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType>メソッドはパフォーマンスが向上する可能性があります。 <xref:Microsoft.Win32.RegistryKey>クラスでは、それを取得する前に、値のデータ型をテストし、キーを削除するレジストリ キーにアクセス制御リスト (ACL) を追加するためのメソッドも提供します。  
  
 このオーバー ロード<xref:Microsoft.Win32.Registry.SetValue%2A>64 ビット整数を文字列として格納されます (<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>)。 として 64 ビットの数値を格納する<xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>、値を使用して、<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>メソッドのオーバー ロードします。  
  
 このオーバー ロード<xref:Microsoft.Win32.Registry.SetValue%2A>としてすべての文字列値を格納<xref:Microsoft.Win32.RegistryValueKind.String?displayProperty=nameWithType>オブジェクトの場合、環境変数への展開可能な参照が含まれている場合でもです。 文字列値として展開可能な文字列を保存する (<xref:Microsoft.Win32.RegistryValueKind.ExpandString?displayProperty=nameWithType>)、使用、<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>メソッドのオーバー ロードします。  
  
 このオーバー ロードの呼び出しと同じですが、<xref:Microsoft.Win32.Registry.SetValue%28System.String%2CSystem.String%2CSystem.Object%2CMicrosoft.Win32.RegistryValueKind%29>メソッドのオーバー ロードで<xref:Microsoft.Win32.RegistryValueKind.Unknown?displayProperty=nameWithType>します。  
  
> [!NOTE]
>  Windows 98 および Windows Millennium Edition (Windows Me) で、レジストリ、Unicode でないし、すべての Unicode 文字はすべてのコード ページに対して無効です。 現在のコード ページに無効な Unicode 文字は、使用可能な最適の一致に置換されます。 例外をスローすることはありません。  
  
   
  
## Examples  
 次のコード例では、サンプル キーとを取得し、値が表示されます、キーを作成でいくつかのデータ型の値を格納します。 例を示しますの格納と取得の既定の (名前のない) の名前と値のペアと、使用して`defaultValue`名前/値ペアが存在しない場合。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> が有効なレジストリ ルートから始まっていません。  
  
または 
 <paramref name="keyName" /> が許容される最大長 (255 文字) を超えています。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> が読み取り専用であるため、このキーに書き込むことはできません。たとえば、ルートレベル ノードの場合などです。</exception>
        <exception cref="T:System.Security.SecurityException">ユーザーに、レジストリ キーの作成または変更に必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">存在する場合は、指定されたレジストリ キーを変更する、または存在しない場合は、レジストリ キーを作成します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />、 <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public static void SetValue (string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetValue(string keyName, string valueName, object value, valuetype Microsoft.Win32.RegistryValueKind valueKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetValue (keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetValue(System::String ^ keyName, System::String ^ valueName, System::Object ^ value, Microsoft::Win32::RegistryValueKind valueKind);" />
      <MemberSignature Language="F#" Value="static member SetValue : string * string * obj * Microsoft.Win32.RegistryValueKind -&gt; unit" Usage="Microsoft.Win32.Registry.SetValue (keyName, valueName, value, valueKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueName" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.Object" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueKind" Type="Microsoft.Win32.RegistryValueKind" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keyName">有効なレジストリ ルート ("HKEY_CURRENT_USER" など) から始まるキーの完全なレジストリ パス。</param>
        <param name="valueName">名前/値ペアの名前。</param>
        <param name="value">格納される値。</param>
        <param name="valueKind">データを格納する際に使用するレジストリ データ型。</param>
        <summary>指定したレジストリ データ型を使用して、指定したレジストリ キーに名前/値ペアを設定します。 指定したキーが存在しない場合は、キーが作成されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、`valueName`パラメーターが 255 文字の最大数に制限されなくただし、`keyName`パラメーターは、255 文字に制限があるが続行されます。  
  
 多くの値をレジストリ内の各キーに格納できるため、使用、`valueName`パラメーターを設定する特定の値を指定します。  
  
> [!NOTE]
>  レジストリ キーは、任意の名前に関連付けられていない 1 つの値を含めることができます。 レジストリ エディターでこの無名の値が表示されたら、名の代わりに文字列「(既定値)」が表示されます。 この無名の値を設定するには、いずれかを指定`null`または空の文字列 ("") の`valueName`します。  
  
 場合`valueName`が存在しないキーが作成され、関連付けられている値に設定されて`value`します。  
  
 場合`keyName`存在しない場合、サブキーを指定して、サブキーが指定したルートに作成されます。 たとえば、Visual Basic で文字列"HKEY_CURRENT_USER\MyTestKey"は HKEY_CURRENT_USER のルートにサブキー"MyTestKey"を作成します。 文字列"HKEY_CURRENT_USER\MyTestKey\Key2\Key3"は、"MyTestKey"、"MyTestKey\Key2"および"MyTestKey\Key2\Key3"は、入れ子になったサブキーを作成します。  
  
 有効なルート名には、HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_CLASSES_ROOT、HKEY_USERS、HKEY_PERFORMANCE_DATA、HKEY_CURRENT_CONFIG、および HKEY_DYN_DATA が含まれます。  
  
> [!NOTE]
>  <xref:Microsoft.Win32.Registry.SetValue%2A>メソッド レジストリ キーを開きの値を設定およびそれが呼び出されるたびに、キーを閉じます。 大規模な数の値を変更する必要がある場合、<xref:Microsoft.Win32.RegistryKey.SetValue%2A?displayProperty=nameWithType>メソッドはパフォーマンスが向上する可能性があります。 <xref:Microsoft.Win32.RegistryKey>クラスでは、それを取得する前に、値のデータ型をテストし、キーを削除するレジストリ キーにアクセス制御リスト (ACL) を追加するためのメソッドも提供します。  
  
 場合の指定した型`value`、指定したとが一致しません`valueKind`、データにすることはできませんと変換、<xref:System.ArgumentException>がスローされます。 たとえば、格納、<xref:System.Int64?displayProperty=nameWithType>として、 <xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>、その値がの最大値より小さい場合にのみが、 <xref:System.Int32?displayProperty=nameWithType>。 として 1 つの文字列値を格納することはできません、<xref:Microsoft.Win32.RegistryValueKind.MultiString?displayProperty=nameWithType>します。  
  
> [!NOTE]
>  ボックス化された値が渡された場合<xref:Microsoft.Win32.RegistryValueKind.DWord?displayProperty=nameWithType>または<xref:Microsoft.Win32.RegistryValueKind.QWord?displayProperty=nameWithType>、変換が行われるインバリアント カルチャを使用します。  
  
> [!NOTE]
>  Windows 98 および Windows Millennium Edition (Windows Me) で、レジストリ、Unicode でないし、すべての Unicode 文字はすべてのコード ページに対して無効です。 現在のコード ページに無効な Unicode 文字は、使用可能な最適の一致に置換されます。 例外をスローすることはありません。  
  
   
  
## Examples  
 次のコード例では、サンプル キーとを取得し、値が表示されます、キーを作成でいくつかのデータ型の値を格納します。 例を示しますの格納と取得の既定の (名前のない) の名前と値のペアと、使用して`defaultValue`名前/値ペアが存在しない場合。  
  
 [!code-cpp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CPP/source.cpp#1)]
 [!code-csharp[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/CS/source.cs#1)]
 [!code-vb[Microsoft.Win32.Registry.GetSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Microsoft.Win32.Registry.GetSet/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="keyName" /> が有効なレジストリ ルートから始まっていません。  
  
または 
 <paramref name="keyName" /> が許容される最大長 (255 文字) を超えています。  
  
または 
<paramref name="value" /> の型が <paramref name="valueKind" /> で指定したレジストリ データ型と一致しなかったため、データを適切に変換できませんでした。</exception>
        <exception cref="T:System.UnauthorizedAccessException"><see cref="T:Microsoft.Win32.RegistryKey" /> が読み取り専用であるため、このキーに書き込むことはできません。ルートレベル ノードの場合や、書き込みアクセスが設定された状態でキーが開かれていない場合などです。</exception>
        <exception cref="T:System.Security.SecurityException">ユーザーに、レジストリ キーの作成または変更に必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">存在する場合は、指定されたレジストリ キーを変更する、または存在しない場合は、レジストリ キーを作成します。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Write" />、 <see cref="F:System.Security.Permissions.RegistryPermissionAccess.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Users">
      <MemberSignature Language="C#" Value="public static readonly Microsoft.Win32.RegistryKey Users;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class Microsoft.Win32.RegistryKey Users" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Win32.Registry.Users" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Users As RegistryKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly Microsoft::Win32::RegistryKey ^ Users;" />
      <MemberSignature Language="F#" Value=" staticval mutable Users : Microsoft.Win32.RegistryKey" Usage="Microsoft.Win32.Registry.Users" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Win32.Registry</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のユーザー構成に関する情報を格納します。 このフィールドには、Windows レジストリの基本キー HKEY_USERS が読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このキーには、コンピューターのユーザーごとの分岐が含まれています。 既定の構成は、ユーザーが基本設定を変更していない場合、ローカル コンピューター上の新しいユーザーと既定の現在のユーザーに対して提供されます。 ため、Windows 98/Registry.Users 私もサポートしています、アプリケーションが Windows 2000 と同じようにはユーザー固有の情報のアクセスできます。 各ユーザーの情報は、ローカルまたはネットワーク サーバー上に格納できる個別のファイルに格納されます。 Windows 98]、[ユーザーと別の設定を 1 台のコンピューターから移動できるように、ユーザーの現在のシステムにこのファイルをコピー ME ことができます。  
  
   
  
## Examples  
 次の例では、このキーのサブキーを取得する方法について説明し、画面に名前を出力します。 使用して、<xref:Microsoft.Win32.RegistryKey.OpenSubKey%2A>関心のある特定のサブキーのインスタンスを作成します。 その他の操作を使用することができますし、<xref:Microsoft.Win32.RegistryKey>そのキーを操作します。  
  
 [!code-cpp[Classic Registry.Users Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Registry.Users Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Registry.Users Example/CS/source.cs#1)]
 [!code-vb[Classic Registry.Users Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Registry.Users Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>