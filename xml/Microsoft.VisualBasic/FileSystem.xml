<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="aa6147a0783461c4dfb22838d1d20f87a6a770da" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52609160" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see langword="FileSystem" /> モジュールに含まれるプロシージャを使って、ファイル、ディレクトリ、またはフォルダー、およびシステムの操作を実行します。 <see langword="My" /> 機能を使用すると、<see langword="FileSystem" /> モジュールを使用した場合よりファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このモジュールは、Visual Basic 言語のキーワードおよびファイルとフォルダーにアクセスするランタイム ライブラリ メンバーをサポートします。  
  
   
  
## Examples  
 この例では、`GetAttr`ファイルとディレクトリまたはフォルダーの属性を確認する関数。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">ディレクトリとファイルの概要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">入出力の概要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">キーワード (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic ランタイム ライブラリ メンバー</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須。 新しい既定ディレクトリまたはフォルダーになるディレクトリまたはフォルダーを識別する <see langword="String" /> 式。 <paramref name="Path" /> にはドライブを含めることができます。 ドライブを指定しない場合、<see langword="ChDir" /> は現在のドライブの既定ディレクトリまたは既定フォルダーを変更します。</param>
        <summary>現在のディレクトリまたはフォルダーを変更します。 <see langword="My" /> 機能を使用すると、<see langword="ChDir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir`関数は、既定のディレクトリが既定のドライブを変更します。 たとえば、既定のドライブが C の場合は、次のステートメントは変更既定のディレクトリをドライブ D、C が既定のドライブに残ります。  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 相対に行うことができますディレクトリの変更は、次のように 2 つのピリオドを入力します。  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir`関数が部分的に信頼された状況では、その実行に影響を与えるアンマネージ コードのアクセス許可が必要です。 詳細については、次を参照してください。<xref:System.Security.Permissions.SecurityPermission>とします。  
  
   
  
## Examples  
 この例では、`ChDir`を現在のディレクトリまたはフォルダーを変更する関数。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> が空です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定されたドライブが無効です。または利用できません。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">方法 : Visual Basic でファイル パスを解析する</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Visual Basic でのファイルおよびディレクトリの作成、削除、および移動</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のドライブを変更します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">必須。 既存のドライブを指定する文字列式。 長さ 0 の文字列 ("") を指定した場合、現在のドライブは変更されません。 <paramref name="Drive" /> 引数が複数の文字で構成される文字列の場合、<see langword="ChDrive" /> は先頭の文字だけを使用します。</param>
        <summary>現在のドライブを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`関数が部分的に信頼された状況では、その実行に影響を与えるアンマネージ コードのアクセス許可が必要です。 詳細については、次を参照してください。<xref:System.Security.Permissions.SecurityPermission>と[コード アクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)します。  
  
   
  
## Examples  
 この例では、`ChDrive`を現在のドライブを変更する関数。 関数は、ドライブが存在しない場合に例外をスローします。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定されたドライブが無効です。または利用できません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">必須。 既存のドライブを指定する文字列式。 長さ 0 の文字列 ("") を指定した場合、現在のドライブは変更されません。 <paramref name="Drive" /> 引数が複数の文字で構成される文字列の場合、<see langword="ChDrive" /> は先頭の文字だけを使用します。</param>
        <summary>現在のドライブを変更します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`関数が部分的に信頼された状況では、その実行に影響を与えるアンマネージ コードのアクセス許可が必要です。 詳細については、次を参照してください。<xref:System.Security.Permissions.SecurityPermission>と[コード アクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)します。  
  
   
  
## Examples  
 この例では、`ChDrive`を現在のドライブを変更する関数。 関数は、ドライブが存在しない場合に例外をスローします。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定されたドライブが無効です。または利用できません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="CurDir" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="CurDir" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
        <returns>現在のパスを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`CurDir`関数を現在のパスを返します。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">任意。 既存のドライブを指定する <see langword="Char" /> 式です。 ドライブが指定されていない場合、または <paramref name="Drive" /> が長さ 0 の文字列 ("") である場合は、<see langword="CurDir" /> により現在のドライブのパスが返されます。</param>
        <summary>現在のパスを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="CurDir" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />」を参照してください。</summary>
        <returns>現在のパスを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`CurDir`関数を現在のパスを返します。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定パターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="Dir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>指定パターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="Dir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />」を参照してください。</summary>
        <returns>指定されたパターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`関数は、複数の文字の使用をサポートしています (`*`) と 1 文字 (`?`) ワイルドカードを使用すると、複数のファイルを指定します。  
  
 `VbVolume` 特定のファイル名の代わりに、ドライブのボリューム ラベルを返します。  
  
 指定する必要があります、`PathName`初めて呼び出す、`Dir`関数。 次の項目を取得するには、後続の呼び出しを行うことができます、`Dir`パラメーターなしの関数。  
  
> [!IMPORTANT]
>  正常に実行する、`Dir`関数に必要な<xref:System.Security.Permissions.FileIOPermissionAccess.Read>と<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>のフラグ<xref:System.Security.Permissions.FileIOPermission>コードの実行に許可します。 詳細については、次を参照してください。 <xref:System.Security.Permissions.FileIOPermission>、 <xref:System.Security.SecurityException>、および[コード アクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)します。  
  
 `Attributes`列挙値の引数は次のようにします。  
  
|[値]|定数|説明|  
|-|-|-|  
|`Normal`|`vbnormal`|既定モード。 属性のないファイルを指定します。|  
|`ReadOnly`|`vbReadOnly`|属性のないファイルや読み取り専用ファイルを指定します。|  
|`Hidden`|`vbHidden`|属性のないファイルや隠しファイルを指定します。|  
|`System`|`vbSystem`|システム ファイル、およびも属性のないファイルを指定します。|  
|`Volume`|`vbVolume`|ボリューム ラベルを指定しますその他の属性が指定されている場合`vbVolume`は無視されます。|  
|`Directory`|`vbDirectory`|ディレクトリまたはフォルダー、およびも属性のないファイルを指定します。|  
|`Archive`|`vbArchive`|ファイルは前回のバックアップ以降に変更されています。|  
|`Alias`|`vbAlias`|ファイルに別の名前が付いています。|  
  
> [!NOTE]
>  これらの列挙体は、Visual Basic 言語によって指定され、実際の値ではなく、コード内の任意の場所で使用できます。  
  
   
  
## Examples  
 この例では、`Dir`関数を特定のファイルおよびディレクトリの存在を確認します。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">任意。 ファイル名、ディレクトリまたはフォルダー名、あるいはドライブ ボリューム ラベルを指定する <see langword="String" /> 型の式。 <paramref name="PathName" /> が見つからない場合は、長さ 0 の文字列 (<see langword="&quot;&quot;" />) が返されます。</param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">任意。 値がファイル属性を指定する列挙式または数式。 省略した場合、<see langword="Dir" /> は、<paramref name="PathName" /> に一致する、属性のないファイルを返します。</param>
        <summary>指定パターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="Dir" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />」を参照してください。</summary>
        <returns>指定されたパターンまたはファイル属性と一致するファイル名、ディレクトリ名、フォルダー名を表す文字列、またはドライブのボリューム ラベルを表す文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`関数は、複数の文字の使用をサポートしています (`*`) と 1 文字 (`?`) ワイルドカードを使用すると、複数のファイルを指定します。  
  
 `VbVolume` 特定のファイル名の代わりに、ドライブのボリューム ラベルを返します。  
  
 指定する必要があります、`PathName`初めて呼び出す、`Dir`関数。 次の項目を取得するには、後続の呼び出しを行うことができます、`Dir`パラメーターなしの関数。  
  
> [!IMPORTANT]
>  正常に実行する、`Dir`関数に必要な<xref:System.Security.Permissions.FileIOPermissionAccess.Read>と<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>のフラグ<xref:System.Security.Permissions.FileIOPermission>コードの実行に許可します。 詳細については、次を参照してください。 <xref:System.Security.Permissions.FileIOPermission>、 <xref:System.Security.SecurityException>、および[コード アクセス許可](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)します。  
  
 `Attributes`列挙値の引数は次のようにします。  
  
|[値]|定数|説明|  
|-|-|-|  
|`Normal`|`vbnormal`|既定モード。 属性のないファイルを指定します。|  
|`ReadOnly`|`vbReadOnly`|ファイル属性がないだけでなく、読み取り専用のファイルを指定します。|  
|`Hidden`|`vbHidden`|ファイル属性がないだけでなく、非表示のファイルを指定します。|  
|`System`|`vbSystem`|ファイル属性がないだけでなく、システム ファイルを指定します。|  
|`Volume`|`vbVolume`|ボリューム ラベルを指定しますその他の属性が指定されている場合`vbVolume`は無視されます。|  
|`Directory`|`vbDirectory`|ディレクトリまたはファイル属性がないだけでなく、フォルダーを指定します。|  
|`Archive`|`vbArchive`|ファイルは前回のバックアップ以降に変更されています。|  
|`Alias`|`vbAlias`|ファイルに別の名前が付いています。|  
  
> [!NOTE]
>  これらの列挙体は、Visual Basic 言語によって指定され、実際の値の代わりに、コード内の任意の場所で使用できます。  
  
   
  
## Examples  
 この例では、`Dir`関数を特定のファイルおよびディレクトリの存在を確認します。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 有効なファイル番号が含まれている <see langword="Integer" /> 型の値。</param>
        <summary>
          <see langword="True" /> モードまたはシーケンシャル <see langword="Random" /> モードで開いたファイルの現在位置がファイルの末尾に達している場合、ブール値 <see langword="Input" /> を返します。</summary>
        <returns>
          <see langword="True" /> モードまたはシーケンシャル <see langword="Random" /> モードで開いたファイルの現在位置がファイルの末尾に達している場合、ブール値 <see langword="Input" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`EOF`ファイルの末尾の入力を取得しようとして生成されたエラーを回避するためにします。  
  
 `EOF`関数が返される`False`ファイルの末尾に達するまでです。 開いたファイル`Random`または`Binary`アクセス、`EOF`返します`False`最後に実行されるまで`FileGet`関数は、レコード全体を読めるようにすることはありません。  
  
 開いたファイル`Binary`アクセス、ファイルを使用して、読み込もうとすると、`Input`行われるまで`EOF`返します`True`エラーが生成されます。 使用して、`LOF`と`Loc`関数の代わりに`EOF`でバイナリ ファイルを読み取るときに`Input`、使用または`Get`を使用する場合、`EOF`関数。 開いたファイル`Output`、`EOF`は常に返します`True`します。  
  
   
  
## Examples  
 この例では、`EOF`ファイルの終わりを検出する関数。 この例では、`Testfile`複数行のテキストを含むテキスト ファイルです。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 <see langword="Integer" />。 任意の有効なファイル数。</param>
        <summary>
          <see langword="FileOpen" /> 関数を使用して開いたファイルのファイル モードを表す列挙体を返します。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="FileAttr" /> 関数を使用した場合より I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />」を参照してください。</summary>
        <returns>次の列挙型値は、ファイルのアクセス モードを示します。 
 <list type="table"><item><term> [値] 
 </term><description> モード 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この関数は、ファイルのモードを使用して開かれたファイルを表す列挙体を返します、`FileOpen`関数。  
  
   
  
## Examples  
 この例では、`FileAttr`関数を開いているファイルのファイル モードを返します。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">任意。 閉じる対象となる、0 以上のチャネルで構成されるパラメーター配列。</param>
        <summary>
          <see langword="FileOpen" /> 関数で開いたファイルへの入出力を終了して、ファイルを閉じます。 <see langword="My" /> を使用すると、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください[する方法: StreamReader を使用してファイルからのテキストの読み取り](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)、[する方法: StreamWriter を持つファイルに書き込むテキスト](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)、と[チュートリアル: 操作のファイルとディレクトリの。Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)します。  
  
 省略した場合`FileNumbers`、すべてのアクティブなファイルを開く、`FileOpen`関数は閉じられます。  
  
 開かれているファイルを閉じるとき`Output`または`Append`出力の最終的なバッファーがそのファイルのオペレーティング システムのバッファーに書き込まれます。 すべてのバッファー領域が閉じたに関連付けられているファイルは解放されます。  
  
 ときに、`FileClose`関数が実行され、ファイルをそのファイルの関連付け番号が終了します。  
  
   
  
## Examples  
 この例では、`FileClose`の開かれたファイルを閉じる関数`Input`します。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> は存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End ステートメント</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Stop ステートメント (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">必須。 コピーするファイルの名前を指定する <see langword="String" /> 型の式。 <paramref name="Source" /> には、コピー先ファイルのディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <param name="Destination">必須。 コピー先のファイルの名前を指定する <see langword="String" /> 型の式。 <paramref name="Destination" /> には、コピー先ファイルのディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルをコピーします。 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> を使用すると、<see langword="FileCopy" /> を使用した場合よりも、ファイル I/O 操作の生産性およびパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用しようとする場合、`FileCopy`で現在開いているファイルの場合は、関数のエラーが発生します。  
  
 `FileCopy` ローカル ドライブで動作する完全な信頼が必要です。  
  
   
  
## Examples  
 この例では、`FileCopy`別に 1 つのファイルをコピーする関数。 この例のために、仮定`SrcFile`はデータを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> または <paramref name="Destination" /> が無効であるか、指定されていません。</exception>
        <exception cref="T:System.IO.IOException">ファイルは既に開いています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">方法 : Visual Basic でファイルのコピーを別のディレクトリに作成する</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">方法 : Visual Basic でファイルのコピーを同じディレクトリに作成する</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">方法 : Visual Basic でディレクトリを別のディレクトリにコピーする</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須。 ファイル名を指定する <see langword="String" /> 型の式。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルへの書き込み日時を示す <see langword="Date" /> 値を返します。 <see langword="My" /> 機能を使用すると、<see langword="FileDateTime" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />」を参照してください。</summary>
        <returns>ファイルの作成日時または最終変更日時を示す <see langword="Date" /> 値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`FileDateTime`関数を日付し、時刻のファイルが作成または最後に変更します。 表示される日付の形式は、システムのロケール設定に基づきます。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> が無効です。またはワイルドカードを含んでいます。</exception>
        <exception cref="T:System.IO.FileNotFoundException">対象のファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`通常のファイルに書き込まれ、`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`通常のファイルに書き込まれ、`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 場合は、記述子は使用されません。 渡された配列の境界とサイズ、`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`通常のファイルに書き込まれ、`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`通常のファイルに書き込まれ、`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`を使用して、ファイルに書き込まれますが、通常は`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`を使用して、ファイルに書き込まれますが、通常は`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`を使用して、ファイルに書き込まれますが、通常は`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`を使用して、ファイルに書き込まれますが、通常は`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`を使用して、ファイルに書き込まれますが、通常は`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`を使用して、ファイルに書き込まれますが、通常は`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`を使用して、ファイルに書き込まれますが、通常は`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="StringIsFixedLength">任意。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`を使用して、ファイルに書き込まれますが、通常は`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="ArrayIsDynamic">任意。 文字列を書き込む場合のみ適用します。 配列を動的として扱うかどうか、およびサイズと境界を表す配列記述子が必要かどうかを指定します。</param>
        <param name="StringIsFixedLength">任意。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。 <see langword="My" /> 機能を使用すると、<see langword="FileGet" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGet`を使用して、ファイルに書き込まれますが、通常は`FilePut`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたはバイトの前回`FileGet`または`FilePut`関数 (最後を指すまたは`Seek`関数) は読み取り専用です。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGet`レコード長の境界上でその後のレコードを読み取ります。 次のレコードの開始する 1 つのレコードの末尾までには、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないためには一般にはレコード長を読み取られるデータの長さと一致します。  
  
-   既定でに読み取られた変数が文字列、`FileGet`を文字列の長さを含み、変数にデータを読み込みます 2 バイトの記述子を読み取ります。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョン サポートの固定長文字列。ファイルに書き込む場合、長さの記述子は書き込まれません。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が配列の場合は、サイズと配列の次元の記述子を読み取るかどうかを選択できます。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を読み取るときに、配列の書き込み方法に合わせる必要があります。 記述子を書き込んだ場合、記述子を読み取る必要があります。 配列の境界とサイズに渡される記述子を使用しない場合`FileGet`読み込む対象を決定します。  
  
     記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 バイトは、次のように配布されます。  
  
    -   18 バイトの記述子の: (2 * 2 + 8)  
  
    -   データの 200 バイト: (4 * 5 * 10)。  
  
-   読み取られた変数は他の種類 (いない可変長文字列またはオブジェクト) の変数の`FileGet`変数のデータのみを読み取ります。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が読み取られるデータの長さ以上にする必要があります。  
  
-   `FileGet` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePut`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 これには、すべてのアレイとその記述子が含まれます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGet` すべての変数をディスクからデータを連続的読み取りつまり、レコード間余白なし。  
  
-   すべての配列、構造体の配列以外の`FileGet`データのみを読み取ります。 記述子は読み取られませんでした。  
  
-   `FileGet` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
    > [!IMPORTANT]
    >  使用して、ファイルから読み取り、`FileGet`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 データの読み込み先となる有効な変数名。</param>
        <param name="RecordNumber">任意。 読み込みを開始する位置の、レコード数 (<see langword="Random" /> モードのファイル) またはバイト数 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>開いたディスク ファイルからデータを読み込んで変数に格納します。  <see langword="My" /> 機能を使用すると、<see langword="FileGetObject" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject`の代わりに関数を使用して`FileGet`場合は、コンパイル時にあいまいさを避けるために型`Object`など別の型の代わりに返される`Integer`、 `Long`、`Short`となります。  
  
 記述する場合、`Variant`型、`FileGetObject`が必要です。 あれば、2 番目のパラメーター オブジェクトを使用している場合、常にお勧めを使用すること`FilePutObject`と`FileGetObject`します。  
  
 `FileGetObject` のみ有効ですが`Random`と`Binary`モード。  
  
 データを読み取る`FileGetObject`に通常書き込まれ、`FilePutObject`します。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、`FileGetObject`レコードまたはバイトを読み取り、最後の後に`FileGetObject`または`FilePutObject`関数 (または最後を指す`Seek`関数)。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   読み取られるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FileGetObject`レコード長の境界上でその後のレコードを読み取ります。 1 つのレコードの終わりと次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量を正確に判断できないためには読み取られるデータの長さと一致するレコードの長さであることをお勧めします。  
  
-   読み取られた変数が既定では、文字列である`FileGetObject`文字列の長さを含む 2 バイトの記述子を読み取って、変数にデータを読み込みます。 そのためで指定されたレコード長、`RecordLength`の句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。 Visual Basic 6.0 と以前のバージョンは、固定長文字列とファイルを読み取るときに、長さの記述子は書き込まれませんをサポートします。 記述子なしの文字列を読み取る場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   読み取られた変数が、配列で指定されたレコード長の場合、`RecordLength`パラメーター、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: 2 + 8 * 含まします。  
  
     次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 バイトが次のように分散: 18 バイトの記述子 (2 + 8 * 2)、およびデータ (4 * 5 * 10) の 100 バイトです。  
  
-   `FileGetObject` 要素間の余白がないこと以外は場合に、個別に、それぞれ読み取り中の構造体の要素を読み取ります。 ディスク上で、ユーザー定義型の配列の動的な (で記述された`FilePutObject`) 長さが等しい 2 と 8 時間ディメンションの数の記述子のプレフィックスが付いた: 2 + 8 * 含まします。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が、配列とその記述子を含む、個々 の要素の読み取りに必要なすべてのバイトの合計以上にする必要があります。 <xref:Microsoft.VisualBasic.VBFixedStringAttribute>クラスは、書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに適用できますをディスクにします。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、すべての`Random`でこれらの例外の規則が適用されます。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FileGetObject` 変数を読み取るすべてディスクから連続的、つまり、レコード間の埋め込みなしで。  
  
-   すべての配列、構造体の配列以外の`FileGetObject`データのみを読み取ります。 記述子は読み取られませんでした。  
  
 `FileGetObject` 2 バイトの長さの記述子構造体の要素ではない可変長文字列を読み取ります。 読み取られたバイト数では、文字列内の文字の数と同じです。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb という名前のファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
   
  
## Examples  
 次の例では、テスト ファイルにレコードを読み取るし、それを取得します。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須。 ファイルを指定する <see langword="String" /> 式。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルの長さをバイト数で指定する <see langword="Long" /> 値を返します。 <see langword="My" /> 機能を使用すると、<see langword="FileLen" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />」を参照してください。</summary>
        <returns>ファイルの長さをバイト数で指定する <see langword="Long" /> 値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定したファイルが開いている場合場合に、`FileLen`関数が呼び出されると、返される値は、開かれた時点で、ファイルのサイズを表します。  
  
> [!NOTE]
>  現在開いているファイルの長さを取得する、`LOF`関数。  
  
   
  
## Examples  
 この例では、`FileLen`関数をファイルの長さをバイト単位で返します。 この例のために、仮定`TestFile`はいくつかのデータを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。 <see langword="FreeFile" /> 関数を使用して、次に使用できるファイル番号を取得します。</param>
        <param name="FileName">必須。 ファイル名を指定する <see langword="String" /> 型の式。ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <param name="Mode">必須。 ファイル モード (<see langword="Append" />、<see langword="Binary" />、<see langword="Input" />、<see langword="Output" />、または <see langword="Random" />) を指定する列挙体。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenMode" />」を参照してください。</param>
        <param name="Access">任意。 開いているファイルで許可されている操作 (<see langword="Read" />、<see langword="Write" />、または <see langword="ReadWrite" />) を示す列挙体。 既定値は <see langword="ReadWrite" /> です。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenAccess" />」を参照してください。</param>
        <param name="Share">任意。 他のプロセスによって開かれたファイルで許可されていない操作 (<see langword="Shared" />、<see langword="Lock Read" />、<see langword="Lock Write" />、および <see langword="Lock Read Write" />) を指定する列挙体。 既定値は <see langword="Lock Read Write" /> です。 詳細については、「<see cref="T:Microsoft.VisualBasic.OpenShare" />」を参照してください。</param>
        <param name="RecordLength">任意。 32,767 以下の値 (バイト単位)。 ランダム アクセス ファイルの場合は、レコード長を表します。 シーケンシャル ファイルの場合は、バッファー内の文字数を表します。</param>
        <summary>ファイルを開いて入出力を行います。 <see langword="My" /> 機能を使用すると、<see langword="FileOpen" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 すべての I/O 操作を実行する前に、は、ファイルを開く必要があります。 `FileOpen` ファイル I/O のバッファーを割り当てし、バッファーへのアクセス モードを決定します。  
  
> [!IMPORTANT]
>  ファイルに書き込む場合、アプリケーションを作成しようとするファイルが存在しない場合、ファイルを作成する必要があります。 これを行うには、ファイルが作成されるディレクトリのアクセス許可が必要です。 ただし、によってファイルが指定されている場合`FileName`存在は、アプリケーションのニーズ`Write`ファイル自体にのみアクセスを許可します。 セキュリティを強化する、可能なが展開および付与中にファイルを作成する任意の場所`Write`アクセス許可をディレクトリ全体の代わりにのみ、します。 セキュリティを強化するには、ルート ディレクトリまたは Program Files ディレクトリの代わりに、ユーザーのディレクトリにデータを書き込みます。  
  
 使用して、チャネルを開くにはあります、`FreeFile()`関数。  
  
> [!IMPORTANT]
>  `FileOpen`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体は、部分的な信頼された状況では、その実行に影響を与える可能性があります。 詳細については、次を参照してください。<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例でのさまざまな使用、`FileOpen`入力と出力ファイルを有効にする関数。  
  
 次のコードは、ファイルを開きます`TestFile`で`Input`モード。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 この例で、ファイルが開きます`Binary`操作のみを記述するためのモード。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 次の例で、ファイルを開きます`Random`モード。 ファイルには、構造体のレコードが含まれています。`Person`します。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 このコード例でファイルを開き`Output`モード; 任意のプロセスはファイルに対する読み取りまたは書き込み。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 このコード例でファイルを開き`Binary`読み込み専用の他のプロセスがファイルを読み取ることはできません。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">レコード長が、-1 ではない負の値です。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> が既に開かれています。または <paramref name="FileName" /> が無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="StringIsFixedLength">任意。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <param name="ArrayIsDynamic">任意。 文字列を書き込む場合のみ適用します。 配列を動的として扱うかどうか、および長さを表す文字列の配列記述子を書き込むかどうかを指定します。</param>
        <param name="StringIsFixedLength">任意。 文字列を書き込む場合のみ適用します。 長さを表す文字列に対して 2 バイトの記述子を書き込むかどうかを指定します。 既定値は、<see langword="False" /> です。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。 <see langword="My" /> 機能を使用すると、<see langword="FilePut" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePut` を使用して書き込まれたデータは通常、`FileGet` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、[次へ] のレコードまたは最後後のバイト`FileGet`または`FilePut`関数または最後が指す`Seek`関数が書き込まれます。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePut` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePut`と同じ処理を実行する必要がある`FileGet`長さが予期する文字列が初期化されていることを確認する必要があります。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePut`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量は指定できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が、文字列の場合`FilePut`を文字列の長さを含み、変数にデータを書き込む 2 バイトの記述子を書き込みます。 そのためで指定されたレコード長、`RecordLength`句、`FileOpen`関数は 2 バイト以上で、文字列の実際の長さより大きい値である必要があります。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePut`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePut` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれている変数が、文字列を含むオブジェクトの場合`FilePut`2 バイト記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が配列である場合がある場合のサイズと配列の次元の記述子を書き込むかどうかを選択します。 Visual Basic 6.0 以前のバージョンは、動的配列の固定サイズの配列ではなく、ファイル記述子を書き込みます。 Visual Basic 2005 は、記述子を記述しない既定値です。 記述子を書き込むには、設定、`ArrayIsDynamic`パラメーター`True`します。 配列を書き込むときに、配列の読み込み方法と一致する必要があります。記述子を読み取ることがある場合は記述子を記述する必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 次の配列の宣言に 218 バイトが必要です、配列が書き込まれるときに、ディスクにします。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   書き込まれている変数が他の種類の変数 (いない可変長文字列またはオブジェクト) の場合`FilePut`変数のデータのみを書き込みます。 指定されたレコードの長さ、`RecordLength`句、`FileOpen`関数が書き込まれるデータの長さ以上にする必要があります。  
  
-   `FilePut` 要素間の余白がない点を除いて、個別にそれぞれ記述された場合と構造体の要素を書き込みます。 `VBFixedString`書き込まれるときに、文字列のサイズを指定する構造体の文字列フィールドに属性を適用できるディスクにします。  
  
    > [!NOTE]
    >  文字列のバイトで指定された数のフィールド、`VBFixedString`書き込まれるときに、属性は切り捨てられます、ディスクに  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、ほとんどの`Random`いくつかの例外のモードの規則が適用されます。 次の規則ファイルが開かれている`Binary`モードとは異なる規則`Random`モード。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePut` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
-   すべての配列、構造体の配列以外の`FilePut`データだけを書き込みます。 記述子は書き込まれません。  
  
-   `FilePut` 2 バイトの長さ記述子構造体の要素ではない可変長文字列を書き込みます。 書き込まれたバイト数では、文字列内の文字の数と同じです。 たとえば、次のステートメントは、ファイル番号 1 を 11 バイトまでですを記述します。  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用して、ファイルへの書き込み、`FilePut`関数に必要な`Write`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`FilePut`関数にはデータをファイルに書き込めません。 構造体の 5 つのレコード`Person`ファイルに書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> は &lt; 1 で、-1 と等しくありません。</exception>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ディスクに書き込まれるデータを保持する有効な変数の名前。</param>
        <param name="RecordNumber">任意。 書き込みを始めるレコード番号 (<see langword="Random" /> モードのファイル) またはバイト位置 (<see langword="Binary" /> モードのファイル)。</param>
        <summary>変数の内容をディスク上のファイルに書き込みます。  <see langword="My" /> 機能を使用すると、<see langword="FilePutObject" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject`の代わりに関数を使用して`FilePut`場合は、コンパイル時にあいまいさを避けるために型`Object`など別の型ではなく渡された`Integer`、 `Long`、`Short`となります。  
  
 `FilePutObject` 書き込み、オブジェクトを記述する記述子を読み取ります。 記述する場合、`Variant`型、`FilePutObject`が必要です。 状態が不明な 2 番目のパラメーター オブジェクトを使用している場合と、で常に使用こと勧め`FilePutObject`と`FileGetObject`します。  
  
 `FilePutObject` のみ有効ですが`Random`と`Binary`モード。  
  
 `FilePutObject` を使用して書き込まれたデータは通常、`FileGetObject` を使用してファイルから読み込まれます。  
  
 最初のレコードまたはファイル内のバイトは、位置 1 では、2 番目のレコードまたはバイトが位置 2、という具合にあります。 省略した場合`RecordNumber`、 `FilePutObject` 、最後の後に次のレコードまたはバイトを書き込みます`FileGetObject`または`FilePutObject`関数 (またはレコードまたはバイトが、最後が指す`Seek`関数)。  
  
 `StringIsFixedLength`引数は、関数が変数または固定長として文字列を解釈するかどうかを制御します。 `FilePutObject` 引数が長さの記述子が書き込みません`True`します。 使用する場合`StringIsFixedLength`  =  `True`で`FilePutObject`と同じ処理を実行する必要がある`FileGetObject`長さが予期する文字列が初期化されていることを確認することも必要とします。  
  
## <a name="random-mode"></a>ランダムなモード  
 ファイルを開くの`Random`モードでは、次の規則が適用されます。  
  
-   書き込まれるデータの長さがで指定された長さより小さい場合、`RecordLength`の句、`FileOpen`関数、`FilePutObject`レコード長の境界上でその後のレコードを書き込みます。 1 つのレコードの末尾と次のレコードの先頭の間には、既存のファイル バッファーの内容が埋め込まれます。 埋め込みデータの量を正確に判断できないために、一般的には書き込まれるデータの長さと一致するレコード長に。 書き込まれるデータの長さがで指定された長さより大きい場合、`RecordLength`の句、`FileOpen`関数の場合、例外がスローされます。  
  
-   書き込まれている変数が数値の型を格納しているオブジェクトの場合`FilePutObject`を識別する 2 バイトを書き込んで、`VarType`オブジェクトのによって変数が出力されます。 たとえば、オブジェクトを記述するときに格納している整数では、 `FilePutObject` 6 バイトを書き込みます: 2 バイトとしてオブジェクトを識別する`VarType(3)`(`Integer`) とデータを含む 4 つのバイト数。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は 2 バイト以上で実際の変数を格納するために必要なバイト数よりも大きい値である必要があります。  
  
-   書き込まれる変数は、文字列を含むオブジェクト場合`FilePutObject`2 バイトの記述子を書き込み、`VarType(8)`オブジェクト、文字列、および、文字列データの書き込みの長さを示す 2 バイトの記述子の。 指定されたレコードの長さ、`RecordLength`パラメーター、`FileOpen`関数は少なくとも 4 バイトの文字列の実際の長さより大きい値である必要があります。 記述子なしの文字列を配置する場合は、渡す必要があります`True`を`StringIsFixedLength`パラメーター、および文字列を読み込むときに、正しい長さにする必要があります。  
  
-   書き込まれている変数が、配列で指定されたレコード長の場合、`RecordLength`句、`FileOpen`関数が配列のデータや配列記述子を作成するために必要なすべてのバイトの合計以上にする必要があります。 記述子では、配列、サイズ、および各ランクの下限のランクを指定します。 長さが 2 に加えて、8 時間ディメンションの数: (2 + 8 * 含ま)。  
  
## <a name="binary-mode"></a>バイナリ モード  
 ファイルを開くの`Binary`モードでは、すべて、`Random`モードの規則を適用するを除く。  
  
-   `RecordLength`句、`FileOpen`関数が影響を与えません。 `FilePutObject` つまり、レコード間のパディングなし連続して、ディスクにすべての変数に書き込みます。  
  
   
  
## Examples  
 この例では、`FilePutObject`ファイルに文字列を書き込みます。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="RecordWidth">必須。 改行される前に 1 行に表示できる文字数を表す 0 ～ 255 の範囲の数式。 <paramref name="RecordWidth" /> が 0 の場合は、行の長さに制限がないことを示します。 <paramref name="RecordWidth" /> の既定値は 0 です。</param>
        <summary>
          <see langword="FileOpen" /> 関数を使用して開いたファイルに出力行の桁数を割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 この例では、`FileWidth`ファイルの出力の線の幅を設定します。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see langword="Integer" /> 関数で使用できる次のファイル番号を表す <see langword="FileOpen" /> 値を返します。</summary>
        <returns>
          <see langword="Integer" /> 関数で使用できる次のファイル番号を表す <see langword="FileOpen" /> 値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FreeFile`を既に使用されていない、ファイル番号を入力します。  
  
   
  
## Examples  
 この例では、 `FreeFile` [次へ] の使用可能なファイル数を返す関数。 出力、ループ内で開かれている 5 つのファイルとそれぞれにいくつかのサンプル データが書き込まれます。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">使用中のファイルが 255 個を超えています。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須。 ファイル、ディレクトリ、またはフォルダーの名前を指定する <see langword="String" /> 型の式。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイル、ディレクトリ、またはフォルダーの属性を表す <see langword="FileAttribute" /> 型の値を返します。 <see langword="My" /> 機能を使用すると、<see langword="FileAttribute" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns>
          <see langword="GetAttr" /> によって返される値は、次の表に示す列挙型値の合計です。 
 <list type="table"><item><term> [値] 
 </term><description> 定数 
 </description><description> 説明 
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> 標準。  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> 読み取り専用。  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> 非表示。  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> システム ファイル。  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> ディレクトリまたはフォルダー。  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> ファイルは前回のバックアップ以降に変更されています。  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> ファイルに別の名前が付いています。  
  
 </description></item></list><block subset="none" type="note"><para>  
 これらの列挙体は Visual Basic 言語によって指定されています。 これらの名前は、実際の値の代わりにコード内のどの部分でも使用できます。  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 どの属性が設定を確認するのには、使用、`And`によって返される値のビットごとの比較を実行する演算子、`GetAttr`関数とする個々 のファイル属性の値。 結果がゼロでない場合は、その属性が名前付きのファイルの設定されます。 次の戻り値など、`And`式が場合は 0、`Archive`属性が設定されていません。  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 場合、0 以外の値が返されます、`Archive`属性を設定します。  
  
   
  
## Examples  
 この例では、`GetAttr`ファイルとディレクトリまたはフォルダーの属性を確認する関数。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> が無効です。またはワイルドカードを含んでいます。</exception>
        <exception cref="T:System.IO.FileNotFoundException">対象のファイルが存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">And 演算子 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの一部の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの一部の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Value">必須。 ファイルから読み込まれた値を割り当てられた変数。配列変数やオブジェクト変数は指定できません。</param>
        <summary>開いているシーケンシャル ファイルからデータを読み込み、そのデータを変数に代入します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`Input`を使用して、ファイルに書き込まれますが、通常は`Write`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルは、Visual Basic 2005 ソース ファイルではない可能性があります。  
  
 読み込む場合、標準の文字列または数値データが割り当てられる変数を変更せずに。 次の表は、その他の入力データを処理する方法を示しています。  
  
|データ|変数に割り当てられた値|  
|-|-|  
|コンマまたは空白行を区切る|Empty|  
|[NULL]|`DBNull`|  
|[TRUE] または [FALSE]|`True` または `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日付や時刻の式で表される|  
|#ERROR `errornumber`#|`errornumber` (変数は、エラーとしてタグ付けされたオブジェクト)|  
  
 データ項目の入力中に、ファイルの末尾に到達する場合は、入力を停止し、エラーが発生します。  
  
> [!NOTE]
>  `Input`関数はローカライズされていません。 たとえば、ドイツ語のバージョンでは、3,14159 を入力する場合、コンマが小数点としての代わりに変数の区切り文字として扱われるため、3 だけが返されます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`Input`関数に必要な`Read`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Input`ファイルから 2 つの変数にデータを読み取る関数。 この例では、`TestFile`を使用して書き込まれたデータの複数の行を含むファイルには、`Write`関数は、見積と、コンマで区切られた数の文字列を格納している各行: (「こんにちは」、234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="CharCount">必須。 読み込む文字数を指定する有効な任意の数式。</param>
        <summary>
          <see langword="String" /> モードまたは <see langword="Input" /> モードで開いたファイルから読み取る文字を表す文字列型 (<see langword="Binary" />) の値を返します。 <see langword="My" /> 機能を使用すると、<see langword="InputString" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns>
          <see langword="String" /> モードまたは <see langword="Input" /> モードで開いたファイルから読み取る文字を表す文字列型 (<see langword="Binary" />) の値を返します。 <see langword="My" /> 機能を使用すると、<see langword="InputString" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取り、`InputString`を使用して関数が記述ファイルには、通常`Print`または`FilePut`します。 この関数で開いているファイルでのみ使用`Input`または`Binary`モード。  
  
 異なり、`Input`関数の場合、`InputString`関数には、そこにすべての文字が返されます。 これには、コンマ、キャリッジ リターン、ライン フィード、引用符、および先頭のスペースが含まれます。  
  
 開いたファイル`Binary`アクセスを使用してファイルを読み取ろうとして、`InputString`行われるまで`EOF`返します`True`エラーが生成されます。 使用して、`LOF`と`Loc`関数の代わりに`EOF`を使用してバイナリ ファイルを読み取るときに`InputString`、使用または`FileGet`を使用すると、`EOF`関数。  
  
> [!NOTE]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容に関するセキュリティ上の決定は行いません。 たとえば、Form1.vb という名前のファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
   
  
## Examples  
 この例では、`InputString`ファイルから一度に 1 つの文字を読み取りし、印刷をする関数、`Output`ウィンドウ。 この例では、`MyFile`をいくつかの行のサンプル データを持つテキスト ファイルです。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> は存在しません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> は &lt; 0 または &gt; 214 です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必須。 削除する 1 つ以上のファイル名を指定する <see langword="String" /> 型の式。 <paramref name="PathName" /> には、ディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <summary>ファイルをディスクから削除します。 <see langword="My" /> 機能を使用すると、<see langword="Kill" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` 複数の文字の使用をサポートしています (`*`) と 1 文字 (`?`) ワイルドカードを使用すると、複数のファイルを指定します。  
  
 **セキュリティに関する注意**を実行するために、`Kill`関数に必要な`Read`と`PathDiscovery`のフラグ<xref:System.Security.Permissions.FileIOPermission>コードの実行に許可します。 詳細については、次を参照してください<xref:System.Security.SecurityException>[コード アクセス許可。](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 この例では、`Kill`ディスクからファイルを削除する関数。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">対象のファイルが開かれています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">対象のファイルが見つかりません。</exception>
        <exception cref="T:System.Security.SecurityException">アクセス許可は拒否されました。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <summary>開かれたシーケンシャル ファイルから 1 行を読み込み、<see langword="String" /> 変数に割り当てます。</summary>
        <returns>開かれたシーケンシャル ファイルから 1 行を読み込み、<see langword="String" /> 変数に割り当てます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 データを読み取る`LineInput`を使用して、ファイルに書き込まれますが、通常は`Print`します。  
  
> [!IMPORTANT]
>  ファイルから読み取る場合、ファイル名拡張子に基づいてファイルの内容を判断を行わない。 たとえば、Form1.vb というファイルには、Visual Basic のソース ファイル可能性がありますできません。  
  
 `LineInput`が復帰を検出するまでの時にファイルの 1 文字から関数を読み取ります (`Chr(13)`) またはキャリッジ リターン/ライン フィード (`Chr(13) + Chr(10)`) シーケンス。 キャリッジ リターン/ライン フィードのシーケンスは文字の文字列に追加の代わりにスキップされます。  
  
> [!IMPORTANT]
>  使用して、ファイルから読み取り、`LineInput`関数に必要な`Read`からへのアクセス、<xref:System.Security.Permissions.FileIOPermissionAccess>列挙体。  
  
   
  
## Examples  
 この例では、`LineInput`シーケンシャル ファイルから行を読み取るを変数に割り当てる関数。 この例では、`TestFile`をいくつかの行のサンプル データを持つテキスト ファイルです。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">ファイルの終端に達しました。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> は存在しません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 有効な任意の <see langword="Integer" /> 型のファイル番号。</param>
        <summary>開かれたファイル内の現在の読み込みと書き込みの位置を指定する <see langword="Long" /> 値を返します。</summary>
        <returns>開かれたファイル内の現在の読み込みと書き込みの位置を指定する <see langword="Long" /> 値を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc`関数は 0 から始まる; ファイルの最初のバイトを取得するために使用すると、0 が返されます。  
  
 `Loc`関数は、旧バージョンとの互換性は提供されており、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 各ファイルのアクセス モードの戻り値を次に示します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|最後のレコードから読み取りまたは書き込みをファイルの数。|  
|`Sequential`|128 で割ったファイル内の現在のバイト位置。 ただし、した情報が返されます。`Loc`のシーケンシャル ファイルは使用も必要です。|  
|`Binary`|最後のバイトの読み取りまたは書き込みの位置。|  
  
   
  
## Examples  
 この例では、`Loc`を開いているファイル内の現在の読み取り/書き込み位置を返す関数。 この例では、`MyFile`をいくつかの行のサンプル データを持つテキスト ファイルです。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <summary>
          <see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数は環境で使用がいくつかのプロセスが同じファイルへのアクセスを必要があります。  
  
 `Lock` `Unlock`関数は常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`は省略すると、ロックはファイル全体でになります。 場合`Record`1 つのレコードはロック/ロック解除をするだけでを指定します。  
  
 シーケンシャル入力または出力ファイルが開かれている場合`Lock`と`Unlock`で指定された範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`します。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイル`Person`します。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Record">任意。 ロックまたはアンロックされる唯一のレコードまたはバイトの番号。</param>
        <summary>
          <see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数は環境で使用がいくつかのプロセスが同じファイルへのアクセスを必要があります。  
  
 `Lock` `Unlock`関数は常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`は省略すると、ロックはファイル全体でになります。 場合`Record`1 つのレコードはロック/ロック解除をするだけでを指定します。  
  
 シーケンシャル入力または出力ファイルが開かれている場合`Lock`と`Unlock`で指定された範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`します。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイル`Person`します。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="FromRecord">任意。 ロックまたはアンロックされる最初のレコードまたはバイトの番号。</param>
        <param name="ToRecord">任意。 ロックまたはアンロックされる最後のレコードまたはバイトの番号。</param>
        <summary>
          <see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数は環境で使用がいくつかのプロセスが同じファイルへのアクセスを必要があります。  
  
 `Lock` `Unlock`関数は常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`は省略すると、ロックはファイル全体でになります。 場合`Record`1 つのレコードはロック/ロック解除をするだけでを指定します。  
  
 シーケンシャル入力または出力ファイルが開かれている場合`Lock`と`Unlock`で指定された範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`します。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイル`Person`します。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 有効なファイル番号が含まれている <see langword="Integer" /> 型の値。</param>
        <summary>
          <see langword="Long" /> 関数を使用して開かれたファイルのサイズをバイト単位で表す <see langword="FileOpen" /> を返します。 <see langword="My" /> 機能を使用すると、<see langword="LOF" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns>
          <see langword="Long" /> 関数を使用して開かれたファイルのサイズをバイト単位で表す <see langword="FileOpen" /> を返します。 <see langword="My" /> 機能を使用すると、<see langword="LOF" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、`FileLen`開かれていないファイルの長さを取得します。  
  
   
  
## Examples  
 この例では、`LOF`開いているファイルのサイズを決定する関数。 この例では、`TestFile`はサンプル データを含むテキスト ファイルです。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須。 作成されるディレクトリを識別する <see langword="String" /> 型の式。 <paramref name="Path" /> にはドライブを含めることができます。 ドライブを指定しない場合、<see langword="MkDir" /> は現在のドライブに新しいディレクトリを作成します。</param>
        <summary>新しいディレクトリを作成します。 <see langword="My" /> 機能を使用すると、<see langword="MkDir" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この関数は、新しいディレクトリを作成します。  
  
   
  
## Examples  
 この例では、`MkDir`ディレクトリを作成する関数。 ドライブが指定されていない場合は、新しいディレクトリが現在のドライブに作成されます。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> が指定されていません。または空です。</exception>
        <exception cref="T:System.Security.SecurityException">アクセス許可は拒否されました。</exception>
        <exception cref="T:System.IO.IOException">ディレクトリが既に存在しています。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">方法 : Visual Basic でディレクトリを作成する</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Output">任意。 ファイルへ書き込む 0 個以上のコンマで区切られた式。  
  
<paramref name="Output" /> 引数の設定は以下の通りです。 
 <see langword="T:System.IO.IOException" />: ファイル モードが有効ではありません。  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> が存在しません。</param>
        <summary>表示形式データをシーケンシャル ファイルに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`と`PrintLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 `Print` 行の最後に、改行は含まれませんただし、`PrintLine`改行にが含まれます。  
  
 書き込まれたデータ`Print`を使用してファイルから通常の読み取りは`LineInput`または`Input`します。  
  
 省略した場合`Output`の`PrintLine`、ファイルには、空行が出力`Print`、何も出力します。 タブの境界が混合コンマ上をコンマで区切られた複数の式に配置され、`TAB`矛盾した結果が発生する可能性があります。  
  
 `Boolean`データか、`True`または`False`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。  
  
 日付データは、システムによって認識される標準の短い日付形式を使用して、ファイルに書き込まれます。 日付または時刻部分のいずれかが不足している、または 0 の場合は、提供された部分のみが、ファイルに書き込まれます。  
  
 場合、ファイルに何も書き込まれませんが`Output`データが空です。 ただし場合、`Output`リスト データは`DBNull`、`Null`ファイルに書き込まれます。  
  
 `Error`として、データ、出力が表示されます`Error errorcode`します。 `Error`キーワードは、ロケールに関係なくは翻訳されません。  
  
 使用して、ファイルに書き込まれたすべてのデータ`Print`が国際的に対応しています。 つまり、データの形式が正しく、適切な 10 進区切り記号。 ユーザーが複数のロケールで使用するためのデータを出力する場合`Write`使用する必要があります。  
  
 使用して、ファイルへの書き込み、`Print`または`PrintLine`functions が必要です`Write`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Print`と`PrintLine`関数にはデータをファイルに書き込めません。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Output">任意。 ファイルへ書き込む 0 個以上のコンマで区切られた式。  
  
<paramref name="Output" /> 引数の設定は以下の通りです。 
 <see langword="T:System.IO.IOException" />: ファイル モードが有効ではありません。  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> が存在しません。</param>
        <summary>表示形式データをシーケンシャル ファイルに書き込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`と`PrintLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 `Print` 行の最後に、改行は含まれませんただし、`PrintLine`改行にが含まれます。  
  
 書き込まれたデータ`Print`を使用してファイルから通常の読み取りは`LineInput`または`Input`します。  
  
 省略した場合`Output`の`PrintLine`、ファイルには、空行が出力`Print`、何も出力します。 タブの境界が混合コンマ上をコンマで区切られた複数の式に配置され、`TAB`矛盾した結果が発生する可能性があります。  
  
 `Boolean`データか、`True`または`False`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。  
  
 日付データは、システムによって認識される標準の短い日付形式を使用して、ファイルに書き込まれます。 日付または時刻部分のいずれかが不足している、または 0 の場合は、提供された部分のみが、ファイルに書き込まれます。  
  
 場合、ファイルに何も書き込まれませんが`Output`データが空です。 ただし場合、`Output`リスト データは`DBNull`、`Null`ファイルに書き込まれます。  
  
 `Error`として、データ、出力が表示されます`Error errorcode`します。 `Error`キーワードは、ロケールに関係なくは翻訳されません。  
  
 使用して、ファイルに書き込まれたすべてのデータ`Print`が国際的に対応しています。 つまり、データの形式が正しく、適切な 10 進区切り記号。 ユーザーが複数のロケールで使用するためのデータを出力する場合`Write`使用する必要があります。  
  
 使用して、ファイルへの書き込み、`Print`または`PrintLine`functions が必要です`Write`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Print`と`PrintLine`関数にはデータをファイルに書き込めません。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">必須。 既存のファイルの名前と場所を指定する <see langword="String" /> 型の式。 <paramref name="OldPath" /> には、ファイルのディレクトリおよびドライブを含めることができます。</param>
        <param name="NewPath">必須。 新しいファイルの名前と場所を指定する <see langword="String" /> 型の式。 <paramref name="NewPath" /> には、出力先のディレクトリおよびドライブを含めることができます。 <paramref name="NewPath" /> には、既に存在しているファイル名は指定できません。</param>
        <summary>ディスク ファイルまたはディレクトリの名前を変更します。 <see langword="My" /> 機能を使用すると、<see langword="Rename" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename`関数は、ファイルの名前を変更し、必要な場合は、別のディレクトリに移動します。 `Rename`関数は、ドライブ間でファイルを移動できますが、既存のディレクトリ名前のみ変更できますと両方`NewPath`と`OldPath`同じドライブ上にあります。 `Rename` 新しいファイルまたはディレクトリを作成することはできません。  
  
 使用して、`Rename`関数ファイルを開くには、エラーを生成します。 名前を変更する前に、開いているファイルを閉じる必要があります。 `Rename` 引数には、複数の文字 (*) および 1 文字 (?) のワイルドカードを含めることはできません。  
  
> [!IMPORTANT]
>  使用する場合`Rename`保護されていない場所からファイルを保護された場所にコピーするファイルは制限の少ない権限を保持します。 セキュリティ リスクの可能性を大きくしないことを確認します。  
  
   
  
## Examples  
 この例では、`Rename`ファイルの名前を変更する関数。 この例では、既に指定されているディレクトリが存在すると仮定します。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">パスが無効です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> ファイルが存在しません。</exception>
        <exception cref="T:System.IO.IOException">異なるデバイスには名前を変更できません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">方法 : Visual Basic でファイルの名前を変更する</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see langword="FileOpen" /> 関数を使用して開いたすべてのディスク ファイルを閉じます。 <see langword="My" /> 機能を使用すると、<see langword="Reset" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset`関数によって開かれたすべてのアクティブなファイルを閉じ、`FileOpen`関数と同じ機能があり`FileClose()`パラメーターなし。  
  
   
  
## Examples  
 この例では、`Reset`を開いているすべてのファイルを閉じて、すべてのファイル バッファーの内容をディスクに書き込む関数です。 使用に注意してください、`Object`変数`FileNumber`文字列と数値の両方として。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End ステートメント</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必須。 削除するディレクトリまたはフォルダーを識別する <see langword="String" /> 型の式。 <paramref name="Path" /> にはドライブを含めることができます。 ドライブを指定しない場合、<see langword="RmDir" /> は現在のドライブのディレクトリを削除します。</param>
        <summary>既存のディレクトリを削除します。 <see langword="My" /> 機能を使用すると、<see langword="RmDir" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用しようとする場合にエラーが発生した`RmDir`ファイルを含むディレクトリにします。 使用して、`Kill`ディレクトリを削除しようとする前に、すべてのファイルを削除する関数。  
  
   
  
## Examples  
 この例では、`RmDir`既存のディレクトリを削除する関数。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> が指定されていません。または空です。</exception>
        <exception cref="T:System.IO.IOException">対象のディレクトリにファイルが存在しています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ディレクトリが存在していません。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" /> を返します。また、<see langword="FileOpen" /> 関数で開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。 <see langword="My" /> 機能を使用すると、<see langword="Seek" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 有効なファイル番号が含まれている <see langword="Integer" /> 型の値。</param>
        <summary>
          <see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" /> を返します。また、<see langword="FileOpen" /> 関数で開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。 <see langword="My" /> 機能を使用すると、<see langword="Seek" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <returns>
          <see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" /> を返します。また、<see langword="FileOpen" /> 関数で開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 1 から 2,147, 483,647 の値を返します (= 2 ^31-1) と、包括的です。  
  
 各ファイルのアクセス モードの戻り値を次に示します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|次のレコードの読み取りまたは書き込みの数|  
|`Binary`, `Input`, `Output`, `Append`|バイトの位置が次の操作が発生します。 ファイルの最初のバイト位置 1、2 番目のバイトが位置 2、という具合になります。|  
  
   
  
## Examples  
 この例では、`Seek`関数を現在の位置を返します。 この例では`TestFile`構造体のレコードを含むファイル`Record`します。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 ファイルを開くの`Random`モード、`Seek`次のレコードの数を返します。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 以外のモードで開いているファイルの`Random`モード、`Seek`次のバイト位置を返します。 想定`TestFile`は数行のテキストを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 この例では、`Seek`関数またはファイルに書き込みを次の読み取り位置を設定します。  
  
 以外のモードで開いているファイルの`Random`モード、`Seek`次のバイト位置を設定します。 想定`TestFile`は数行のテキストを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 有効なファイル番号が含まれている <see langword="Integer" /> 型の値。</param>
        <param name="Position">必須。 次の読み書き操作が発生する場所を示す 1 ～ 2,147,483,647 の範囲の数値。</param>
        <summary>
          <see langword="Long" /> 関数を使用して開いたファイル内の現在の読み込み位置または書き込み位置を示す <see langword="FileOpen" /> を返します。また、<see langword="FileOpen" /> 関数で開いたファイルの、次に読み込みまたは書き込みを行う位置を設定します。 <see langword="My" /> 機能を使用すると、<see langword="Seek" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 1 から 2,147, 483,647 の値を返します (= 2 ^31-1) と、包括的です。  
  
 各ファイルのアクセス モードの戻り値を次に示します。  
  
|モード|戻り値|  
|-|-|  
|`Random`|次のレコードの読み取りまたは書き込みの数|  
|`Binary`, `Input`, `Output`, `Append`|バイトの位置が次の操作が発生します。 ファイルの最初のバイト位置 1、2 番目のバイトが位置 2、という具合になります。|  
  
   
  
## Examples  
 この例では、`Seek`関数を現在の位置を返します。 この例では`TestFile`構造体のレコードを含むファイル`Record`します。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 ファイルを開くの`Random`モード、`Seek`次のレコードの数を返します。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 以外のモードで開いているファイルの`Random`モード、`Seek`次のバイト位置を返します。 想定`TestFile`は数行のテキストを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 この例では、`Seek`関数またはファイルに書き込みを次の読み取り位置を設定します。  
  
 以外のモードで開いているファイルの`Random`モード、`Seek`次のバイト位置を設定します。 想定`TestFile`は数行のテキストを含むファイルです。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Visual Basic でのファイルの読み取り</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Visual Basic でのファイルへの書き込み</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">必須。 ファイル名を指定する <see langword="String" /> 型の式。 <paramref name="PathName" /> にはディレクトリまたはフォルダー、およびドライブを含めることができます。</param>
        <param name="Attributes">必須。 定数式または数式の合計がファイル属性を指定する場合の定数式または数式。</param>
        <summary>ファイルの属性情報を設定します。 <see langword="My" /> 機能を使用すると、<see langword="SetAttr" /> よりもファイル I/O 処理の生産性とパフォーマンスが向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 開いているファイルの属性を設定しようとする場合、実行時エラーが発生します。  
  
 `Attributes`列挙値の引数は次のようにします。  
  
|[値]|定数|説明|  
|-|-|-|  
|`Normal`|`vbNormal`|標準 (既定値)。|  
|`ReadOnly`|`vbReadOnly`|読み取り専用。|  
|`Hidden`|`vbHidden`|非表示。|  
|`System`|`vbSystem`|システム ファイル。|  
|`Volume`|`vbVolume`|ボリューム ラベル|  
|`Directory`|`vbDirectory`|ディレクトリまたはフォルダー。|  
|`Archive`|`vbArchive`|ファイルは前回のバックアップ以降に変更されています。|  
|`Alias`|`vbAlias`|ファイルに別の名前が付いています。|  
  
> [!NOTE]
>  これらの列挙体は Visual Basic 言語によって指定されています。 名前は、実際の値ではなく、コード内の任意の場所で使用できます。  
  
   
  
## Examples  
 この例では、`SetAttr`ファイルの属性を設定します。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> の型が無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">必須。 リストの次の式を表示または出力する前に挿入する空白の数。</param>
        <summary>
          <see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
        <returns>
          <see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`Count`が出力線の幅、次の出力位置にすぐに次の空白の数よりも少ない。 場合`Count`が出力の線の幅よりも大きい`SPC`数式を使用して、次の出力位置が計算されます。  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 たとえば、現在の出力位置が 24 の場合は、出力行の幅は 80、しを指定する`SPC(90)`、次の出力は 34 (現在の印刷位置 + 90/80 の残りの部分) の位置から開始します。 現在の出力位置と出力の線の幅の違いがある場合より小さい`Count`(または`Count` `Mod` *幅*)、`SPC`関数は、次の行の先頭にはスキップし、生成されます空白と等しく`Count`– (*幅*–*桁数*)。  
  
> [!NOTE]
>  ワイド文字のための十分な表の列があることを確認します。  
  
   
  
## Examples  
 この例では、`SPC`関数ファイルと出力の位置を**出力**ウィンドウ。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 演算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
        <returns>
          <see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の行に現在の出力位置がより大きいかどうか`Column`、`TAB`列の値と等しいにスキップ`Column`次の出力行にします。 場合`Column`が 1 より小さい、`TAB`印刷位置を 1 列目に移動します。 場合`Column`出力線の幅よりも大きい`TAB`数式を使用して、次の出力位置が計算されます。  
  
 Mod の列の幅  
  
 たとえば場合、*幅*80 は、指定した`TAB(90)`10 (残り 90/80 の) 列に、次の出力が開始されます。 場合`Column`が現在の出力の位置、計算の印刷位置にある次の行に印刷を開始未満です。 計算された出力位置が現在の印刷位置よりも大きい場合は、同じ行に位置が印刷計算された印刷を開始します。  
  
 出力行の左端の出力位置は 1 では常にです。 使用すると、`Print`または`PrintLine`ファイルは、印刷する機能右端からの出力位置が現在の幅を使用して設定できる出力ファイルの`FileWidth`関数。  
  
 `TAB`関数はでも使用できます、`WriteLine`関数。 は使用できません<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>または<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>します。  
  
> [!NOTE]
>  ワイド文字の十分な表の列があることを確認します。  
  
   
  
## Examples  
 この例では、`TAB`関数ファイルと出力の位置を**出力**ウィンドウ。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 演算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">任意。 リスト内の次の式を表示または出力する前に移動する先の列番号。 省略した場合、<see langword="TAB" /> は挿入位置を次の印字領域の最初に移動します。</param>
        <summary>
          <see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</summary>
        <returns>
          <see langword="Print" /> 関数または <see langword="PrintLine" /> 関数と共に使用し、出力の位置を移動させます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 現在の行に現在の出力位置がより大きいかどうか`Column`、`TAB`列の値と等しいにスキップ`Column`次の出力行にします。 場合`Column`が 1 より小さい、`TAB`印刷位置を 1 列目に移動します。 場合`Column`が出力の線の幅よりも大きい`TAB`数式を使用して、次の出力位置が計算されます。  
  
 Mod の列の幅  
  
 たとえば場合、*幅*80 は、指定した`TAB(90)`10 (残り 90/80 の) 列に、次の出力が開始されます。 場合`Column`が現在の出力の位置、計算の印刷位置にある次の行に印刷を開始未満です。 計算された出力位置が現在の印刷位置よりも大きい場合は、同じ行に位置が印刷計算された印刷を開始します。  
  
 出力行の左端の出力位置は 1 では常にです。 使用すると、`Print`または`PrintLine`ファイルは、印刷する機能右端からの出力位置が現在の幅を使用して設定できる出力ファイルの`FileWidth`関数。  
  
 `TAB`関数はでも使用できます、`WriteLine`関数。 は使用できません<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>または<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>します。  
  
> [!NOTE]
>  ワイド文字の十分な表の列があることを確認します。  
  
   
  
## Examples  
 この例では、`TAB`関数ファイルと出力の位置を**出力**ウィンドウ。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 演算子 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <summary>
          <see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数は環境で使用がいくつかのプロセスが同じファイルへのアクセスを必要があります。  
  
 `Lock` `Unlock`関数は常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`は省略すると、ロックはファイル全体でになります。 場合`Record`1 つのレコードはロック/ロック解除をするだけでを指定します。  
  
 シーケンシャル入力または出力ファイルが開かれている場合`Lock`と`Unlock`で指定された範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`します。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイル`Person`します。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="Record">任意。 ロックまたはアンロックされる唯一のレコードまたはバイトの番号。</param>
        <summary>
          <see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数は環境で使用がいくつかのプロセスが同じファイルへのアクセスを必要があります。  
  
 `Lock` `Unlock`関数は常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`は省略すると、ロックはファイル全体でになります。 場合`Record`1 つのレコードはロック/ロック解除をするだけでを指定します。  
  
 シーケンシャル入力または出力ファイルが開かれている場合`Lock`と`Unlock`で指定された範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`します。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイル`Person`します。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数。</param>
        <param name="FromRecord">任意。 ロックまたはアンロックされる最初のレコードまたはバイトの番号。</param>
        <param name="ToRecord">任意。 ロックまたはアンロックされる最後のレコードまたはバイトの番号。</param>
        <summary>
          <see langword="Open" /> 関数を使用して開かれたファイルの全部または一部に対して、他のプロセスからのアクセスを制御します。 <see langword="My" /> 機能を使用すると、<see langword="Lock" /> および <see langword="Unlock" /> を使用するよりもファイル I/O 処理の生産性とパフォーマンスが格段に向上します。 詳細については、「<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />」を参照してください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`と`Unlock`関数は環境で使用がいくつかのプロセスが同じファイルへのアクセスを必要があります。  
  
 `Lock` `Unlock`関数は常にペアで使用します。 引数を`Lock`と`Unlock`と同じである必要があります。  
  
 場合`Record`、または`FromRecord`と`ToRecord`は省略すると、ロックはファイル全体でになります。 場合`Record`1 つのレコードはロック/ロック解除をするだけでを指定します。  
  
 シーケンシャル入力または出力ファイルが開かれている場合`Lock`と`Unlock`で指定された範囲に関係なく、ファイル全体に影響を与える`FromRecord`と`ToRecord`します。  
  
   
  
## Examples  
 この例での使用、`Lock`と`Unlock`関数。 この例では、`People.txt`構造体のレコードを含むファイル`Person`します。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数を含む <see langword="Integer" /> 式。</param>
        <param name="Output">任意。 ファイルへ書き込む 1 個以上のコンマで区切られた式。</param>
        <summary>シーケンシャル ファイルにデータを書き込みます。 <see langword="Write" /> を使用して書き込まれたデータは通常、<see langword="Input" /> を使用してファイルから読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`と`WriteLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 省略した場合`Output`、空白行がファイルに出力します。 複数の式は、コンマで区切ってことができます。  
  
 異なり、`Print`関数の場合、`Write`関数は、ファイルに書き込まれる項目と文字列を囲む引用符の間にコンマを挿入します。 一覧に明示的な区切り記号を配置する必要はありません。 ときに`Write`ファイルにのみ数値データの書き込みに使用`Boolean`、日付、null の場合、および`Error`データ形式がサポートされています。 データが読み取ることができ、正しく解釈されません。 を使用して、次の前提が後に`Input`ロケールに関係なく、します。  
  
-   数値データには、小数点区切り文字としてピリオドを使用して常に書き込まれます。  
  
-   `Boolean`データか、`#TRUE#`または`#FALSE#`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。  
  
-   日付データは、汎用の日付形式を使用してファイルに書き込まれます。 日付または時刻部分のいずれかが不足している、または 0 の場合は、提供された部分のみが、ファイルに書き込まれます。  
  
-   場合、ファイルに何も書き込まれませんが`Output`データが空です。 ただし、null のデータの`#NULL#`が書き込まれます。  
  
-   `Error`として、データ、出力が表示されます`#ERROR errorcode#`します。 `Error`ロケールに関係なくキーワードはない変換します。  
  
 `WriteLine` 改行文字を挿入します (つまり、キャリッジ リターン/ライン フィード、または`Chr(13) + Chr(10)`) 最後の文字、記述後、`Output`ファイルにします。  
  
 二重引用符を使用して文字列に引用符を埋め込むことができます、または""です。 たとえば、オブジェクトに適用された  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 文字列の値を返します`Double quotation marks aren't "difficult" to handle`します。  
  
 使用して、ファイルへの書き込み、`Write`または`WriteLine`functions が必要です`Append`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Write`関数には生データをシーケンシャル ファイルに書き込めません。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">ファイル モードが無効です。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必須。 任意の有効なファイル数を含む <see langword="Integer" /> 式。</param>
        <param name="Output">任意。 ファイルへ書き込む 1 個以上のコンマで区切られた式。</param>
        <summary>シーケンシャル ファイルにデータを書き込みます。 <see langword="Write" /> を使用して書き込まれたデータは通常、<see langword="Input" /> を使用してファイルから読み込まれます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`と`WriteLine`関数は、旧バージョンとの互換性のために提供され、パフォーマンスに影響を与える可能性があります。 非レガシ アプリケーションの場合、`My.Computer.FileSystem`オブジェクトより優れたパフォーマンスを提供します。 詳細については、次を参照してください。 [Visual basic におけるファイル アクセス](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)します。  
  
 省略した場合`Output`、空白行がファイルに出力します。 複数の式は、コンマで区切ってことができます。  
  
 異なり、`Print`関数の場合、`Write`関数は、ファイルに書き込まれる項目と文字列を囲む引用符の間にコンマを挿入します。 一覧に明示的な区切り記号を配置する必要はありません。 ときに`Write`ファイルにのみ数値データの書き込みに使用`Boolean`、日付、null の場合、および`Error`データ形式がサポートされています。 データが読み取ることができ、正しく解釈されません。 を使用して、次の前提が後に`Input`ロケールに関係なく、します。  
  
-   数値データには、小数点区切り文字としてピリオドを使用して常に書き込まれます。  
  
-   `Boolean`データか、`#TRUE#`または`#FALSE#`が出力されます。 `True`と`False`キーワードは翻訳されません、ロケールに関係なく。  
  
-   日付データは、汎用の日付形式を使用してファイルに書き込まれます。 日付または時刻部分のいずれかが不足している、または 0 の場合は、提供された部分のみが、ファイルに書き込まれます。  
  
-   場合、ファイルに何も書き込まれませんが`Output`データが空です。 ただし、null のデータの`#NULL#`が書き込まれます。  
  
-   `Error`として、データ、出力が表示されます`#ERROR errorcode#`します。 `Error`ロケールに関係なくキーワードはない変換します。  
  
 `WriteLine` 改行文字を挿入します (つまり、キャリッジ リターン/ライン フィード、または`Chr(13) + Chr(10)`) 最後の文字、記述後、`Output`ファイルにします。  
  
 二重引用符を使用して文字列に引用符を埋め込むことができます、または""です。 たとえば、オブジェクトに適用された  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 文字列の値を返します`Double quotation marks aren't "difficult" to handle`します。  
  
 使用して、ファイルへの書き込み、`Write`または`WriteLine`functions が必要です`Append`からへのアクセス、`FileIOPermissionAccess`列挙体。 詳細については、「<xref:System.Security.Permissions.FileIOPermissionAccess>」を参照してください。  
  
   
  
## Examples  
 この例では、`Write`関数には生データをシーケンシャル ファイルに書き込めません。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Visual Basic におけるファイル アクセス</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">方法: ファイルにテキストを書き込む (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">方法: Streamwriter (Visual Basic) を持つファイルにテキストを書き込む</related>
      </Docs>
    </Member>
  </Members>
</Type>