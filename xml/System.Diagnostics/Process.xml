<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2f1e385dc8b74a1c8974753b9483fea0e44a13f1" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53300350" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="48f92-101">ローカル プロセスとリモート プロセスにアクセスできるようにして、ローカル システム プロセスの起動と中断ができるようにします。</span><span class="sxs-lookup"><span data-stu-id="48f92-101">Provides access to local and remote processes and enables you to start and stop local system processes.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-102">A<xref:System.Diagnostics.Process>コンポーネントがコンピューターで実行されているプロセスへのアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="48f92-102">A <xref:System.Diagnostics.Process> component provides access to a process that is running on a computer.</span></span> <span data-ttu-id="48f92-103">プロセスを簡単に言えば、実行中のアプリとは。</span><span class="sxs-lookup"><span data-stu-id="48f92-103">A process, in the simplest terms, is a running app.</span></span> <span data-ttu-id="48f92-104">スレッドは、オペレーティング システムをプロセッサ時間を割り当てる基本単位です。</span><span class="sxs-lookup"><span data-stu-id="48f92-104">A thread is the basic unit to which the operating system allocates processor time.</span></span> <span data-ttu-id="48f92-105">スレッドは、別のスレッドによって実行されている部分を含む、プロセスのコードの任意の部分を実行できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-105">A thread can execute any part of the code of the process, including parts currently being executed by another thread.</span></span>  
  
 <span data-ttu-id="48f92-106"><xref:System.Diagnostics.Process>コンポーネントは、開始、停止、制御、およびアプリを監視する便利なツールです。</span><span class="sxs-lookup"><span data-stu-id="48f92-106">The <xref:System.Diagnostics.Process> component is a useful tool for starting, stopping, controlling, and monitoring apps.</span></span> <span data-ttu-id="48f92-107">使用することができます、<xref:System.Diagnostics.Process>するか、実行されているプロセスの一覧を取得するためのコンポーネントは、新しいプロセスを開始できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-107">You can use the <xref:System.Diagnostics.Process> component, to obtain a list of the processes that are running, or you can start a new process.</span></span> <span data-ttu-id="48f92-108">A<xref:System.Diagnostics.Process>コンポーネント システム プロセスへのアクセスに使用されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-108">A <xref:System.Diagnostics.Process> component is used to access system processes.</span></span> <span data-ttu-id="48f92-109">後に、<xref:System.Diagnostics.Process>コンポーネントが初期化され、実行中のプロセスに関する情報を取得するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-109">After a <xref:System.Diagnostics.Process> component has been initialized, it can be used to obtain information about the running process.</span></span> <span data-ttu-id="48f92-110">このような情報が読み込まれたモジュール (.dll と .exe ファイル)、スレッドのセットが含まれていて、プロセス メモリの量などのパフォーマンス情報を使用しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-110">Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.</span></span>  
  
 <span data-ttu-id="48f92-111">この型は、<xref:System.IDisposable>インターフェイス。</span><span class="sxs-lookup"><span data-stu-id="48f92-111">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="48f92-112">型の使用が完了したら、直接的または間接的にそれを破棄する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-112">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="48f92-113">型の直接 dispose を呼び出してその<xref:System.IDisposable.Dispose%2A>メソッド、 `try` / `finally`ブロックします。</span><span class="sxs-lookup"><span data-stu-id="48f92-113">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`finally` block.</span></span> <span data-ttu-id="48f92-114">直接ことのない破棄する場合など、言語コンストラクトを使用して`using`(で C# の場合) または`Using`(Visual Basic) でします。</span><span class="sxs-lookup"><span data-stu-id="48f92-114">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="48f92-115">詳細については、"を使用して、オブジェクトを実装する IDisposable"のセクションを参照してください、<xref:System.IDisposable>インターフェイスに関するトピック。</span><span class="sxs-lookup"><span data-stu-id="48f92-115">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-116">32 ビット プロセスは、64 ビット プロセスのモジュールにアクセスできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-116">32-bit processes cannot access the modules of a 64-bit process.</span></span> <span data-ttu-id="48f92-117">32 ビット プロセスから 64 ビット プロセスの詳細情報を取得しようとする場合になります、<xref:System.ComponentModel.Win32Exception>例外。</span><span class="sxs-lookup"><span data-stu-id="48f92-117">If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref:System.ComponentModel.Win32Exception> exception.</span></span> <span data-ttu-id="48f92-118">その一方の 64 ビット プロセスで、32 ビット プロセスのモジュールにアクセスすることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-118">A 64-bit process, on the other hand, can access the modules of a 32-bit process.</span></span>  
  
 <span data-ttu-id="48f92-119">プロセスのコンポーネントでは、一度にすべてのプロパティのグループに関する情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-119">The process component obtains information about a group of properties all at once.</span></span> <span data-ttu-id="48f92-120">後に、<xref:System.Diagnostics.Process>コンポーネントがどのグループの 1 つのメンバーに関する情報を取得した、そのグループ内の他のプロパティの値をキャッシュし、グループの他のメンバーに関する新しい情報を取得できませんを呼び出すまで、<xref:System.Diagnostics.Process.Refresh%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-120">After the <xref:System.Diagnostics.Process> component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span> <span data-ttu-id="48f92-121">そのため、プロパティ値を最後の呼び出しよりも、新しいものを保証されません、<xref:System.Diagnostics.Process.Refresh%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-121">Therefore, a property value is not guaranteed to be any newer than the last call to the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span> <span data-ttu-id="48f92-122">グループの内訳は、オペレーティング システムに依存します。</span><span class="sxs-lookup"><span data-stu-id="48f92-122">The group breakdowns are operating-system dependent.</span></span>  
  
 <span data-ttu-id="48f92-123">引用符を使用して、システムで宣言されているパス変数があれば、その場所で見つかったすべてのプロセスを開始するときにそのパスを完全に修飾する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-123">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="48f92-124">それ以外の場合、システムでは、パスは検索されません。</span><span class="sxs-lookup"><span data-stu-id="48f92-124">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="48f92-125">たとえば場合、`c:\mypath`パスには引用符を使用してファイルを追加:`path = %path%;"c:\mypath"`の任意のプロセスを完全に修飾する必要があります`c:\mypath`開始するとき。</span><span class="sxs-lookup"><span data-stu-id="48f92-125">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
 <span data-ttu-id="48f92-126">システム プロセスは、プロセス識別子によって、システムで一意に識別します。</span><span class="sxs-lookup"><span data-stu-id="48f92-126">A system process is uniquely identified on the system by its process identifier.</span></span> <span data-ttu-id="48f92-127">多くの Windows リソースと同様に、プロセスは、そのハンドルは、コンピューター上で一意でない場合がありますで識別もされます。</span><span class="sxs-lookup"><span data-stu-id="48f92-127">Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer.</span></span> <span data-ttu-id="48f92-128">ハンドルは、リソースの識別子の総称です。</span><span class="sxs-lookup"><span data-stu-id="48f92-128">A handle is the generic term for an identifier of a resource.</span></span> <span data-ttu-id="48f92-129">オペレーティング システムを通じてアクセスされるプロセス ハンドルが引き続き発生する、<xref:System.Diagnostics.Process.Handle%2A>のプロパティ、<xref:System.Diagnostics.Process>プロセスが終了した場合でも、コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-129">The operating system persists the process handle, which is accessed through the <xref:System.Diagnostics.Process.Handle%2A> property of the <xref:System.Diagnostics.Process> component, even when the process has exited.</span></span> <span data-ttu-id="48f92-130">プロセスの管理についてなどを取得するために、 <xref:System.Diagnostics.Process.ExitCode%2A> (通常、いずれかの場合は 0 の成功または 0 以外のエラー コード) と<xref:System.Diagnostics.Process.ExitTime%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-130">Thus, you can get the process's administrative information, such as the <xref:System.Diagnostics.Process.ExitCode%2A> (usually either zero for success or a nonzero error code) and the <xref:System.Diagnostics.Process.ExitTime%2A>.</span></span> <span data-ttu-id="48f92-131">ハンドルは、メモリ リークが発生するよりも有害ハンドルのリークは非常に貴重なリソースでは、します。</span><span class="sxs-lookup"><span data-stu-id="48f92-131">Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-132">このクラスには、リンク確認要求し、すべてのメンバーに適用される、クラス レベルで継承確認要求が含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-132">This class contains a link demand and an inheritance demand at the class level that applies to all members.</span></span> <span data-ttu-id="48f92-133">A<xref:System.Security.SecurityException>直前の呼び出し元または派生クラスのいずれかに完全信頼アクセス許可があるない場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="48f92-133">A <xref:System.Security.SecurityException> is thrown when either the immediate caller or the derived class does not have full-trust permission.</span></span> <span data-ttu-id="48f92-134">セキュリティ要求の詳細については、次を参照してください。[リンク確認要求](~/docs/framework/misc/link-demands.md)します。</span><span class="sxs-lookup"><span data-stu-id="48f92-134">For details about security demands, see [Link Demands](~/docs/framework/misc/link-demands.md).</span></span>  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] <span data-ttu-id="48f92-135">ノート</span><span class="sxs-lookup"><span data-stu-id="48f92-135">Notes</span></span>  
 <span data-ttu-id="48f92-136">.NET Framework で、<xref:System.Diagnostics.Process>クラスは既定では<xref:System.Console>エンコーディングでは、通常はコード ページ エンコーディングは、入力、出力、およびエラー ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-136">In the .NET Framework, the <xref:System.Diagnostics.Process> class by default uses <xref:System.Console> encodings, which are typically code page encodings, for the input, output, and error streams.</span></span> <span data-ttu-id="48f92-137">コード例は、コード ページ 437 のカルチャが英語 (米国) システムの既定のエンコーディングは、<xref:System.Console>クラス。</span><span class="sxs-lookup"><span data-stu-id="48f92-137">For example code, on systems whose culture is English (United States), code page 437 is the default encoding for the <xref:System.Console> class.</span></span> <span data-ttu-id="48f92-138">ただし、[!INCLUDE[net_core](~/includes/net-core-md.md)]これらのエンコーディングの一部のサブセットのみを使用できるようにします。</span><span class="sxs-lookup"><span data-stu-id="48f92-138">However, [!INCLUDE[net_core](~/includes/net-core-md.md)] may make only a limited subset of these encodings available.</span></span> <span data-ttu-id="48f92-139">使用して、ケースの場合は、<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>として既定のエンコーディングします。</span><span class="sxs-lookup"><span data-stu-id="48f92-139">If this is the case, it uses <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> as the default encoding.</span></span>  
  
 <span data-ttu-id="48f92-140">場合、<xref:System.Diagnostics.Process>オブジェクトは、特定のコード ページ エンコーディングによって異なります、こともできるようにする、次の手順に従って*する前に*を呼び出す<xref:System.Diagnostics.Process>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-140">If a <xref:System.Diagnostics.Process> object depends on specific code page encodings, you can still make them available by doing the following *before* you call any <xref:System.Diagnostics.Process> methods:</span></span>  
  
1.  <span data-ttu-id="48f92-141">System.Text.Encoding.CodePages.dll アセンブリへの参照をプロジェクトに追加します。</span><span class="sxs-lookup"><span data-stu-id="48f92-141">Add a reference to the System.Text.Encoding.CodePages.dll assembly to your project.</span></span>  
  
2.  <span data-ttu-id="48f92-142">取得、<xref:System.Text.EncodingProvider>オブジェクトから、<xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-142">Retrieve the <xref:System.Text.EncodingProvider> object from the <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> property.</span></span>  
  
3.  <span data-ttu-id="48f92-143">渡す、<xref:System.Text.EncodingProvider>オブジェクトを<xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType>メソッドを使用可能なエンコーディング プロバイダーでサポートされているその他のエンコーディング。</span><span class="sxs-lookup"><span data-stu-id="48f92-143">Pass the <xref:System.Text.EncodingProvider> object to the <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> method to make the additional encodings supported by the encoding provider available.</span></span>  
  
 <span data-ttu-id="48f92-144"><xref:System.Diagnostics.Process>クラスから自動的が使用されます、UTF8 ではなく既定のシステム エンコードを呼び出す前に、エンコーディング プロバイダーを登録した<xref:System.Diagnostics.Process>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-144">The <xref:System.Diagnostics.Process> class will then automatically use the default system encoding rather than UTF8, provided that you have registered the encoding provider before calling any <xref:System.Diagnostics.Process> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-145">次の例のインスタンスを使用して、<xref:System.Diagnostics.Process>プロセスを開始するクラス。</span><span class="sxs-lookup"><span data-stu-id="48f92-145">The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 <span data-ttu-id="48f92-146">次の例では、<xref:System.Diagnostics.Process>クラス自体と静的な<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するメソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-146">The following example uses the <xref:System.Diagnostics.Process> class itself and a static <xref:System.Diagnostics.Process.Start%2A> method to start a process.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 <span data-ttu-id="48f92-147">次F#例、 `runProc` 、プロセスを開始する関数はすべての出力とエラー情報をキャプチャし、プロセスが実行時間をミリ秒単位の数を記録します。</span><span class="sxs-lookup"><span data-stu-id="48f92-147">The following F# example defines a `runProc` function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.</span></span>  <span data-ttu-id="48f92-148">`runProc`関数には、3 つのパラメーター: アプリケーションの起動、アプリケーション、および開始ディレクトリを指定する引数の名前。</span><span class="sxs-lookup"><span data-stu-id="48f92-148">The `runProc` function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory.</span></span>  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 <span data-ttu-id="48f92-149">コードを`runProc`によって関数が書き込まれた[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)下にあると、 [Microsoft Public License](https://opensource.org/licenses/ms-pl)します。</span><span class="sxs-lookup"><span data-stu-id="48f92-149">The code for the `runProc` function was written by [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) and is available under the [Microsoft Public License](https://opensource.org/licenses/ms-pl).</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-150">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-150">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-151">このクラスは、部分的に信頼されたコードでは使用できません。</span><span class="sxs-lookup"><span data-stu-id="48f92-151">This class cannot be used by partially trusted code.</span></span></permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="48f92-152">継承クラスの完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-152">for full trust for inheritors.</span></span> <span data-ttu-id="48f92-153">部分的に信頼されたコードでは、このクラスを継承できません。</span><span class="sxs-lookup"><span data-stu-id="48f92-153">This class cannot be inherited by partially trusted code.</span></span></permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef"><span data-ttu-id="48f92-154">.NET Process クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-154">Using the .NET Process Class</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-155"><see cref="T:System.Diagnostics.Process" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="48f92-155">Initializes a new instance of the <see cref="T:System.Diagnostics.Process" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-156">指定しない場合、<xref:System.Diagnostics.Process.MachineName%2A>プロパティ、既定値は、ローカル コンピューター (".")。</span><span class="sxs-lookup"><span data-stu-id="48f92-156">If you do not specify the <xref:System.Diagnostics.Process.MachineName%2A> property, the default is the local computer, (".").</span></span>  
  
 <span data-ttu-id="48f92-157">新しいに関連付けるための 2 つのオプションがある<xref:System.Diagnostics.Process>コンピューター上のプロセスとコンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-157">You have two options for associating a new <xref:System.Diagnostics.Process> component with a process on the computer.</span></span> <span data-ttu-id="48f92-158">最初のオプションが、コンス トラクターを使用して作成するには、<xref:System.Diagnostics.Process>コンポーネント、設定の適切なメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティと呼び出し<xref:System.Diagnostics.Process.Start%2A>に関連付ける、<xref:System.Diagnostics.Process>新しいシステム プロセスを。</span><span class="sxs-lookup"><span data-stu-id="48f92-158">The first option is to use the constructor to create the <xref:System.Diagnostics.Process> component, set the appropriate members of the <xref:System.Diagnostics.Process.StartInfo%2A> property and call <xref:System.Diagnostics.Process.Start%2A> to associate the <xref:System.Diagnostics.Process> with a new system process.</span></span> <span data-ttu-id="48f92-159">2 番目のオプションを関連付けるには、<xref:System.Diagnostics.Process>を使用して、実行中のシステム プロセスと<xref:System.Diagnostics.Process.GetProcessById%2A>またはのいずれか、<xref:System.Diagnostics.Process.GetProcesses%2A>値を返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-159">The second option is to associate the <xref:System.Diagnostics.Process> with a running system process by using <xref:System.Diagnostics.Process.GetProcessById%2A> or one of the <xref:System.Diagnostics.Process.GetProcesses%2A> return values.</span></span>  
  
 <span data-ttu-id="48f92-160">使用する場合、`static`のオーバー ロード、 <xref:System.Diagnostics.Process.Start%2A> 、メソッド、新規システム プロセスを開始する方法が新たに作成<xref:System.Diagnostics.Process>コンポーネント、プロセスに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-160">If you use a `static` overload of the <xref:System.Diagnostics.Process.Start%2A> method to start a new system process, the method creates a new <xref:System.Diagnostics.Process> component and associates it with the process.</span></span>  
  
 <span data-ttu-id="48f92-161">ときに、<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>プロパティがその既定値に設定`true`を使用して次のような方法でアプリケーションとドキュメントを開始することができます、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。</span><span class="sxs-lookup"><span data-stu-id="48f92-161">When the <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> property is set to its default value, `true`, you can start applications and documents in a way that is similar to using the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="48f92-162">ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>は`false`、実行可能ファイルだけを開始することができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-162">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> is `false`, you can start only executables.</span></span>  
  
 <span data-ttu-id="48f92-163">コマンドラインから呼び出すことができる実行可能ファイルは、2 つの方法のいずれかで開始できます: の適切なメンバーを設定して、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティと呼び出し、<xref:System.Diagnostics.Process.Start%2A>メソッドのパラメーターなしで、または適切なパラメーターを渡すことによって、`static` <xref:System.Diagnostics.Process.Start%2A>メンバー。</span><span class="sxs-lookup"><span data-stu-id="48f92-163">Any executable file that you can call from the command line can be started in one of two ways: by setting the appropriate members of the <xref:System.Diagnostics.Process.StartInfo%2A> property and calling the <xref:System.Diagnostics.Process.Start%2A> method with no parameters, or by passing the appropriate parameter to the `static`<xref:System.Diagnostics.Process.Start%2A> member.</span></span>  
  
 <span data-ttu-id="48f92-164">作成することができます、 <xref:System.Diagnostics.Process> 、静的なコンス トラクターを使用してコンポーネント<xref:System.Diagnostics.Process.Start%2A>のいずれかのオーバー ロード、または、 <xref:System.Diagnostics.Process.GetProcessById%2A>、 <xref:System.Diagnostics.Process.GetProcesses%2A>、または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-164">You can create a <xref:System.Diagnostics.Process> component by using the constructor, one of the static <xref:System.Diagnostics.Process.Start%2A> overloads, or any of the <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, or <xref:System.Diagnostics.Process.GetProcessesByName%2A> methods.</span></span> <span data-ttu-id="48f92-165">関連付けられたプロセスにビューがあるため、設定が終了します。</span><span class="sxs-lookup"><span data-stu-id="48f92-165">After you have done so, you have a view into the associated process.</span></span> <span data-ttu-id="48f92-166">これはメモリ内でプロセスのプロパティが変更されたときに自動的に更新される動的ビューではありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-166">This is not a dynamic view that updates itself automatically when the process properties have changed in memory.</span></span> <span data-ttu-id="48f92-167">代わりに、呼び出す必要がある<xref:System.Diagnostics.Process.Refresh%2A>コンポーネントを更新するため、<xref:System.Diagnostics.Process>アプリケーションでプロパティ情報。</span><span class="sxs-lookup"><span data-stu-id="48f92-167">Instead, you must call <xref:System.Diagnostics.Process.Refresh%2A> for the component to update the <xref:System.Diagnostics.Process> property information in your application.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-168">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-168">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-169">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-169">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-170">関連付けられたプロセスの基本優先順位を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-170">Gets the base priority of the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-171">関連付けられたプロセスの <see cref="P:System.Diagnostics.Process.PriorityClass" /> から算出される基本優先順位。</span><span class="sxs-lookup"><span data-stu-id="48f92-171">The base priority, which is computed from the <see cref="P:System.Diagnostics.Process.PriorityClass" /> of the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-172"><xref:System.Diagnostics.Process.BasePriority%2A>プロセスが関連付けられているプロセス内で作成されたスレッドを開始する優先度。</span><span class="sxs-lookup"><span data-stu-id="48f92-172">The <xref:System.Diagnostics.Process.BasePriority%2A> of the process is the starting priority for threads created within the associated process.</span></span> <span data-ttu-id="48f92-173">システム モニターの優先度ベース カウンター基本優先順位に関する情報を表示できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-173">You can view information about the base priority through the System Monitor's Priority Base counter.</span></span>  
  
 <span data-ttu-id="48f92-174">プロセスは、他のユーザーの前に配置するときに、経過時間、またはその他の要因、オペレーティング システムは基本優先順位を変更できます時間に基づいています。</span><span class="sxs-lookup"><span data-stu-id="48f92-174">Based on the time elapsed or other boosts, the operating system can change the base priority when a process should be placed ahead of others.</span></span>  
  
 <span data-ttu-id="48f92-175"><xref:System.Diagnostics.Process.BasePriority%2A>プロパティでは、プロセスに割り当てられている開始の優先順位を表示することができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-175">The <xref:System.Diagnostics.Process.BasePriority%2A> property lets you view the starting priority assigned to a process.</span></span> <span data-ttu-id="48f92-176">ただし、これは、読み取り専用であるために使用できません、<xref:System.Diagnostics.Process.BasePriority%2A>プロセスの優先順位を設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-176">However, because it is read-only, you cannot use the <xref:System.Diagnostics.Process.BasePriority%2A> to set the priority of the process.</span></span> <span data-ttu-id="48f92-177">優先順位を変更するには、使用、<xref:System.Diagnostics.Process.PriorityClass%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-177">To change the priority, use the <xref:System.Diagnostics.Process.PriorityClass%2A> property.</span></span> <span data-ttu-id="48f92-178"><xref:System.Diagnostics.Process.BasePriority%2A>表示できる中に、システム モニターを使用して、<xref:System.Diagnostics.Process.PriorityClass%2A>はありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-178">The <xref:System.Diagnostics.Process.BasePriority%2A> is viewable using the System Monitor, while the <xref:System.Diagnostics.Process.PriorityClass%2A> is not.</span></span> <span data-ttu-id="48f92-179">両方の<xref:System.Diagnostics.Process.BasePriority%2A>と<xref:System.Diagnostics.Process.PriorityClass%2A>プログラムから表示できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-179">Both the <xref:System.Diagnostics.Process.BasePriority%2A> and the <xref:System.Diagnostics.Process.PriorityClass%2A> can be viewed programmatically.</span></span> <span data-ttu-id="48f92-180">次の表は、関係<xref:System.Diagnostics.Process.BasePriority%2A>値と<xref:System.Diagnostics.Process.PriorityClass%2A>値。</span><span class="sxs-lookup"><span data-stu-id="48f92-180">The following table shows the relationship between <xref:System.Diagnostics.Process.BasePriority%2A> values and <xref:System.Diagnostics.Process.PriorityClass%2A> values.</span></span>  
  
|<span data-ttu-id="48f92-181">BasePriority</span><span class="sxs-lookup"><span data-stu-id="48f92-181">BasePriority</span></span>|<span data-ttu-id="48f92-182">PriorityClass</span><span class="sxs-lookup"><span data-stu-id="48f92-182">PriorityClass</span></span>|  
|------------------|-------------------|  
|<span data-ttu-id="48f92-183">4</span><span class="sxs-lookup"><span data-stu-id="48f92-183">4</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|<span data-ttu-id="48f92-184">8</span><span class="sxs-lookup"><span data-stu-id="48f92-184">8</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|<span data-ttu-id="48f92-185">13</span><span class="sxs-lookup"><span data-stu-id="48f92-185">13</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|<span data-ttu-id="48f92-186">24</span><span class="sxs-lookup"><span data-stu-id="48f92-186">24</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 <span data-ttu-id="48f92-187">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-187">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-188">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-188">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-189">例では、検出プロセスが終了し、プロセスの終了コードを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-189">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-190">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-190">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-191">プロセスが終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-191">The process has exited.</span></span>  
  
<span data-ttu-id="48f92-192">または</span><span class="sxs-lookup"><span data-stu-id="48f92-192">-or-</span></span> 
<span data-ttu-id="48f92-193">プロセスが開始されていないため、プロセス ID はありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-193">The process has not started, so there is no process ID.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-194">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-194">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-195">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-195">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-196">アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで、非同期読み取り操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-196">Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-197"><xref:System.Diagnostics.Process.StandardError%2A>同期または非同期でストリームを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-197">The <xref:System.Diagnostics.Process.StandardError%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="48f92-198">などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスのエラー出力ストリームでの同期読み取り操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-198">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the error output stream of the process.</span></span> <span data-ttu-id="48f92-199">関連付けられているまで操作を実行しないでこれらの同期読み取り<xref:System.Diagnostics.Process>を書き込みます、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはストリームを閉じます。</span><span class="sxs-lookup"><span data-stu-id="48f92-199">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardError%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="48f92-200">これに対し、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-200">In contrast, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="48f92-201">このメソッドは、ストリームの出力に指定されたイベント ハンドラーを有効し、すぐにストリーム出力するイベント ハンドラー中に、その他の作業を実行できる呼び出し元に返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-201">This method enables the designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="48f92-202">非同期の読み取り操作を実行する次の手順に従って<xref:System.Diagnostics.Process.StandardError%2A>の<xref:System.Diagnostics.Process>:</span><span class="sxs-lookup"><span data-stu-id="48f92-202">Follow these steps to perform asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A> for a <xref:System.Diagnostics.Process> :</span></span>  
  
1.  <span data-ttu-id="48f92-203"><xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> を `false` に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-203">Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</span></span>  
  
2.  <span data-ttu-id="48f92-204"><xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> を `true` に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-204">Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> to `true`.</span></span>  
  
3.  <span data-ttu-id="48f92-205">イベント ハンドラーを追加、<xref:System.Diagnostics.Process.ErrorDataReceived>イベント。</span><span class="sxs-lookup"><span data-stu-id="48f92-205">Add your event handler to the <xref:System.Diagnostics.Process.ErrorDataReceived> event.</span></span> <span data-ttu-id="48f92-206">イベント ハンドラーに一致する必要があります、<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>デリゲート シグネチャ。</span><span class="sxs-lookup"><span data-stu-id="48f92-206">The event handler must match the <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> delegate signature.</span></span>  
  
4.  <span data-ttu-id="48f92-207">開始、<xref:System.Diagnostics.Process>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-207">Start the <xref:System.Diagnostics.Process>.</span></span>  
  
5.  <span data-ttu-id="48f92-208">呼び出す<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>の<xref:System.Diagnostics.Process>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-208">Call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> for the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="48f92-209">この呼び出しで非同期読み取り操作を開始する<xref:System.Diagnostics.Process.StandardError%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-209">This call starts asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A>.</span></span>  
  
 <span data-ttu-id="48f92-210">たびに、関連付けられている非同期読み取り操作の開始、イベント ハンドラーが呼び出されたときに<xref:System.Diagnostics.Process>行のテキストを書き込み、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-210">When asynchronous read operations start, the event handler is called each time the associated <xref:System.Diagnostics.Process> writes a line of text to its <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="48f92-211">非同期の読み取り操作をキャンセルするには呼び出すことによって<xref:System.Diagnostics.Process.CancelErrorRead%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-211">You can cancel an asynchronous read operation by calling <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</span></span> <span data-ttu-id="48f92-212">呼び出し元によって、またはイベント ハンドラーによって、読み取り操作をキャンセルできます。</span><span class="sxs-lookup"><span data-stu-id="48f92-212">The read operation can be canceled by the caller or by the event handler.</span></span> <span data-ttu-id="48f92-213">キャンセル後に呼び出すことができます<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>非同期読み取り操作を再開します。</span><span class="sxs-lookup"><span data-stu-id="48f92-213">After canceling, you can call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> again to resume asynchronous read operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-214">リダイレクトされたストリームで読み取り操作を非同期と同期を混在させることはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-214">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="48f92-215">リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-215">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="48f92-216">例に従っていない<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>への呼び出しで<xref:System.IO.StreamReader.ReadLine%2A>上、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはその逆。</span><span class="sxs-lookup"><span data-stu-id="48f92-216">For example, do not follow <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardError%2A> stream, or vice versa.</span></span> <span data-ttu-id="48f92-217">ただし、異なるモードでの 2 つの異なるストリームを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-217">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="48f92-218">たとえば、呼び出す<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>を呼び出して<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-218">For example, you can call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-219">次の例では、`net view`コマンドをリモート コンピューターで使用可能なネットワーク リソースを一覧表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-219">The following example uses the `net view` command to list the available network resources on a remote computer.</span></span> <span data-ttu-id="48f92-220">ユーザーは、コマンドライン引数として対象のコンピューター名を提供します。</span><span class="sxs-lookup"><span data-stu-id="48f92-220">The user supplies the target computer name as a command-line argument.</span></span> <span data-ttu-id="48f92-221">ユーザーには、エラー出力のファイル名を指定もできます。</span><span class="sxs-lookup"><span data-stu-id="48f92-221">The user can also supply a file name for error output.</span></span> <span data-ttu-id="48f92-222">この例では、プロセスを完了して、出力がコンソールに結果の書き込みの待機、net コマンドの出力を収集します。</span><span class="sxs-lookup"><span data-stu-id="48f92-222">The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console.</span></span> <span data-ttu-id="48f92-223">ユーザーがオプションのエラー ファイルを指定する場合、例は、ファイルにエラーを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-223">If the user supplies the optional error file, the example writes errors to the file.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-224"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> プロパティが <see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-224">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is <see langword="false" />.</span></span>  
  
<span data-ttu-id="48f92-225">\- または</span><span class="sxs-lookup"><span data-stu-id="48f92-225">\- or -</span></span> 
<span data-ttu-id="48f92-226"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで非同期読み取り操作は既に実行されています。</span><span class="sxs-lookup"><span data-stu-id="48f92-226">An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</span></span>  
  
<span data-ttu-id="48f92-227">\- または</span><span class="sxs-lookup"><span data-stu-id="48f92-227">\- or -</span></span> 
<span data-ttu-id="48f92-228"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームは、同期読み取り操作によって使用されています。</span><span class="sxs-lookup"><span data-stu-id="48f92-228">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been used by a synchronous read operation.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-229">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-229">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-230">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-230">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-231">アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで、非同期読み取り操作を開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-231">Begins asynchronous read operations on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of the application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-232"><xref:System.Diagnostics.Process.StandardOutput%2A>同期または非同期でストリームを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-232">The <xref:System.Diagnostics.Process.StandardOutput%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="48f92-233">などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスの出力ストリームに同期の読み取り操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-233">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the output stream of the process.</span></span> <span data-ttu-id="48f92-234">関連付けられているまで操作を実行しないでこれらの同期読み取り<xref:System.Diagnostics.Process>を書き込みます、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはストリームを閉じます。</span><span class="sxs-lookup"><span data-stu-id="48f92-234">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="48f92-235">これに対し、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-235">In contrast, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="48f92-236">このメソッドは、ストリーム出力に指定されたイベント ハンドラーを有効にして、すぐにストリーム出力するイベント ハンドラー中に、その他の作業を実行できる呼び出し元に返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-236">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="48f92-237">非同期の読み取り操作を実行する次の手順に従って<xref:System.Diagnostics.Process.StandardOutput%2A>の<xref:System.Diagnostics.Process>:</span><span class="sxs-lookup"><span data-stu-id="48f92-237">Follow these steps to perform asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A> for a <xref:System.Diagnostics.Process> :</span></span>  
  
1.  <span data-ttu-id="48f92-238"><xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> を `false` に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-238">Set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> to `false`.</span></span>  
  
2.  <span data-ttu-id="48f92-239"><xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> を `true` に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-239">Set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> to `true`.</span></span>  
  
3.  <span data-ttu-id="48f92-240">イベント ハンドラーを追加、<xref:System.Diagnostics.Process.OutputDataReceived>イベント。</span><span class="sxs-lookup"><span data-stu-id="48f92-240">Add your event handler to the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="48f92-241">イベント ハンドラーに一致する必要があります、<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>デリゲート シグネチャ。</span><span class="sxs-lookup"><span data-stu-id="48f92-241">The event handler must match the <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> delegate signature.</span></span>  
  
4.  <span data-ttu-id="48f92-242">開始、<xref:System.Diagnostics.Process>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-242">Start the <xref:System.Diagnostics.Process>.</span></span>  
  
5.  <span data-ttu-id="48f92-243">呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>の<xref:System.Diagnostics.Process>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-243">Call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> for the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="48f92-244">この呼び出しで非同期読み取り操作を開始する<xref:System.Diagnostics.Process.StandardOutput%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-244">This call starts asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A>.</span></span>  
  
 <span data-ttu-id="48f92-245">たびに、関連付けられている非同期読み取り操作の開始、イベント ハンドラーが呼び出されたときに<xref:System.Diagnostics.Process>行のテキストを書き込み、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-245">When asynchronous read operations start, the event handler is called each time the associated <xref:System.Diagnostics.Process> writes a line of text to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="48f92-246">非同期の読み取り操作をキャンセルするには呼び出すことによって<xref:System.Diagnostics.Process.CancelOutputRead%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-246">You can cancel an asynchronous read operation by calling <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</span></span> <span data-ttu-id="48f92-247">呼び出し元によって、またはイベント ハンドラーによって、読み取り操作をキャンセルできます。</span><span class="sxs-lookup"><span data-stu-id="48f92-247">The read operation can be canceled by the caller or by the event handler.</span></span> <span data-ttu-id="48f92-248">キャンセル後に呼び出すことができます<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>非同期読み取り操作を再開します。</span><span class="sxs-lookup"><span data-stu-id="48f92-248">After canceling, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> again to resume asynchronous read operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-249">リダイレクトされたストリームで読み取り操作を非同期と同期を混在させることはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-249">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="48f92-250">リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-250">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="48f92-251">例に従っていない<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>への呼び出しで<xref:System.IO.StreamReader.ReadLine%2A>上、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはその逆。</span><span class="sxs-lookup"><span data-stu-id="48f92-251">For example, do not follow <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or vice versa.</span></span> <span data-ttu-id="48f92-252">ただし、異なるモードでの 2 つの異なるストリームを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-252">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="48f92-253">たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を呼び出して<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-253">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-254">次の例では、リダイレクトされたで非同期の読み取り操作を実行する方法を示しています。<xref:System.Diagnostics.Process.StandardOutput%2A>のストリーム、`sort`コマンド。</span><span class="sxs-lookup"><span data-stu-id="48f92-254">The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `sort` command.</span></span> <span data-ttu-id="48f92-255">`sort`コマンドは、コンソール アプリケーションを読み取り、テキスト入力を並べ替えます。</span><span class="sxs-lookup"><span data-stu-id="48f92-255">The `sort` command is a console application that reads and sorts text input.</span></span>  
  
 <span data-ttu-id="48f92-256">例でのイベントのデリゲートを作成、`SortOutputHandler`イベント ハンドラーを関連付けます、<xref:System.Diagnostics.Process.OutputDataReceived>イベント。</span><span class="sxs-lookup"><span data-stu-id="48f92-256">The example creates an event delegate for the `SortOutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="48f92-257">イベント ハンドラーがリダイレクトされたからテキスト行を受け取る<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、テキストを書式設定し、画面にテキストを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-257">The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and writes the text to the screen.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-258"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> プロパティが <see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-258">The <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> property is <see langword="false" />.</span></span>  
  
<span data-ttu-id="48f92-259">\- または</span><span class="sxs-lookup"><span data-stu-id="48f92-259">\- or -</span></span> 
<span data-ttu-id="48f92-260"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで非同期読み取り操作は既に実行されています。</span><span class="sxs-lookup"><span data-stu-id="48f92-260">An asynchronous read operation is already in progress on the <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</span></span>  
  
<span data-ttu-id="48f92-261">\- または</span><span class="sxs-lookup"><span data-stu-id="48f92-261">\- or -</span></span> 
<span data-ttu-id="48f92-262"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームは、同期読み取り操作によって使用されています。</span><span class="sxs-lookup"><span data-stu-id="48f92-262">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been used by a synchronous read operation.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-263">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-263">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-264">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-264">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-265">アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで、非同期読み取り操作をキャンセルします。</span><span class="sxs-lookup"><span data-stu-id="48f92-265">Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream of an application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-266"><xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 非同期読み取り操作を開始、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-266"><xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts an asynchronous read operation on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="48f92-267"><xref:System.Diagnostics.Process.CancelErrorRead%2A> 終了、非同期の読み取り操作。</span><span class="sxs-lookup"><span data-stu-id="48f92-267"><xref:System.Diagnostics.Process.CancelErrorRead%2A> ends the asynchronous read operation.</span></span>  
  
 <span data-ttu-id="48f92-268">キャンセル後に呼び出すことによって、非同期読み取り操作を再開できます<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>もう一度です。</span><span class="sxs-lookup"><span data-stu-id="48f92-268">After canceling, you can resume the asynchronous read operation by calling <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> again.</span></span>  
  
 <span data-ttu-id="48f92-269">呼び出すと<xref:System.Diagnostics.Process.CancelErrorRead%2A>、すべて進行中の読み取り操作の<xref:System.Diagnostics.Process.StandardError%2A>が完了し、イベント ハンドラーが無効になっています。</span><span class="sxs-lookup"><span data-stu-id="48f92-269">When you call <xref:System.Diagnostics.Process.CancelErrorRead%2A>, all in-progress read operations for <xref:System.Diagnostics.Process.StandardError%2A> are completed and then the event handler is disabled.</span></span> <span data-ttu-id="48f92-270">さらにリダイレクトされたすべての出力を<xref:System.Diagnostics.Process.StandardError%2A>バッファーに保存されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-270">All further redirected output to <xref:System.Diagnostics.Process.StandardError%2A> is saved in a buffer.</span></span> <span data-ttu-id="48f92-271">イベント ハンドラーへの呼び出しで再度有効にするかどうかは<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>、保存済みの出力は、イベント ハンドラーに送信し、非同期読み取り操作を再開します。</span><span class="sxs-lookup"><span data-stu-id="48f92-271">If you re-enable the event handler with a call to <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, the saved output is sent to the event handler and asynchronous read operations resume.</span></span> <span data-ttu-id="48f92-272">非同期の読み取り操作を再開する前に、イベント ハンドラーを変更する場合は、新しいイベント ハンドラーを追加する前に既存のイベント ハンドラーを削除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-272">If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:</span></span>  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  <span data-ttu-id="48f92-273">リダイレクトされた上および非同期の読み取り操作を混在させることはできません<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-273">You cannot mix asynchronous and synchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="48f92-274">リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-274">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="48f92-275">キャンセルした場合、非同期の読み取り操作で<xref:System.Diagnostics.Process.StandardError%2A>ストリームから読み取る、もう一度、使用する必要がありますし、必要がある<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>非同期読み取り操作を再開します。</span><span class="sxs-lookup"><span data-stu-id="48f92-275">If you cancel an asynchronous read operation on <xref:System.Diagnostics.Process.StandardError%2A> and then need to read from the stream again, you must use <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> to resume asynchronous read operations.</span></span> <span data-ttu-id="48f92-276">従っていない<xref:System.Diagnostics.Process.CancelErrorRead%2A>読み取りのメソッドを呼び出し、同期を<xref:System.Diagnostics.Process.StandardError%2A>など<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、または<xref:System.IO.StreamReader.ReadToEnd%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-276">Do not follow <xref:System.Diagnostics.Process.CancelErrorRead%2A> with a call to the synchronous read methods of <xref:System.Diagnostics.Process.StandardError%2A> such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, or <xref:System.IO.StreamReader.ReadToEnd%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-277">次の例では、開始、`nmake`コマンドでは、ユーザーが指定された引数。</span><span class="sxs-lookup"><span data-stu-id="48f92-277">The following example starts the `nmake` command with user supplied arguments.</span></span> <span data-ttu-id="48f92-278">エラーと出力ストリームが非同期的に読み取り収集されたテキスト行は、コンソールに表示されるだけでなくログ ファイルに書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="48f92-278">The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file.</span></span> <span data-ttu-id="48f92-279">コマンドの出力は、指定された行数を超えている場合は、非同期読み取り操作が取り消されました。</span><span class="sxs-lookup"><span data-stu-id="48f92-279">If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-280"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームは、非同期読み取り操作では有効になっていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-280">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream is not enabled for asynchronous read operations.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-281">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-281">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-282">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-282">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-283">アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで、非同期読み取り操作をキャンセルします。</span><span class="sxs-lookup"><span data-stu-id="48f92-283">Cancels the asynchronous read operation on the redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream of an application.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-284"><xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 非同期読み取り操作を開始、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-284"><xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts an asynchronous read operation on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="48f92-285"><xref:System.Diagnostics.Process.CancelOutputRead%2A> 終了、非同期の読み取り操作。</span><span class="sxs-lookup"><span data-stu-id="48f92-285"><xref:System.Diagnostics.Process.CancelOutputRead%2A> ends the asynchronous read operation.</span></span>  
  
 <span data-ttu-id="48f92-286">キャンセル後に呼び出すことによって、非同期読み取り操作を再開できます<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>もう一度です。</span><span class="sxs-lookup"><span data-stu-id="48f92-286">After canceling, you can resume asynchronous read operations by calling <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> again.</span></span>  
  
 <span data-ttu-id="48f92-287">呼び出すと<xref:System.Diagnostics.Process.CancelOutputRead%2A>、すべて進行中の読み取り操作の<xref:System.Diagnostics.Process.StandardOutput%2A>が完了し、イベント ハンドラーが無効になっています。</span><span class="sxs-lookup"><span data-stu-id="48f92-287">When you call <xref:System.Diagnostics.Process.CancelOutputRead%2A>, all in-progress read operations for <xref:System.Diagnostics.Process.StandardOutput%2A> are completed and then the event handler is disabled.</span></span> <span data-ttu-id="48f92-288">さらにリダイレクトされたすべての出力を<xref:System.Diagnostics.Process.StandardOutput%2A>バッファーに保存されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-288">All further redirected output to <xref:System.Diagnostics.Process.StandardOutput%2A> is saved in a buffer.</span></span> <span data-ttu-id="48f92-289">イベント ハンドラーへの呼び出しで再度有効にするかどうかは<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>、保存済みの出力は、イベント ハンドラーに送信し、非同期読み取り操作を再開します。</span><span class="sxs-lookup"><span data-stu-id="48f92-289">If you re-enable the event handler with a call to <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, the saved output is sent to the event handler and asynchronous read operations resume.</span></span> <span data-ttu-id="48f92-290">非同期の読み取り操作を再開する前に、イベント ハンドラーを変更する場合は、新しいイベント ハンドラーを追加する前に既存のイベント ハンドラーを削除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-290">If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler:</span></span>  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  <span data-ttu-id="48f92-291">リダイレクトされた上および非同期の読み取り操作を混在させることはできません<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-291">You cannot mix asynchronous and synchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="48f92-292">リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-292">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="48f92-293">キャンセルした場合、非同期の読み取り操作で<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームから読み取る、もう一度、使用する必要がありますし、必要がある<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>非同期読み取り操作を再開します。</span><span class="sxs-lookup"><span data-stu-id="48f92-293">If you cancel an asynchronous read operation on <xref:System.Diagnostics.Process.StandardOutput%2A> and then need to read from the stream again, you must use <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> to resume asynchronous read operations.</span></span> <span data-ttu-id="48f92-294">従っていない<xref:System.Diagnostics.Process.CancelOutputRead%2A>読み取りのメソッドを呼び出し、同期を<xref:System.Diagnostics.Process.StandardOutput%2A>など<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、または<xref:System.IO.StreamReader.ReadToEnd%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-294">Do not follow <xref:System.Diagnostics.Process.CancelOutputRead%2A> with a call to the synchronous read methods of <xref:System.Diagnostics.Process.StandardOutput%2A> such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, or <xref:System.IO.StreamReader.ReadToEnd%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-295">次の例では、開始、`nmake`コマンドでは、ユーザーが指定された引数。</span><span class="sxs-lookup"><span data-stu-id="48f92-295">The following example starts the `nmake` command with user supplied arguments.</span></span> <span data-ttu-id="48f92-296">エラーと出力ストリームが非同期的に読み取り収集されたテキスト行は、コンソールに表示されるだけでなくログ ファイルに書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="48f92-296">The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file.</span></span> <span data-ttu-id="48f92-297">コマンドの出力は、指定された行数を超えている場合は、非同期読み取り操作が取り消されました。</span><span class="sxs-lookup"><span data-stu-id="48f92-297">If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-298"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームは、非同期読み取り操作では有効になっていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-298">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream is not enabled for asynchronous read operations.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-299">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-299">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-300">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-300">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-301">このコンポーネントに関連付けられているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="48f92-301">Frees all the resources that are associated with this component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-302"><xref:System.Diagnostics.Process.Close%2A>メソッドにより、プロセスの終了が待機している場合、プロセスのハンドルを終了してプロセス固有のプロパティをクリアしますに待機を停止します。</span><span class="sxs-lookup"><span data-stu-id="48f92-302">The <xref:System.Diagnostics.Process.Close%2A> method causes the process to stop waiting for exit if it was waiting, closes the process handle, and clears process-specific properties.</span></span> <span data-ttu-id="48f92-303"><xref:System.Diagnostics.Process.Close%2A> 外部から参照されている場合に、標準の出力、入力、およびエラーのリーダーとライターを終了しません。</span><span class="sxs-lookup"><span data-stu-id="48f92-303"><xref:System.Diagnostics.Process.Close%2A> does not close the standard output, input, and error readers and writers in case they are being referenced externally.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-304"><xref:System.Diagnostics.Process.Dispose%2A> メソッドは <xref:System.Diagnostics.Process.Close%2A> を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="48f92-304">The <xref:System.Diagnostics.Process.Dispose%2A> method calls <xref:System.Diagnostics.Process.Close%2A>.</span></span> <span data-ttu-id="48f92-305">配置すること、<xref:System.Diagnostics.Process>オブジェクト、`using`ブロックを呼び出すことがなくリソースを破棄<xref:System.Diagnostics.Process.Close%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-305">Placing the <xref:System.Diagnostics.Process> object in a `using` block disposes of resources without the need to call <xref:System.Diagnostics.Process.Close%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-306">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-306">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-307">関連付けられたプロセスの物理メモリ使用量は 10 秒間に最大 2 秒間隔で取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-307">It then retrieves the physical memory usage of the associated process at 2-second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="48f92-308">この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。</span><span class="sxs-lookup"><span data-stu-id="48f92-308">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="48f92-309">例は、10 秒後に実行されている場合、プロセスを閉じます。</span><span class="sxs-lookup"><span data-stu-id="48f92-309">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-310">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-310">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-311">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-311">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-312">メイン ウィンドウにクローズ メッセージを送信して、ユーザー インターフェイスがあるプロセスを終了します。</span><span class="sxs-lookup"><span data-stu-id="48f92-312">Closes a process that has a user interface by sending a close message to its main window.</span></span></summary>
        <returns><span data-ttu-id="48f92-313">クローズ メッセージが正常に送信された場合は <see langword="true" />。関連付けられたプロセスにメイン ウィンドウがない場合、またはメイン ウィンドウが使用できない場合 (モーダル ダイアログ ボックスが表示されているときなど) は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-313"><see langword="true" /> if the close message was successfully sent; <see langword="false" /> if the associated process does not have a main window or if the main window is disabled (for example if a modal dialog is being shown).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-314">プロセスを実行しているときに、メッセージ ループは、待機状態です。</span><span class="sxs-lookup"><span data-stu-id="48f92-314">When a process is executing, its message loop is in a wait state.</span></span> <span data-ttu-id="48f92-315">オペレーティング システムが Windows メッセージがプロセスに送信されるたびにメッセージ ループを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-315">The message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="48f92-316">呼び出す<xref:System.Diagnostics.Process.CloseMainWindow%2A>メイン ウィンドウに、適切な形式でのアプリケーションでは、子ウィンドウを閉じ、アプリケーションの実行中のすべてのメッセージ ループでは失効の近くに要求を送信します。</span><span class="sxs-lookup"><span data-stu-id="48f92-316">Calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</span></span> <span data-ttu-id="48f92-317">呼び出すことによって、プロセスを終了する要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>アプリケーションの終了を強制しません。</span><span class="sxs-lookup"><span data-stu-id="48f92-317">The request to exit the process by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> does not force the application to quit.</span></span> <span data-ttu-id="48f92-318">アプリケーションは、終了する前にユーザー認証を求めることまたは拒否を終了することができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-318">The application can ask for user verification before quitting, or it can refuse to quit.</span></span> <span data-ttu-id="48f92-319">アプリケーションの終了を強制するには使用、<xref:System.Diagnostics.Process.Kill%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-319">To force the application to quit, use the <xref:System.Diagnostics.Process.Kill%2A> method.</span></span> <span data-ttu-id="48f92-320">動作<xref:System.Diagnostics.Process.CloseMainWindow%2A>システム メニューを使用して、アプリケーションのメイン ウィンドウを閉じると、ユーザーの場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="48f92-320">The behavior of <xref:System.Diagnostics.Process.CloseMainWindow%2A> is identical to that of a user closing an application's main window using the system menu.</span></span> <span data-ttu-id="48f92-321">そのため、メイン ウィンドウを閉じることでプロセスを終了する要求はすぐに終了するアプリケーションを強制しません。</span><span class="sxs-lookup"><span data-stu-id="48f92-321">Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</span></span>  
  
 <span data-ttu-id="48f92-322">プロセスによって編集されたデータまたはプロセスに割り当てられたリソースが失われる場合を呼び出す<xref:System.Diagnostics.Process.Kill%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-322">Data edited by the process or resources allocated to the process can be lost if you call <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="48f92-323"><xref:System.Diagnostics.Process.Kill%2A> により、プロセスが異常終了と必要な場合にのみ使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-323"><xref:System.Diagnostics.Process.Kill%2A> causes an abnormal process termination, and should be used only when necessary.</span></span> <span data-ttu-id="48f92-324"><xref:System.Diagnostics.Process.CloseMainWindow%2A> により、プロセスの手順の終了し、インターフェイスを使用するアプリケーションのことをお勧めしているために、すべての windows を閉じます。</span><span class="sxs-lookup"><span data-stu-id="48f92-324"><xref:System.Diagnostics.Process.CloseMainWindow%2A> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</span></span> <span data-ttu-id="48f92-325">場合<xref:System.Diagnostics.Process.CloseMainWindow%2A>使用することができますが失敗した<xref:System.Diagnostics.Process.Kill%2A>プロセスを終了します。</span><span class="sxs-lookup"><span data-stu-id="48f92-325">If <xref:System.Diagnostics.Process.CloseMainWindow%2A> fails, you can use <xref:System.Diagnostics.Process.Kill%2A> to terminate the process.</span></span> <span data-ttu-id="48f92-326"><xref:System.Diagnostics.Process.Kill%2A> グラフィカル インターフェイスがないプロセスを終了する唯一の方法です。</span><span class="sxs-lookup"><span data-stu-id="48f92-326"><xref:System.Diagnostics.Process.Kill%2A> is the only way to terminate processes that do not have graphical interfaces.</span></span>  
  
 <span data-ttu-id="48f92-327">呼び出すことができます<xref:System.Diagnostics.Process.Kill%2A>と<xref:System.Diagnostics.Process.CloseMainWindow%2A>ローカル コンピューターで実行されているプロセスに対してのみです。</span><span class="sxs-lookup"><span data-stu-id="48f92-327">You can call <xref:System.Diagnostics.Process.Kill%2A> and <xref:System.Diagnostics.Process.CloseMainWindow%2A> only for processes that are running on the local computer.</span></span> <span data-ttu-id="48f92-328">プロセスが終了するリモート コンピューターで発生することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-328">You cannot cause processes on remote computers to exit.</span></span> <span data-ttu-id="48f92-329">リモート コンピューター上で実行されているプロセスの情報のみ表示できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-329">You can only view information for processes running on remote computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-330">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-330">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-331">関連付けられたプロセスの物理メモリ使用量は 10 秒間に最大 2 秒間隔で取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-331">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="48f92-332">この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。</span><span class="sxs-lookup"><span data-stu-id="48f92-332">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="48f92-333">例は、10 秒後に実行されている場合、プロセスを閉じます。</span><span class="sxs-lookup"><span data-stu-id="48f92-333">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-334">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-334">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-335">プロセスは既に終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-335">The process has already exited.</span></span>  
  
<span data-ttu-id="48f92-336">または</span><span class="sxs-lookup"><span data-stu-id="48f92-336">-or-</span></span> 
<span data-ttu-id="48f92-337">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-337">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-338">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-338">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-339">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-339">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="48f92-340">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-340"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="48f92-341">このプロセスによって使用されているすべてのリソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="48f92-341">Release all resources used by this process.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-342">プロセスが終了したときに、<see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させるかどうかを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-342">Gets or sets whether the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the process terminates.</span></span></summary>
        <value><span data-ttu-id="48f92-343">正常終了または <see cref="M:System.Diagnostics.Process.Kill" /> の呼び出しによって関連付けられたプロセスが終了したときに <see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-343"><see langword="true" /> if the <see cref="E:System.Diagnostics.Process.Exited" /> event should be raised when the associated process is terminated (through either an exit or a call to <see cref="M:System.Diagnostics.Process.Kill" />); otherwise, <see langword="false" />.</span></span> <span data-ttu-id="48f92-344">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-344">The default is <see langword="false" />.</span></span> <span data-ttu-id="48f92-345">注意してください、<see cref="E:System.Diagnostics.Process.Exited" />イベントが発生した場合でもの値<see cref="P:System.Diagnostics.Process.EnableRaisingEvents" />は<see langword="false" />中に、プロセスの終了時に、またはユーザーが実行する前に、<see cref="P:System.Diagnostics.Process.HasExited" />を確認します。</span><span class="sxs-lookup"><span data-stu-id="48f92-345">Note that the <see cref="E:System.Diagnostics.Process.Exited" /> event is raised even if the value of <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> is <see langword="false" /> when the process exits during or before the user performs a <see cref="P:System.Diagnostics.Process.HasExited" /> check.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<span data-ttu-id="48f92-346"><xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティは、オペレーティング システムがプロセスをシャット ダウン時にコンポーネントを通知するかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-346">The <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property suggests whether the component should be notified when the operating system has shut down a process.</span></span> <span data-ttu-id="48f92-347"><xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティは、プロセスが終了しているアプリケーションに通知する非同期処理で使用されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-347">The <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property is used in asynchronous processing to notify your application that a process has exited.</span></span> <span data-ttu-id="48f92-348">(これは、終了イベントが発生するまでは、アプリケーションの処理を中断) 終了イベントを同期的に待機する、アプリケーションを強制するには、使用、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-348">To force your application to synchronously wait for an exit event (which interrupts processing of the application until the exit event has occurred), use the <xref:System.Diagnostics.Process.WaitForExit%2A> method.</span></span>

> [!NOTE]
> <span data-ttu-id="48f92-349">ダブルクリックして Visual Studio を使用して、<xref:System.Diagnostics.Process>プロジェクトで、コンポーネント、<xref:System.Diagnostics.Process.Exited>イベントのデリゲートとイベント ハンドラーが自動的に生成されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-349">If you're using Visual Studio and double-click a <xref:System.Diagnostics.Process> component in your project, an <xref:System.Diagnostics.Process.Exited> event delegate and event handler are automatically generated.</span></span> <span data-ttu-id="48f92-350">追加のコードのセット、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティを`false`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-350">Additional code sets the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property to `false`.</span></span> <span data-ttu-id="48f92-351">このプロパティを変更する必要があります`true`ときに実行するイベント ハンドラーの関連付けられたプロセスが終了します。</span><span class="sxs-lookup"><span data-stu-id="48f92-351">You must change this property to `true` for your event handler to execute when the associated process exits.</span></span>

<span data-ttu-id="48f92-352">場合、コンポーネントの<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>値は`true`、または<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>は`false`と<xref:System.Diagnostics.Process.HasExited%2A>チェックは、コンポーネントにより呼び出され、コンポーネントは、関連付けられたプロセスの管理情報にアクセスできますオペレーティング システムによって格納されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-352">If the component's <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> value is `true`, or when <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> is `false` and a <xref:System.Diagnostics.Process.HasExited%2A> check is invoked by the component, the component can access the administrative information for the associated process, which remains stored by the operating system.</span></span> <span data-ttu-id="48f92-353">このような情報が含まれています、 <xref:System.Diagnostics.Process.ExitTime%2A> 、<xref:System.Diagnostics.Process.ExitCode%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-353">Such information includes the <xref:System.Diagnostics.Process.ExitTime%2A> and the <xref:System.Diagnostics.Process.ExitCode%2A>.</span></span>

<span data-ttu-id="48f92-354">関連付けられたプロセスが終了した後、<xref:System.Diagnostics.Process.Handle%2A>のコンポーネントをポイントしない既存のプロセス リソース。</span><span class="sxs-lookup"><span data-stu-id="48f92-354">After the associated process exits, the <xref:System.Diagnostics.Process.Handle%2A> of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="48f92-355">代わりに、そのみ使用プロセス リソースについて、オペレーティング システムの情報にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="48f92-355">Instead, it can only be used to access the operating system's information about the process resource.</span></span> <span data-ttu-id="48f92-356">オペレーティング システムがによってリリースされていない終了のプロセスへのハンドルがあることに注意してください<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>メモリ内の情報。</span><span class="sxs-lookup"><span data-stu-id="48f92-356">The operating system is aware that there are handles to exited processes that haven't been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory.</span></span>

<span data-ttu-id="48f92-357">プロセスが終了するを監視に関連するコストがあります。</span><span class="sxs-lookup"><span data-stu-id="48f92-357">There's a cost associated with watching for a process to exit.</span></span> <span data-ttu-id="48f92-358">場合<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>は`true`、<xref:System.Diagnostics.Process.Exited>関連付けられたプロセスが終了するときにイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="48f92-358">If <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> is `true`, the <xref:System.Diagnostics.Process.Exited> event is raised when the associated process terminates.</span></span> <span data-ttu-id="48f92-359">手順、<xref:System.Diagnostics.Process.Exited>イベント時に実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-359">Your procedures for the <xref:System.Diagnostics.Process.Exited> event run at that time.</span></span>

<span data-ttu-id="48f92-360">場合によっては、アプリケーションはプロセスを開始しますが、クロージャの通知は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-360">Sometimes, your application starts a process but doesn't require notification of its closure.</span></span> <span data-ttu-id="48f92-361">たとえば、アプリケーションでは、テキストを編集がないことをメモ帳を使用するユーザーを許可するメモ帳を開始できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-361">For example, your application can start Notepad to allow the user to perform text editing but make no further use of the Notepad application.</span></span> <span data-ttu-id="48f92-362">関連するアプリケーションの継続的な操作ではないため、プロセスの終了時に通知を回避するために選択できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-362">You can choose to avoid notification when the process exits because it's not relevant to the continued operation of your application.</span></span> <span data-ttu-id="48f92-363">設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に`false`システム リソースを保存できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-363">Setting <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> to `false` can save system resources.</span></span>

## Examples  
<span data-ttu-id="48f92-364">次のコード例では、ファイルを出力するプロセスを作成します。</span><span class="sxs-lookup"><span data-stu-id="48f92-364">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="48f92-365">設定、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>させるプロセスをプロパティ、<xref:System.Diagnostics.Process.Exited>イベントが終了する場合。</span><span class="sxs-lookup"><span data-stu-id="48f92-365">It sets the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property to cause the process to raise the <xref:System.Diagnostics.Process.Exited> event when it exits.</span></span> <span data-ttu-id="48f92-366"><xref:System.Diagnostics.Process.Exited>イベント ハンドラーは、プロセス情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-366">The <xref:System.Diagnostics.Process.Exited> event handler displays process information.</span></span>

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-367">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-367">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-368">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-368">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-369">現在のスレッドのネイティブ プロパティ <see langword="SeDebugPrivilege" /> を有効にすることにより、<see cref="T:System.Diagnostics.Process" /> コンポーネントを、特殊なモードで実行されているオペレーティング システム プロセスと対話する状態にします。</span><span class="sxs-lookup"><span data-stu-id="48f92-369">Puts a <see cref="T:System.Diagnostics.Process" /> component in state to interact with operating system processes that run in a special mode by enabling the native property <see langword="SeDebugPrivilege" /> on the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-370">一部のオペレーティング システム プロセスは、特殊なモードで実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-370">Some operating system processes run in a special mode.</span></span> <span data-ttu-id="48f92-371">プロパティを読み取るか、これらのプロセスにアタッチしようとしています。 は、呼び出した<xref:System.Diagnostics.Process.EnterDebugMode%2A>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-371">Attempting to read properties of or attach to these processes is not possible unless you have called <xref:System.Diagnostics.Process.EnterDebugMode%2A> on the component.</span></span> <span data-ttu-id="48f92-372">呼び出す<xref:System.Diagnostics.Process.LeaveDebugMode%2A>特殊なモードで実行されているこれらのプロセスへのアクセスが不要です。</span><span class="sxs-lookup"><span data-stu-id="48f92-372">Call <xref:System.Diagnostics.Process.LeaveDebugMode%2A> when you no longer need access to these processes that run in special mode.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-373">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-373">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-374">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-374">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-375">アプリケーションがリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームに書き込む場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="48f92-375">Occurs when an application writes to its redirected <see cref="P:System.Diagnostics.Process.StandardError" /> stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-376"><xref:System.Diagnostics.Process.ErrorDataReceived>イベントは、リダイレクトされた関連付けられたプロセスによって書き込まれたことを示します<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-376">The <xref:System.Diagnostics.Process.ErrorDataReceived> event indicates that the associated process has written to its redirected <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="48f92-377">イベントがのみで非同期読み取り操作中に発生<xref:System.Diagnostics.Process.StandardError%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-377">The event only occurs during asynchronous read operations on <xref:System.Diagnostics.Process.StandardError%2A>.</span></span> <span data-ttu-id="48f92-378">非同期の読み取り操作を開始するには、リダイレクトする必要があります、<xref:System.Diagnostics.Process.StandardError%2A>のストリームを<xref:System.Diagnostics.Process>、イベント ハンドラーを追加、<xref:System.Diagnostics.Process.ErrorDataReceived>イベント、および呼び出し<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-378">To start asynchronous read operations, you must redirect the <xref:System.Diagnostics.Process.StandardError%2A> stream of a <xref:System.Diagnostics.Process>, add your event handler to the <xref:System.Diagnostics.Process.ErrorDataReceived> event, and call <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>.</span></span> <span data-ttu-id="48f92-379">その後、<xref:System.Diagnostics.Process.ErrorDataReceived>イベント シグナル プロセスでは、リダイレクトされたに行を書き込むたびに<xref:System.Diagnostics.Process.StandardError%2A>プロセスが終了するかを呼び出すまで、ストリーム<xref:System.Diagnostics.Process.CancelErrorRead%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-379">Thereafter, the <xref:System.Diagnostics.Process.ErrorDataReceived> event signals each time the process writes a line to the redirected <xref:System.Diagnostics.Process.StandardError%2A> stream, until the process exits or calls <xref:System.Diagnostics.Process.CancelErrorRead%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-380">非同期出力を処理するアプリケーションを呼び出す必要があります、<xref:System.Diagnostics.Process.WaitForExit>メソッドを出力バッファーがフラッシュされたことを確認します。</span><span class="sxs-lookup"><span data-stu-id="48f92-380">The application that is processing the asynchronous output should call the <xref:System.Diagnostics.Process.WaitForExit> method to ensure that the output buffer has been flushed.</span></span> <span data-ttu-id="48f92-381">使用してタイムアウトを指定することに注意してください、<xref:System.Diagnostics.Process.WaitForExit(System.Int32)>オーバー ロードは*いない*出力バッファーがフラッシュされたことを確認します。</span><span class="sxs-lookup"><span data-stu-id="48f92-381">Note that specifying a timeout by using the <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> overload does *not* ensure the output buffer has been flushed.</span></span>
  
   
  
## Examples  
 <span data-ttu-id="48f92-382">次の例では、`net view`コマンドをリモート コンピューターで使用可能なネットワーク リソースを一覧表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-382">The following example uses the `net view` command to list the available network resources on a remote computer.</span></span> <span data-ttu-id="48f92-383">ユーザーは、コマンドライン引数として対象のコンピューター名を提供します。</span><span class="sxs-lookup"><span data-stu-id="48f92-383">The user supplies the target computer name as a command-line argument.</span></span> <span data-ttu-id="48f92-384">ユーザーには、エラー出力のファイル名を指定もできます。</span><span class="sxs-lookup"><span data-stu-id="48f92-384">The user can also supply a file name for error output.</span></span> <span data-ttu-id="48f92-385">この例では、プロセスを完了して、出力がコンソールに結果の書き込みの待機、net コマンドの出力を収集します。</span><span class="sxs-lookup"><span data-stu-id="48f92-385">The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console.</span></span> <span data-ttu-id="48f92-386">ユーザーがオプションのエラー ファイルを指定する場合、例は、ファイルにエラーを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-386">If the user supplies the optional error file, the example writes errors to the file.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-387">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-387">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-388">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-388">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-389">関連付けられたプロセスが終了したときにプロセスによって指定された値を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-389">Gets the value that the associated process specified when it terminated.</span></span></summary>
        <value><span data-ttu-id="48f92-390">関連付けられたプロセスが終了したときにプロセスによって指定されたコード。</span><span class="sxs-lookup"><span data-stu-id="48f92-390">The code that the associated process specified when it terminated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-391">使用<xref:System.Diagnostics.Process.ExitCode%2A>が終了すると、システム プロセスが返されるステータスを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-391">Use <xref:System.Diagnostics.Process.ExitCode%2A> to get the status that the system process returned when it exited.</span></span> <span data-ttu-id="48f92-392">はるか整数からの値を返すように、終了コードを使用することができます、`main()`プロシージャ。</span><span class="sxs-lookup"><span data-stu-id="48f92-392">You can use the exit code much like an integer return value from a `main()` procedure.</span></span>  
  
 <span data-ttu-id="48f92-393"><xref:System.Diagnostics.Process.ExitCode%2A>値をプロセスには、そのプロセスのアプリケーション開発者によって実装される特定の規則が反映されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-393">The <xref:System.Diagnostics.Process.ExitCode%2A> value for a process reflects the specific convention implemented by the application developer for that process.</span></span> <span data-ttu-id="48f92-394">意思決定、コード内に終了コード値を使用する場合は、アプリケーション プロセスによって使用される終了コードの規則がわかっていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="48f92-394">If you use the exit code value to make decisions in your code, be sure that you know the exit code convention used by the application process.</span></span>  
  
 <span data-ttu-id="48f92-395">開発者は通常によって正常に終了を示す、<xref:System.Diagnostics.Process.ExitCode%2A>呼び出し元のメソッドは、通常とは異なるプロセスの終了の原因を識別するために使用できる値は 0 以外の場合、0、および指定のエラーの値。</span><span class="sxs-lookup"><span data-stu-id="48f92-395">Developers usually indicate a successful exit by an <xref:System.Diagnostics.Process.ExitCode%2A> value of zero, and designate errors by nonzero values that the calling method can use to identify the cause of an abnormal process termination.</span></span> <span data-ttu-id="48f92-396">これらのガイドラインに従う必要はありませんが、規則をします。</span><span class="sxs-lookup"><span data-stu-id="48f92-396">It is not necessary to follow these guidelines, but they are the convention.</span></span>  
  
 <span data-ttu-id="48f92-397">取得しようとする場合、<xref:System.Diagnostics.Process.ExitCode%2A>がプロセスの終了前に、試行は例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="48f92-397">If you try to get the <xref:System.Diagnostics.Process.ExitCode%2A> before the process has exited, the attempt throws an exception.</span></span> <span data-ttu-id="48f92-398">確認、<xref:System.Diagnostics.Process.HasExited%2A>関連付けられたプロセスが終了したかどうかを確認するには、最初のプロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-398">Examine the <xref:System.Diagnostics.Process.HasExited%2A> property first to verify whether the associated process has terminated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-399">標準出力は、非同期イベント ハンドラーにリダイレクトされましたがと、ことで出力の処理が完了していない場合に<xref:System.Diagnostics.Process.HasExited%2A>返します`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-399">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when <xref:System.Diagnostics.Process.HasExited%2A> returns `true`.</span></span> <span data-ttu-id="48f92-400">非同期イベント処理が完了したことを確認するを呼び出して、<xref:System.Diagnostics.Process.WaitForExit>をチェックする前にパラメーターを受け取らないオーバー ロード<xref:System.Diagnostics.Process.HasExited%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-400">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter before checking <xref:System.Diagnostics.Process.HasExited%2A>.</span></span>  
  
 <span data-ttu-id="48f92-401">使用することができます、<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>メソッドを呼び出すと、関連付けられているプロセスを終了します。</span><span class="sxs-lookup"><span data-stu-id="48f92-401">You can use the <xref:System.Diagnostics.Process.CloseMainWindow%2A> or the <xref:System.Diagnostics.Process.Kill%2A> method to cause an associated process to exit.</span></span>  
  
 <span data-ttu-id="48f92-402">関連付けられたプロセスが終了したときに通知する 2 つの方法がある: 同期的および非同期的にします。</span><span class="sxs-lookup"><span data-stu-id="48f92-402">There are two ways of being notified when the associated process exits: synchronously and asynchronously.</span></span> <span data-ttu-id="48f92-403">同期の通知は、呼び出し元に依存、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドに関連付けられているコンポーネントを終了するまで、アプリケーションの処理を一時停止します。</span><span class="sxs-lookup"><span data-stu-id="48f92-403">Synchronous notification relies on calling the <xref:System.Diagnostics.Process.WaitForExit%2A> method to pause the processing of your application until the associated component exits.</span></span> <span data-ttu-id="48f92-404">非同期の通知は、<xref:System.Diagnostics.Process.Exited>イベント。</span><span class="sxs-lookup"><span data-stu-id="48f92-404">Asynchronous notification relies on the <xref:System.Diagnostics.Process.Exited> event.</span></span> <span data-ttu-id="48f92-405">非同期の通知を使用する場合<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に設定する必要があります`true`の<xref:System.Diagnostics.Process>プロセスが終了したことを示す通知を受け取るコンポーネントです。</span><span class="sxs-lookup"><span data-stu-id="48f92-405">When using asynchronous notification, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> must be set to `true` for the <xref:System.Diagnostics.Process> component to receive notification that the process has exited.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-406">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-406">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-407">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-407">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-408">例では、検出プロセスが終了し、プロセスの終了コードを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-408">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-409">プロセスは終了していません。</span><span class="sxs-lookup"><span data-stu-id="48f92-409">The process has not exited.</span></span>  
  
<span data-ttu-id="48f92-410">または</span><span class="sxs-lookup"><span data-stu-id="48f92-410">-or-</span></span> 
<span data-ttu-id="48f92-411">プロセス <see cref="P:System.Diagnostics.Process.Handle" /> は終了していません。</span><span class="sxs-lookup"><span data-stu-id="48f92-411">The process <see cref="P:System.Diagnostics.Process.Handle" /> is not valid.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-412">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.ExitCode" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-412">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitCode" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-413">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-413">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-414">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-414">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-415">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-415">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-416">プロセスが終了したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="48f92-416">Occurs when a process exits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-417"><xref:System.Diagnostics.Process.Exited>イベントは、関連付けられたプロセスが終了していることを示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-417">The <xref:System.Diagnostics.Process.Exited> event indicates that the associated process exited.</span></span> <span data-ttu-id="48f92-418">この状況の発生を意味するか、プロセス終了 (中止) または正常に終了します。</span><span class="sxs-lookup"><span data-stu-id="48f92-418">This occurrence means either that the process terminated (aborted) or successfully closed.</span></span> <span data-ttu-id="48f92-419">場合にのみ、このイベントが発生する可能性がの値、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティは`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-419">This event can occur only if the value of the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property is `true`.</span></span>  
  
 <span data-ttu-id="48f92-420">関連付けられたプロセスが終了したときに通知する 2 つの方法がある: 同期的および非同期的にします。</span><span class="sxs-lookup"><span data-stu-id="48f92-420">There are two ways of being notified when the associated process exits: synchronously and asynchronously.</span></span> <span data-ttu-id="48f92-421">同期の通知呼び出し元の意味、<xref:System.Diagnostics.Process.WaitForExit%2A>プロセスを終了するまで、現在のスレッドをブロックするメソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-421">Synchronous notification means calling the <xref:System.Diagnostics.Process.WaitForExit%2A> method to block the current thread until the process exits.</span></span> <span data-ttu-id="48f92-422">非同期通知を使用して、<xref:System.Diagnostics.Process.Exited>イベントで、呼び出し元スレッドがその間に実行を続行することができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-422">Asynchronous notification uses the <xref:System.Diagnostics.Process.Exited> event, which allows the calling thread to continue execution in the meantime.</span></span> <span data-ttu-id="48f92-423">後者の場合、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に設定する必要があります`true`Exited イベントを受信する呼び出し元のアプリケーション。</span><span class="sxs-lookup"><span data-stu-id="48f92-423">In the latter case, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> must be set to `true` for the calling application to receive the Exited event.</span></span>  
  
 <span data-ttu-id="48f92-424">オペレーティング システムをシャット ダウン、プロセス、Exited イベントのハンドラーを登録している他のすべてのプロセスを通知します。</span><span class="sxs-lookup"><span data-stu-id="48f92-424">When the operating system shuts down a process, it notifies all other processes that have registered handlers for the Exited event.</span></span> <span data-ttu-id="48f92-425">この時点でだけが終了したプロセスのハンドルを使用してなど一部のプロパティにアクセスする<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.HasExited%2A>そのハンドルを完全に解放するまで、オペレーティング システムが維持されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-425">At this time, the handle of the process that just exited can be used to access some properties such as  <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.HasExited%2A> that the operating system maintains until it releases that handle completely.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-426">呼び出すことはできません、終了プロセスを識別するハンドルがある場合でも<xref:System.Diagnostics.Process.Start%2A>再接続するには、同じプロセスです。</span><span class="sxs-lookup"><span data-stu-id="48f92-426">Even if you have a handle to an exited process, you cannot call <xref:System.Diagnostics.Process.Start%2A> again to reconnect to the same process.</span></span> <span data-ttu-id="48f92-427">呼び出す<xref:System.Diagnostics.Process.Start%2A>自動的に関連付けられたプロセスを解放し、同じファイルが完全に新しいプロセスに接続<xref:System.Diagnostics.Process.Handle%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-427">Calling <xref:System.Diagnostics.Process.Start%2A> automatically releases the associated process and connects to a process with the same file but an entirely new <xref:System.Diagnostics.Process.Handle%2A>.</span></span>  
  
 <span data-ttu-id="48f92-428">使用の詳細については、 <xref:System.Diagnostics.Process.Exited> Windows フォーム アプリケーションでイベントを参照してください、<xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-428">For more information about the use of the <xref:System.Diagnostics.Process.Exited> event in Windows Forms applications, see the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-429">次のコード例では、ファイルを出力するプロセスを作成します。</span><span class="sxs-lookup"><span data-stu-id="48f92-429">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="48f92-430">生成、<xref:System.Diagnostics.Process.Exited>ため、プロセスが終了するときにイベントを<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロセスの作成時にプロパティが設定されました。</span><span class="sxs-lookup"><span data-stu-id="48f92-430">It raises the <xref:System.Diagnostics.Process.Exited> event when the process exits because the <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> property was set when the process was created.</span></span> <span data-ttu-id="48f92-431"><xref:System.Diagnostics.Process.Exited>イベント ハンドラーは、プロセス情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-431">The <xref:System.Diagnostics.Process.Exited> event handler displays process information.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-432">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-432">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-433">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-433">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-434">関連付けられたプロセスが終了した時刻を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-434">Gets the time that the associated process exited.</span></span></summary>
        <value><span data-ttu-id="48f92-435">関連付けられたプロセスが終了した時刻を示す <see cref="T:System.DateTime" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-435">A <see cref="T:System.DateTime" /> that indicates when the associated process was terminated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-436">取得するプロセスが終了していない場合にしようとしています、<xref:System.Diagnostics.Process.ExitTime%2A>プロパティは例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="48f92-436">If the process has not terminated, attempting to retrieve the <xref:System.Diagnostics.Process.ExitTime%2A> property throws an exception.</span></span> <span data-ttu-id="48f92-437">使用<xref:System.Diagnostics.Process.HasExited%2A>取得する前に、<xref:System.Diagnostics.Process.ExitTime%2A>プロパティに関連付けられたプロセスが終了したかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="48f92-437">Use <xref:System.Diagnostics.Process.HasExited%2A> before getting the <xref:System.Diagnostics.Process.ExitTime%2A> property to determine whether the associated process has terminated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-438">次のコード例では、ファイルを出力するプロセスを作成します。</span><span class="sxs-lookup"><span data-stu-id="48f92-438">The following code example creates a process that prints a file.</span></span> <span data-ttu-id="48f92-439">プロセスが発生、<xref:System.Diagnostics.Process.Exited>終了すると、イベントとイベント ハンドラーが表示されます、<xref:System.Diagnostics.Process.ExitTime%2A>プロパティおよびその他の情報を処理します。</span><span class="sxs-lookup"><span data-stu-id="48f92-439">The process raises the <xref:System.Diagnostics.Process.Exited> event when it exits, and the event handler displays the <xref:System.Diagnostics.Process.ExitTime%2A> property and other process information.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-440">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-440">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-441">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.ExitTime" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-441">You are trying to access the <see cref="P:System.Diagnostics.Process.ExitTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-442">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-442">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-443">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-443">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-444">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-444">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-445">新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを取得し、現在アクティブなプロセスに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-445">Gets a new <see cref="T:System.Diagnostics.Process" /> component and associates it with the currently active process.</span></span></summary>
        <returns><span data-ttu-id="48f92-446">呼び出し元のアプリケーションを実行しているプロセス リソースに関連付けられた新しい <see cref="T:System.Diagnostics.Process" /> コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-446">A new <see cref="T:System.Diagnostics.Process" /> component associated with the process resource that is running the calling application.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-447">このメソッドを使用して、新たに作成する<xref:System.Diagnostics.Process>をインスタンス化し、ローカル コンピューター上のプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-447">Use this method to create a new <xref:System.Diagnostics.Process> instance and associate it with the process resource on the local computer.</span></span>  
  
 <span data-ttu-id="48f92-448">などのような<xref:System.Diagnostics.Process.GetProcessById%2A>、 <xref:System.Diagnostics.Process.GetProcessesByName%2A>、および<xref:System.Diagnostics.Process.GetProcesses%2A>メソッド、<xref:System.Diagnostics.Process.GetCurrentProcess%2A>新しい、既存のリソースに関連付けます<xref:System.Diagnostics.Process>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-448">Like the similar <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, and <xref:System.Diagnostics.Process.GetProcesses%2A> methods, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associates an existing resource with a new <xref:System.Diagnostics.Process> component.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-449">次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-449">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="48f92-450">リモート コンピューター上と同じプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-450">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-451">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-451">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-452">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-452">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="48f92-453">新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成し、指定した既存のプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-453">Creates a new <see cref="T:System.Diagnostics.Process" /> component, and associates it with the existing process resource that you specify.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId"><span data-ttu-id="48f92-454">システムで一意なプロセス リソースの識別子。</span><span class="sxs-lookup"><span data-stu-id="48f92-454">The system-unique identifier of a process resource.</span></span></param>
        <summary><span data-ttu-id="48f92-455">ローカル コンピューター上のプロセス ID が指定された新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-455">Returns a new <see cref="T:System.Diagnostics.Process" /> component, given the identifier of a process on the local computer.</span></span></summary>
        <returns><span data-ttu-id="48f92-456"><paramref name="processId" /> パラメーターで識別されるローカル プロセス リソースに関連付けられた <see cref="T:System.Diagnostics.Process" /> コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-456">A <see cref="T:System.Diagnostics.Process" /> component that is associated with the local process resource identified by the <paramref name="processId" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-457">このメソッドを使用して、新たに作成する<xref:System.Diagnostics.Process>コンポーネントと、ローカル コンピューター上のプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-457">Use this method to create a new <xref:System.Diagnostics.Process> component and associate it with a process resource on the local computer.</span></span> <span data-ttu-id="48f92-458">プロセス リソースが既に存在して、コンピューターのため<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>、システム リソースでは作成されませんが、リソースに関連付けますではなくアプリケーションによって生成<xref:System.Diagnostics.Process>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-458">The process resource must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> does not create a system resource, but rather associates a resource with an application-generated <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="48f92-459">プロセス<xref:System.Diagnostics.Process.Id%2A>コンピューターで現在実行中のプロセスに対してのみ取得できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-459">A process <xref:System.Diagnostics.Process.Id%2A> can be retrieved only for a process that is currently running on the computer.</span></span> <span data-ttu-id="48f92-460">プロセスの終了後<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>期限切れの識別子を渡すと、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="48f92-460">After the process terminates, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> throws an exception if you pass it an expired identifier.</span></span>  
  
 <span data-ttu-id="48f92-461">特定のコンピューター上のプロセス id は一意です。</span><span class="sxs-lookup"><span data-stu-id="48f92-461">On any particular computer, the identifier of a process is unique.</span></span> <span data-ttu-id="48f92-462"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 最大で 1 つのプロセスを返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-462"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> returns one process at most.</span></span> <span data-ttu-id="48f92-463">使用して、特定のアプリケーションを実行しているすべてのプロセスを取得したい場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-463">If you want to get all the processes running a particular application, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</span></span> <span data-ttu-id="48f92-464">指定したアプリケーションを実行しているコンピューターに複数のプロセスが存在する場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>関連付けられているすべてのプロセスを含む配列を返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-464">If multiple processes exist on the computer running the specified application, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> returns an array containing all the associated processes.</span></span> <span data-ttu-id="48f92-465">各プロセスの識別子の順番を照会できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-465">You can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="48f92-466">プロセス識別子で表示できる、`Processes`パネルの Windows タスク マネージャー。</span><span class="sxs-lookup"><span data-stu-id="48f92-466">The process identifier can be viewed in the `Processes` panel of the Windows Task Manager.</span></span> <span data-ttu-id="48f92-467">`PID`列には、プロセスに割り当てられているプロセス id が表示されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-467">The `PID` column displays the process identifier that is assigned to a process.</span></span>  
  
 <span data-ttu-id="48f92-468">`processId`パラメーターは、 <xref:System.Int32> (32 ビット符号付き整数)、基になる Windows API を使用しますが、 `DWORD` (符号なし 32 ビット整数) と同様の api。</span><span class="sxs-lookup"><span data-stu-id="48f92-468">The `processId` parameter is an <xref:System.Int32> (a 32-bit signed integer), although the underlying Windows API uses a `DWORD` (an unsigned 32-bit integer) for similar APIs.</span></span> <span data-ttu-id="48f92-469">これは歴史的な理由からです。</span><span class="sxs-lookup"><span data-stu-id="48f92-469">This is for historical reasons.</span></span>
  
## Examples  
 <span data-ttu-id="48f92-470">次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-470">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="48f92-471">リモート コンピューター上と同じプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-471">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="48f92-472"><paramref name="processId" /> パラメーターで指定されたプロセスは実行されていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-472">The process specified by the <paramref name="processId" /> parameter is not running.</span></span> <span data-ttu-id="48f92-473">識別子の有効期限が切れている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-473">The identifier might be expired.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-474">このオブジェクトによってプロセスは開始されませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-474">The process was not started by this object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-475">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-475">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-476">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-476">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId"><span data-ttu-id="48f92-477">システムで一意なプロセス リソースの識別子。</span><span class="sxs-lookup"><span data-stu-id="48f92-477">The system-unique identifier of a process resource.</span></span></param>
        <param name="machineName"><span data-ttu-id="48f92-478">ネットワーク上のコンピューターの名前。</span><span class="sxs-lookup"><span data-stu-id="48f92-478">The name of a computer on the network.</span></span></param>
        <summary><span data-ttu-id="48f92-479">プロセス ID とネットワーク上のコンピューターの名前が指定された新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-479">Returns a new <see cref="T:System.Diagnostics.Process" /> component, given a process identifier and the name of a computer on the network.</span></span></summary>
        <returns><span data-ttu-id="48f92-480"><paramref name="processId" /> パラメーターで識別されるリモート プロセス リソースに関連付けられた <see cref="T:System.Diagnostics.Process" /> コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-480">A <see cref="T:System.Diagnostics.Process" /> component that is associated with a remote process resource identified by the <paramref name="processId" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-481">このメソッドを使用して、新たに作成する<xref:System.Diagnostics.Process>コンポーネントと、ネットワーク上のリモート コンピューター上のプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-481">Use this method to create a new <xref:System.Diagnostics.Process> component and associate it with a process resource on a remote computer on the network.</span></span> <span data-ttu-id="48f92-482">プロセス リソースが既に存在して、指定したコンピューターのため<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>、システム リソースでは作成されませんが、リソースに関連付けますではなくアプリケーションによって生成<xref:System.Diagnostics.Process>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-482">The process resource must already exist on the specified computer, because <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> does not create a system resource, but rather associates a resource with an application-generated <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="48f92-483">プロセス<xref:System.Diagnostics.Process.Id%2A>コンピューターで現在実行中のプロセスに対してのみ取得できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-483">A process <xref:System.Diagnostics.Process.Id%2A> can be retrieved only for a process that is currently running on the computer.</span></span> <span data-ttu-id="48f92-484">プロセスの終了後<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>期限切れの識別子を渡すと、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="48f92-484">After the process terminates, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> throws an exception if you pass it an expired identifier.</span></span>  
  
 <span data-ttu-id="48f92-485">特定のコンピューター上のプロセス id は一意です。</span><span class="sxs-lookup"><span data-stu-id="48f92-485">On any particular computer, the identifier of a process is unique.</span></span> <span data-ttu-id="48f92-486"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 最大で 1 つのプロセスを返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-486"><xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> returns one process at most.</span></span> <span data-ttu-id="48f92-487">使用して、特定のアプリケーションを実行しているすべてのプロセスを取得したい場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-487">If you want to get all the processes running a particular application, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>.</span></span> <span data-ttu-id="48f92-488">指定したアプリケーションを実行しているコンピューターに複数のプロセスが存在する場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>関連付けられているすべてのプロセスを含む配列を返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-488">If multiple processes exist on the computer running the specified application, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> returns an array containing all the associated processes.</span></span> <span data-ttu-id="48f92-489">各プロセスの識別子の順番を照会できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-489">You can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="48f92-490">プロセス識別子で表示できる、`Processes`パネルの Windows タスク マネージャー。</span><span class="sxs-lookup"><span data-stu-id="48f92-490">The process identifier can be viewed in the `Processes` panel of the Windows Task Manager.</span></span> <span data-ttu-id="48f92-491">`PID`列には、プロセスに割り当てられているプロセス id が表示されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-491">The `PID` column displays the process identifier that is assigned to a process.</span></span>  
  
 <span data-ttu-id="48f92-492">指定しない場合、 `machineName`、ローカル コンピューターが使用されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-492">If you do not specify a `machineName`, the local computer is used.</span></span> <span data-ttu-id="48f92-493">設定して、ローカル コンピューターを指定する代わりに、`machineName`値に"."または空の文字列 ("")。</span><span class="sxs-lookup"><span data-stu-id="48f92-493">Alternatively, you can specify the local computer by setting `machineName` to the value "." or to an empty string ("").</span></span>  
  
 <span data-ttu-id="48f92-494">`processId`パラメーターは、 <xref:System.Int32> (32 ビット符号付き整数)、基になる Windows API を使用しますが、 `DWORD` (符号なし 32 ビット整数) と同様の api。</span><span class="sxs-lookup"><span data-stu-id="48f92-494">The `processId` parameter is an <xref:System.Int32> (a 32-bit signed integer), although the underlying Windows API uses a `DWORD` (an unsigned 32-bit integer) for similar APIs.</span></span> <span data-ttu-id="48f92-495">これは歴史的な理由からです。</span><span class="sxs-lookup"><span data-stu-id="48f92-495">This is for historical reasons.</span></span>   
  
## Examples  
 <span data-ttu-id="48f92-496">次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-496">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="48f92-497">リモート コンピューター上と同じプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-497">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="48f92-498"><paramref name="processId" /> パラメーターで指定されたプロセスは実行されていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-498">The process specified by the <paramref name="processId" /> parameter is not running.</span></span> <span data-ttu-id="48f92-499">識別子の有効期限が切れている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-499">The identifier might be expired.</span></span>  
  
<span data-ttu-id="48f92-500">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-500">-or-</span></span> 
<span data-ttu-id="48f92-501"><paramref name="machineName" /> パラメーターの構文が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-501">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="48f92-502">名前の長さがゼロ (0) の可能性があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-502">The name might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="48f92-503"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-503">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-504">このオブジェクトによってプロセスは開始されませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-504">The process was not started by this object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-505">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-505">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-506">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-506">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="48f92-507">新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、既存のプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-507">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with existing process resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-508">ローカル コンピューター上の各プロセス リソースごとに新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成します。</span><span class="sxs-lookup"><span data-stu-id="48f92-508">Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the local computer.</span></span></summary>
        <returns><span data-ttu-id="48f92-509">ローカル コンピューター上で実行されているすべてのプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="48f92-509">An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the local computer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-510">このメソッドを使用して、新しいの配列を作成する<xref:System.Diagnostics.Process>コンポーネントし、ローカル コンピューター上のすべてのプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-510">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources on the local computer.</span></span> <span data-ttu-id="48f92-511">プロセス リソースが既に存在してローカル コンピューターでは、ため<xref:System.Diagnostics.Process.GetProcesses%2A>システム リソースは作成されませんが、リソースに関連付けますではなくアプリケーションによって生成される<xref:System.Diagnostics.Process>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-511">The process resources must already exist on the local computer, because <xref:System.Diagnostics.Process.GetProcesses%2A> does not create system resources but rather associates resources with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="48f92-512">オペレーティング システム自体でバック グラウンド プロセスが実行されているため、この配列は空ではありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-512">Because the operating system itself is running background processes, this array is never empty.</span></span>  
  
 <span data-ttu-id="48f92-513">使用してユーザー数を制限するには、コンピューターで実行中のプロセスをすべて取得しない場合、<xref:System.Diagnostics.Process.GetProcessById%2A>または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-513">If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref:System.Diagnostics.Process.GetProcessById%2A> or <xref:System.Diagnostics.Process.GetProcessesByName%2A> method.</span></span> <span data-ttu-id="48f92-514"><xref:System.Diagnostics.Process.GetProcessById%2A> 作成、<xref:System.Diagnostics.Process>システム上で、メソッドに渡すプロセス識別子によって識別プロセスに関連付けられているコンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-514"><xref:System.Diagnostics.Process.GetProcessById%2A> creates a <xref:System.Diagnostics.Process> component that is associated with the process identified on the system by the process identifier that you pass to the method.</span></span> <span data-ttu-id="48f92-515"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 配列を作成します<xref:System.Diagnostics.Process>メソッドに関連付けられているプロセス リソースを含む実行可能ファイルの共有コンポーネントを渡します。</span><span class="sxs-lookup"><span data-stu-id="48f92-515"><xref:System.Diagnostics.Process.GetProcessesByName%2A> creates an array of <xref:System.Diagnostics.Process> components whose associated process resources share the executable file you pass to the method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-516">複数の Windows サービス、サービス ホスト プロセス (svchost.exe) の同じインスタンス内で読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-516">Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</span></span> <span data-ttu-id="48f92-517">GetProcesses が個々 のサービスです。 これらを識別できません。そのため、次を参照してください。<xref:System.ServiceProcess.ServiceController.GetServices%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-517">GetProcesses does not identify those individual services; for that, see <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-518">次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-518">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="48f92-519">リモート コンピューター上と同じプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-519">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-520">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-520">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-521">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-521">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName"><span data-ttu-id="48f92-522">プロセスの一覧を読み取る対象のコンピューター。</span><span class="sxs-lookup"><span data-stu-id="48f92-522">The computer from which to read the list of processes.</span></span></param>
        <summary><span data-ttu-id="48f92-523">指定したコンピューター上の各プロセス リソースごとに新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成します。</span><span class="sxs-lookup"><span data-stu-id="48f92-523">Creates a new <see cref="T:System.Diagnostics.Process" /> component for each process resource on the specified computer.</span></span></summary>
        <returns><span data-ttu-id="48f92-524">指定したコンピューター上で実行されているすべてのプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="48f92-524">An array of type <see cref="T:System.Diagnostics.Process" /> that represents all the process resources running on the specified computer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-525">このメソッドを使用して、新しいの配列を作成する<xref:System.Diagnostics.Process>コンポーネントし (通常はリモート) の指定したコンピューター上のすべてのプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-525">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources on the specified (usually remote) computer.</span></span> <span data-ttu-id="48f92-526">プロセス リソースが既に存在してローカル コンピューターでは、ため<xref:System.Diagnostics.Process.GetProcesses%2A>システム リソースは作成されませんが、リソースに関連付けますではなくアプリケーションによって生成される<xref:System.Diagnostics.Process>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-526">The process resources must already exist on the local computer, because <xref:System.Diagnostics.Process.GetProcesses%2A> does not create system resources but rather associates resources with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="48f92-527">オペレーティング システム自体でバック グラウンド プロセスが実行されているため、この配列は空ではありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-527">Because the operating system itself is running background processes, this array is never empty.</span></span>  
  
 <span data-ttu-id="48f92-528">使用してユーザー数を制限するには、コンピューターで実行中のプロセスをすべて取得しない場合、<xref:System.Diagnostics.Process.GetProcessById%2A>または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-528">If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref:System.Diagnostics.Process.GetProcessById%2A> or <xref:System.Diagnostics.Process.GetProcessesByName%2A> method.</span></span> <span data-ttu-id="48f92-529"><xref:System.Diagnostics.Process.GetProcessById%2A> 作成、<xref:System.Diagnostics.Process>システム上で、メソッドに渡すプロセス識別子によって識別プロセスに関連付けられているコンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-529"><xref:System.Diagnostics.Process.GetProcessById%2A> creates a <xref:System.Diagnostics.Process> component that is associated with the process identified on the system by the process identifier that you pass to the method.</span></span> <span data-ttu-id="48f92-530"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 配列を作成します<xref:System.Diagnostics.Process>メソッドに関連付けられているプロセス リソースを含む実行可能ファイルの共有コンポーネントを渡します。</span><span class="sxs-lookup"><span data-stu-id="48f92-530"><xref:System.Diagnostics.Process.GetProcessesByName%2A> creates an array of <xref:System.Diagnostics.Process> components whose associated process resources share the executable file you pass to the method.</span></span>  
  
 <span data-ttu-id="48f92-531">このオーバー ロード、<xref:System.Diagnostics.Process.GetProcesses%2A>メソッドは、ネットワーク上のリモート コンピューターで実行されているプロセス リソースの一覧を取得する一般的に使用されますが、渡すことによって、ローカル コンピューターを指定することができます"."です。</span><span class="sxs-lookup"><span data-stu-id="48f92-531">This overload of the <xref:System.Diagnostics.Process.GetProcesses%2A> method is generally used to retrieve the list of process resources running on a remote computer on the network, but you can specify the local computer by passing ".".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-532">複数の Windows サービス、サービス ホスト プロセス (svchost.exe) の同じインスタンス内で読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-532">Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe).</span></span> <span data-ttu-id="48f92-533">GetProcesses が個々 のサービスです。 これらを識別できません。そのため、次を参照してください。<xref:System.ServiceProcess.ServiceController.GetServices%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-533">GetProcesses does not identify those individual services; for that, see <xref:System.ServiceProcess.ServiceController.GetServices%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-534">次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-534">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="48f92-535">リモート コンピューター上と同じプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-535">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="48f92-536"><paramref name="machineName" /> パラメーターの構文が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-536">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="48f92-537">長さがゼロ (0) の可能性があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-537">It might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="48f92-538"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-538">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-539">リモート コンピューターに対してこの操作を実行することは、オペレーティング システム プラットフォームでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-539">The operating system platform does not support this operation on remote computers.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-540">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-540">There are problems accessing the performance counter API's used to get process information.</span></span> <span data-ttu-id="48f92-541">この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</span><span class="sxs-lookup"><span data-stu-id="48f92-541">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-542">基になるシステム API にアクセスしようとして、問題が発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-542">A problem occurred accessing an underlying system API.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-543">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-543">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-544">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-544">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="48f92-545">新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有する既存のプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-545">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with the existing process resources that all share the specified process name.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName"><span data-ttu-id="48f92-546">プロセスのフレンドリ名。</span><span class="sxs-lookup"><span data-stu-id="48f92-546">The friendly name of the process.</span></span></param>
        <summary><span data-ttu-id="48f92-547">新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有するローカル コンピューター上のすべてのプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-547">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on the local computer that share the specified process name.</span></span></summary>
        <returns><span data-ttu-id="48f92-548">指定したアプリケーションまたはファイルを実行しているプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="48f92-548">An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-549">新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントとそれらをローカル コンピューターの同じ実行可能ファイルを実行しているすべてのプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-549">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources that are running the same executable file on the local computer.</span></span> <span data-ttu-id="48f92-550">プロセス リソースが既に存在してコンピューターのため、<xref:System.Diagnostics.Process.GetProcessesByName%2A>システム リソースは作成されませんが、代わりに関連付けますアプリケーションによって生成される<xref:System.Diagnostics.Process>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-550">The process resources must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessesByName%2A> does not create system resources but rather associates them with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="48f92-551">A`processName`が現在実行されていないローカル コンピューターでは、メソッドが返す配列を空にすることができますので、実行可能ファイルを指定できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-551">A `processName` can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</span></span>  
  
 <span data-ttu-id="48f92-552">プロセス名とは、プロセスは、.exe 拡張子またはパスが含まれていない、Outlook などのフレンドリ名です。</span><span class="sxs-lookup"><span data-stu-id="48f92-552">The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="48f92-553"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 取得して、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="48f92-553"><xref:System.Diagnostics.Process.GetProcessesByName%2A> is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span> <span data-ttu-id="48f92-554">たとえば、として、実行可能ファイル名を渡すことができます、`processName`その実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンするために、パラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-554">For example, you can pass an executable file name as the `processName` parameter, in order to shut down all the running instances of that executable file.</span></span>  
  
 <span data-ttu-id="48f92-555">プロセスが<xref:System.Diagnostics.Process.Id%2A>は、システム上の 1 つのプロセス リソースには一意で、ローカル コンピューター上の複数のプロセス実行できるで指定されたアプリケーション、`processName`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-555">Although a process <xref:System.Diagnostics.Process.Id%2A> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the `processName` parameter.</span></span> <span data-ttu-id="48f92-556">そのため、 <xref:System.Diagnostics.Process.GetProcessById%2A> 、最大で 1 つのプロセスを返しますが、<xref:System.Diagnostics.Process.GetProcessesByName%2A>関連付けられているすべてのプロセスを含む配列を返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-556">Therefore, <xref:System.Diagnostics.Process.GetProcessById%2A> returns one process at most, but <xref:System.Diagnostics.Process.GetProcessesByName%2A> returns an array containing all the associated processes.</span></span> <span data-ttu-id="48f92-557">標準 API 呼び出しを使用して、プロセスを操作する必要がある場合は、その識別子のさらに、これらのプロセスの各を照会できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-557">If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="48f92-558">プロセス名だけでは、配列を取得するとプロセス リソースにアクセスすることはできません<xref:System.Diagnostics.Process>関連付けられているコンポーネント、プロセス リソースに、最初を終了し、それ以外の場合、システム リソースを操作します。</span><span class="sxs-lookup"><span data-stu-id="48f92-558">You cannot access process resources through the process name alone but, once you have retrieved an array of <xref:System.Diagnostics.Process> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-559">次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-559">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="48f92-560">リモート コンピューター上と同じプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-560">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-561">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-561">There are problems accessing the performance counter API's used to get process information.</span></span> <span data-ttu-id="48f92-562">この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</span><span class="sxs-lookup"><span data-stu-id="48f92-562">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-563">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-563">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-564">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-564">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName"><span data-ttu-id="48f92-565">プロセスのフレンドリ名。</span><span class="sxs-lookup"><span data-stu-id="48f92-565">The friendly name of the process.</span></span></param>
        <param name="machineName"><span data-ttu-id="48f92-566">ネットワーク上のコンピューターの名前。</span><span class="sxs-lookup"><span data-stu-id="48f92-566">The name of a computer on the network.</span></span></param>
        <summary><span data-ttu-id="48f92-567">新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有するリモート コンピューター上のすべてのプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-567">Creates an array of new <see cref="T:System.Diagnostics.Process" /> components and associates them with all the process resources on a remote computer that share the specified process name.</span></span></summary>
        <returns><span data-ttu-id="48f92-568">指定したアプリケーションまたはファイルを実行しているプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="48f92-568">An array of type <see cref="T:System.Diagnostics.Process" /> that represents the process resources running the specified application or file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-569">新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントとそれらを指定したコンピューター上の同じ実行可能ファイルを実行しているすべてのプロセス リソースに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-569">Use this method to create an array of new <xref:System.Diagnostics.Process> components and associate them with all the process resources that are running the same executable file on the specified computer.</span></span> <span data-ttu-id="48f92-570">プロセス リソースが既に存在してコンピューターのため、<xref:System.Diagnostics.Process.GetProcessesByName%2A>システム リソースは作成されませんが、代わりに関連付けますアプリケーションによって生成される<xref:System.Diagnostics.Process>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-570">The process resources must already exist on the computer, because <xref:System.Diagnostics.Process.GetProcessesByName%2A> does not create system resources but rather associates them with application-generated <xref:System.Diagnostics.Process> components.</span></span> <span data-ttu-id="48f92-571">A`processName`が現在実行されていないローカル コンピューターでは、メソッドが返す配列を空にすることができますので、実行可能ファイルを指定できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-571">A `processName` can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</span></span>  
  
 <span data-ttu-id="48f92-572">プロセス名とは、プロセスは、.exe 拡張子またはパスが含まれていない、Outlook などのフレンドリ名です。</span><span class="sxs-lookup"><span data-stu-id="48f92-572">The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="48f92-573"><xref:System.Diagnostics.Process.GetProcessesByName%2A> 取得して、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="48f92-573"><xref:System.Diagnostics.Process.GetProcessesByName%2A> is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span> <span data-ttu-id="48f92-574">たとえば、として、実行可能ファイル名を渡すことができます、`processName`その実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンするために、パラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-574">For example, you can pass an executable file name as the `processName` parameter, in order to shut down all the running instances of that executable file.</span></span>  
  
 <span data-ttu-id="48f92-575">プロセスが<xref:System.Diagnostics.Process.Id%2A>は、システム上の 1 つのプロセス リソースには一意で、ローカル コンピューター上の複数のプロセス実行できるで指定されたアプリケーション、`processName`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-575">Although a process <xref:System.Diagnostics.Process.Id%2A> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the `processName` parameter.</span></span> <span data-ttu-id="48f92-576">そのため、 <xref:System.Diagnostics.Process.GetProcessById%2A> 、最大で 1 つのプロセスを返しますが、<xref:System.Diagnostics.Process.GetProcessesByName%2A>関連付けられているすべてのプロセスを含む配列を返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-576">Therefore, <xref:System.Diagnostics.Process.GetProcessById%2A> returns one process at most, but <xref:System.Diagnostics.Process.GetProcessesByName%2A> returns an array containing all the associated processes.</span></span> <span data-ttu-id="48f92-577">標準 API 呼び出しを使用して、プロセスを操作する必要がある場合は、その識別子のさらに、これらのプロセスの各を照会できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-577">If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier.</span></span> <span data-ttu-id="48f92-578">プロセス名だけでは、配列を取得するとプロセス リソースにアクセスすることはできません<xref:System.Diagnostics.Process>関連付けられているコンポーネント、プロセス リソースに、最初を終了し、それ以外の場合、システム リソースを操作します。</span><span class="sxs-lookup"><span data-stu-id="48f92-578">You cannot access process resources through the process name alone but, once you have retrieved an array of <xref:System.Diagnostics.Process> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</span></span>  
  
 <span data-ttu-id="48f92-579">このオーバー ロードを使用すると、ローカル コンピューターおよびリモート コンピューター上のプロセスを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-579">You can use this overload to get processes on the local computer as well as on a remote computer.</span></span> <span data-ttu-id="48f92-580">使用して"."ローカル コンピューターを指定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-580">Use "." to specify the local computer.</span></span> <span data-ttu-id="48f92-581">既定では、ローカル コンピューターを使用して別のオーバー ロードが存在します。</span><span class="sxs-lookup"><span data-stu-id="48f92-581">Another overload exists that uses the local computer by default.</span></span>  
  
 <span data-ttu-id="48f92-582">プロセスに関する統計情報などの情報を表示するのみのリモート コンピューター上のプロセスにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="48f92-582">You can access processes on remote computers only to view information, such as statistics, about the processes.</span></span> <span data-ttu-id="48f92-583">閉じる、終了することはできません (を使用して<xref:System.Diagnostics.Process.Kill%2A>)、またはリモート コンピューターでプロセスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-583">You cannot close, terminate (using <xref:System.Diagnostics.Process.Kill%2A>), or start processes on remote computers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-584">次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-584">The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer.</span></span> <span data-ttu-id="48f92-585">リモート コンピューター上と同じプロセスの情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-585">It then retrieves information for the same processes on a remote computer.</span></span>  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="48f92-586"><paramref name="machineName" /> パラメーターの構文が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-586">The <paramref name="machineName" /> parameter syntax is invalid.</span></span> <span data-ttu-id="48f92-587">長さがゼロ (0) の可能性があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-587">It might have length zero (0).</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="48f92-588"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-588">The <paramref name="machineName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-589">リモート コンピューターに対してこの操作を実行することは、オペレーティング システム プラットフォームでサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-589">The operating system platform does not support this operation on remote computers.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-590"><paramref name="machineName" /> に接続する試みが失敗しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-590">The attempt to connect to <paramref name="machineName" /> has failed.</span></span>

<span data-ttu-id="48f92-591">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-591">-or-</span></span> 
<span data-ttu-id="48f92-592">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-592">There are problems accessing the performance counter API's used to get process information.</span></span> <span data-ttu-id="48f92-593">この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</span><span class="sxs-lookup"><span data-stu-id="48f92-593">This exception is specific to Windows NT, Windows 2000, and Windows XP.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-594">基になるシステム API にアクセスしようとして、問題が発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-594">A problem occurred accessing an underlying system API.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-595">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-595">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-596">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-596">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="48f92-597">アンマネージ コードを呼び出す。</span><span class="sxs-lookup"><span data-stu-id="48f92-597">to call unmanaged code.</span></span> <span data-ttu-id="48f92-598">関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="48f92-598">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-599">関連付けられたプロセスのネイティブ ハンドルを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-599">Gets the native handle of the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-600">関連付けられたプロセスを起動したときに、オペレーティング システムがプロセスに割り当てたハンドル。</span><span class="sxs-lookup"><span data-stu-id="48f92-600">The handle that the operating system assigned to the associated process when the process was started.</span></span> <span data-ttu-id="48f92-601">システムはこのハンドルを使用して、プロセス属性の追跡を続けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-601">The system uses this handle to keep track of process attributes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-602">アプリケーションでは、多くのプロセス情報および制御関数のパラメーターとして使用できるプロセスを識別するハンドルを取得できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-602">An application can obtain a handle to a process that can be used as a parameter to many process-information and control functions.</span></span> <span data-ttu-id="48f92-603">このハンドルを使用するには初期化するために、<xref:System.Threading.WaitHandle>またはプラットフォームでネイティブ メソッドの呼び出しを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="48f92-603">You can use this handle to initialize a <xref:System.Threading.WaitHandle> or to call native methods with platform invoke.</span></span>  
  
 <span data-ttu-id="48f92-604">このプロセスのハンドルでは、アプリケーションごとに言い換えると、プロセスのハンドルを共有できないプライベートです。</span><span class="sxs-lookup"><span data-stu-id="48f92-604">This process handle is private to an application--in other words, process handles cannot be shared.</span></span> <span data-ttu-id="48f92-605">プロセスにも、プロセス<xref:System.Diagnostics.Process.Id%2A>これとは異なり、<xref:System.Diagnostics.Process.Handle%2A>が一意でと、そのため、システム全体で有効な。</span><span class="sxs-lookup"><span data-stu-id="48f92-605">A process also has a process <xref:System.Diagnostics.Process.Id%2A> which, unlike the <xref:System.Diagnostics.Process.Handle%2A>, is unique and, therefore, valid throughout the system.</span></span>  
  
 <span data-ttu-id="48f92-606">呼び出すことによって開始されるプロセスのみ<xref:System.Diagnostics.Process.Start%2A>設定、<xref:System.Diagnostics.Process.Handle%2A>プロパティの対応する<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-606">Only processes started through a call to <xref:System.Diagnostics.Process.Start%2A> set the <xref:System.Diagnostics.Process.Handle%2A> property of the corresponding <xref:System.Diagnostics.Process> instances.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-607">プロセスが開始されていないか、終了しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-607">The process has not been started or has exited.</span></span> <span data-ttu-id="48f92-608">この <see cref="T:System.Diagnostics.Process" /> インスタンスにプロセスが関連付けられていないので、<see cref="P:System.Diagnostics.Process.Handle" /> プロパティを読み取ることができません。</span><span class="sxs-lookup"><span data-stu-id="48f92-608">The <see cref="P:System.Diagnostics.Process.Handle" /> property cannot be read because there is no process associated with this <see cref="T:System.Diagnostics.Process" /> instance.</span></span>  
  
<span data-ttu-id="48f92-609">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-609">-or-</span></span> 
<span data-ttu-id="48f92-610"><see cref="T:System.Diagnostics.Process" /> インスタンスは実行中のプロセスにアタッチされていますが、フル アクセス権を持つハンドルを取得するために必要なアクセス許可がありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-610">The <see cref="T:System.Diagnostics.Process" /> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-611">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.Handle" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-611">You are trying to access the <see cref="P:System.Diagnostics.Process.Handle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-612">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-612">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-613">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-613">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-614">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-614">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-615">プロセスが開いたハンドルの数を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-615">Gets the number of handles opened by the process.</span></span></summary>
        <value><span data-ttu-id="48f92-616">プロセスが開いたオペレーティング システム ハンドルの数。</span><span class="sxs-lookup"><span data-stu-id="48f92-616">The number of operating system handles the process has opened.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-617">ハンドルは、プロセス オブジェクトを参照するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="48f92-617">Handles provide a way for a process to refer to objects.</span></span> <span data-ttu-id="48f92-618">プロセスでは、ファイル、リソース、メッセージ キュー、およびその他の多くのオペレーティング システム オブジェクトへのハンドルを取得できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-618">A process can obtain handles to files, resources, message queues, and many other operating system objects.</span></span> <span data-ttu-id="48f92-619">オペレーティング システム ハンドルの数が 0 の場合にのみ、プロセスに関連付けられているメモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="48f92-619">The operating system reclaims the memory associated with the process only when the handle count is zero.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-620">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-620">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-621">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-621">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-622">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-622">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-623">関連付けられているプロセスが終了したかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-623">Gets a value indicating whether the associated process has been terminated.</span></span></summary>
        <value><span data-ttu-id="48f92-624"><see cref="T:System.Diagnostics.Process" /> コンポーネントが参照するオペレーティング システム プロセスが終了している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-624"><see langword="true" /> if the operating system process referenced by the <see cref="T:System.Diagnostics.Process" /> component has terminated; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-625">値`true`の<xref:System.Diagnostics.Process.HasExited%2A>関連付けられたプロセスが終了して正常または異常のいずれかを示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-625">A value of `true` for <xref:System.Diagnostics.Process.HasExited%2A> indicates that the associated process has terminated, either normally or abnormally.</span></span> <span data-ttu-id="48f92-626">要求または関連付けられたプロセスを呼び出すことによって終了を強制できます<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-626">You can request or force the associated process to exit by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="48f92-627">ハンドルがプロセスに開いている場合は、オペレーティング システムは、プロセスが終了しましたが、ハンドル、終了コード、および終了時刻など、プロセスに関する管理情報を保持するときに、プロセス メモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="48f92-627">If a handle is open to the process, the operating system releases the process memory when the process has exited, but retains administrative information about the process, such as the handle, exit code, and exit time.</span></span> <span data-ttu-id="48f92-628">この情報を取得するには、使用することができます、<xref:System.Diagnostics.Process.ExitCode%2A>と<xref:System.Diagnostics.Process.ExitTime%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-628">To get this information, you can use the <xref:System.Diagnostics.Process.ExitCode%2A> and <xref:System.Diagnostics.Process.ExitTime%2A> properties.</span></span> <span data-ttu-id="48f92-629">これらのプロパティは、このコンポーネントによって起動されたプロセスを自動的に設定されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-629">These properties are populated automatically for processes that were started by this component.</span></span> <span data-ttu-id="48f92-630">管理情報がリリースされたときにすべて、<xref:System.Diagnostics.Process>システム プロセスに関連付けられているコンポーネントが破棄され、以上ないハンドルを終了したプロセスに保持します。</span><span class="sxs-lookup"><span data-stu-id="48f92-630">The administrative information is released when all the <xref:System.Diagnostics.Process> components that are associated with the system process are destroyed and hold no more handles to the exited process.</span></span>  
  
 <span data-ttu-id="48f92-631">コードとは無関係に、プロセスを終了できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-631">A process can terminate independently of your code.</span></span> <span data-ttu-id="48f92-632">このコンポーネントを使用して、プロセスを開始した場合の値が更新されます<xref:System.Diagnostics.Process.HasExited%2A>自動的に関連付けられたプロセスが個別に終了した場合でもです。</span><span class="sxs-lookup"><span data-stu-id="48f92-632">If you started the process using this component, the system updates the value of <xref:System.Diagnostics.Process.HasExited%2A> automatically, even if the associated process exits independently.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-633">標準出力は、非同期イベント ハンドラーにリダイレクトされましたが、ときにこのプロパティが返されるときにでは出力の処理が完了していないことは`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-633">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this property returns `true`.</span></span> <span data-ttu-id="48f92-634">非同期イベント処理が完了したことを確認するを呼び出して、<xref:System.Diagnostics.Process.WaitForExit>をチェックする前にパラメーターを受け取らないオーバー ロード<xref:System.Diagnostics.Process.HasExited%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-634">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter before checking <xref:System.Diagnostics.Process.HasExited%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-635">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-635">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-636">関連付けられたプロセスの物理メモリ使用量は 10 秒間に最大 2 秒間隔で取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-636">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="48f92-637">この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。</span><span class="sxs-lookup"><span data-stu-id="48f92-637">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="48f92-638">例は、10 秒後に実行されている場合、プロセスを閉じます。</span><span class="sxs-lookup"><span data-stu-id="48f92-638">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-639">オブジェクトに関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-639">There is no process associated with the object.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-640">プロセスの終了コードを取得できませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-640">The exit code for the process could not be retrieved.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-641">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.HasExited" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-641">You are trying to access the <see cref="P:System.Diagnostics.Process.HasExited" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-642">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-642">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-643">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-643">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-644">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-644">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-645">関連付けられたプロセスの一意の識別子を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-645">Gets the unique identifier for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-646">この <see cref="T:System.Diagnostics.Process" /> インスタンスが参照する、システムが生成したプロセスの一意の識別子。</span><span class="sxs-lookup"><span data-stu-id="48f92-646">The system-generated unique identifier of the process that is referenced by this <see cref="T:System.Diagnostics.Process" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-647">プロセス<xref:System.Diagnostics.Process.Id%2A>が関連付けられたプロセスが実行されていない場合は無効です。</span><span class="sxs-lookup"><span data-stu-id="48f92-647">The process <xref:System.Diagnostics.Process.Id%2A> is not valid if the associated process is not running.</span></span> <span data-ttu-id="48f92-648">取得を試みる前に、プロセスが実行されていることを確認する必要があります、そのため、<xref:System.Diagnostics.Process.Id%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-648">Therefore, you should ensure that the process is running before attempting to retrieve the <xref:System.Diagnostics.Process.Id%2A> property.</span></span> <span data-ttu-id="48f92-649">プロセスが終了するまでプロセス識別子は、システム全体でプロセスを一意に識別します。</span><span class="sxs-lookup"><span data-stu-id="48f92-649">Until the process terminates, the process identifier uniquely identifies the process throughout the system.</span></span>  
  
 <span data-ttu-id="48f92-650">新しいローカルまたはリモート コンピューターで実行されているプロセスを接続する<xref:System.Diagnostics.Process>インスタンスにプロセス id を渡すことによって、<xref:System.Diagnostics.Process.GetProcessById%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-650">You can connect a process that is running on a local or remote computer to a new <xref:System.Diagnostics.Process> instance by passing the process identifier to the <xref:System.Diagnostics.Process.GetProcessById%2A> method.</span></span> <span data-ttu-id="48f92-651"><xref:System.Diagnostics.Process.GetProcessById%2A> `static`新しいコンポーネントを作成するメソッドを設定し、<xref:System.Diagnostics.Process.Id%2A>新しいプロパティ<xref:System.Diagnostics.Process>インスタンスによって自動的に。</span><span class="sxs-lookup"><span data-stu-id="48f92-651"><xref:System.Diagnostics.Process.GetProcessById%2A> is a `static` method that creates a new component and sets the <xref:System.Diagnostics.Process.Id%2A> property for the new <xref:System.Diagnostics.Process> instance automatically.</span></span>  
  
 <span data-ttu-id="48f92-652">プロセス id は、システムによって再利用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-652">Process identifiers can be reused by the system.</span></span> <span data-ttu-id="48f92-653"><xref:System.Diagnostics.Process.Id%2A>プロパティの値が、関連付けられたプロセスが実行中にのみ一意です。</span><span class="sxs-lookup"><span data-stu-id="48f92-653">The <xref:System.Diagnostics.Process.Id%2A> property value is unique only while the associated process is running.</span></span> <span data-ttu-id="48f92-654">システム プロセスが終了し、再利用できる、<xref:System.Diagnostics.Process.Id%2A>関連のないプロセスのプロパティの値。</span><span class="sxs-lookup"><span data-stu-id="48f92-654">After the process has terminated, the system can reuse the <xref:System.Diagnostics.Process.Id%2A> property value for an unrelated process.</span></span>  
  
 <span data-ttu-id="48f92-655">識別子は、システム上で一意であるために渡すことができる他のスレッドに渡すことの代替として、<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-655">Because the identifier is unique on the system, you can pass it to other threads as an alternative to passing a <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="48f92-656">このアクションは、システム リソースを節約まだプロセスが正しく認識されていることを保証します。</span><span class="sxs-lookup"><span data-stu-id="48f92-656">This action can save system resources yet guarantee that the process is correctly identified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-657">次の例では、取得する方法、<xref:System.Diagnostics.Process.Id%2A>すべてのアプリケーションのインスタンスを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-657">The following example demonstrates how to obtain the <xref:System.Diagnostics.Process.Id%2A> for all running instances of an application.</span></span> <span data-ttu-id="48f92-658">コードのメモ帳の新しいインスタンスを作成、メモ帳のすべてのインスタンスが一覧表示し、ユーザーを入力できるように、<xref:System.Diagnostics.Process.Id%2A>数を特定のインスタンスを削除します。</span><span class="sxs-lookup"><span data-stu-id="48f92-658">The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the <xref:System.Diagnostics.Process.Id%2A> number to remove a specific instance.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-659">プロセスの <see cref="P:System.Diagnostics.Process.Id" /> プロパティが設定されていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-659">The process's <see cref="P:System.Diagnostics.Process.Id" /> property has not been set.</span></span>  
  
<span data-ttu-id="48f92-660">または</span><span class="sxs-lookup"><span data-stu-id="48f92-660">-or-</span></span> 
<span data-ttu-id="48f92-661">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-661">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-662">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-662">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-663">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-663">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-664">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-664">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-665">関連付けられたプロセスを即時中断します。</span><span class="sxs-lookup"><span data-stu-id="48f92-665">Immediately stops the associated process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-666"><xref:System.Diagnostics.Process.Kill%2A> 強制的に、終了、プロセスの中に<xref:System.Diagnostics.Process.CloseMainWindow%2A>のみ終了を要求します。</span><span class="sxs-lookup"><span data-stu-id="48f92-666"><xref:System.Diagnostics.Process.Kill%2A> forces a termination of the process, while <xref:System.Diagnostics.Process.CloseMainWindow%2A> only requests a termination.</span></span> <span data-ttu-id="48f92-667">グラフィカル インターフェイスを持つプロセスを実行しているときに、メッセージ ループは、待機状態です。</span><span class="sxs-lookup"><span data-stu-id="48f92-667">When a process with a graphical interface is executing, its message loop is in a wait state.</span></span> <span data-ttu-id="48f92-668">オペレーティング システムが Windows メッセージがプロセスに送信されるたびにメッセージ ループを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-668">The message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="48f92-669">呼び出す<xref:System.Diagnostics.Process.CloseMainWindow%2A>メイン ウィンドウに、適切な形式でのアプリケーションでは、子ウィンドウを閉じ、アプリケーションの実行中のすべてのメッセージ ループでは失効の近くに要求を送信します。</span><span class="sxs-lookup"><span data-stu-id="48f92-669">Calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application.</span></span> <span data-ttu-id="48f92-670">呼び出すことによって、プロセスを終了する要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>アプリケーションの終了を強制しません。</span><span class="sxs-lookup"><span data-stu-id="48f92-670">The request to exit the process by calling <xref:System.Diagnostics.Process.CloseMainWindow%2A> does not force the application to quit.</span></span> <span data-ttu-id="48f92-671">アプリケーションは、終了する前にユーザー認証を求めることまたは拒否を終了することができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-671">The application can ask for user verification before quitting, or it can refuse to quit.</span></span> <span data-ttu-id="48f92-672">アプリケーションの終了を強制するには使用、<xref:System.Diagnostics.Process.Kill%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-672">To force the application to quit, use the <xref:System.Diagnostics.Process.Kill%2A> method.</span></span> <span data-ttu-id="48f92-673">動作<xref:System.Diagnostics.Process.CloseMainWindow%2A>システム メニューを使用して、アプリケーションのメイン ウィンドウを閉じると、ユーザーの場合と同じです。</span><span class="sxs-lookup"><span data-stu-id="48f92-673">The behavior of <xref:System.Diagnostics.Process.CloseMainWindow%2A> is identical to that of a user closing an application's main window using the system menu.</span></span> <span data-ttu-id="48f92-674">そのため、メイン ウィンドウを閉じることでプロセスを終了する要求はすぐに終了するアプリケーションを強制しません。</span><span class="sxs-lookup"><span data-stu-id="48f92-674">Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-675"><xref:System.Diagnostics.Process.Kill%2A>メソッドを非同期的に実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-675">The <xref:System.Diagnostics.Process.Kill%2A> method executes asynchronously.</span></span> <span data-ttu-id="48f92-676">呼び出した後、<xref:System.Diagnostics.Process.Kill%2A>メソッドを呼び出します、 <xref:System.Diagnostics.Process.WaitForExit%2A> 、プロセスを終了するかを確認するまで待機する方法、<xref:System.Diagnostics.Process.HasExited%2A>プロパティをプロセスが終了したかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="48f92-676">After calling the <xref:System.Diagnostics.Process.Kill%2A> method, call the <xref:System.Diagnostics.Process.WaitForExit%2A> method to wait for the process to exit, or check the <xref:System.Diagnostics.Process.HasExited%2A> property to determine if the process has exited.</span></span>  
  
 <span data-ttu-id="48f92-677">プロセスによって編集されたデータまたはプロセスに割り当てられたリソースが失われる場合を呼び出す<xref:System.Diagnostics.Process.Kill%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-677">Data edited by the process or resources allocated to the process can be lost if you call <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="48f92-678"><xref:System.Diagnostics.Process.Kill%2A> 異常なプロセスを終了させます、必要な場合にのみ使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-678"><xref:System.Diagnostics.Process.Kill%2A> causes an abnormal process termination and should be used only when necessary.</span></span> <span data-ttu-id="48f92-679"><xref:System.Diagnostics.Process.CloseMainWindow%2A> により、プロセスの手順の終了し、インターフェイスを使用するアプリケーションのことをお勧めしているために、すべての windows を閉じます。</span><span class="sxs-lookup"><span data-stu-id="48f92-679"><xref:System.Diagnostics.Process.CloseMainWindow%2A> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface.</span></span> <span data-ttu-id="48f92-680">場合<xref:System.Diagnostics.Process.CloseMainWindow%2A>使用することができますが失敗した<xref:System.Diagnostics.Process.Kill%2A>プロセスを終了します。</span><span class="sxs-lookup"><span data-stu-id="48f92-680">If <xref:System.Diagnostics.Process.CloseMainWindow%2A> fails, you can use <xref:System.Diagnostics.Process.Kill%2A> to terminate the process.</span></span> <span data-ttu-id="48f92-681"><xref:System.Diagnostics.Process.Kill%2A> グラフィカル インターフェイスがないプロセスを終了する唯一の方法です。</span><span class="sxs-lookup"><span data-stu-id="48f92-681"><xref:System.Diagnostics.Process.Kill%2A> is the only way to terminate processes that do not have graphical interfaces.</span></span>  
  
 <span data-ttu-id="48f92-682">呼び出すことができます<xref:System.Diagnostics.Process.Kill%2A>と<xref:System.Diagnostics.Process.CloseMainWindow%2A>ローカル コンピューターで実行されているプロセスに対してのみです。</span><span class="sxs-lookup"><span data-stu-id="48f92-682">You can call <xref:System.Diagnostics.Process.Kill%2A> and <xref:System.Diagnostics.Process.CloseMainWindow%2A> only for processes that are running on the local computer.</span></span> <span data-ttu-id="48f92-683">プロセスが終了するリモート コンピューターで発生することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-683">You cannot cause processes on remote computers to exit.</span></span> <span data-ttu-id="48f92-684">リモート コンピューター上で実行されているプロセスの情報のみ表示できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-684">You can only view information for processes running on remote computers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-685">場合への呼び出し、<xref:System.Diagnostics.Process.Kill%2A>メソッドが、プロセスを終了して現在、中に行われた、<xref:System.ComponentModel.Win32Exception>アクセスが拒否されましたがスローされます。</span><span class="sxs-lookup"><span data-stu-id="48f92-685">If the call to the <xref:System.Diagnostics.Process.Kill%2A> method is made while the process is currently terminating, a <xref:System.ComponentModel.Win32Exception> is thrown for Access Denied.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-686">関連付けられたプロセスを終了できませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-686">The associated process could not be terminated.</span></span>  
  
<span data-ttu-id="48f92-687">または</span><span class="sxs-lookup"><span data-stu-id="48f92-687">-or-</span></span> 
<span data-ttu-id="48f92-688">プロセスを終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-688">The process is terminating.</span></span>  
  
<span data-ttu-id="48f92-689">または</span><span class="sxs-lookup"><span data-stu-id="48f92-689">-or-</span></span> 
<span data-ttu-id="48f92-690">関連付けられたプロセスは、Win16 実行可能ファイルです。</span><span class="sxs-lookup"><span data-stu-id="48f92-690">The associated process is a Win16 executable.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-691">リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.Kill" /> を呼び出そうとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-691">You are attempting to call <see cref="M:System.Diagnostics.Process.Kill" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-692">このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-692">The method is available only for processes running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-693">プロセスは既に終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-693">The process has already exited.</span></span>  
  
<span data-ttu-id="48f92-694">または</span><span class="sxs-lookup"><span data-stu-id="48f92-694">-or-</span></span> 
<span data-ttu-id="48f92-695">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-695">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-696">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-696">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-697">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-697">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-698"><see cref="T:System.Diagnostics.Process" /> コンポーネントを、特殊なモードで実行されているオペレーティング システム プロセスと対話する状態から解放します。</span><span class="sxs-lookup"><span data-stu-id="48f92-698">Takes a <see cref="T:System.Diagnostics.Process" /> component out of the state that lets it interact with operating system processes that run in a special mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-699">一部のオペレーティング システム プロセスは、特殊なモードで実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-699">Some operating system processes run in a special mode.</span></span> <span data-ttu-id="48f92-700">プロパティを読み取るか、これらのプロセスにアタッチしようとしています。 は、呼び出した<xref:System.Diagnostics.Process.EnterDebugMode%2A>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-700">Attempting to read properties of or attach to these processes is not possible unless you have called <xref:System.Diagnostics.Process.EnterDebugMode%2A> on the component.</span></span> <span data-ttu-id="48f92-701">呼び出す<xref:System.Diagnostics.Process.LeaveDebugMode%2A>特殊なモードで実行されているこれらのプロセスへのアクセスが不要です。</span><span class="sxs-lookup"><span data-stu-id="48f92-701">Call <xref:System.Diagnostics.Process.LeaveDebugMode%2A> when you no longer need access to these processes that run in special mode.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-702">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-702">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-703">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-703">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-704">関連付けられたプロセスを実行しているコンピューターの名前を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-704">Gets the name of the computer the associated process is running on.</span></span></summary>
        <value><span data-ttu-id="48f92-705">関連付けられたプロセスを実行しているコンピューターの名前。</span><span class="sxs-lookup"><span data-stu-id="48f92-705">The name of the computer that the associated process is running on.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-706">統計データを表示して、リモート コンピューターで実行されているプロセスのプロセス情報を呼び出すことはできません<xref:System.Diagnostics.Process.Start%2A>、 <xref:System.Diagnostics.Process.CloseMainWindow%2A>、または<xref:System.Diagnostics.Process.Kill%2A>リモート コンピューター上でします。</span><span class="sxs-lookup"><span data-stu-id="48f92-706">You can view statistical data and process information for processes running on remote computers but you cannot call <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, or <xref:System.Diagnostics.Process.Kill%2A> on remote computers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-707">ローカル コンピューターに関連付けられたプロセスを実行しているときに、このプロパティは、期間を返します (".") マシン名。</span><span class="sxs-lookup"><span data-stu-id="48f92-707">When the associated process is executing on the local machine, this property returns a period (".") for the machine name.</span></span> <span data-ttu-id="48f92-708">使用する必要があります、<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>正しいコンピューター名を取得するプロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-708">You should use the <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> property to get the correct machine name.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-709">使用するには、は、するには、次の例は、リモート コンピューターでメモ帳のインスタンスを少なくとも 1 つを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-709">To use the following example you must first start at least one instance of Notepad on a remote computer.</span></span> <span data-ttu-id="48f92-710">例では、リモート コンピューターをメモ帳が実行されているし、表示、それぞれの名前を要求する<xref:System.Diagnostics.Process.ProcessName%2A>、 <xref:System.Diagnostics.Process.Id%2A>、および<xref:System.Diagnostics.Process.MachineName%2A>各インスタンスのプロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-710">The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, and <xref:System.Diagnostics.Process.MachineName%2A> properties for each instance.</span></span>  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-711">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-711">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-712">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-712">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-713">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-713">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-714">関連付けられたプロセスのメイン モジュールを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-714">Gets the main module for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-715">プロセスを開始する際に使用した <see cref="T:System.Diagnostics.ProcessModule" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-715">The <see cref="T:System.Diagnostics.ProcessModule" /> that was used to start the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-716">プロセス モジュールは、特定のプロセスに読み込まれる a.dll または .exe のファイルを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-716">A process module represents a.dll or .exe file that is loaded into a particular process.</span></span> <span data-ttu-id="48f92-717"><xref:System.Diagnostics.Process.MainModule%2A>プロパティでは、モジュール名、ファイル名、モジュールのメモリの詳細など、プロセスを開始するために使用する実行可能ファイルに関する情報を表示することができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-717">The <xref:System.Diagnostics.Process.MainModule%2A> property lets you view information about the executable used to start the process, including the module name, file name, and module memory details.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-718">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainModule" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-718">You are trying to access the <see cref="P:System.Diagnostics.Process.MainModule" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-719">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-719">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-720">32 ビット プロセスが 64 ビット プロセスのモジュールにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-720">A 32-bit process is trying to access the modules of a 64-bit process.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-721">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-721">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-722">プロセス <see cref="P:System.Diagnostics.Process.Id" /> は使用できません。</span><span class="sxs-lookup"><span data-stu-id="48f92-722">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
<span data-ttu-id="48f92-723">または</span><span class="sxs-lookup"><span data-stu-id="48f92-723">-or-</span></span> 
<span data-ttu-id="48f92-724">プロセスが終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-724">The process has exited.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-725">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-725">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-726">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-726">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-727">関連付けられたプロセスのメイン ウィンドウで使用するウィンドウ ハンドルを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-727">Gets the window handle of the main window of the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-728">関連付けられたプロセスのメイン ウィンドウで使用する、システムが生成したウィンドウ ハンドル。</span><span class="sxs-lookup"><span data-stu-id="48f92-728">The system-generated window handle of the main window of the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-729">メイン ウィンドウが現在、フォーカスがあるプロセスによって開かれたウィンドウ (、<xref:System.Windows.Forms.Form.TopLevel%2A>形式)。</span><span class="sxs-lookup"><span data-stu-id="48f92-729">The main window is the window opened by the process that currently has the focus (the <xref:System.Windows.Forms.Form.TopLevel%2A> form).</span></span> <span data-ttu-id="48f92-730">使用する必要があります、<xref:System.Diagnostics.Process.Refresh%2A>を更新する方法、<xref:System.Diagnostics.Process>変更されている場合、現在のメイン ウィンドウのハンドルを取得するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="48f92-730">You must use the <xref:System.Diagnostics.Process.Refresh%2A> method to refresh the <xref:System.Diagnostics.Process> object to get the current main window handle if it has changed.</span></span> <span data-ttu-id="48f92-731">一般に、ウィンドウ ハンドルがキャッシュされるため使用<xref:System.Diagnostics.Process.Refresh%2A>現在のハンドルを取得することを保証するために事前します。</span><span class="sxs-lookup"><span data-stu-id="48f92-731">In general, because the window handle is cached, use <xref:System.Diagnostics.Process.Refresh%2A> beforehand to guarantee that you'll retrieve the current handle.</span></span>  
  
 <span data-ttu-id="48f92-732">取得することができます、<xref:System.Diagnostics.Process.MainWindowHandle%2A>プロパティは、ローカル コンピューター上で実行されているプロセスに対してのみです。</span><span class="sxs-lookup"><span data-stu-id="48f92-732">You can get the <xref:System.Diagnostics.Process.MainWindowHandle%2A> property only for processes that are running on the local computer.</span></span> <span data-ttu-id="48f92-733"><xref:System.Diagnostics.Process.MainWindowHandle%2A>プロパティは、プロセスに関連付けられているウィンドウを一意に識別する値。</span><span class="sxs-lookup"><span data-stu-id="48f92-733">The <xref:System.Diagnostics.Process.MainWindowHandle%2A> property is a value that uniquely identifies the window that is associated with the process.</span></span>  
  
 <span data-ttu-id="48f92-734">プロセスでは、プロセスにグラフィカル インターフェイスがある場合にのみ関連付けられているメイン ウィンドウがあります。</span><span class="sxs-lookup"><span data-stu-id="48f92-734">A process has a main window associated with it only if the process has a graphical interface.</span></span> <span data-ttu-id="48f92-735">関連付けられたプロセスには、メイン ウィンドウがない場合、<xref:System.Diagnostics.Process.MainWindowHandle%2A>値は 0 です。</span><span class="sxs-lookup"><span data-stu-id="48f92-735">If the associated process does not have a main window, the <xref:System.Diagnostics.Process.MainWindowHandle%2A> value is zero.</span></span> <span data-ttu-id="48f92-736">値は 0、非表示されているプロセスのタスク バーに表示されないプロセス、つまりもです。</span><span class="sxs-lookup"><span data-stu-id="48f92-736">The value is also zero for processes that have been hidden, that is, processes that are not visible in the taskbar.</span></span> <span data-ttu-id="48f92-737">これは、タスク バーの右端にある、通知領域にアイコンとして表示されるプロセスの場合です。</span><span class="sxs-lookup"><span data-stu-id="48f92-737">This can be the case for processes that appear as icons in the notification area, at the far right of the taskbar.</span></span>  
  
 <span data-ttu-id="48f92-738">プロセスを開始したし、メイン ウィンドウのハンドルを使用する場合は、使用を検討して、<xref:System.Diagnostics.Process.WaitForInputIdle%2A>起動が完了するプロセスをできるように、メイン ウィンドウのハンドルが作成されていることを確認する方法。</span><span class="sxs-lookup"><span data-stu-id="48f92-738">If you have just started a process and want to use its main window handle, consider using the <xref:System.Diagnostics.Process.WaitForInputIdle%2A> method to allow the process to finish starting, ensuring that the main window handle has been created.</span></span> <span data-ttu-id="48f92-739">この操作を行わない場合、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="48f92-739">Otherwise, an exception will be thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-740">プロセスが終了したため、<see cref="P:System.Diagnostics.Process.MainWindowHandle" /> が定義されていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-740">The <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> is not defined because the process has exited.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-741">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-741">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-742">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-742">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-743">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-743">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-744">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-744">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-745">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-745">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-746">プロセスのメイン ウィンドウのキャプションを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-746">Gets the caption of the main window of the process.</span></span></summary>
        <value><span data-ttu-id="48f92-747">プロセスのメイン ウィンドウのタイトル。</span><span class="sxs-lookup"><span data-stu-id="48f92-747">The main window title of the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-748">プロセスでは、プロセスにグラフィカル インターフェイスがある場合にのみ関連付けられているメイン ウィンドウがあります。</span><span class="sxs-lookup"><span data-stu-id="48f92-748">A process has a main window associated with it only if the process has a graphical interface.</span></span> <span data-ttu-id="48f92-749">関連付けられたプロセスにメイン ウィンドウがない場合 (ように<xref:System.Diagnostics.Process.MainWindowHandle%2A>は 0 です)、<xref:System.Diagnostics.Process.MainWindowTitle%2A>空の文字列 ("")。</span><span class="sxs-lookup"><span data-stu-id="48f92-749">If the associated process does not have a main window (so that <xref:System.Diagnostics.Process.MainWindowHandle%2A> is zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> is an empty string ("").</span></span> <span data-ttu-id="48f92-750">プロセスを開始したしてメイン ウィンドウのタイトルを使用する場合は、使用を検討して、<xref:System.Diagnostics.Process.WaitForInputIdle%2A>起動が完了するプロセスをできるように、メイン ウィンドウのハンドルが作成されていることを確認する方法。</span><span class="sxs-lookup"><span data-stu-id="48f92-750">If you have just started a process and want to use its main window title, consider using the <xref:System.Diagnostics.Process.WaitForInputIdle%2A> method to allow the process to finish starting, ensuring that the main window handle has been created.</span></span> <span data-ttu-id="48f92-751">それ以外の場合、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="48f92-751">Otherwise, the system throws an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-752">メイン ウィンドウが現在、フォーカスのあるウィンドウです。プロセスの主なウィンドウをできない可能性がありますこれに注意してください。</span><span class="sxs-lookup"><span data-stu-id="48f92-752">The main window is the window that currently has the focus; note that this might not be the primary window for the process.</span></span> <span data-ttu-id="48f92-753">使用する必要があります、<xref:System.Diagnostics.Process.Refresh%2A>を更新する方法、<xref:System.Diagnostics.Process>変更されている場合、現在のメイン ウィンドウのハンドルを取得するオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="48f92-753">You must use the <xref:System.Diagnostics.Process.Refresh%2A> method to refresh the <xref:System.Diagnostics.Process> object to get the current main window handle if it has changed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-754">次の例では、メモ帳のインスタンスを起動し、プロセスのメイン ウィンドウのキャプションを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-754">The following example starts an instance of Notepad and retrieves the caption of the main window of the process.</span></span>  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-755">プロセスが終了したため、<see cref="P:System.Diagnostics.Process.MainWindowTitle" /> プロパティが定義されていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-755">The <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property is not defined because the process has exited.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-756">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-756">You are trying to access the <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-757">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-757">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-758">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-758">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-759">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-759">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-760">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-760">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-761">関連付けられたプロセスに許可されるワーキング セットの最大サイズ (バイト単位) を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-761">Gets or sets the maximum allowable working set size, in bytes, for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-762">プロセスに許可されるメモリ上のワーキング セットの最大サイズ (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-762">The maximum working set size that is allowed in memory for the process, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-763">プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。</span><span class="sxs-lookup"><span data-stu-id="48f92-763">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="48f92-764">これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-764">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="48f92-765">ワーキング セットには、共有とプライベートの両方のデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-765">The working set includes both shared and private data.</span></span> <span data-ttu-id="48f92-766">共有データには、アプリケーションを実行する .dll ファイルと system.dll ファイル内のページを含むすべての命令を含むページが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-766">The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</span></span> <span data-ttu-id="48f92-767">ワーキング セットのサイズ増加、必要なメモリが増加します。</span><span class="sxs-lookup"><span data-stu-id="48f92-767">As the working set size increases, memory demand increases.</span></span>  
  
 <span data-ttu-id="48f92-768">プロセスは、最小と最大ワーキング セットのサイズ。</span><span class="sxs-lookup"><span data-stu-id="48f92-768">A process has minimum and maximum working set sizes.</span></span> <span data-ttu-id="48f92-769">プロセス リソースが作成されるたびに、システムは、、プロセスのワーキング セットの最小メモリ容量を予約します。</span><span class="sxs-lookup"><span data-stu-id="48f92-769">Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</span></span> <span data-ttu-id="48f92-770">仮想メモリ マネージャーは、少なくとも最小限のメモリ常駐させるプロセスがアクティブであるが、保持の最大サイズを超えることはありませんしようとします。</span><span class="sxs-lookup"><span data-stu-id="48f92-770">The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</span></span>  
  
 <span data-ttu-id="48f92-771">システムでは、既定の作業セット サイズを設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-771">The system sets the default working set sizes.</span></span> <span data-ttu-id="48f92-772">使用してこれらのサイズを変更することができます、<xref:System.Diagnostics.Process.MaxWorkingSet%2A>と<xref:System.Diagnostics.Process.MinWorkingSet%2A>メンバー。</span><span class="sxs-lookup"><span data-stu-id="48f92-772">You can modify these sizes using the <xref:System.Diagnostics.Process.MaxWorkingSet%2A> and <xref:System.Diagnostics.Process.MinWorkingSet%2A> members.</span></span> <span data-ttu-id="48f92-773">ただし、これらの値の設定はありませんが保証メモリされます予約または常駐します。</span><span class="sxs-lookup"><span data-stu-id="48f92-773">However, setting these values does not guarantee that the memory will be reserved or resident.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-774">プロセスのワーキング セットのサイズを大きくと、システムの他の部分から物理メモリを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-774">When you increase the working set size of a process, you take physical memory away from the rest of the system.</span></span> <span data-ttu-id="48f92-775">システム パフォーマンスが低下することができますが、大きすぎるを最小値または最大のワーキング セットのサイズを要求しないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="48f92-775">Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="48f92-776">ワーキング セットの最大サイズが正しくありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-776">The maximum working set size is invalid.</span></span> <span data-ttu-id="48f92-777">この値は、ワーキング セットの最小サイズ以上である必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-777">It must be greater than or equal to the minimum working set size.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-778">関連付けられているプロセス リソースからワーキング セット情報を取得できません。</span><span class="sxs-lookup"><span data-stu-id="48f92-778">Working set information cannot be retrieved from the associated process resource.</span></span>  
  
<span data-ttu-id="48f92-779">または</span><span class="sxs-lookup"><span data-stu-id="48f92-779">-or-</span></span> 
<span data-ttu-id="48f92-780">プロセスが開始されていないので、プロセス識別子またはプロセス ハンドルが 0 です。</span><span class="sxs-lookup"><span data-stu-id="48f92-780">The process identifier or process handle is zero because the process has not been started.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-781">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-781">You are trying to access the <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-782">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-782">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-783">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。</span><span class="sxs-lookup"><span data-stu-id="48f92-783">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
<span data-ttu-id="48f92-784">または</span><span class="sxs-lookup"><span data-stu-id="48f92-784">-or-</span></span> 
<span data-ttu-id="48f92-785">プロセスが終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-785">The process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-786">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-786">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-787">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-787">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-788">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-788">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-789">関連付けられたプロセスに許可されるワーキング セットの最小サイズ (バイト単位) を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-789">Gets or sets the minimum allowable working set size, in bytes, for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-790">プロセスに必要なメモリ上のワーキング セットの最小サイズ (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-790">The minimum working set size that is required in memory for the process, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-791">プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。</span><span class="sxs-lookup"><span data-stu-id="48f92-791">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="48f92-792">これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-792">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="48f92-793">ワーキング セットには、共有とプライベートの両方のデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-793">The working set includes both shared and private data.</span></span> <span data-ttu-id="48f92-794">共有データには、アプリケーションを実行する .dll ファイルと system.dll ファイル内のページを含むすべての命令を含むページが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-794">The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files.</span></span> <span data-ttu-id="48f92-795">ワーキング セットのサイズ増加、必要なメモリが増加します。</span><span class="sxs-lookup"><span data-stu-id="48f92-795">As the working set size increases, memory demand increases.</span></span>  
  
 <span data-ttu-id="48f92-796">プロセスは、最小と最大ワーキング セットのサイズ。</span><span class="sxs-lookup"><span data-stu-id="48f92-796">A process has minimum and maximum working set sizes.</span></span> <span data-ttu-id="48f92-797">プロセス リソースが作成されるたびに、システムは、、プロセスのワーキング セットの最小メモリ容量を予約します。</span><span class="sxs-lookup"><span data-stu-id="48f92-797">Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process.</span></span> <span data-ttu-id="48f92-798">仮想メモリ マネージャーは、少なくとも最小限のメモリ常駐させるプロセスがアクティブであるが、保持の最大サイズを超えることはありませんしようとします。</span><span class="sxs-lookup"><span data-stu-id="48f92-798">The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</span></span>  
  
 <span data-ttu-id="48f92-799">システムでは、既定の作業セット サイズを設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-799">The system sets the default working set sizes.</span></span> <span data-ttu-id="48f92-800">使用してこれらのサイズを変更することができます、<xref:System.Diagnostics.Process.MaxWorkingSet%2A>と<xref:System.Diagnostics.Process.MinWorkingSet%2A>メンバー。</span><span class="sxs-lookup"><span data-stu-id="48f92-800">You can modify these sizes using the <xref:System.Diagnostics.Process.MaxWorkingSet%2A> and <xref:System.Diagnostics.Process.MinWorkingSet%2A> members.</span></span> <span data-ttu-id="48f92-801">ただし、これらの値の設定はありませんが保証メモリされます予約または常駐します。</span><span class="sxs-lookup"><span data-stu-id="48f92-801">However, setting these values does not guarantee that the memory will be reserved or resident.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-802">プロセスのワーキング セットのサイズを大きくと、システムの他の部分から物理メモリを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-802">When you increase the working set size of a process, you take physical memory away from the rest of the system.</span></span> <span data-ttu-id="48f92-803">システム パフォーマンスが低下することができますが、大きすぎるを最小値または最大のワーキング セットのサイズを要求しないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="48f92-803">Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="48f92-804">ワーキング セットの最小サイズが正しくありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-804">The minimum working set size is invalid.</span></span> <span data-ttu-id="48f92-805">この値は、ワーキング セットの最大サイズ以下にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-805">It must be less than or equal to the maximum working set size.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-806">関連付けられているプロセス リソースからワーキング セット情報を取得できません。</span><span class="sxs-lookup"><span data-stu-id="48f92-806">Working set information cannot be retrieved from the associated process resource.</span></span>  
  
<span data-ttu-id="48f92-807">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-807">-or-</span></span> 
<span data-ttu-id="48f92-808">プロセスが開始されていないので、プロセス識別子またはプロセス ハンドルが 0 です。</span><span class="sxs-lookup"><span data-stu-id="48f92-808">The process identifier or process handle is zero because the process has not been started.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-809">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-809">You are trying to access the <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-810">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-810">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-811">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。</span><span class="sxs-lookup"><span data-stu-id="48f92-811">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span>  
  
<span data-ttu-id="48f92-812">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-812">-or-</span></span> 
<span data-ttu-id="48f92-813">プロセスが終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-813">The process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-814">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-814">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-815">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-815">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-816">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-816">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-817">関連付けられたプロセスに読み込まれたモジュールを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-817">Gets the modules that have been loaded by the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-818">関連付けられたプロセスに読み込まれたモジュールを表す <see cref="T:System.Diagnostics.ProcessModule" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="48f92-818">An array of type <see cref="T:System.Diagnostics.ProcessModule" /> that represents the modules that have been loaded by the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-819">プロセス モジュールは、特定のプロセスに読み込まれる a.dll または .exe のファイルを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-819">A process module represents a.dll or .exe file that is loaded into a particular process.</span></span> <span data-ttu-id="48f92-820">A<xref:System.Diagnostics.ProcessModule>インスタンスでは、モジュール名、ファイル名、モジュールのメモリの詳細など、モジュールに関する情報を表示することができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-820">A <xref:System.Diagnostics.ProcessModule> instance lets you view information about a module, including the module name, file name, and module memory details.</span></span>  
  
 <span data-ttu-id="48f92-821">プロセスでは、メモリに複数のモジュールを読み込むことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-821">A process can load multiple modules into memory.</span></span> <span data-ttu-id="48f92-822">たとえば、.exe ファイルを追加の .dll ファイルを読み込むには、複数のモジュールがあります。</span><span class="sxs-lookup"><span data-stu-id="48f92-822">For example,.exe files that load additional .dll files have multiple modules.</span></span>  
  
 <span data-ttu-id="48f92-823">プロセスを開始した後、システムには、プロセスが読み込まれるまでこのコレクションが空です。</span><span class="sxs-lookup"><span data-stu-id="48f92-823">After starting the process, this collection is empty until the system has loaded the process.</span></span> <span data-ttu-id="48f92-824">プロセスのメイン ウィンドウにある場合は、呼び出す<xref:System.Diagnostics.Process.WaitForInputIdle%2A>コレクションが空でない場合にことを確認するには、このプロパティを取得する前に、一覧を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-824">If the process has a main window, you can call <xref:System.Diagnostics.Process.WaitForInputIdle%2A> before retrieving this property to ensure that the collection is nonempty when you get the list.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-825">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.Modules" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-825">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-826">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-826">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-827">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。</span><span class="sxs-lookup"><span data-stu-id="48f92-827">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-828">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-828">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-829">システム プロセスまたはアイドル状態のプロセスのいずれかの <see cref="P:System.Diagnostics.Process.Modules" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-829">You are attempting to access the <see cref="P:System.Diagnostics.Process.Modules" /> property for either the system process or the idle process.</span></span> <span data-ttu-id="48f92-830">これらのプロセスには、モジュールが存在しません。</span><span class="sxs-lookup"><span data-stu-id="48f92-830">These processes do not have modules.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-831">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-831">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-832">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-832">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-833">関連付けられたプロセスに割り当てられたページングされないシステム メモリの量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-833">Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-834">システムによって関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができないメモリの容量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-834">The amount of memory, in bytes, the system has allocated for the associated process that cannot be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-835">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-835">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-836">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-836">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-837">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-837">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-838">関連付けられたプロセスに割り当てられたページングされないシステム メモリの量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-838">Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-839">関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができないシステム メモリの容量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-839">The amount of system memory, in bytes, allocated for the associated process that cannot be written to the virtual memory paging file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-840">このプロパティによって返される値は、現在のサイズ (バイト単位)、プロセスによって使用される非ページ システム メモリを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-840">The value returned by this property represents the current size of nonpaged system memory used by the process, in bytes.</span></span> <span data-ttu-id="48f92-841">システム メモリは、オペレーティング システムで使用される物理メモリがあり、ページおよび非ページ プールに分割されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-841">System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</span></span> <span data-ttu-id="48f92-842">非ページ メモリの割り当ては、システム メモリに保持され、仮想メモリ ページング ファイルにページ アウトできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-842">Nonpaged memory allocations remain in system memory and are not paged out to the virtual memory paging file.</span></span>  
  
 <span data-ttu-id="48f92-843">このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-843">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="48f92-844">プロパティ値が等しく、 **Pool Nonpaged Bytes**プロセスのパフォーマンス カウンター。</span><span class="sxs-lookup"><span data-stu-id="48f92-844">The property value is equivalent to the **Pool Nonpaged Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-845">次のコード例では、メモ帳アプリケーションのインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-845">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="48f92-846">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-846">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-847">例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-847">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-848">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-848">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-849">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-849">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-850">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-850">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-851"><see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="48f92-851">Raises the <see cref="E:System.Diagnostics.Process.Exited" /> event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-852"><xref:System.Diagnostics.Process.OnExited%2A> 発生させる API メソッドには、<xref:System.Diagnostics.Process.Exited>イベント。</span><span class="sxs-lookup"><span data-stu-id="48f92-852"><xref:System.Diagnostics.Process.OnExited%2A> is the API method that raises the <xref:System.Diagnostics.Process.Exited> event.</span></span> <span data-ttu-id="48f92-853">呼び出す<xref:System.Diagnostics.Process.OnExited%2A>により、<xref:System.Diagnostics.Process.Exited>イベントの発生を使用してイベントを発生させる唯一の方法であり、<xref:System.Diagnostics.Process>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-853">Calling <xref:System.Diagnostics.Process.OnExited%2A> causes the <xref:System.Diagnostics.Process.Exited> event to occur and is the only way to raise the event using the <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="48f92-854"><xref:System.Diagnostics.Process.OnExited%2A> コンポーネントからクラスを派生するときに主に使用されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-854"><xref:System.Diagnostics.Process.OnExited%2A> is primarily used when deriving classes from the component.</span></span>  
  
 <span data-ttu-id="48f92-855">代替手段として<xref:System.Diagnostics.Process.OnExited%2A>、独自のイベント ハンドラーを記述することができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-855">As an alternative to <xref:System.Diagnostics.Process.OnExited%2A>, you can write your own event handler.</span></span> <span data-ttu-id="48f92-856">独自のイベント ハンドラー デリゲートおよびイベント処理メソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="48f92-856">You create your own event handler delegate and your own event-handling method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-857">Visual Studio 環境を使用している場合 (AddOnExited) イベント ハンドラー デリゲートおよびイベント処理メソッド (Process1_Exited) が作成されますをドラッグすると、<xref:System.Diagnostics.Process>コンポーネントをフォームにアイコンをダブルクリックします。</span><span class="sxs-lookup"><span data-stu-id="48f92-857">If you are using the Visual Studio environment, an event handler delegate (AddOnExited) and an event-handling method (Process1_Exited) are created for you when you drag a <xref:System.Diagnostics.Process> component onto a form and double-click the icon.</span></span> <span data-ttu-id="48f92-858">ときに実行するコードを作成する、 <xref:System.Diagnostics.Process.Exited> Process1_Exited プロシージャに入力されたイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="48f92-858">The code you create to run when the <xref:System.Diagnostics.Process.Exited> event occurs is entered into the Process1_Exited procedure.</span></span> <span data-ttu-id="48f92-859">作成する必要はありません、<xref:System.Diagnostics.Process.OnExited%2A>メンバーが実装されているためです。</span><span class="sxs-lookup"><span data-stu-id="48f92-859">You do not need to create the <xref:System.Diagnostics.Process.OnExited%2A> member, because it is implemented for you.</span></span>  
  
 <span data-ttu-id="48f92-860">イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-860">Raising an event invokes the event handler through a delegate.</span></span> <span data-ttu-id="48f92-861">概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。</span><span class="sxs-lookup"><span data-stu-id="48f92-861">For an overview, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-862">次の例は、使用する方法を示します、<xref:System.Diagnostics.Process.OnExited%2A>派生クラスのメソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-862">The following example shows how to use the <xref:System.Diagnostics.Process.OnExited%2A> method in a derived class.</span></span>  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-863">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-863">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-864">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-864">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-865">アプリケーションが、リダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームに行を書き込む度に発生します。</span><span class="sxs-lookup"><span data-stu-id="48f92-865">Occurs each time an application writes a line to its redirected <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-866"><xref:System.Diagnostics.Process.OutputDataReceived>イベントでは、ことを示します、関連付けられている<xref:System.Diagnostics.Process>、リダイレクトされた、改行文字で終了して、行が書き込まれる<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-866">The <xref:System.Diagnostics.Process.OutputDataReceived> event indicates that the associated <xref:System.Diagnostics.Process> has written a line, terminating with a newline character, to its redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="48f92-867">非同期読み取り操作中に、イベントが有効になっている<xref:System.Diagnostics.Process.StandardOutput%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-867">The event is enabled during asynchronous read operations on <xref:System.Diagnostics.Process.StandardOutput%2A>.</span></span> <span data-ttu-id="48f92-868">非同期の読み取り操作を開始するには、リダイレクトする必要があります、<xref:System.Diagnostics.Process.StandardOutput%2A>のストリームを<xref:System.Diagnostics.Process>、イベント ハンドラーを追加、<xref:System.Diagnostics.Process.OutputDataReceived>イベント、および呼び出し<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-868">To start asynchronous read operations, you must redirect the <xref:System.Diagnostics.Process.StandardOutput%2A> stream of a <xref:System.Diagnostics.Process>, add your event handler to the <xref:System.Diagnostics.Process.OutputDataReceived> event, and call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>.</span></span> <span data-ttu-id="48f92-869">その後、<xref:System.Diagnostics.Process.OutputDataReceived>イベント シグナル プロセスでは、リダイレクトされたに行を書き込むたびに<xref:System.Diagnostics.Process.StandardOutput%2A>プロセスが終了するかを呼び出すまで、ストリーム<xref:System.Diagnostics.Process.CancelOutputRead%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-869">Thereafter, the <xref:System.Diagnostics.Process.OutputDataReceived> event signals each time the process writes a line to the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, until the process exits or calls <xref:System.Diagnostics.Process.CancelOutputRead%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-870">非同期出力を処理するアプリケーションを呼び出す必要があります、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドを出力バッファーがフラッシュされたことを確認します。</span><span class="sxs-lookup"><span data-stu-id="48f92-870">The application that is processing the asynchronous output should call the <xref:System.Diagnostics.Process.WaitForExit%2A> method to ensure that the output buffer has been flushed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-871">次の例では、リダイレクトされたで非同期の読み取り操作を実行する方法を示しています。<xref:System.Diagnostics.Process.StandardOutput%2A>のストリーム、`ipconfig`コマンド。</span><span class="sxs-lookup"><span data-stu-id="48f92-871">The following example illustrates how to perform asynchronous read operations on the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream of the `ipconfig` command.</span></span>  
  
 <span data-ttu-id="48f92-872">例でのイベントのデリゲートを作成、`OutputHandler`イベント ハンドラーを関連付けます、<xref:System.Diagnostics.Process.OutputDataReceived>イベント。</span><span class="sxs-lookup"><span data-stu-id="48f92-872">The example creates an event delegate for the `OutputHandler` event handler and associates it with the <xref:System.Diagnostics.Process.OutputDataReceived> event.</span></span> <span data-ttu-id="48f92-873">イベント ハンドラーがリダイレクトされたからテキスト行を受け取る<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームは、テキストを書式設定し、コンソール ウィンドウの例の後に表示される出力文字列に保存します。</span><span class="sxs-lookup"><span data-stu-id="48f92-873">The event handler receives text lines from the redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream, formats the text, and saves it in an output string that's later shown in the example's console window.</span></span>  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-874">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-874">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-875">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-875">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-876">関連付けられたプロセスに割り当てられたページ メモリの量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-876">Gets the amount of paged memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-877">仮想メモリ ページング ファイルに書き込むことができる関連付けられたプロセスによって割り当てられたメモリの容量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-877">The amount of memory, in bytes, allocated by the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-878">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-878">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-879">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-879">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-880">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-880">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-881">関連付けられたプロセスに割り当てられたページ メモリの量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-881">Gets the amount of paged memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-882">関連付けられたプロセスの仮想メモリ ページング ファイル内で割り当てられたメモリの量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-882">The amount of memory, in bytes, allocated in the virtual memory paging file for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-883">このプロパティによって返される値は、メモリ (バイト単位)、プロセスによって使用される仮想メモリ ページング ファイル内の現在のサイズを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-883">The value returned by this property represents the current size of memory in the virtual memory paging file used by the process, in bytes.</span></span> <span data-ttu-id="48f92-884">オペレーティング システムでは、物理メモリの量と組み合わせて仮想メモリ ページング ファイルを使用して、各プロセスの仮想アドレス領域を管理します。</span><span class="sxs-lookup"><span data-stu-id="48f92-884">The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</span></span> <span data-ttu-id="48f92-885">ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-885">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span> <span data-ttu-id="48f92-886">プロセスのオペレーティング システムで使用されるメモリのサイズを取得する、<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-886">To obtain the size of memory used by the operating system for the process, use the <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> property.</span></span>  
  
 <span data-ttu-id="48f92-887">このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-887">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="48f92-888">プロパティ値が等しく、**ページ ファイルのバイト数**プロセスのパフォーマンス カウンター。</span><span class="sxs-lookup"><span data-stu-id="48f92-888">The property value is equivalent to the **Page File Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-889">次のコード例は、メモ帳アプリケーションのインスタンスを起動しを取得して関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-889">The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-890">例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-890">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-891">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-891">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-892">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-892">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-893">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-893">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-894">関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-894">Gets the amount of pageable system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-895">システムによって関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができるメモリの容量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-895">The amount of memory, in bytes, the system has allocated for the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-896">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-896">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-897">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-897">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-898">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-898">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-899">関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-899">Gets the amount of pageable system memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-900">関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができるシステム メモリの容量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-900">The amount of system memory, in bytes, allocated for the associated process that can be written to the virtual memory paging file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-901">このプロパティの値によって返される値は、(バイト単位)、プロセスによって使用されているページング可能なシステム メモリの現在のサイズを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-901">The value returned by this property value represents the current size of pageable system memory used by the process, in bytes.</span></span> <span data-ttu-id="48f92-902">システム メモリは、オペレーティング システムで使用される物理メモリがあり、ページおよび非ページ プールに分割されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-902">System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools.</span></span> <span data-ttu-id="48f92-903">ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-903">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span> <span data-ttu-id="48f92-904">プロセスによって使用されるアプリケーションのメモリのサイズを取得する、<xref:System.Diagnostics.Process.PagedMemorySize64%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-904">To obtain the size of the application memory used by the process, use the <xref:System.Diagnostics.Process.PagedMemorySize64%2A> property.</span></span>  
  
 <span data-ttu-id="48f92-905">このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-905">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="48f92-906">プロパティ値が等しく、**ページ プールのサイズ**プロセスのパフォーマンス カウンター。</span><span class="sxs-lookup"><span data-stu-id="48f92-906">The property value is equivalent to the **Pool Paged Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-907">次のコード例では、メモ帳アプリケーションのインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-907">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="48f92-908">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-908">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-909">例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-909">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-910">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-910">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-911">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-911">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-912">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-912">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-913">関連付けられたプロセスによって使用される、仮想メモリ ページング ファイル内のメモリの最大量を取得します (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-913">Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-914">関連付けられたプロセスによって割り当てられた、仮想メモリ ページング ファイルに書き込むことができたメモリの最大容量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-914">The maximum amount of memory, in bytes, allocated by the associated process that could be written to the virtual memory paging file.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-915">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-915">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-916">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-916">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-917">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-917">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-918">関連付けられたプロセスによって使用される、仮想メモリ ページング ファイル内のメモリの最大量を取得します (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-918">Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-919">プロセスの開始以降、関連付けられたプロセスの仮想メモリ ページング ファイル内で割り当てられたメモリの最大量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-919">The maximum amount of memory, in bytes, allocated in the virtual memory paging file for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-920">このプロパティの値によって返される値は、(バイト単位)、起動されてから、プロセスで使用される仮想メモリ ページング ファイル内のメモリの最大サイズを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-920">The value returned by this property value represents the maximum size of memory in the virtual memory paging file used by the process since it started, in bytes.</span></span> <span data-ttu-id="48f92-921">オペレーティング システムでは、物理メモリの量と組み合わせて仮想メモリ ページング ファイルを使用して、各プロセスの仮想アドレス領域を管理します。</span><span class="sxs-lookup"><span data-stu-id="48f92-921">The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process.</span></span> <span data-ttu-id="48f92-922">ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-922">When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="48f92-923">このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-923">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="48f92-924">プロパティ値が等しく、**ページ ファイルのバイト数のピーク**プロセスのパフォーマンス カウンター。</span><span class="sxs-lookup"><span data-stu-id="48f92-924">The property value is equivalent to the **Page File Bytes Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-925">次のコード例では、メモ帳アプリケーションのインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-925">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="48f92-926">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-926">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-927">例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-927">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-928">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-928">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-929">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-929">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-930">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-930">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-931">関連付けられたプロセスによって使用される仮想メモリの最大量を取得します (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-931">Gets the maximum amount of virtual memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-932">関連付けられたプロセスが要求した仮想メモリの最大容量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-932">The maximum amount of virtual memory, in bytes, that the associated process has requested.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-933">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-933">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-934">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-934">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-935">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-935">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-936">関連付けられたプロセスによって使用される仮想メモリの最大量を取得します (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-936">Gets the maximum amount of virtual memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-937">プロセスの開始以降、関連付けられたプロセスに割り当てられた仮想メモリの最大量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-937">The maximum amount of virtual memory, in bytes, allocated for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-938">このプロパティによって返される値は、(バイト単位)、起動されてから、プロセスによって使用される仮想メモリの最大サイズを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-938">The value returned by this property represents the maximum size of virtual memory used by the process since it started, in bytes.</span></span> <span data-ttu-id="48f92-939">オペレーティング システムでは、各プロセスの物理メモリまたはディスク上の仮想メモリ ページング ファイルに格納されているページが読み込まれるページのいずれかの仮想アドレス空間をマップします。</span><span class="sxs-lookup"><span data-stu-id="48f92-939">The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="48f92-940">このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-940">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="48f92-941">プロパティ値が等しく、**仮想バイト ピーク**プロセスのパフォーマンス カウンター。</span><span class="sxs-lookup"><span data-stu-id="48f92-941">The property value is equivalent to the **Virtual Bytes Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-942">次のコード例では、メモ帳アプリケーションのインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-942">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="48f92-943">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-943">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-944">例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-944">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-945">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-945">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-946">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-946">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-947">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-947">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-948">関連付けられたプロセスのピーク ワーキング セット サイズをバイト単位で取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-948">Gets the peak working set size for the associated process, in bytes.</span></span></summary>
        <value><span data-ttu-id="48f92-949">関連づけられたプロセスが一度に要求した物理メモリのバイト単位での最大容量。</span><span class="sxs-lookup"><span data-stu-id="48f92-949">The maximum amount of physical memory that the associated process has required all at once, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-950">プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。</span><span class="sxs-lookup"><span data-stu-id="48f92-950">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="48f92-951">これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-951">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="48f92-952">ワーキング セットには、共有とプライベートの両方のデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-952">The working set includes both shared and private data.</span></span> <span data-ttu-id="48f92-953">共有データには、プロセスのモジュールおよびシステム ライブラリを含む、プロセスが実行されるすべての指示を含むページが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-953">The shared data includes the pages that contain all the instructions that the process executes, including process modules and the system libraries.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-954">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-954">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-955">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-955">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-956">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-956">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-957">関連付けられたプロセスによって使用される物理メモリの最大量をバイト数として取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-957">Gets the maximum amount of physical memory, in bytes, used by the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-958">プロセスの開始以降、関連付けられたプロセスに割り当てられた物理メモリの最大量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-958">The maximum amount of physical memory, in bytes, allocated for the associated process since it was started.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-959">このプロパティによって返される値は、ワーキング セット メモリのバイト単位で起動されてから、プロセスで使用されるの最大サイズを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-959">The value returned by this property represents the maximum size of working set memory used by the process since it started, in bytes.</span></span> <span data-ttu-id="48f92-960">プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。</span><span class="sxs-lookup"><span data-stu-id="48f92-960">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="48f92-961">これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-961">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="48f92-962">ワーキング セットには、共有とプライベートの両方のデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-962">The working set includes both shared and private data.</span></span> <span data-ttu-id="48f92-963">共有データには、プロセスのモジュールと、システム ライブラリから命令を含む、プロセスが実行されるすべての指示を含むページが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-963">The shared data includes the pages that contain all the instructions that the process executes, including instructions from the process modules and the system libraries.</span></span>  
  
 <span data-ttu-id="48f92-964">このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-964">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="48f92-965">プロパティ値が等しく、 **Working Set Peak**プロセスのパフォーマンス カウンター。</span><span class="sxs-lookup"><span data-stu-id="48f92-965">The property value is equivalent to the **Working Set Peak** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-966">次のコード例では、メモ帳アプリケーションのインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-966">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="48f92-967">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-967">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-968">例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-968">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-969">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-969">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-970">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-970">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-971">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-971">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-972">メイン ウィンドウのフォーカス時に、オペレーティング システムによって関連付けられたプロセスの優先順位を一時的に上げるかどうかを示す値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-972">Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</span></span></summary>
        <value><span data-ttu-id="48f92-973">待機状態から抜けたときにプロセスの優先順位を動的に上げる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-973"><see langword="true" /> if dynamic boosting of the process priority should take place for a process when it is taken out of the wait state; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="48f92-974">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-974">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-975">対象の優先度クラスには動的な優先順位の列挙値の 1 つのプロセスでスレッドを実行すると (<xref:System.Diagnostics.ProcessPriorityClass.Normal>、 <xref:System.Diagnostics.ProcessPriorityClass.High>、または<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)、システムは、待機状態から抜けたときに一時的にスレッドの優先順位をブーストします。</span><span class="sxs-lookup"><span data-stu-id="48f92-975">When a thread runs in a process for which the priority class has one of the dynamic priority enumeration values (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), the system temporarily boosts the thread's priority when it is taken out of a wait state.</span></span> <span data-ttu-id="48f92-976">このアクションでは、他のプロセスが現在のスレッドの処理を中断できなくなります。</span><span class="sxs-lookup"><span data-stu-id="48f92-976">This action prevents other processes from interrupting the processing of the current thread.</span></span> <span data-ttu-id="48f92-977"><xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>設定は、既存のすべてのスレッドと、その後、プロセスによって作成されたすべてのスレッドに影響します。</span><span class="sxs-lookup"><span data-stu-id="48f92-977">The <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> setting affects all the existing threads and any threads subsequently created by the process.</span></span> <span data-ttu-id="48f92-978">通常の動作を復元するには、設定、<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>プロパティを`false`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-978">To restore normal behavior, set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-979">優先順位が高すぎると重要なオペレーティング システムおよびネットワーク機能、オペレーティング システムの他のタスクと問題の原因のリソースにドレインを実行できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-979">Boosting the priority too high can drain resources from essential operating system and network functions, causing problems with other operating system tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-980">関連付けられているプロセス リソースから priority boost 情報を取得できませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-980">Priority boost information could not be retrieved from the associated process resource.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-981">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-981">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span>  
  
<span data-ttu-id="48f92-982">または</span><span class="sxs-lookup"><span data-stu-id="48f92-982">-or-</span></span> 
<span data-ttu-id="48f92-983">プロセス識別子またはプロセス ハンドルが 0 です。</span><span class="sxs-lookup"><span data-stu-id="48f92-983">The process identifier or process handle is zero.</span></span> <span data-ttu-id="48f92-984">(プロセスは開始されていません。)</span><span class="sxs-lookup"><span data-stu-id="48f92-984">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-985">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-985">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-986">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-986">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-987">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。</span><span class="sxs-lookup"><span data-stu-id="48f92-987">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-988">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-988">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-989">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-989">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-990">関連付けられたプロセスの全体的な優先順位カテゴリを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-990">Gets or sets the overall priority category for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-991">プロセスの <see cref="P:System.Diagnostics.Process.BasePriority" /> を計算するときに使用する、関連付けられたプロセスの優先順位カテゴリ。</span><span class="sxs-lookup"><span data-stu-id="48f92-991">The priority category for the associated process, from which the <see cref="P:System.Diagnostics.Process.BasePriority" /> of the process is calculated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-992">プロセスの優先度クラスには、さまざまなスレッド優先度レベルが含まれます。</span><span class="sxs-lookup"><span data-stu-id="48f92-992">A process priority class encompasses a range of thread priority levels.</span></span> <span data-ttu-id="48f92-993">プロセスの優先度クラスを基準としたプロセスで実行されている優先順位が異なるスレッドを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-993">Threads with different priorities that are running in the process run relative to the priority class of the process.</span></span> <span data-ttu-id="48f92-994">Win32 では、クラスごとに 7 つの基本優先度レベルの 4 つの優先度クラスを使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-994">Win32 uses four priority classes with seven base priority levels per class.</span></span> <span data-ttu-id="48f92-995">これらのプロセス優先度クラスをキャプチャ、<xref:System.Diagnostics.ProcessPriorityClass>できるようにする列挙体にプロセスの優先順位を設定する<xref:System.Diagnostics.ProcessPriorityClass.Idle>、 <xref:System.Diagnostics.ProcessPriorityClass.Normal>、 <xref:System.Diagnostics.ProcessPriorityClass.High>、 <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>、 <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>、または<xref:System.Diagnostics.ProcessPriorityClass.RealTime>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-995">These process priority classes are captured in the <xref:System.Diagnostics.ProcessPriorityClass> enumeration, which lets you set the process priority to <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>.</span></span> <span data-ttu-id="48f92-996">プロセスがプロセッサにアクセスの他のユーザーを事前設定する必要がある場合、オペレーティング システムによって経過またはその他の要因、基本優先度レベルを変更できます時間に基づいています。</span><span class="sxs-lookup"><span data-stu-id="48f92-996">Based on the time elapsed or other boosts, the base priority level can be changed by the operating system when a process needs to be put ahead of others for access to the processor.</span></span> <span data-ttu-id="48f92-997">さらに、設定、<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>を一時的に待機状態から作成されたスレッドの優先度レベルを上げます。</span><span class="sxs-lookup"><span data-stu-id="48f92-997">In addition, you can set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> to temporarily boost the priority level of threads that have been taken out of the wait state.</span></span> <span data-ttu-id="48f92-998">優先順位は、プロセスが待機状態に戻ったときにリセットされます。</span><span class="sxs-lookup"><span data-stu-id="48f92-998">The priority is reset when the process returns to the wait state.</span></span>  
  
 <span data-ttu-id="48f92-999"><xref:System.Diagnostics.Process.BasePriority%2A>プロパティでは、プロセスに割り当てられている開始の優先順位を表示することができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-999">The <xref:System.Diagnostics.Process.BasePriority%2A> property lets you view the starting priority that is assigned to a process.</span></span> <span data-ttu-id="48f92-1000">ただし、これは、読み取り専用であるために使用できません、<xref:System.Diagnostics.Process.BasePriority%2A>プロセスの優先順位を設定するプロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1000">However, because it is read-only, you cannot use the <xref:System.Diagnostics.Process.BasePriority%2A> property to set the priority of a process.</span></span> <span data-ttu-id="48f92-1001">優先順位を変更するには、使用、<xref:System.Diagnostics.Process.PriorityClass%2A>プロパティを取得または設定、プロセスの全体的な優先順位カテゴリ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1001">To change the priority, use the <xref:System.Diagnostics.Process.PriorityClass%2A> property, which gets or sets the overall priority category for the process.</span></span>  
  
 <span data-ttu-id="48f92-1002">システム モニターを使用して、優先度クラスを表示できません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1002">The priority class cannot be viewed using System Monitor.</span></span> <span data-ttu-id="48f92-1003">次の表は、リレーションシップ、<xref:System.Diagnostics.Process.BasePriority%2A>と<xref:System.Diagnostics.Process.PriorityClass%2A>値。</span><span class="sxs-lookup"><span data-stu-id="48f92-1003">The following table shows the relationship between the <xref:System.Diagnostics.Process.BasePriority%2A> and <xref:System.Diagnostics.Process.PriorityClass%2A> values.</span></span>  
  
|<span data-ttu-id="48f92-1004">BasePriority</span><span class="sxs-lookup"><span data-stu-id="48f92-1004">BasePriority</span></span>|<span data-ttu-id="48f92-1005">PriorityClass</span><span class="sxs-lookup"><span data-stu-id="48f92-1005">PriorityClass</span></span>|  
|------------------|-------------------|  
|<span data-ttu-id="48f92-1006">4</span><span class="sxs-lookup"><span data-stu-id="48f92-1006">4</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|<span data-ttu-id="48f92-1007">8</span><span class="sxs-lookup"><span data-stu-id="48f92-1007">8</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|<span data-ttu-id="48f92-1008">13</span><span class="sxs-lookup"><span data-stu-id="48f92-1008">13</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|<span data-ttu-id="48f92-1009">24</span><span class="sxs-lookup"><span data-stu-id="48f92-1009">24</span></span>|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1010">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1010">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-1011">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1011">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-1012">例では、検出プロセスが終了し、プロセスの終了コードを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1012">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1013">関連付けられているプロセスのリソースからプロセス優先度情報を設定できないか、取得できませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1013">Process priority information could not be set or retrieved from the associated process resource.</span></span>  
  
<span data-ttu-id="48f92-1014">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1014">-or-</span></span> 
<span data-ttu-id="48f92-1015">プロセス識別子またはプロセス ハンドルが 0 です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1015">The process identifier or process handle is zero.</span></span> <span data-ttu-id="48f92-1016">(プロセスは開始されていません。)</span><span class="sxs-lookup"><span data-stu-id="48f92-1016">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-1017">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PriorityClass" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1017">You are attempting to access the <see cref="P:System.Diagnostics.Process.PriorityClass" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-1018">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1018">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1019">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できなくなっています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1019">The process <see cref="P:System.Diagnostics.Process.Id" /> is not available.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1020">Windows 98 または Windows Millennium Edition (Windows Me) を使用していて、<see cref="P:System.Diagnostics.Process.PriorityClass" /> を <see langword="AboveNormal" /> または <see langword="BelowNormal" /> に設定しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1020">You have set the <see cref="P:System.Diagnostics.Process.PriorityClass" /> to <see langword="AboveNormal" /> or <see langword="BelowNormal" /> when using Windows 98 or Windows Millennium Edition (Windows Me).</span></span> <span data-ttu-id="48f92-1021">これらのプラットフォームにおいて、優先度クラスにそれらの値はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1021">These platforms do not support those values for the priority class.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="48f92-1022"><see cref="T:System.Diagnostics.ProcessPriorityClass" /> 列挙体で定義されている有効な値が使用されていないため、優先度クラスを設定できません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1022">Priority class cannot be set because it does not use a valid value, as defined in the <see cref="T:System.Diagnostics.ProcessPriorityClass" /> enumeration.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1023">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1023">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1024">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1024">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1025">関連付けられたプロセスに割り当てられたプライベート メモリの量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1025">Gets the amount of private memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-1026">関連付けられたプロセスに割り当てられ、他のプロセスと共有できないバイト数。</span><span class="sxs-lookup"><span data-stu-id="48f92-1026">The number of bytes allocated by the associated process that cannot be shared with other processes.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1027">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1027">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1028">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1028">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1029">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1029">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1030">関連付けられたプロセスに割り当てられたプライベート メモリの量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1030">Gets the amount of private memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-1031">関連付けられたプロセスに割り当てられ、他のプロセスと共有できないメモリの量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-1031">The amount of memory, in bytes, allocated for the associated process that cannot be shared with other processes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1032">このプロパティによって返される値は、他のプロセスと共有することはできませんをバイト単位で、プロセスによって使用されるメモリの現在のサイズを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1032">The value returned by this property represents the current size of memory used by the process, in bytes, that cannot be shared with other processes.</span></span>  
  
 <span data-ttu-id="48f92-1033">このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1033">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="48f92-1034">プロパティ値が等しく、 **Private Bytes**プロセスのパフォーマンス カウンター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1034">The property value is equivalent to the **Private Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1035">次のコード例では、メモ帳アプリケーションのインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1035">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="48f92-1036">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1036">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-1037">例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1037">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1038">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1038">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1039">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1039">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1040">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1040">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1041">このプロセスの特権プロセッサ時間を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1041">Gets the privileged processor time for this process.</span></span></summary>
        <value><span data-ttu-id="48f92-1042">プロセスが、オペレーティング システム コア内でコードを実行した合計時間を示す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1042">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the process has spent running code inside the operating system core.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="48f92-1043">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1043">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-1044">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1044">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-1045">例では、検出プロセスが終了し、プロセスの終了コードを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1045">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1046">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1046">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-1047">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1047">You are attempting to access the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-1048">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1048">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1049">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1049">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1050">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1050">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1051">プロセスの名前を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1051">Gets the name of the process.</span></span></summary>
        <value><span data-ttu-id="48f92-1052">システムで使用する、ユーザーがプロセスを識別するための名前。</span><span class="sxs-lookup"><span data-stu-id="48f92-1052">The name that the system uses to identify the process to the user.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1053"><xref:System.Diagnostics.Process.ProcessName%2A>プロパティは、.exe 拡張子またはパスが含まれていない Outlook など、実行可能ファイル名を保持します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1053">The <xref:System.Diagnostics.Process.ProcessName%2A> property holds an executable file name, such as Outlook, that does not include the .exe extension or the path.</span></span> <span data-ttu-id="48f92-1054">取得すると、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1054">It is helpful for getting and manipulating all the processes that are associated with the same executable file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1055">[!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 、オペレーティング システム、<xref:System.Diagnostics.Process.ProcessName%2A>プロパティはプロセス モジュールの情報を取得できない場合、15 文字に切り捨て可能性があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1055">On [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] operating systems, the <xref:System.Diagnostics.Process.ProcessName%2A> property may be truncated to 15 characters if the process module information cannot be obtained.</span></span>  
  
 <span data-ttu-id="48f92-1056">呼び出すことができます<xref:System.Diagnostics.Process.GetProcessesByName%2A>、指定したコンピューター上のすべての実行中インスタンスを含む配列を取得する、実行可能ファイル名を渡します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1056">You can call <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passing it an executable file name, to retrieve an array that contains every running instance on the specified computer.</span></span> <span data-ttu-id="48f92-1057">たとえば、この配列を使用すると、実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1057">You can use this array, for example, to shut down all the running instances of the executable file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1058">プロセスに ID がないか、<see cref="T:System.Diagnostics.Process" /> に関連付けられているプロセスがありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1058">The process does not have an identifier, or no process is associated with the <see cref="T:System.Diagnostics.Process" />.</span></span>  
  
<span data-ttu-id="48f92-1059">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1059">-or-</span></span> 
<span data-ttu-id="48f92-1060">関連付けられたプロセスが終了しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1060">The associated process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1061">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1061">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-1062">プロセスはこのコンピューター上のものではありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1062">The process is not on this computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1063">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1063">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1064">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1064">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1065">このプロセスでのスレッドの実行をスケジュールできるプロセッサを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1065">Gets or sets the processors on which the threads in this process can be scheduled to run.</span></span></summary>
        <value><span data-ttu-id="48f92-1066">関連付けられたプロセスのスレッドを実行できるプロセッサを示すビットマスク。</span><span class="sxs-lookup"><span data-stu-id="48f92-1066">A bitmask representing the processors that the threads in the associated process can run on.</span></span> <span data-ttu-id="48f92-1067">既定値は、コンピューターのプロセッサ数によって異なります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1067">The default depends on the number of processors on the computer.</span></span> <span data-ttu-id="48f92-1068">既定値は 2 <sup>n</sup> -1 で、n はプロセッサの数です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1068">The default value is 2 <sup>n</sup> -1, where n is the number of processors.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1069">Windows 2000 以降では、プロセスのスレッドはプロセッサごとの移行、プロセッサーを移行できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1069">In Windows 2000 and later, a thread in a process can migrate from processor to processor, with each migration reloading the processor cache.</span></span> <span data-ttu-id="48f92-1070">重い負荷、プロセッサが特定のスレッドを実行する必要がありますを指定するパフォーマンスを向上できますプロセッサのキャッシュが再読み込み回数を削減します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1070">Under heavy system loads, specifying which processor should run a specific thread can improve performance by reducing the number of times the processor cache is reloaded.</span></span> <span data-ttu-id="48f92-1071">プロセッサと、スレッド間の関連付けは、プロセッサのアフィニティと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1071">The association between a processor and a thread is called the processor affinity.</span></span>  
  
 <span data-ttu-id="48f92-1072">各プロセッサは少しとして表されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1072">Each processor is represented as a bit.</span></span> <span data-ttu-id="48f92-1073">ビット 0 がいずれかのプロセッサ、ビット 1 は、2 つのプロセッサとなどです。</span><span class="sxs-lookup"><span data-stu-id="48f92-1073">Bit 0 is processor one, bit 1 is processor two, and so forth.</span></span> <span data-ttu-id="48f92-1074">値を 1 に、少し設定した場合は、対応するプロセッサがスレッドの割り当てに選択されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1074">If you set a bit to the value 1, the corresponding processor is selected for thread assignment.</span></span> <span data-ttu-id="48f92-1075">設定すると、<xref:System.Diagnostics.Process.ProcessorAffinity%2A>値を 0、オペレーティング システムには、スレッドのアフィニティにアルゴリズムのセットのスケジューリングします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1075">When you set the <xref:System.Diagnostics.Process.ProcessorAffinity%2A> value to zero, the operating system's scheduling algorithms set the thread's affinity.</span></span> <span data-ttu-id="48f92-1076">ときに、<xref:System.Diagnostics.Process.ProcessorAffinity%2A>値が 0 以外の値に設定されて、値は選択可能なプロセッサを指定するビットマスクとして解釈されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1076">When the <xref:System.Diagnostics.Process.ProcessorAffinity%2A> value is set to any nonzero value, the value is interpreted as a bitmask that specifies those processors eligible for selection.</span></span>  
  
 <span data-ttu-id="48f92-1077">次の表に、選択した<xref:System.Diagnostics.Process.ProcessorAffinity%2A>8 プロセッサ システム値です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1077">The following table shows a selection of <xref:System.Diagnostics.Process.ProcessorAffinity%2A> values for an eight-processor system.</span></span>  
  
|<span data-ttu-id="48f92-1078">ビットマスク</span><span class="sxs-lookup"><span data-stu-id="48f92-1078">Bitmask</span></span>|<span data-ttu-id="48f92-1079">バイナリ値</span><span class="sxs-lookup"><span data-stu-id="48f92-1079">Binary value</span></span>|<span data-ttu-id="48f92-1080">対象となるプロセッサ</span><span class="sxs-lookup"><span data-stu-id="48f92-1080">Eligible processors</span></span>|  
|-------------|------------------|-------------------------|  
|<span data-ttu-id="48f92-1081">0x0001</span><span class="sxs-lookup"><span data-stu-id="48f92-1081">0x0001</span></span>|<span data-ttu-id="48f92-1082">00000000 00000001</span><span class="sxs-lookup"><span data-stu-id="48f92-1082">00000000 00000001</span></span>|<span data-ttu-id="48f92-1083">1</span><span class="sxs-lookup"><span data-stu-id="48f92-1083">1</span></span>|  
|<span data-ttu-id="48f92-1084">0x0003</span><span class="sxs-lookup"><span data-stu-id="48f92-1084">0x0003</span></span>|<span data-ttu-id="48f92-1085">00000000 00000011</span><span class="sxs-lookup"><span data-stu-id="48f92-1085">00000000 00000011</span></span>|<span data-ttu-id="48f92-1086">1 と 2</span><span class="sxs-lookup"><span data-stu-id="48f92-1086">1 and 2</span></span>|  
|<span data-ttu-id="48f92-1087">0x0007</span><span class="sxs-lookup"><span data-stu-id="48f92-1087">0x0007</span></span>|<span data-ttu-id="48f92-1088">00000000 00000111</span><span class="sxs-lookup"><span data-stu-id="48f92-1088">00000000 00000111</span></span>|<span data-ttu-id="48f92-1089">1、2、3</span><span class="sxs-lookup"><span data-stu-id="48f92-1089">1, 2 and 3</span></span>|  
|<span data-ttu-id="48f92-1090">0x0009</span><span class="sxs-lookup"><span data-stu-id="48f92-1090">0x0009</span></span>|<span data-ttu-id="48f92-1091">00000000 00001001</span><span class="sxs-lookup"><span data-stu-id="48f92-1091">00000000 00001001</span></span>|<span data-ttu-id="48f92-1092">1 および 4</span><span class="sxs-lookup"><span data-stu-id="48f92-1092">1 and 4</span></span>|  
|<span data-ttu-id="48f92-1093">0x007F</span><span class="sxs-lookup"><span data-stu-id="48f92-1093">0x007F</span></span>|<span data-ttu-id="48f92-1094">00000000 01111111</span><span class="sxs-lookup"><span data-stu-id="48f92-1094">00000000 01111111</span></span>|<span data-ttu-id="48f92-1095">1、2、3、4、5、6 および 7</span><span class="sxs-lookup"><span data-stu-id="48f92-1095">1, 2, 3, 4, 5, 6 and 7</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1096">関連付けられているプロセスのリソースから <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 情報を設定できないか、取得できませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1096"><see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> information could not be set or retrieved from the associated process resource.</span></span>  
  
<span data-ttu-id="48f92-1097">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1097">-or-</span></span> 
<span data-ttu-id="48f92-1098">プロセス識別子またはプロセス ハンドルが 0 です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1098">The process identifier or process handle is zero.</span></span> <span data-ttu-id="48f92-1099">(プロセスは開始されていません。)</span><span class="sxs-lookup"><span data-stu-id="48f92-1099">(The process has not been started.)</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-1100">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1100">You are attempting to access the <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-1101">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1101">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1102">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1102">The process <see cref="P:System.Diagnostics.Process.Id" /> was not available.</span></span>  
  
<span data-ttu-id="48f92-1103">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1103">-or-</span></span> 
<span data-ttu-id="48f92-1104">プロセスが終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1104">The process has exited.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1105">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1105">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1106">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1106">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-1107">プロセス コンポーネントにキャッシュされている関連付けられたプロセスに関するすべての情報を破棄します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1107">Discards any information about the associated process that has been cached inside the process component.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1108">後<xref:System.Diagnostics.Process.Refresh%2A>を呼び出すときは、最初の要求と、関連付けられたプロセスから新しい値を取得するプロセスのコンポーネントの各プロパティについてはします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1108">After <xref:System.Diagnostics.Process.Refresh%2A> is called, the first request for information about each property causes the process component to obtain a new value from the associated process.</span></span>  
  
 <span data-ttu-id="48f92-1109">ときに、<xref:System.Diagnostics.Process>コンポーネントは、プロセスのリソースのプロパティ値に関連付け、<xref:System.Diagnostics.Process>はすぐに、関連付けられたプロセスの状態に応じて設定されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1109">When a <xref:System.Diagnostics.Process> component is associated with a process resource, the property values of the <xref:System.Diagnostics.Process> are immediately populated according to the status of the associated process.</span></span> <span data-ttu-id="48f92-1110">その後、関連付けられているプロセスに関する情報が変更された場合、それらの変更には反映されません、<xref:System.Diagnostics.Process>コンポーネントのキャッシュされた値。</span><span class="sxs-lookup"><span data-stu-id="48f92-1110">If the information about the associated process subsequently changes, those changes are not reflected in the <xref:System.Diagnostics.Process> component's cached values.</span></span> <span data-ttu-id="48f92-1111"><xref:System.Diagnostics.Process>コンポーネントが関連付けられている時にプロセス リソースのスナップショットを示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1111">The <xref:System.Diagnostics.Process> component is a snapshot of the process resource at the time they are associated.</span></span> <span data-ttu-id="48f92-1112">関連付けられたプロセスの現在の値を表示するには、呼び出し、<xref:System.Diagnostics.Process.Refresh%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-1112">To view the current values for the associated process, call the <xref:System.Diagnostics.Process.Refresh%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1113">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1113">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-1114">関連付けられたプロセスの物理メモリ使用量は 10 秒間に最大 2 秒間隔で取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1114">It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds.</span></span> <span data-ttu-id="48f92-1115">この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1115">The example detects whether the process exits before 10 seconds have elapsed.</span></span> <span data-ttu-id="48f92-1116">例は、10 秒後に実行されている場合、プロセスを閉じます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1116">The example closes the process if it is still running after 10 seconds.</span></span>  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1117">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1117">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1118">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1118">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1119">プロセスのユーザー インターフェイスが応答するかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1119">Gets a value indicating whether the user interface of the process is responding.</span></span></summary>
        <value><span data-ttu-id="48f92-1120">関連付けられたプロセスのユーザー インターフェイスがシステムに応答する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1120"><see langword="true" /> if the user interface of the associated process is responding to the system; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1121">プロセスは、ユーザー インターフェイス、<xref:System.Diagnostics.Process.Responding%2A>プロパティは、プロセスがユーザー入力に応答しているかどうかを判断するユーザー インターフェイスを接続します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1121">If a process has a user interface, the <xref:System.Diagnostics.Process.Responding%2A> property contacts the user interface to determine whether the process is responding to user input.</span></span> <span data-ttu-id="48f92-1122">インターフェイスが、すぐに応答しない場合、<xref:System.Diagnostics.Process.Responding%2A>プロパティが返す`false`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1122">If the interface does not respond immediately, the <xref:System.Diagnostics.Process.Responding%2A> property returns `false`.</span></span> <span data-ttu-id="48f92-1123">このプロパティを使用して、関連付けられたプロセスのインターフェイスが応答を停止したかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1123">Use this property to determine whether the interface of the associated process has stopped responding.</span></span>  
  
 <span data-ttu-id="48f92-1124">プロセスがない場合、 <xref:System.Diagnostics.Process.MainWindowHandle%2A>、このプロパティを返します`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1124">If the process does not have a <xref:System.Diagnostics.Process.MainWindowHandle%2A>, this property returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1125">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1125">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-1126">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1126">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-1127">例では、検出プロセスが終了し、プロセスの終了コードを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1127">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1128">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1128">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1129">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1129">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-1130">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.Responding" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1130">You are attempting to access the <see cref="P:System.Diagnostics.Process.Responding" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-1131">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1131">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1132">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1132">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1133">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1133">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1134">このプロセスへのネイティブ ハンドルを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1134">Gets the native handle to this process.</span></span></summary>
        <value><span data-ttu-id="48f92-1135">このプロセスへのネイティブ ハンドル。</span><span class="sxs-lookup"><span data-stu-id="48f92-1135">The native handle to this process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1136">ハンドルは呼び出し元のコンポーネントがプロセスを起動した場合にのみ使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1136">The handle is only available if the calling component started the process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1137">関連付けられたプロセスのターミナル サービス セッション識別子を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1137">Gets the Terminal Services session identifier for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-1138">関連付けられたプロセスのターミナル サービス セッション識別子。</span><span class="sxs-lookup"><span data-stu-id="48f92-1138">The Terminal Services session identifier for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1139"><xref:System.Diagnostics.Process.SessionId%2A>プロパティは、アプリケーションが現在実行されているセッションを識別します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1139">The <xref:System.Diagnostics.Process.SessionId%2A> property identifies the session in which the application is currently running.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="48f92-1140">このプロセスに関連付けられているセッションはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1140">There is no session associated with this process.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1141">このセッション識別子に関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1141">There is no process associated with this session identifier.</span></span>  
  
<span data-ttu-id="48f92-1142">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1142">-or-</span></span> 
<span data-ttu-id="48f92-1143">関連付けられたプロセスが、このコンピューター上にありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1143">The associated process is not on this machine.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1144"><see cref="P:System.Diagnostics.Process.SessionId" /> プロパティは Windows 98 ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1144">The <see cref="P:System.Diagnostics.Process.SessionId" /> property is not supported on Windows 98.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1145">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1145">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1146">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1146">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1147">アプリケーションのエラー出力の読み取りに使用されるストリームを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1147">Gets a stream used to read the error output of the application.</span></span></summary>
        <value><span data-ttu-id="48f92-1148">アプリケーションの標準エラー ストリームの読み取りに使用できる <see cref="T:System.IO.StreamReader" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1148">A <see cref="T:System.IO.StreamReader" /> that can be used to read the standard error stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1149">ときに、<xref:System.Diagnostics.Process>テキストがコンソールに通常表示されることを標準エラー ストリームにテキストを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1149">When a <xref:System.Diagnostics.Process> writes text to its standard error stream, that text is normally displayed on the console.</span></span> <span data-ttu-id="48f92-1150">リダイレクトすることにより、<xref:System.Diagnostics.Process.StandardError%2A>ストリームを操作するか、プロセスのエラー出力を抑制します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1150">By redirecting the <xref:System.Diagnostics.Process.StandardError%2A> stream, you can manipulate or suppress the error output of a process.</span></span> <span data-ttu-id="48f92-1151">たとえば、テキストをフィルター処理、異なる方法で書式を設定して、または、コンソールと指定したログ ファイルの両方に出力を書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1151">For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1152">使用する<xref:System.Diagnostics.Process.StandardError%2A>、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>に`false`を設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>に`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1152">To use <xref:System.Diagnostics.Process.StandardError%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="48f92-1153">それ以外の場合からの読み取り、<xref:System.Diagnostics.Process.StandardError%2A>ストリームが例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1153">Otherwise, reading from the <xref:System.Diagnostics.Process.StandardError%2A> stream throws an exception.</span></span>  
  
 <span data-ttu-id="48f92-1154">リダイレクトされた<xref:System.Diagnostics.Process.StandardError%2A>同期または非同期でストリームを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1154">The redirected <xref:System.Diagnostics.Process.StandardError%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="48f92-1155">などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスのエラー出力ストリームでの同期読み取り操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1155">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the error output stream of the process.</span></span> <span data-ttu-id="48f92-1156">関連付けられているまで操作を実行しないでこれらの同期読み取り<xref:System.Diagnostics.Process>を書き込みます、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはストリームを閉じます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1156">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardError%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="48f92-1157">これに対し、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1157">In contrast, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span> <span data-ttu-id="48f92-1158">このメソッドは、ストリーム出力に指定されたイベント ハンドラーを有効にして、すぐにストリーム出力するイベント ハンドラー中に、その他の作業を実行できる呼び出し元に返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1158">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="48f92-1159">同期読み取り操作は、呼び出し元からの読み取りとの間の依存関係を導入、<xref:System.Diagnostics.Process.StandardError%2A>ストリームと子要素は、そのストリームへの書き込みを処理します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1159">Synchronous read operations introduce a dependency between the caller reading from the <xref:System.Diagnostics.Process.StandardError%2A> stream and the child process writing to that stream.</span></span> <span data-ttu-id="48f92-1160">これらの依存関係と、デッドロック状態があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1160">These dependencies can result in deadlock conditions.</span></span> <span data-ttu-id="48f92-1161">子プロセスのリダイレクトされたストリームから読み取ると、呼び出し元は、子に依存します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1161">When the caller reads from the redirected stream of a child process, it is dependent on the child.</span></span> <span data-ttu-id="48f92-1162">呼び出し元は、子のストリームに書き込みまたはストリームを閉じるまで、読み取り操作を待機します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1162">The caller waits on the read operation until the child writes to the stream or closes the stream.</span></span> <span data-ttu-id="48f92-1163">子プロセスが、リダイレクトされたストリームを入力するための十分なデータを書き込むときに、親に依存します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1163">When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</span></span> <span data-ttu-id="48f92-1164">子プロセスは、親の完全なストリームから読み取りまたはストリームを閉じるまで、次の書き込み操作を待機します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1164">The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</span></span> <span data-ttu-id="48f92-1165">デッドロック状態の結果、呼び出し元と子プロセスが、操作を完了する相互に待機し、どちらも進むことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1165">The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</span></span> <span data-ttu-id="48f92-1166">呼び出し元と子プロセス間の依存関係を評価することによって、デッドロックを回避できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1166">You can avoid deadlocks by evaluating dependencies between the caller and child process.</span></span>  
  
 <span data-ttu-id="48f92-1167">次の c# コードでは、たとえば、リダイレクトされたストリームから読み取り、子プロセスが終了するまで待機する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1167">The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</span></span>  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 <span data-ttu-id="48f92-1168">コード例は、呼び出すことによってデッドロック状態を回避`p.StandardError.ReadToEnd`する前に`p.WaitForExit`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1168">The code example avoids a deadlock condition by calling `p.StandardError.ReadToEnd` before `p.WaitForExit`.</span></span> <span data-ttu-id="48f92-1169">デッドロック状態が生じる場合は、親プロセスが呼び出し`p.WaitForExit`する前に`p.StandardError.ReadToEnd`子プロセスは、リダイレクトされたストリームを入力するための十分なテキストを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1169">A deadlock condition can result if the parent process calls `p.WaitForExit` before `p.StandardError.ReadToEnd` and the child process writes enough text to fill the redirected stream.</span></span> <span data-ttu-id="48f92-1170">親プロセスが、子プロセスが終了する無期限に待機します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1170">The parent process would wait indefinitely for the child process to exit.</span></span> <span data-ttu-id="48f92-1171">完全なから読み取る親の子プロセスを無制限に待機が<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1171">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="48f92-1172">同様の問題がある、標準出力と標準エラー ストリームからすべてのテキストを読み取るときにします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1172">There is a similar issue when you read all text from both the standard output and standard error streams.</span></span> <span data-ttu-id="48f92-1173">たとえば、次の c# コードは、両方のストリームで読み取り操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1173">The following C# code, for example, performs a read operation on both streams.</span></span>  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="48f92-1174">コード例では、デッドロック状態を回避非同期の読み取り操作を実行して、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1174">The code example avoids the deadlock condition by performing asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="48f92-1175">デッドロック状態が、親の呼び出しを処理する場合に結果`p.StandardOutput.ReadToEnd`続けて`p.StandardError.ReadToEnd`子プロセスが、エラー ストリームを入力するための十分なテキストを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1175">A deadlock condition results if the parent process calls `p.StandardOutput.ReadToEnd` followed by `p.StandardError.ReadToEnd` and the child process writes enough text to fill its error stream.</span></span> <span data-ttu-id="48f92-1176">子プロセスが終了する親プロセスが無期限に待機がその<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1176">The parent process would wait indefinitely for the child process to close its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="48f92-1177">完全なから読み取る親の子プロセスを無制限に待機が<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1177">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="48f92-1178">非同期の読み取り操作は、これらの依存関係とデッドロックの可能性を回避するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1178">You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</span></span> <span data-ttu-id="48f92-1179">または、別のスレッドで各ストリームの出力の読み取りを 2 つのスレッドを作成してデッドロックの状態を回避できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1179">Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1180">リダイレクトされたストリームで読み取り操作を非同期と同期を混在させることはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1180">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="48f92-1181">リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1181">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="48f92-1182">例に従っていない<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>への呼び出しで<xref:System.IO.StreamReader.ReadLine%2A>上、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはその逆。</span><span class="sxs-lookup"><span data-stu-id="48f92-1182">For example, do not follow <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardError%2A> stream, or vice versa.</span></span> <span data-ttu-id="48f92-1183">ただし、異なるモードでの 2 つの異なるストリームを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1183">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="48f92-1184">たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を呼び出して<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1184">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1185">次の例では、`net use`コマンドをユーザーがネットワーク リソースをマップする引数を指定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1185">The following example uses the `net use` command together with a user supplied argument to map a network resource.</span></span> <span data-ttu-id="48f92-1186">Net コマンドの標準エラー ストリームを読み取るし、コンソールに書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1186">It then reads the standard error stream of the net command and writes it to console.</span></span>  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1187"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームがリダイレクト用に定義されていません。<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> が <see langword="true" /> に設定されており、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> が <see langword="false" /> に設定されていることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="48f92-1187">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.</span></span>  
  
<span data-ttu-id="48f92-1188">\- または</span><span class="sxs-lookup"><span data-stu-id="48f92-1188">\- or -</span></span> 
<span data-ttu-id="48f92-1189"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームが、<see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> を使用した非同期読み取り操作のために開いています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1189">The <see cref="P:System.Diagnostics.Process.StandardError" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1190">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1190">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1191">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1191">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1192">アプリケーションの入力の書き込みに使用されるストリームを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1192">Gets a stream used to write the input of the application.</span></span></summary>
        <value><span data-ttu-id="48f92-1193">アプリケーションの標準入力ストリームの書き込みに使用できる <see cref="T:System.IO.StreamWriter" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1193">A <see cref="T:System.IO.StreamWriter" /> that can be used to write the standard input stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1194">A<xref:System.Diagnostics.Process>標準入力ストリーム、通常は、キーボードから入力テキストを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1194">A <xref:System.Diagnostics.Process> can read input text from its standard input stream, typically the keyboard.</span></span> <span data-ttu-id="48f92-1195">リダイレクトすることにより、 <xref:System.Diagnostics.Process.StandardInput%2A> 、ストリーム入力をプログラムで指定できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1195">By redirecting the <xref:System.Diagnostics.Process.StandardInput%2A> stream, you can programmatically specify the input.</span></span> <span data-ttu-id="48f92-1196">たとえば、キーボード入力を使用する代わりに、指定したファイルの内容をテキストまたは別のアプリケーションからの出力を指定できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1196">For example, instead of using keyboard input, you can provide text from the contents of a designated file or output from another application.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1197">使用する<xref:System.Diagnostics.Process.StandardInput%2A>、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>に`false`を設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>に`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1197">To use <xref:System.Diagnostics.Process.StandardInput%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="48f92-1198">それ以外の場合、書き込み、<xref:System.Diagnostics.Process.StandardInput%2A>ストリームが例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1198">Otherwise, writing to the <xref:System.Diagnostics.Process.StandardInput%2A> stream throws an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1199">次の例では、リダイレクトする方法を示しています、<xref:System.Diagnostics.Process.StandardInput%2A>プロセスのストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1199">The following example illustrates how to redirect the <xref:System.Diagnostics.Process.StandardInput%2A> stream of a process.</span></span> <span data-ttu-id="48f92-1200">例は、開始、`sort`リダイレクトされた入力とコマンド。</span><span class="sxs-lookup"><span data-stu-id="48f92-1200">The example starts the `sort` command with redirected input.</span></span> <span data-ttu-id="48f92-1201">次に、テキストのユーザーに求めますを渡して、`sort`プロセスによってリダイレクトされた<xref:System.Diagnostics.Process.StandardInput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1201">It then prompts the user for text, and passes that to the `sort` process by means of the redirected <xref:System.Diagnostics.Process.StandardInput%2A> stream.</span></span> <span data-ttu-id="48f92-1202">`sort`コンソールのユーザーに結果が表示されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1202">The `sort` results are displayed to the user on the console.</span></span>  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1203"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> が <see langword="false" /> に設定されているため、<see cref="P:System.Diagnostics.Process.StandardInput" /> ストリームが定義されませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1203">The <see cref="P:System.Diagnostics.Process.StandardInput" /> stream has not been defined because <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> is set to <see langword="false" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1204">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1204">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1205">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1205">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1206">アプリケーションのテキスト出力の読み取りに使用されるストリームを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1206">Gets a stream used to read the textual output of the application.</span></span></summary>
        <value><span data-ttu-id="48f92-1207">アプリケーションの標準出力ストリームの読み取りに使用できる <see cref="T:System.IO.StreamReader" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1207">A <see cref="T:System.IO.StreamReader" /> that can be used to read the standard output stream of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1208">ときに、<xref:System.Diagnostics.Process>テキストがコンソールに通常表示されることを標準ストリームにテキストを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1208">When a <xref:System.Diagnostics.Process> writes text to its standard stream, that text is normally displayed on the console.</span></span> <span data-ttu-id="48f92-1209">リダイレクトすることにより、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームを操作するか、プロセスの出力を抑制します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1209">By redirecting the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, you can manipulate or suppress the output of a process.</span></span> <span data-ttu-id="48f92-1210">たとえば、テキストをフィルター処理、異なる方法で書式を設定して、または、コンソールと指定したログ ファイルの両方に出力を書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1210">For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1211">使用する<xref:System.Diagnostics.Process.StandardOutput%2A>、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>に`false`を設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>に`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1211">To use <xref:System.Diagnostics.Process.StandardOutput%2A>, you must set <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> to `false`, and you must set <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> to `true`.</span></span> <span data-ttu-id="48f92-1212">それ以外の場合からの読み取り、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームが例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1212">Otherwise, reading from the <xref:System.Diagnostics.Process.StandardOutput%2A> stream throws an exception.</span></span>  
  
 <span data-ttu-id="48f92-1213">リダイレクトされた<xref:System.Diagnostics.Process.StandardOutput%2A>同期または非同期でストリームを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1213">The redirected <xref:System.Diagnostics.Process.StandardOutput%2A> stream can be read synchronously or asynchronously.</span></span> <span data-ttu-id="48f92-1214">などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスの出力ストリームに同期の読み取り操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1214">Methods such as <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, and <xref:System.IO.StreamReader.ReadToEnd%2A> perform synchronous read operations on the output stream of the process.</span></span> <span data-ttu-id="48f92-1215">関連付けられているまで操作を実行しないでこれらの同期読み取り<xref:System.Diagnostics.Process>を書き込みます、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはストリームを閉じます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1215">These synchronous read operations do not complete until the associated <xref:System.Diagnostics.Process> writes to its <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or closes the stream.</span></span>  
  
 <span data-ttu-id="48f92-1216">これに対し、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1216">In contrast, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> starts asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="48f92-1217">このメソッドは、ストリーム出力に指定されたイベント ハンドラーを有効にして、すぐにストリーム出力するイベント ハンドラー中に、その他の作業を実行できる呼び出し元に返します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1217">This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</span></span>  
  
 <span data-ttu-id="48f92-1218">同期読み取り操作は、呼び出し元からの読み取りとの間の依存関係を導入、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームと子要素は、そのストリームへの書き込みを処理します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1218">Synchronous read operations introduce a dependency between the caller reading from the <xref:System.Diagnostics.Process.StandardOutput%2A> stream and the child process writing to that stream.</span></span> <span data-ttu-id="48f92-1219">これらの依存関係と、デッドロック状態があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1219">These dependencies can result in deadlock conditions.</span></span> <span data-ttu-id="48f92-1220">子プロセスのリダイレクトされたストリームから読み取ると、呼び出し元は、子に依存します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1220">When the caller reads from the redirected stream of a child process, it is dependent on the child.</span></span> <span data-ttu-id="48f92-1221">呼び出し元は、子のストリームに書き込みまたはストリームを閉じるまで、読み取り操作を待機します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1221">The caller waits on the read operation until the child writes to the stream or closes the stream.</span></span> <span data-ttu-id="48f92-1222">子プロセスが、リダイレクトされたストリームを入力するための十分なデータを書き込むときに、親に依存します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1222">When the child process writes enough data to fill its redirected stream, it is dependent on the parent.</span></span> <span data-ttu-id="48f92-1223">子プロセスは、親の完全なストリームから読み取りまたはストリームを閉じるまで、次の書き込み操作を待機します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1223">The child process waits on the next write operation until the parent reads from the full stream or closes the stream.</span></span> <span data-ttu-id="48f92-1224">デッドロック状態の結果、呼び出し元と子プロセスが、操作を完了する相互に待機し、どちらも進むことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1224">The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed.</span></span> <span data-ttu-id="48f92-1225">呼び出し元と子プロセス間の依存関係を評価することによって、デッドロックを回避できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1225">You can avoid deadlocks by evaluating dependencies between the caller and child process.</span></span>  
  
 <span data-ttu-id="48f92-1226">次の c# コードでは、たとえば、リダイレクトされたストリームから読み取り、子プロセスが終了するまで待機する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1226">The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</span></span>  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="48f92-1227">コード例は、呼び出すことによってデッドロック状態を回避`p.StandardOutput.ReadToEnd`する前に`p.WaitForExit`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1227">The code example avoids a deadlock condition by calling `p.StandardOutput.ReadToEnd` before `p.WaitForExit`.</span></span> <span data-ttu-id="48f92-1228">デッドロック状態が生じる場合は、親プロセスが呼び出し`p.WaitForExit`する前に`p.StandardOutput.ReadToEnd`子プロセスは、リダイレクトされたストリームを入力するための十分なテキストを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1228">A deadlock condition can result if the parent process calls `p.WaitForExit` before `p.StandardOutput.ReadToEnd` and the child process writes enough text to fill the redirected stream.</span></span> <span data-ttu-id="48f92-1229">親プロセスが、子プロセスが終了する無期限に待機します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1229">The parent process would wait indefinitely for the child process to exit.</span></span> <span data-ttu-id="48f92-1230">完全なから読み取る親の子プロセスを無制限に待機が<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1230">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span>  
  
 <span data-ttu-id="48f92-1231">同様の問題がある、標準出力と標準エラー ストリームからすべてのテキストを読み取るときにします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1231">There is a similar issue when you read all text from both the standard output and standard error streams.</span></span> <span data-ttu-id="48f92-1232">たとえば、次の c# コードは、両方のストリームで読み取り操作を実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1232">The following C# code, for example, performs a read operation on both streams.</span></span>  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 <span data-ttu-id="48f92-1233">コード例では、デッドロック状態を回避非同期の読み取り操作を実行して、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1233">The code example avoids the deadlock condition by performing asynchronous read operations on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="48f92-1234">デッドロック状態が、親の呼び出しを処理する場合に結果`p.StandardOutput.ReadToEnd`続けて`p.StandardError.ReadToEnd`子プロセスが、エラー ストリームを入力するための十分なテキストを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1234">A deadlock condition results if the parent process calls `p.StandardOutput.ReadToEnd` followed by `p.StandardError.ReadToEnd` and the child process writes enough text to fill its error stream.</span></span> <span data-ttu-id="48f92-1235">子プロセスが終了する親プロセスが無期限に待機がその<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1235">The parent process would wait indefinitely for the child process to close its <xref:System.Diagnostics.Process.StandardOutput%2A> stream.</span></span> <span data-ttu-id="48f92-1236">完全なから読み取る親の子プロセスを無制限に待機が<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1236">The child process would wait indefinitely for the parent to read from the full <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
 <span data-ttu-id="48f92-1237">非同期の読み取り操作は、これらの依存関係とデッドロックの可能性を回避するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1237">You can use asynchronous read operations to avoid these dependencies and their deadlock potential.</span></span> <span data-ttu-id="48f92-1238">または、別のスレッドで各ストリームの出力の読み取りを 2 つのスレッドを作成してデッドロックの状態を回避できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1238">Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1239">リダイレクトされたストリームで読み取り操作を非同期と同期を混在させることはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1239">You cannot mix asynchronous and synchronous read operations on a redirected stream.</span></span> <span data-ttu-id="48f92-1240">リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1240">Once the redirected stream of a <xref:System.Diagnostics.Process> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode.</span></span> <span data-ttu-id="48f92-1241">例に従っていない<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>への呼び出しで<xref:System.IO.StreamReader.ReadLine%2A>上、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはその逆。</span><span class="sxs-lookup"><span data-stu-id="48f92-1241">For example, do not follow <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> with a call to <xref:System.IO.StreamReader.ReadLine%2A> on the <xref:System.Diagnostics.Process.StandardOutput%2A> stream, or vice versa.</span></span> <span data-ttu-id="48f92-1242">ただし、異なるモードでの 2 つの異なるストリームを読み取ることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1242">However, you can read two different streams in different modes.</span></span> <span data-ttu-id="48f92-1243">たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を呼び出して<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。</span><span class="sxs-lookup"><span data-stu-id="48f92-1243">For example, you can call <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> and then call <xref:System.IO.StreamReader.ReadLine%2A> for the <xref:System.Diagnostics.Process.StandardError%2A> stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1244">次の例では、ipconfig.exe コマンドを実行し、例のコンソール ウィンドウにその標準出力をリダイレクトします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1244">The following example runs the ipconfig.exe command and redirects its standard output to the example's console window.</span></span>  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1245"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームがリダイレクト用に定義されていません。<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> が <see langword="true" /> に設定されており、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> が <see langword="false" /> に設定されていることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="48f92-1245">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has not been defined for redirection; ensure <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> is set to <see langword="true" /> and <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> is set to <see langword="false" />.</span></span>  
  
<span data-ttu-id="48f92-1246">\- または</span><span class="sxs-lookup"><span data-stu-id="48f92-1246">\- or -</span></span> 
<span data-ttu-id="48f92-1247"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームが、<see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> を使用した非同期読み取り操作のために開いています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1247">The <see cref="P:System.Diagnostics.Process.StandardOutput" /> stream has been opened for asynchronous read operations with <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1248">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1248">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1249">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1249">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="48f92-1250">プロセス リソースを起動し、<see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1250">Starts a process resource and associates it with a <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-1251">この <see cref="T:System.Diagnostics.Process" /> コンポーネントの <see cref="P:System.Diagnostics.Process.StartInfo" /> プロパティで指定されたプロセス リソースを起動 (または再利用) し、コンポーネントに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1251">Starts (or reuses) the process resource that is specified by the <see cref="P:System.Diagnostics.Process.StartInfo" /> property of this <see cref="T:System.Diagnostics.Process" /> component and associates it with the component.</span></span></summary>
        <returns><span data-ttu-id="48f92-1252">プロセス リソースが起動された場合は <see langword="true" />。新しいプロセス リソースが起動されなかった場合は <see langword="false" /> (既存のプロセスを再利用した場合など)。</span><span class="sxs-lookup"><span data-stu-id="48f92-1252"><see langword="true" /> if a process resource is started; <see langword="false" /> if no new process resource is started (for example, if an existing process is reused).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1253">このオーバー ロードを使用してプロセス リソースを起動し、現在に関連付ける<xref:System.Diagnostics.Process>コンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-1253">Use this overload to start a process resource and associate it with the current <xref:System.Diagnostics.Process> component.</span></span> <span data-ttu-id="48f92-1254">戻り値`true`新しいプロセス リソースが開始されたことを示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1254">The return value `true` indicates that a new process resource was started.</span></span> <span data-ttu-id="48f92-1255">指定されたプロセス リソースがある場合、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティが既にコンピューターで実行されている、リソースの追加のプロセスは起動されません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1255">If the process resource specified by the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property is already running on the computer, no additional process resource is started.</span></span> <span data-ttu-id="48f92-1256">代わりに、実行中のプロセス リソースを再利用と`false`が返されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1256">Instead, the running process resource is reused and `false` is returned.</span></span>  
  
 <span data-ttu-id="48f92-1257">ClickOnce アプリケーションを起動するには、アプリケーションをインストールした最初の場所 (たとえば、Web アドレス) を指定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1257">You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="48f92-1258">ClickOnce アプリケーションは、ハード ドライブ上のインストール場所を指定することで開始されません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1258">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1259">Visual Studio でのこのオーバー ロードを使用している場合、<xref:System.Diagnostics.Process.Start%2A>メソッドは、ドラッグした後、コードに挿入する 1 つ、<xref:System.Diagnostics.Process>コンポーネントをデザイナーにします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1259">If you are using Visual Studio, this overload of the <xref:System.Diagnostics.Process.Start%2A> method is the one that you insert into your code after you drag a <xref:System.Diagnostics.Process> component onto the designer.</span></span> <span data-ttu-id="48f92-1260">使用して、`Properties`を展開するにはウィンドウ、`StartInfo`カテゴリに適切な値を書き込むと、`FileName`プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1260">Use the `Properties` window to expand the `StartInfo` category and write the appropriate value into the `FileName` property.</span></span> <span data-ttu-id="48f92-1261">フォームの変更内容が表示されます`InitializeComponent`プロシージャ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1261">Your changes will appear in the form's `InitializeComponent` procedure.</span></span>  
  
 <span data-ttu-id="48f92-1262">このオーバー ロード<xref:System.Diagnostics.Process.Start%2A>でない、`static`メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-1262">This overload of <xref:System.Diagnostics.Process.Start%2A> is not a `static` method.</span></span> <span data-ttu-id="48f92-1263">インスタンスから呼び出す必要がある、<xref:System.Diagnostics.Process>クラス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1263">You must call it from an instance of the <xref:System.Diagnostics.Process> class.</span></span> <span data-ttu-id="48f92-1264">呼び出しの前に<xref:System.Diagnostics.Process.Start%2A>、最初に指定する必要があります<xref:System.Diagnostics.Process.StartInfo%2A>プロパティについては、この<xref:System.Diagnostics.Process>インスタンスは、その情報を使用して起動するプロセスのリソースを決定するためです。</span><span class="sxs-lookup"><span data-stu-id="48f92-1264">Before calling <xref:System.Diagnostics.Process.Start%2A>, you must first specify <xref:System.Diagnostics.Process.StartInfo%2A> property information for this <xref:System.Diagnostics.Process> instance, because that information is used to determine the process resource to start.</span></span>  
  
 <span data-ttu-id="48f92-1265">その他のオーバー ロード、<xref:System.Diagnostics.Process.Start%2A>メソッドは`static`メンバー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1265">The other overloads of the <xref:System.Diagnostics.Process.Start%2A> method are `static` members.</span></span> <span data-ttu-id="48f92-1266">インスタンスを作成する必要はありません、<xref:System.Diagnostics.Process>コンポーネント、メソッドのこれらのオーバー ロードを呼び出す前にします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1266">You do not need to create an instance of the <xref:System.Diagnostics.Process> component before you call those overloads of the method.</span></span> <span data-ttu-id="48f92-1267">代わりに、呼び出すことができます<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>クラス自体、および新しい<xref:System.Diagnostics.Process>プロセスが開始された場合、コンポーネントを作成します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1267">Instead, you can call <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> class itself, and a new <xref:System.Diagnostics.Process> component is created if the process was started.</span></span> <span data-ttu-id="48f92-1268">または、`null`プロセスが再利用されたかどうかに返されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1268">Or, `null` is returned if a process was reused.</span></span> <span data-ttu-id="48f92-1269">プロセス リソースが自動的に新しい関連付け<xref:System.Diagnostics.Process>コンポーネントによって返される、<xref:System.Diagnostics.Process.Start%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-1269">The process resource is automatically associated with the new <xref:System.Diagnostics.Process> component that is returned by the <xref:System.Diagnostics.Process.Start%2A> method.</span></span>  
  
 <span data-ttu-id="48f92-1270"><xref:System.Diagnostics.Process.StartInfo%2A>の機能を複製するメンバーを使用できる、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1270">The <xref:System.Diagnostics.Process.StartInfo%2A> members can be used to duplicate the functionality of the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="48f92-1271">適切な値を設定してコマンドラインに入力できるものを起動することができます、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1271">Anything that can be typed into a command line can be started by setting the appropriate values in the <xref:System.Diagnostics.Process.StartInfo%2A> property.</span></span> <span data-ttu-id="48f92-1272">唯一<xref:System.Diagnostics.Process.StartInfo%2A>プロパティを設定する必要がありますが、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1272">The only <xref:System.Diagnostics.Process.StartInfo%2A> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="48f92-1273"><xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは実行可能ファイルは指定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1273">The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not have to be an executable file.</span></span> <span data-ttu-id="48f92-1274">拡張機能は、システムにインストールされているアプリケーションに関連付けられた任意のファイルの種類のことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1274">It can be of any file type for which the extension has been associated with an application that is installed on the system.</span></span> <span data-ttu-id="48f92-1275">たとえば、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>にメモ帳などのエディターでテキスト ファイルを関連付けるか、Microsoft Word などのワード プロセッシング ツールを使用してファイルを関連付けている場合、拡張子 .doc ことができる場合、プロパティは .txt 拡張子を持つことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1275">For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span>  
  
 <span data-ttu-id="48f92-1276">コマンドラインでは、特定の種類のファイルを実行するアクションを指定できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1276">In the command line, you can specify actions to take for certain types of files.</span></span> <span data-ttu-id="48f92-1277">たとえば、ドキュメントを印刷またはテキスト ファイルを編集できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1277">For example, you can print documents or edit text files.</span></span> <span data-ttu-id="48f92-1278">使用してこれらのアクションを指定、<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1278">Specify these actions using the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property.</span></span> <span data-ttu-id="48f92-1279">ファイルを起動するときに他の種類のファイルには、コマンドライン引数を指定することができます、 `Run`  ダイアログ ボックス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1279">For other types of files, you can specify command-line arguments when you start the file from the `Run` dialog box.</span></span> <span data-ttu-id="48f92-1280">たとえば、することができます、URL を引数として渡しますとしてブラウザーを指定する場合、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1280">For example, you can pass a URL as an argument if you specify your browser as the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>.</span></span> <span data-ttu-id="48f92-1281">これらの引数で指定できます、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティの<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>メンバー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1281">These arguments can be specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> member.</span></span>  
  
 <span data-ttu-id="48f92-1282">引用符を使用して、システムで宣言されているパス変数があれば、その場所で見つかったすべてのプロセスを開始するときにそのパスを完全に修飾する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1282">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="48f92-1283">それ以外の場合、システムでは、パスは検索されません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1283">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="48f92-1284">たとえば場合、`c:\mypath`パスには引用符を使用してファイルを追加:`path = %path%;"c:\mypath"`の任意のプロセスを完全に修飾する必要があります`c:\mypath`開始するとき。</span><span class="sxs-lookup"><span data-stu-id="48f92-1284">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1285">ASP.NET Web ページとサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1285">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="48f92-1286">使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッド、ASP.NET Web ページまたはサーバー コントロールで、制限されたアクセス許可を持つ Web サーバーで、新しいプロセスを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1286">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="48f92-1287">プロセスでは、クライアントのブラウザーと同じコンテキストで起動しないと、ユーザーのデスクトップへのアクセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1287">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="48f92-1288">使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1288">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="48f92-1289">使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1289">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="48f92-1290">使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1290">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="48f92-1291">マネージ スレッドのアパートメント状態に関する注意事項がここで必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1291">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="48f92-1292">ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`プロセス コンポーネントの<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、属性を設定して、アプリケーションでスレッド モデルを設定することを確認`[STAThread]`上、`main()`メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-1292">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="48f92-1293">それ以外の場合、マネージ スレッドがであることができます、`unknown`状態またはに、`MTA`状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1293">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="48f92-1294">いくつかのメソッドのアパートメント状態でないことが必要な`unknown`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1294">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="48f92-1295">状態が明示的に設定されていないアプリケーションは、このようなメソッドを検出すると場合、既定`MTA`、一度設定すると、アパートメント状態が変更ことはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1295">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="48f92-1296">ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1296">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1297">次の例のインスタンスを使用して、<xref:System.Diagnostics.Process>プロセスを開始するクラス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1297">The following example uses an instance of the <xref:System.Diagnostics.Process> class to start a process.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1298"><see cref="T:System.Diagnostics.Process" /> コンポーネントの <see cref="P:System.Diagnostics.Process.StartInfo" /> にファイル名が指定されませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1298">No file name was specified in the <see cref="T:System.Diagnostics.Process" /> component's <see cref="P:System.Diagnostics.Process.StartInfo" />.</span></span>
<span data-ttu-id="48f92-1299">あるいは、<see cref="P:System.Diagnostics.Process.StartInfo" /> プロパティの<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> メンバーは <see langword="true" /> ですが、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />、または <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> は <see langword="true" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1299">-or- The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> member of the <see cref="P:System.Diagnostics.Process.StartInfo" /> property is <see langword="true" /> while <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1300">関連付けられているファイルを開いているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1300">There was an error in opening the associated file.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="48f92-1301">プロセス オブジェクトは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1301">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1302">メソッドはシェルがサポートされていない Nano Server (.NET Core のみ) などのオペレーティング システムではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1302">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1303">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1303">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1304">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1304">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo"><span data-ttu-id="48f92-1305">ファイル名やコマンド ライン引数など、プロセスの起動に使用する情報が格納されている <see cref="T:System.Diagnostics.ProcessStartInfo" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1305">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that contains the information that is used to start the process, including the file name and any command-line arguments.</span></span></param>
        <summary><span data-ttu-id="48f92-1306">プロセス起動情報 (起動するプロセスのファイル名など) が格納されているパラメーターで指定されたプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1306">Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="48f92-1307">プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1307">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="48f92-1308">同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1308">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="48f92-1309">また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1309">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="48f92-1310">その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1310">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1311">このオーバー ロードを使用して指定してプロセス リソースを開始する、<xref:System.Diagnostics.ProcessStartInfo>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1311">Use this overload to start a process resource by specifying a <xref:System.Diagnostics.ProcessStartInfo> instance.</span></span> <span data-ttu-id="48f92-1312">オーバー ロードは、新しいリソースに関連付けます<xref:System.Diagnostics.Process>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="48f92-1312">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1313">プロセスが開始されていないを開始する実行可能ファイルのアドレスが URL の場合と`null`が返されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1313">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="48f92-1314">このオーバー ロードでは、最初に、新しい作成せず、プロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1314">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="48f92-1315">このオーバー ロードを使用して、<xref:System.Diagnostics.ProcessStartInfo>パラメーターは、新しいを作成する明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>設定インスタンスその<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および通話<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1315">Using this overload with a <xref:System.Diagnostics.ProcessStartInfo> parameter is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting its <xref:System.Diagnostics.Process.StartInfo%2A> properties, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="48f92-1316">使用して、<xref:System.Diagnostics.ProcessStartInfo>ように、パラメーターを指定する呼び出しをインスタンス<xref:System.Diagnostics.Process.Start%2A>を最大限にプロセスを開始する呼び出しに渡される内容が制御します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1316">Using a <xref:System.Diagnostics.ProcessStartInfo> instance as the parameter lets you call <xref:System.Diagnostics.Process.Start%2A> with the most control over what is passed into the call to start the process.</span></span> <span data-ttu-id="48f92-1317">ファイル名のみ、またはファイル名と引数を渡す必要がある場合は、新たに作成する必要はありません<xref:System.Diagnostics.ProcessStartInfo>オプションですが、インスタンスします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1317">If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref:System.Diagnostics.ProcessStartInfo> instance, although that is an option.</span></span> <span data-ttu-id="48f92-1318">唯一<xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>プロパティを設定する必要がありますが、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1318">The only <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> property that must be set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="48f92-1319"><xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、実行可能ファイルを表す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1319">The <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file.</span></span> <span data-ttu-id="48f92-1320">拡張機能は、システムにインストールされているアプリケーションに関連付けられた任意のファイルの種類のことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1320">It can be of any file type for which the extension has been associated with an application that is installed on the system.</span></span> <span data-ttu-id="48f92-1321">たとえば、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>にメモ帳などのエディターでテキスト ファイルを関連付けるか、Microsoft Word などのワード プロセッシング ツールを使用してファイルを関連付けている場合、拡張子 .doc ことができる場合、プロパティは .txt 拡張子を持つことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1321">For example, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span>  
  
 <span data-ttu-id="48f92-1322">ClickOnce アプリケーションを起動するには、アプリケーションをインストールした最初の場所 (たとえば、Web アドレス) を指定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1322">You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="48f92-1323">ClickOnce アプリケーションは、ハード ドライブ上のインストール場所を指定することで開始されません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1323">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="48f92-1324">場合、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>と<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>インスタンスが設定、管理されていない`CreateProcessWithLogonW`関数が呼び出されると、新しいウィンドウいてでプロセスを開始する、<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType>プロパティの値が`true`または、 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>プロパティの値が<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1324">If the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> instance are set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> property value is <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>.</span></span> <span data-ttu-id="48f92-1325">場合、<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>プロパティは`null`、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>プロパティは、UPN の形式である必要があります*ユーザー*@*DNS_domain_name*します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1325">If the <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> property is `null`, the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> property must be in UPN format, *user*@*DNS_domain_name*.</span></span>   
  
 <span data-ttu-id="48f92-1326">その他のオーバー ロードのオーバー ロードとは異なり<xref:System.Diagnostics.Process.Start%2A>パラメーターを持たないが、`static`メンバー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1326">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="48f92-1327">既に作成しているとき、オーバー ロードを使用して、<xref:System.Diagnostics.Process>インスタンス、(ファイル名を含む)、指定した開始情報と関連付ける既存のプロセス リソースを開始する<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1327">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="48f92-1328">いずれかを使用して、`static`を新規作成するときにオーバー ロード<xref:System.Diagnostics.Process>既存のコンポーネントのプロセスを開始するのではなくコンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-1328">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="48f92-1329">このオーバー ロードとパラメーターがないオーバー ロードの両方を使用してプロセス リソースの開始情報を指定することを許可する<xref:System.Diagnostics.ProcessStartInfo>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1329">Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref:System.Diagnostics.ProcessStartInfo> instance.</span></span>  
  
 <span data-ttu-id="48f92-1330">引用符を使用して、システムで宣言されているパス変数があれば、その場所で見つかったすべてのプロセスを開始するときにそのパスを完全に修飾する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1330">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="48f92-1331">それ以外の場合、システムでは、パスは検索されません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1331">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="48f92-1332">たとえば場合、`c:\mypath`パスには引用符を使用してファイルを追加:`path = %path%;"c:\mypath"`の任意のプロセスを完全に修飾する必要があります`c:\mypath`開始するとき。</span><span class="sxs-lookup"><span data-stu-id="48f92-1332">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1333">ASP.NET Web ページとサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1333">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="48f92-1334">使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッド、ASP.NET Web ページまたはサーバー コントロールで、制限されたアクセス許可を持つ Web サーバーで、新しいプロセスを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1334">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="48f92-1335">プロセスでは、クライアントのブラウザーと同じコンテキストで起動しないと、ユーザーのデスクトップへのアクセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1335">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="48f92-1336">使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1336">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="48f92-1337">使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1337">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="48f92-1338">使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1338">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="48f92-1339">マネージ スレッドのアパートメント状態に関する注意事項がここで必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1339">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="48f92-1340">ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`上、`startInfo`パラメーター、属性を設定して、アプリケーションでスレッド モデルを設定することを確認`[STAThread]`上、`main()`メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-1340">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the `startInfo` parameter, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="48f92-1341">それ以外の場合、マネージ スレッドがであることができます、`unknown`状態またはに、`MTA`状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1341">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="48f92-1342">いくつかのメソッドのアパートメント状態でないことが必要な`unknown`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1342">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="48f92-1343">状態が明示的に設定されていないアプリケーションは、このようなメソッドを検出すると場合、既定`MTA`、一度設定すると、アパートメント状態が変更ことはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1343">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="48f92-1344">ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1344">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1345">まず、次の例は、Internet Explorer のインスタンスを生成し、ブラウザーで [お気に入り] フォルダーの内容を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1345">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="48f92-1346">Internet Explorer の他のいくつかのインスタンスを起動し、特定のページまたはサイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1346">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="48f92-1347">最後に、特定のサイトに移動する際に最小化ウィンドウで Internet Explorer を起動します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1347">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 <span data-ttu-id="48f92-1348">このメソッドの他の使用の他の例の個々 のプロパティを参照してください、<xref:System.Diagnostics.ProcessStartInfo>クラス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1348">For additional examples of other uses of this method, refer to the individual properties of the <xref:System.Diagnostics.ProcessStartInfo> class.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1349"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> プロパティにファイル名が指定されませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1349">No file name was specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property.</span></span>  
  
<span data-ttu-id="48f92-1350">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1350">-or-</span></span> 
<span data-ttu-id="48f92-1351"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティは <see langword="true" /> であり、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />、または <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> プロパティも <see langword="true" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1351">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, or <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> property is also <see langword="true" />.</span></span>  
  
<span data-ttu-id="48f92-1352">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1352">-or-</span></span> 
<span data-ttu-id="48f92-1353"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティは <see langword="true" /> であり、<see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> プロパティは <see langword="null" /> でも空でもないか、または <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> プロパティは <see langword="null" /> ではありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1353">The <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> property of the <paramref name="startInfo" /> parameter is <see langword="true" /> and the <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> property is not <see langword="null" /> or empty or the <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> property is not <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="48f92-1354"><paramref name="startInfo" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1354">The <paramref name="startInfo" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="48f92-1355">プロセス オブジェクトは既には破棄されています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1355">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="48f92-1356"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> プロパティに指定されたファイルを見つけることができませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1356">The file specified in the <paramref name="startInfo" /> parameter's <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> property could not be found.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1357">関連付けられているファイルを開いているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1357">An error occurred when opening the associated file.</span></span>  
  
<span data-ttu-id="48f92-1358">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-1358">-or-</span></span> 
<span data-ttu-id="48f92-1359">引数の長さとプロセスへの完全パスの長さの合計が、2080 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1359">The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</span></span> <span data-ttu-id="48f92-1360">この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます" </span><span class="sxs-lookup"><span data-stu-id="48f92-1360">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="48f92-1361">または「アクセスが拒否されました。」</span><span class="sxs-lookup"><span data-stu-id="48f92-1361">or "Access is denied."</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1362">メソッドはシェルがサポートされていない Nano Server (.NET Core のみ) などのオペレーティング システムではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1362">Method not supported on operating systems without shell support such as Nano Server (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1363">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1363">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1364">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1364">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="48f92-1365">プロセスで実行する文書またはアプリケーション ファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="48f92-1365">The name of a document or application file to run in the process.</span></span></param>
        <summary><span data-ttu-id="48f92-1366">文書またはアプリケーション ファイルの名前を指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1366">Starts a process resource by specifying the name of a document or application file and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="48f92-1367">プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1367">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="48f92-1368">同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1368">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="48f92-1369">また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1369">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="48f92-1370">その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1370">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1371">このオーバー ロードを使用すると、そのファイル名を指定してプロセス リソースを起動します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1371">Use this overload to start a process resource by specifying its file name.</span></span> <span data-ttu-id="48f92-1372">オーバー ロードは、新しいリソースに関連付けます<xref:System.Diagnostics.Process>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="48f92-1372">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1373">プロセスが開始されていないを開始する実行可能ファイルのアドレスが URL の場合と`null`が返されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1373">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="48f92-1374">このオーバー ロードでは、最初に、新しい作成せず、プロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1374">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="48f92-1375">オーバー ロードは、新しいを作成する明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>インスタンス、設定、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および通話<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1375">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="48f92-1376">ClickOnce アプリケーションを起動するには設定して、`fileName`アプリケーションをインストールした最初の位置 (たとえば、Web アドレス) へのパラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1376">You can start a ClickOnce application by setting the `fileName` parameter to the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="48f92-1377">ClickOnce アプリケーションは、ハード ドライブ上のインストール場所を指定することで開始されません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1377">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="48f92-1378">そのファイル名を指定することによって、プロセスを開始するは内の情報を入力に似ています、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1378">Starting a process by specifying its file name is similar to typing the information in the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="48f92-1379">そのため、ファイル名は、実行可能ファイルを表す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1379">Therefore, the file name does not need to represent an executable file.</span></span> <span data-ttu-id="48f92-1380">種類のファイルを拡張機能に関連付けられているシステムにインストールされているアプリケーションのことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1380">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="48f92-1381">たとえばのファイル名は、テキスト ファイルをメモ帳などのエディターに関連付けられましたか Microsoft Word などのワード プロセッシング ツールを使用してファイルを関連付けている場合、.doc ことができます、.txt 拡張子を使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1381">For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="48f92-1382">同じで同様に、方法、 `Run`  ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1382">Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="48f92-1383">たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1383">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span>  
  
 <span data-ttu-id="48f92-1384">このオーバー ロードは、プロセスのコマンドライン引数を許可しません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1384">This overload does not allow command-line arguments for the process.</span></span> <span data-ttu-id="48f92-1385">プロセスの 1 つまたは複数のコマンドライン引数を指定する必要がある場合、<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>または<xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType>オーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1385">If you need to specify one or more command-line arguments for the process, use the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> or <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> overloads.</span></span>  
  
 <span data-ttu-id="48f92-1386">その他のオーバー ロードのオーバー ロードとは異なり<xref:System.Diagnostics.Process.Start%2A>パラメーターを持たないが、`static`メンバー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1386">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="48f92-1387">既に作成しているとき、オーバー ロードを使用して、<xref:System.Diagnostics.Process>インスタンス、(ファイル名を含む)、指定した開始情報と関連付ける既存のプロセス リソースを開始する<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1387">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="48f92-1388">いずれかを使用して、`static`を新規作成するときにオーバー ロード<xref:System.Diagnostics.Process>既存のコンポーネントのプロセスを開始するのではなくコンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-1388">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="48f92-1389">このオーバー ロードとパラメーターがないオーバー ロードの両方を使用すると、起動するプロセスのリソースのファイル名を指定できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1389">Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.</span></span>  
  
 <span data-ttu-id="48f92-1390">引用符を使用して、システムで宣言されているパス変数があれば、その場所で見つかったすべてのプロセスを開始するときにそのパスを完全に修飾する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1390">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="48f92-1391">それ以外の場合、システムでは、パスは検索されません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1391">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="48f92-1392">たとえば場合、`c:\mypath`パスには引用符を使用してファイルを追加:`path = %path%;"c:\mypath"`の任意のプロセスを完全に修飾する必要があります`c:\mypath`開始するとき。</span><span class="sxs-lookup"><span data-stu-id="48f92-1392">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1393">ASP.NET Web ページとサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1393">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="48f92-1394">使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッド、ASP.NET Web ページまたはサーバー コントロールで、制限されたアクセス許可を持つ Web サーバーで、新しいプロセスを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1394">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="48f92-1395">プロセスでは、クライアントのブラウザーと同じコンテキストで起動しないと、ユーザーのデスクトップへのアクセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1395">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="48f92-1396">使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1396">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="48f92-1397">使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1397">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="48f92-1398">使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1398">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span>  
  
 <span data-ttu-id="48f92-1399">マネージ スレッドのアパートメント状態に関する注意事項がここで必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1399">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="48f92-1400">ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`プロセス コンポーネントの<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、属性を設定して、アプリケーションでスレッド モデルを設定することを確認`[STAThread]`上、`main()`メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-1400">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="48f92-1401">それ以外の場合、マネージ スレッドがであることができます、`unknown`状態またはに、`MTA`状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1401">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="48f92-1402">いくつかのメソッドのアパートメント状態でないことが必要な`unknown`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1402">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="48f92-1403">状態が明示的に設定されていないアプリケーションは、このようなメソッドを検出すると場合、既定`MTA`、一度設定すると、アパートメント状態が変更ことはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1403">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="48f92-1404">ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1404">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1405">まず、次の例は、Internet Explorer のインスタンスを生成し、ブラウザーで [お気に入り] フォルダーの内容を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1405">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="48f92-1406">Internet Explorer の他のいくつかのインスタンスを起動し、特定のページまたはサイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1406">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="48f92-1407">最後に、特定のサイトに移動する際に最小化ウィンドウで Internet Explorer を起動します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1407">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1408">関連付けられているファイルを開いているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1408">An error occurred when opening the associated file.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="48f92-1409">プロセス オブジェクトは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1409">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="48f92-1410">PATH 環境変数に、引用符を含む文字列があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1410">The PATH environment variable has a string containing quotes.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1411">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1411">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1412">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1412">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="48f92-1413">プロセスで実行するアプリケーション ファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="48f92-1413">The name of an application file to run in the process.</span></span></param>
        <param name="arguments"><span data-ttu-id="48f92-1414">プロセスを起動するときに渡すコマンド ライン引数。</span><span class="sxs-lookup"><span data-stu-id="48f92-1414">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="48f92-1415">アプリケーションの名前とコマンド ライン引数のセットを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1415">Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="48f92-1416">プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1416">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="48f92-1417">同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1417">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="48f92-1418">また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1418">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="48f92-1419">その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1419">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1420">そのファイルの名前とコマンドライン引数を指定してプロセス リソースを開始するのにには、このオーバー ロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1420">Use this overload to start a process resource by specifying its file name and command-line arguments.</span></span> <span data-ttu-id="48f92-1421">オーバー ロードは、新しいリソースに関連付けます<xref:System.Diagnostics.Process>オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="48f92-1421">The overload associates the resource with a new <xref:System.Diagnostics.Process> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1422">プロセスが開始されていないを開始する実行可能ファイルのアドレスが URL の場合と`null`が返されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1422">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="48f92-1423">このオーバー ロードでは、最初に、新しい作成せず、プロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1423">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="48f92-1424">オーバー ロードは、新しいを作成する明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>インスタンス、設定、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>と<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および通話<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1424">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> and <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> members of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="48f92-1425">ファイルの名前と引数を指定することによって、プロセスを開始するはでコマンドライン引数とファイルの名前を入力に似ています、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1425">Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the `Run` dialog box of the Windows `Start` menu.</span></span> <span data-ttu-id="48f92-1426">そのため、ファイル名は、実行可能ファイルを表す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1426">Therefore, the file name does not need to represent an executable file.</span></span> <span data-ttu-id="48f92-1427">種類のファイルを拡張機能に関連付けられているシステムにインストールされているアプリケーションのことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1427">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="48f92-1428">たとえばのファイル名は、テキスト ファイルをメモ帳などのエディターに関連付けられましたか Microsoft Word などのワード プロセッシング ツールを使用してファイルを関連付けている場合、.doc ことができます、.txt 拡張子を使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1428">For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="48f92-1429">同じで同様に、方法、 `Run`  ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1429">Similarly, in the same way that the `Run` dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="48f92-1430">たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1430">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="48f92-1431">場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、対象となるテキスト ファイルなどのファイルを表す場合があります`Notepad.exe myfile.txt`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1431">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span> <span data-ttu-id="48f92-1432">場合、`fileName`パラメーターがコマンド (.cmd) ファイルを表す、`arguments`パラメーターは、いずれかを含める必要があります、"`/c`「または」`/k`"コマンド ウィンドウが終了するか、完了した後に残すかどうかを指定する引数。</span><span class="sxs-lookup"><span data-stu-id="48f92-1432">If the `fileName` parameter represents a command (.cmd) file, the `arguments` parameter must include either a "`/c`" or "`/k`" argument to specify whether the command window exits or remains after completion.</span></span>  
  
 <span data-ttu-id="48f92-1433">その他のオーバー ロードのオーバー ロードとは異なり<xref:System.Diagnostics.Process.Start%2A>パラメーターを持たないが、`static`メンバー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1433">Unlike the other overloads, the overload of <xref:System.Diagnostics.Process.Start%2A> that has no parameters is not a `static` member.</span></span> <span data-ttu-id="48f92-1434">既に作成しているとき、オーバー ロードを使用して、<xref:System.Diagnostics.Process>インスタンス、(ファイル名を含む)、指定した開始情報と関連付ける既存のプロセス リソースを開始する<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1434">Use that overload when you have already created a <xref:System.Diagnostics.Process> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="48f92-1435">いずれかを使用して、`static`を新規作成するときにオーバー ロード<xref:System.Diagnostics.Process>既存のコンポーネントのプロセスを開始するのではなくコンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-1435">Use one of the `static` overloads when you want to create a new <xref:System.Diagnostics.Process> component rather than start a process for an existing component.</span></span> <span data-ttu-id="48f92-1436">このオーバー ロードとパラメーターがないオーバー ロードの両方を使用すると、プロセスのリソースを起動してに渡すコマンドライン引数のファイル名を指定できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1436">Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.</span></span>  
  
 <span data-ttu-id="48f92-1437">引用符を使用して、システムで宣言されているパス変数があれば、その場所で見つかったすべてのプロセスを開始するときにそのパスを完全に修飾する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1437">If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location.</span></span> <span data-ttu-id="48f92-1438">それ以外の場合、システムでは、パスは検索されません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1438">Otherwise, the system will not find the path.</span></span> <span data-ttu-id="48f92-1439">たとえば場合、`c:\mypath`パスには引用符を使用してファイルを追加:`path = %path%;"c:\mypath"`の任意のプロセスを完全に修飾する必要があります`c:\mypath`開始するとき。</span><span class="sxs-lookup"><span data-stu-id="48f92-1439">For example, if `c:\mypath` is not in your path, and you add it using quotation marks: `path = %path%;"c:\mypath"`, you must fully qualify any process in `c:\mypath` when starting it.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1440">ASP.NET Web ページとサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1440">ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.</span></span>  <span data-ttu-id="48f92-1441">使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッド、ASP.NET Web ページまたはサーバー コントロールで、制限されたアクセス許可を持つ Web サーバーで、新しいプロセスを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1441">If you use the <xref:System.Diagnostics.Process.Start%2A> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions.</span></span> <span data-ttu-id="48f92-1442">プロセスでは、クライアントのブラウザーと同じコンテキストで起動しないと、ユーザーのデスクトップへのアクセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1442">The process does not start in the same context as the client browser, and does not have access to the user desktop.</span></span>  
  
 <span data-ttu-id="48f92-1443">使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1443">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="48f92-1444">使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1444">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="48f92-1445">使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1445">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span> 
  
 <span data-ttu-id="48f92-1446">マネージ スレッドのアパートメント状態に関する注意事項がここで必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1446">A note about apartment states in managed threads is necessary here.</span></span> <span data-ttu-id="48f92-1447">ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`プロセス コンポーネントの<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、属性を設定して、アプリケーションでスレッド モデルを設定することを確認`[STAThread]`上、`main()`メソッド。</span><span class="sxs-lookup"><span data-stu-id="48f92-1447">When <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> is `true` on the process component's <xref:System.Diagnostics.Process.StartInfo%2A> property, make sure you have set a threading model on your application by setting the attribute `[STAThread]` on the `main()` method.</span></span> <span data-ttu-id="48f92-1448">それ以外の場合、マネージ スレッドがであることができます、`unknown`状態またはに、`MTA`状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1448">Otherwise, a managed thread can be in an `unknown` state or put in the `MTA` state, the latter of which conflicts with <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> being `true`.</span></span> <span data-ttu-id="48f92-1449">いくつかのメソッドのアパートメント状態でないことが必要な`unknown`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1449">Some methods require that the apartment state not be `unknown`.</span></span> <span data-ttu-id="48f92-1450">状態が明示的に設定されていないアプリケーションは、このようなメソッドを検出すると場合、既定`MTA`、一度設定すると、アパートメント状態が変更ことはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1450">If the state is not explicitly set, when the application encounters such a method, it defaults to `MTA`, and once set, the apartment state cannot be changed.</span></span> <span data-ttu-id="48f92-1451">ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1451">However, `MTA` causes an exception to be thrown when the operating system shell is managing the thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1452">まず、次の例は、Internet Explorer のインスタンスを生成し、ブラウザーで [お気に入り] フォルダーの内容を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1452">The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser.</span></span> <span data-ttu-id="48f92-1453">Internet Explorer の他のいくつかのインスタンスを起動し、特定のページまたはサイトを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1453">It then starts some other instances of Internet Explorer and displays some specific pages or sites.</span></span> <span data-ttu-id="48f92-1454">最後に、特定のサイトに移動する際に最小化ウィンドウで Internet Explorer を起動します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1454">Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</span></span>  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1455"><paramref name="fileName" /> パラメーターまたは <paramref name="arguments" /> パラメーターが <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1455">The <paramref name="fileName" /> or <paramref name="arguments" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1456">関連付けられているファイルを開いているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1456">An error occurred when opening the associated file.</span></span>  
  
<span data-ttu-id="48f92-1457">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1457">-or-</span></span> 
<span data-ttu-id="48f92-1458">引数の長さとプロセスへの完全パスの長さの合計が、2080 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1458">The sum of the length of the arguments and the length of the full path to the process exceeds 2080.</span></span> <span data-ttu-id="48f92-1459">この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます" </span><span class="sxs-lookup"><span data-stu-id="48f92-1459">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="48f92-1460">または「アクセスが拒否されました。」</span><span class="sxs-lookup"><span data-stu-id="48f92-1460">or "Access is denied."</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="48f92-1461">プロセス オブジェクトは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1461">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="48f92-1462">PATH 環境変数に、引用符を含む文字列があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1462">The PATH environment variable has a string containing quotes.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1463">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1463">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1464">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1464">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="48f92-1465">プロセスで実行するアプリケーション ファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="48f92-1465">The name of an application file to run in the process.</span></span></param>
        <param name="userName"><span data-ttu-id="48f92-1466">プロセスを開始するときに使用するユーザー名。</span><span class="sxs-lookup"><span data-stu-id="48f92-1466">The user name to use when starting the process.</span></span></param>
        <param name="password"><span data-ttu-id="48f92-1467">プロセスを開始するときに使用するパスワードを含む <see cref="T:System.Security.SecureString" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1467">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</span></span></param>
        <param name="domain"><span data-ttu-id="48f92-1468">プロセスを開始するときに使用するドメイン。</span><span class="sxs-lookup"><span data-stu-id="48f92-1468">The domain to use when starting the process.</span></span></param>
        <summary><span data-ttu-id="48f92-1469">アプリケーションの名前、ユーザー名、パスワード、ドメインを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1469">Starts a process resource by specifying the name of an application, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="48f92-1470">プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1470">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="48f92-1471">同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1471">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="48f92-1472">また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1472">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="48f92-1473">その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1473">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1474">このオーバー ロードを使用すると、そのファイル名、ユーザー名、パスワード、およびドメインを指定することで、新しいプロセスとそのプライマリ スレッドを作成できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1474">Use this overload to create a new process and its primary thread by specifying its file name, user name, password, and domain.</span></span> <span data-ttu-id="48f92-1475">新しいプロセスは、(ユーザー、ドメイン、およびパスワード) には、指定した資格情報のセキュリティ コンテキストで、指定した実行可能ファイルを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1475">The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1476">実行可能ファイルがリモート ドライブ上にある場合は、リンクされているドライブ文字ではなく uniform resource identifier (URI) を使用してネットワーク共有を識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1476">When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1477">プロセスが開始されていないを開始する実行可能ファイルのアドレスが URL の場合と`null`が返されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1477">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="48f92-1478">このオーバー ロードでは、最初に、新しい作成せず、プロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1478">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="48f92-1479">オーバー ロードは、新しいを作成する明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>設定インスタンス、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>、および<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および通話<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1479">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, and <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="48f92-1480">同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1480">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="48f92-1481">たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1481">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="48f92-1482">場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、対象となるテキスト ファイルなどのファイルを表す場合があります`Notepad.exe myfile.txt`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1482">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1483">ファイル名での実行可能ファイルを表す必要があります、<xref:System.Diagnostics.Process.Start%2A>がオーバー ロード`userName`、 `password`、および`domain`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1483">The file name must represent an executable file in the <xref:System.Diagnostics.Process.Start%2A> overloads that have `userName`, `password`, and `domain` parameters.</span></span>  
  
 <span data-ttu-id="48f92-1484">使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1484">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="48f92-1485">使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1485">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="48f92-1486">使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1486">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span> 
  
   
  
## Examples  
 <span data-ttu-id="48f92-1487">次のコード例のこのオーバー ロードを開始する実行可能ファイルの使用例を示しものスローを示しています、<xref:System.ComponentModel.Win32Exception>非実行可能ファイルに関連付けられているアプリケーションを起動する試みが行われた場合。</span><span class="sxs-lookup"><span data-stu-id="48f92-1487">The following code example shows the use of this overload to start an executable file and also demonstrates the throwing of a <xref:System.ComponentModel.Win32Exception> when an attempt is made to start an application associated with a nonexecutable file.</span></span>  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1488">ファイル名が指定されませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1488">No file name was specified.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1489">関連付けられているファイルを開いているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1489">There was an error in opening the associated file.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="48f92-1490">プロセス オブジェクトは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1490">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1491">メソッドは Linux または macOS (.NET Core のみ) ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1491">Method not supported on Linux or macOS (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1492">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1492">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1493">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1493">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="48f92-1494">プロセスで実行するアプリケーション ファイルの名前。</span><span class="sxs-lookup"><span data-stu-id="48f92-1494">The name of an application file to run in the process.</span></span></param>
        <param name="arguments"><span data-ttu-id="48f92-1495">プロセスを起動するときに渡すコマンド ライン引数。</span><span class="sxs-lookup"><span data-stu-id="48f92-1495">Command-line arguments to pass when starting the process.</span></span></param>
        <param name="userName"><span data-ttu-id="48f92-1496">プロセスの開始時に使用するユーザー名。</span><span class="sxs-lookup"><span data-stu-id="48f92-1496">The user name to use when starting the process.</span></span></param>
        <param name="password"><span data-ttu-id="48f92-1497">プロセスを開始するときに使用するパスワードを含む <see cref="T:System.Security.SecureString" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1497">A <see cref="T:System.Security.SecureString" /> that contains the password to use when starting the process.</span></span></param>
        <param name="domain"><span data-ttu-id="48f92-1498">プロセスを開始するときに使用するドメイン。</span><span class="sxs-lookup"><span data-stu-id="48f92-1498">The domain to use when starting the process.</span></span></param>
        <summary><span data-ttu-id="48f92-1499">アプリケーションの名前、コマンド ライン引数のセット、ユーザー名、パスワード、およびドメインを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1499">Starts a process resource by specifying the name of an application, a set of command-line arguments, a user name, a password, and a domain and associates the resource with a new <see cref="T:System.Diagnostics.Process" /> component.</span></span></summary>
        <returns><span data-ttu-id="48f92-1500">プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1500">A new <see cref="T:System.Diagnostics.Process" /> that is associated with the process resource, or <see langword="null" /> if no process resource is started.</span></span> <span data-ttu-id="48f92-1501">同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1501">Note that a new process that's started alongside already running instances of the same process will be independent from the others.</span></span> <span data-ttu-id="48f92-1502">また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1502">In addition, Start may return a non-null Process with its <see cref="P:System.Diagnostics.Process.HasExited" /> property already set to <see langword="true" />.</span></span> <span data-ttu-id="48f92-1503">その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1503">In this case, the started process may have activated an existing instance of itself and then exited.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1504">ファイルの名前、コマンドライン引数、ユーザー名、パスワード、およびドメインを指定して、新しいプロセスとそのプライマリ スレッドを作成するのにには、このオーバー ロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1504">Use this overload to create a new process and its primary thread by specifying its file name, command-line arguments, user name, password, and domain.</span></span> <span data-ttu-id="48f92-1505">新しいプロセスは、(ユーザー、ドメイン、およびパスワード) には、指定した資格情報のセキュリティ コンテキストで、指定した実行可能ファイルを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1505">The new process then runs the specified executable file in the security context of the specified credentials (user, domain, and password).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1506">実行可能ファイルがリモート ドライブ上にある場合は、リンクされているドライブ文字ではなく uniform resource identifier (URI) を使用してネットワーク共有を識別する必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1506">When the executable file is located on a remote drive, you must identify the network share by using a uniform resource identifier (URI), not a linked drive letter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1507">プロセスが開始されていないを開始する実行可能ファイルのアドレスが URL の場合と`null`が返されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1507">If the address of the executable file to start is a URL, the process is not started and `null` is returned.</span></span>  
  
 <span data-ttu-id="48f92-1508">このオーバー ロードでは、最初に、新しい作成せず、プロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1508">This overload lets you start a process without first creating a new <xref:System.Diagnostics.Process> instance.</span></span> <span data-ttu-id="48f92-1509">オーバー ロードは、新しいを作成する明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>インスタンス、設定、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>、 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>、および<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および呼び出し元<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1509">The overload is an alternative to the explicit steps of creating a new <xref:System.Diagnostics.Process> instance, setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, and <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> properties of the <xref:System.Diagnostics.Process.StartInfo%2A> property, and calling <xref:System.Diagnostics.Process.Start%2A> for the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 <span data-ttu-id="48f92-1510">同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1510">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the `fileName` parameter.</span></span> <span data-ttu-id="48f92-1511">たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1511">For example, you can set the `fileName` parameter to either "Notepad.exe" or "Notepad".</span></span> <span data-ttu-id="48f92-1512">場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、対象となるテキスト ファイルなどのファイルを表す場合があります`Notepad.exe myfile.txt`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1512">If the `fileName` parameter represents an executable file, the `arguments` parameter might represent a file to act upon, such as the text file in `Notepad.exe myfile.txt`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1513">ファイル名での実行可能ファイルを表す必要があります、<xref:System.Diagnostics.Process.Start%2A>がオーバー ロード`userName`、 `password`、および`domain`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1513">The file name must represent an executable file in the <xref:System.Diagnostics.Process.Start%2A> overloads that have `userName`, `password`, and `domain` parameters.</span></span>  
  
 <span data-ttu-id="48f92-1514">使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1514">Whenever you use <xref:System.Diagnostics.Process.Start%2A> to start a process, you might need to close it or you risk losing system resources.</span></span> <span data-ttu-id="48f92-1515">使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1515">Close processes using <xref:System.Diagnostics.Process.CloseMainWindow%2A> or <xref:System.Diagnostics.Process.Kill%2A>.</span></span> <span data-ttu-id="48f92-1516">使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1516">You can check whether a process has already been closed by using its <xref:System.Diagnostics.Process.HasExited%2A> property.</span></span> 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1517">ファイル名が指定されませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1517">No file name was specified.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1518">関連付けられているファイルを開いているときにエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1518">An error occurred when opening the associated file.</span></span>  
  
<span data-ttu-id="48f92-1519">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1519">-or-</span></span> 
<span data-ttu-id="48f92-1520">引数の長さと関連ファイルへの完全パスの長さの合計が、2080 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1520">The sum of the length of the arguments and the length of the full path to the associated file exceeds 2080.</span></span> <span data-ttu-id="48f92-1521">この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます" </span><span class="sxs-lookup"><span data-stu-id="48f92-1521">The error message associated with this exception can be one of the following: "The data area passed to a system call is too small."</span></span> <span data-ttu-id="48f92-1522">または「アクセスが拒否されました。」</span><span class="sxs-lookup"><span data-stu-id="48f92-1522">or "Access is denied."</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="48f92-1523">プロセス オブジェクトは既に破棄されています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1523">The process object has already been disposed.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1524">メソッドは Linux または macOS (.NET Core のみ) ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1524">Method not supported on Linux or macOS (.NET Core only).</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1525">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1525">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1526">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1526">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1527"><see cref="M:System.Diagnostics.Process.Start" /> の <see cref="T:System.Diagnostics.Process" /> メソッドに渡すプロパティを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1527">Gets or sets the properties to pass to the <see cref="M:System.Diagnostics.Process.Start" /> method of the <see cref="T:System.Diagnostics.Process" />.</span></span></summary>
        <value><span data-ttu-id="48f92-1528">プロセスを起動するときに使用するデータを表す <see cref="T:System.Diagnostics.ProcessStartInfo" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1528">The <see cref="T:System.Diagnostics.ProcessStartInfo" /> that represents the data with which to start the process.</span></span> <span data-ttu-id="48f92-1529">これらの引数には、プロセスの起動時に使用する実行可能ファイルまたは文書の名前があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1529">These arguments include the name of the executable file or document used to start the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1530"><xref:System.Diagnostics.Process.StartInfo%2A> 使用して、プロセスを開始するパラメーターのセットを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1530"><xref:System.Diagnostics.Process.StartInfo%2A> represents the set of parameters to use to start a process.</span></span> <span data-ttu-id="48f92-1531">ときに<xref:System.Diagnostics.Process.Start%2A>が呼び出される、<xref:System.Diagnostics.Process.StartInfo%2A>プロセスを開始するを指定するために使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1531">When <xref:System.Diagnostics.Process.Start%2A> is called, the <xref:System.Diagnostics.Process.StartInfo%2A> is used to specify the process to start.</span></span> <span data-ttu-id="48f92-1532">必要なだけ<xref:System.Diagnostics.Process.StartInfo%2A>を設定するメンバーが、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1532">The only necessary <xref:System.Diagnostics.Process.StartInfo%2A> member to set is the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property.</span></span> <span data-ttu-id="48f92-1533">指定することによって、プロセスを開始、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、情報を入力すると同様、**実行** ダイアログ ボックス、Windows の**開始**メニュー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1533">Starting a process by specifying the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property is similar to typing the information in the **Run** dialog box of the Windows **Start** menu.</span></span> <span data-ttu-id="48f92-1534">そのため、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、実行可能ファイルを表す必要はありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1534">Therefore, the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to represent an executable file.</span></span> <span data-ttu-id="48f92-1535">種類のファイルを拡張機能に関連付けられているシステムにインストールされているアプリケーションのことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1535">It can be of any file type for which the extension has been associated with an application installed on the system.</span></span> <span data-ttu-id="48f92-1536">たとえば、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>にメモ帳などのエディターでテキスト ファイルを関連付けるか、Microsoft Word などのワード プロセッシング ツールを使用してファイルを関連付けている場合、.doc ことができる場合、.txt 拡張子を持つことができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1536">For example the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word.</span></span> <span data-ttu-id="48f92-1537">同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>メンバー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1537">Similarly, in the same way that the **Run** dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member.</span></span> <span data-ttu-id="48f92-1538">たとえば、設定、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティを"Notepad.exe"または"Notepad"。</span><span class="sxs-lookup"><span data-stu-id="48f92-1538">For example, you can set the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property to either "Notepad.exe" or "Notepad".</span></span>  
  
 <span data-ttu-id="48f92-1539">ClickOnce アプリケーションを起動するには設定して、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティをアプリケーションをインストールした最初の場所 (たとえば、Web アドレス)。</span><span class="sxs-lookup"><span data-stu-id="48f92-1539">You can start a ClickOnce application by setting the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property to the location (for example, a Web address) from which you originally installed the application.</span></span> <span data-ttu-id="48f92-1540">ClickOnce アプリケーションは、ハード ドライブ上のインストール場所を指定することで開始されません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1540">Do not start a ClickOnce application by specifying its installed location on your hard drive.</span></span>  
  
 <span data-ttu-id="48f92-1541">ファイル名には、.doc ファイルなどの非実行可能ファイルが含まれている場合は、ファイルを実行するには、どのようなアクションを指定する動詞を含めることができます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1541">If the file name involves a nonexecutable file, such as a .doc file, you can include a verb specifying what action to take on the file.</span></span> <span data-ttu-id="48f92-1542">たとえば、設定する、 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> .doc 拡張子で終わるファイルの"Print"にします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1542">For example, you could set the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> to "Print" for a file ending in the .doc extension.</span></span> <span data-ttu-id="48f92-1543">指定されたファイル名、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティが値を手動で入力する場合、拡張子を指定する必要はありません、<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1543">The file name specified in the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property does not need to have an extension if you manually enter a value for the <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> property.</span></span> <span data-ttu-id="48f92-1544">ただし、使用する場合、<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>動詞を確認するには、拡張機能を含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1544">However, if you use the <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> property to determine what verbs are available, you must include the extension.</span></span>  
  
 <span data-ttu-id="48f92-1545">指定されたパラメーターを変更することができます、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティを呼び出したときまで、<xref:System.Diagnostics.Process.Start%2A>メソッドを処理します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1545">You can change the parameters specified in the <xref:System.Diagnostics.Process.StartInfo%2A> property up to the time that you call the <xref:System.Diagnostics.Process.Start%2A> method on the process.</span></span> <span data-ttu-id="48f92-1546">変更するプロセスを開始した後、<xref:System.Diagnostics.Process.StartInfo%2A>値が影響を与えるまたは関連付けられたプロセスを再起動していません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1546">After you start the process, changing the <xref:System.Diagnostics.Process.StartInfo%2A> values does not affect or restart the associated process.</span></span> <span data-ttu-id="48f92-1547">呼び出す場合、<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>メソッドを<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>と<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>プロパティ セットには、アンマネージ`CreateProcessWithLogonW`関数が呼び出されると、新しいウィンドウいてでプロセスを開始する、<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>プロパティの値が`true`または、 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>プロパティの値が<xref:System.Diagnostics.ProcessWindowStyle.Hidden>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1547">If you call the <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> method with the <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> and <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> properties set, the unmanaged `CreateProcessWithLogonW` function is called, which starts the process in a new window even if the <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> property value is `true` or the <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> property value is <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.</span></span>  
  
 <span data-ttu-id="48f92-1548">使用していない場合、<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するメソッド、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティは、プロセスを開始するためのパラメーターを反映しません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1548">If you did not use the <xref:System.Diagnostics.Process.Start%2A> method to start a process, the <xref:System.Diagnostics.Process.StartInfo%2A> property does not reflect the parameters used to start the process.</span></span> <span data-ttu-id="48f92-1549">例では、使用する場合の<xref:System.Diagnostics.Process.GetProcesses%2A>コンピューターで、実行中のプロセスの配列を取得する、<xref:System.Diagnostics.Process.StartInfo%2A>の各プロパティ<xref:System.Diagnostics.Process>元のファイル名またはプロセスを開始するための引数が含まれていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1549">For example, if you use <xref:System.Diagnostics.Process.GetProcesses%2A> to get an array of processes running on the computer, the <xref:System.Diagnostics.Process.StartInfo%2A> property of each <xref:System.Diagnostics.Process> does not contain the original file name or arguments used to start the process.</span></span>  
  
 <span data-ttu-id="48f92-1550">プロセスを起動すると、ファイル名は、(読み取り専用) のメンバーを追加するファイル<xref:System.Diagnostics.Process.MainModule%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1550">When the process is started, the file name is the file that populates the (read-only) <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="48f92-1551">プロセスが開始した後、プロセスに関連付けられている実行可能ファイルを取得するには、使用する場合、<xref:System.Diagnostics.Process.MainModule%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1551">If you want to retrieve the executable file that is associated with the process after the process has started, use the <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="48f92-1552">実行可能ファイルを設定する場合、<xref:System.Diagnostics.Process>インスタンスが、関連付けられたプロセスが開始されていない場合、使用、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティの<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>メンバー。</span><span class="sxs-lookup"><span data-stu-id="48f92-1552">If you want to set the executable file of a <xref:System.Diagnostics.Process> instance for which an associated process has not been started, use the <xref:System.Diagnostics.Process.StartInfo%2A> property's <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> member.</span></span> <span data-ttu-id="48f92-1553">のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティに渡される引数には、<xref:System.Diagnostics.Process.Start%2A>メソッドを変更する、プロセスの<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティ、関連付けられたプロセスが開始した後の状態はリセットされません、<xref:System.Diagnostics.Process.MainModule%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1553">Because the members of the <xref:System.Diagnostics.Process.StartInfo%2A> property are arguments that are passed to the <xref:System.Diagnostics.Process.Start%2A> method of a process, changing the <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> property after the associated process has started will not reset the <xref:System.Diagnostics.Process.MainModule%2A> property.</span></span> <span data-ttu-id="48f92-1554">これらのプロパティは、関連付けられたプロセスを初期化するためにのみ使用されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1554">These properties are used only to initialize the associated process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1555">次の例を<xref:System.Diagnostics.Process.StartInfo%2A>ことで、ファイルを実行するアクションを実行して、ユーザー インターフェイスを表示するかどうか。</span><span class="sxs-lookup"><span data-stu-id="48f92-1555">The following example populates a <xref:System.Diagnostics.Process.StartInfo%2A> with the file to execute, the action performed on it and whether it should displays a user interface.</span></span> <span data-ttu-id="48f92-1556">その他の例のプロパティのリファレンス ページを参照してください、<xref:System.Diagnostics.ProcessStartInfo>クラス。</span><span class="sxs-lookup"><span data-stu-id="48f92-1556">For additional examples, refer to the reference pages for properties of the <xref:System.Diagnostics.ProcessStartInfo> class.</span></span>  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="48f92-1557"><see cref="P:System.Diagnostics.Process.StartInfo" /> を指定する値は <see langword="null" /> です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1557">The value that specifies the <see cref="P:System.Diagnostics.Process.StartInfo" /> is <see langword="null" />.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1558">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1558">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1559">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1559">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1560">関連付けられたプロセスが起動された時刻を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1560">Gets the time that the associated process was started.</span></span></summary>
        <value><span data-ttu-id="48f92-1561">プロセスが起動された時刻を示すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="48f92-1561">An object  that indicates when the process started.</span></span> <span data-ttu-id="48f92-1562">プロセスが実行中でない場合は、例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1562">An exception is thrown if the process is not running.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1563">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1563">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-1564">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.StartTime" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1564">You are attempting to access the <see cref="P:System.Diagnostics.Process.StartTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-1565">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1565">This property is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1566">プロセスが終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1566">The process has exited.</span></span>  
  
<span data-ttu-id="48f92-1567">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-1567">-or-</span></span> 
<span data-ttu-id="48f92-1568">プロセスは開始されていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1568">The process has not been started.</span></span></exception>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1569">Windows 関数の呼び出しでエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1569">An error occurred in the call to the Windows function.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1570">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1570">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1571">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1571">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1572">プロセス終了イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1572">Gets or sets the object used to marshal the event handler calls that are issued as a result of a process exit event.</span></span></summary>
        <value><span data-ttu-id="48f92-1573">プロセスの <see cref="E:System.Diagnostics.Process.Exited" /> イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用する <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1573">The <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> used to marshal event handler calls that are issued as a result of an <see cref="E:System.Diagnostics.Process.Exited" /> event on the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1574">ときに<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>は`null`、処理するメソッド、<xref:System.Diagnostics.Process.Exited>イベントは、システム スレッド プールのスレッドで呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1574">When <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> is `null`, methods that handle the <xref:System.Diagnostics.Process.Exited> event are called on a thread from the system thread pool.</span></span> <span data-ttu-id="48f92-1575">システム スレッド プールの詳細については、次を参照してください。<xref:System.Threading.ThreadPool>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1575">For more information about system thread pools, see <xref:System.Threading.ThreadPool>.</span></span>  
  
 <span data-ttu-id="48f92-1576">ときに、<xref:System.Diagnostics.Process.Exited>イベントがなどのビジュアルの Windows フォーム コンポーネントによって処理されます、 <xref:System.Windows.Forms.Button>、システム スレッド プールを介したコンポーネントへのアクセスが機能しないか、例外が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1576">When the <xref:System.Diagnostics.Process.Exited> event is handled by a visual Windows Forms component, such as a <xref:System.Windows.Forms.Button>, accessing the component through the system thread pool might not work, or might result in an exception.</span></span> <span data-ttu-id="48f92-1577">設定してこの問題を回避<xref:System.Diagnostics.Process.SynchronizingObject%2A>これにより、Windows フォームのコンポーネントを処理するメソッド、<xref:System.Diagnostics.Process.Exited>コンポーネントが作成された同じスレッドで呼び出されるイベント。</span><span class="sxs-lookup"><span data-stu-id="48f92-1577">Avoid this by setting <xref:System.Diagnostics.Process.SynchronizingObject%2A> to a Windows Forms component, which causes the methods handling the <xref:System.Diagnostics.Process.Exited> event to be called on the same thread on which the component was created.</span></span>  
  
 <span data-ttu-id="48f92-1578">場合、<xref:System.Diagnostics.Process>内で使用する[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]Windows フォーム デザイナーで<xref:System.Diagnostics.Process.SynchronizingObject%2A>を含むコントロールを自動的に設定されますが、<xref:System.Diagnostics.Process>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1578">If the <xref:System.Diagnostics.Process> is used inside [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] in a Windows Forms designer, <xref:System.Diagnostics.Process.SynchronizingObject%2A> is automatically set to the control that contains the <xref:System.Diagnostics.Process>.</span></span> <span data-ttu-id="48f92-1579">配置する場合など、<xref:System.Diagnostics.Process>のデザイナーで`Form1`(から継承される<xref:System.Windows.Forms.Form>)、<xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティの<xref:System.Diagnostics.Process>のインスタンスに設定されている`Form1`:</span><span class="sxs-lookup"><span data-stu-id="48f92-1579">For example, if you place a <xref:System.Diagnostics.Process> on a designer for `Form1` (which inherits from <xref:System.Windows.Forms.Form>) the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property of <xref:System.Diagnostics.Process> is set to the instance of `Form1`:</span></span>  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 <span data-ttu-id="48f92-1580">通常、このプロパティがコントロールまたはフォーム内でコンポーネントを配置するとこれらのコンポーネントは、特定のスレッドにバインドされるためです。</span><span class="sxs-lookup"><span data-stu-id="48f92-1580">Typically, this property is set when the component is placed inside a control or form, because those components are bound to a specific thread.</span></span>  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1581">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1581">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1582">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1582">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1583">関連付けられたプロセスで実行されているスレッドのセットを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1583">Gets the set of threads that are running in the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-1584">関連付けられたプロセスで現在実行中のオペレーティング システム スレッドを表す <see cref="T:System.Diagnostics.ProcessThread" /> 型の配列。</span><span class="sxs-lookup"><span data-stu-id="48f92-1584">An array of type <see cref="T:System.Diagnostics.ProcessThread" /> representing the operating system threads currently running in the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1585">スレッドは、プロセスでコードを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1585">A thread executes code in a process.</span></span> <span data-ttu-id="48f92-1586">1 つのスレッド、プライマリ スレッドで各プロセスが開始されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1586">Each process is started with a single thread, its primary thread.</span></span> <span data-ttu-id="48f92-1587">どのスレッドでも新しいスレッドを作成できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1587">Any thread can create additional threads.</span></span> <span data-ttu-id="48f92-1588">プロセス内のスレッドは、プロセスのアドレス空間を共有します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1588">Threads within a process share the address space of the process.</span></span>  
  
 <span data-ttu-id="48f92-1589">使用<xref:System.Diagnostics.ProcessThread>を現在のプロセスに関連付けられているすべてのスレッドを取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1589">Use <xref:System.Diagnostics.ProcessThread> to get all the threads associated with the current process.</span></span> <span data-ttu-id="48f92-1590">プライマリ スレッドは必ずしも配列内のインデックス 0 位置です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1590">The primary thread is not necessarily at index zero in the array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException"><span data-ttu-id="48f92-1591">プロセスに <see cref="P:System.Diagnostics.Process.Id" /> がないか、<see cref="T:System.Diagnostics.Process" /> インスタンスに関連付けられているプロセスがありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1591">The process does not have an <see cref="P:System.Diagnostics.Process.Id" />, or no process is associated with the <see cref="T:System.Diagnostics.Process" /> instance.</span></span>  
  
<span data-ttu-id="48f92-1592">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-1592">-or-</span></span> 
<span data-ttu-id="48f92-1593">関連付けられたプロセスが終了しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1593">The associated process has exited.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1594">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1594">The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> to <see langword="false" /> to access this property on Windows 98 and Windows Me.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1595">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1595">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1596">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1596">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-1597">プロセス名の書式指定は文字列にします。親コンポーネント型があれば、この型と組み合わせます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1597">Formats the process's name as a string, combined with the parent component type, if applicable.</span></span></summary>
        <returns><span data-ttu-id="48f92-1598">ベース コンポーネントの <see cref="M:System.Object.ToString" /> の戻り値と組み合わせた <see cref="P:System.Diagnostics.Process.ProcessName" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1598">The <see cref="P:System.Diagnostics.Process.ProcessName" />, combined with the base component's <see cref="M:System.Object.ToString" /> return value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="48f92-1599">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1599">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-1600">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1600">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-1601">例では、検出プロセスが終了し、プロセスの終了コードを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1601">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1602"><see cref="M:System.Diagnostics.Process.ToString" /> は、Windows 98 ではサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1602"><see cref="M:System.Diagnostics.Process.ToString" /> is not supported on Windows 98.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1603">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1603">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1604">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1604">This member cannot be used by partially trusted code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1605">このプロセスの合計プロセッサ時間を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1605">Gets the total processor time for this process.</span></span></summary>
        <value><span data-ttu-id="48f92-1606">関連付けられたプロセスが CPU を使用した合計時間を示す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1606">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the associated process has spent utilizing the CPU.</span></span> <span data-ttu-id="48f92-1607">この値は、<see cref="P:System.Diagnostics.Process.UserProcessorTime" /> と <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> の合計です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1607">This value is the sum of the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> and the <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="48f92-1608">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1608">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-1609">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1609">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-1610">例では、検出プロセスが終了し、プロセスの終了コードを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1610">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1611">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1611">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-1612">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1612">You are attempting to access the <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-1613">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1613">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1614">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1614">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1615">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1615">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1616">このプロセスのユーザー プロセッサ時間を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1616">Gets the user processor time for this process.</span></span></summary>
        <value><span data-ttu-id="48f92-1617">関連付けられたプロセスが、プロセスのアプリケーション部分の内部 (オペレーティング システム コアの外部) でコードを実行した合計時間を示す <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1617">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the associated process has spent running code inside the application portion of the process (not inside the operating system core).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="48f92-1618">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1618">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-1619">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1619">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-1620">例では、検出プロセスが終了し、プロセスの終了コードを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1620">The example detects when the process exits, and displays the process's exit code.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1621">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1621">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="48f92-1622">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> プロパティにアクセスしようとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1622">You are attempting to access the <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> property for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-1623">このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1623">This property is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1624">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1624">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1625">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1625">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1626">プロセスの仮想メモリのサイズ (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1626">Gets the size of the process's virtual memory, in bytes.</span></span></summary>
        <value><span data-ttu-id="48f92-1627">関連付けられたプロセスが要求した仮想メモリの容量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-1627">The amount of virtual memory, in bytes, that the associated process has requested.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1628">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1628">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1629">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1629">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1630">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1630">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1631">関連付けられたプロセスに割り当てられた仮想メモリの量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1631">Gets the amount of the virtual memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-1632">関連付けられたプロセスに割り当てられた仮想メモリの量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-1632">The amount of virtual memory, in bytes, allocated for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1633">このプロパティによって返される値は、(バイト単位)、プロセスによって使用される仮想メモリの現在のサイズを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1633">The value returned by this property represents the current size of virtual memory used by the process, in bytes.</span></span> <span data-ttu-id="48f92-1634">オペレーティング システムでは、各プロセスの物理メモリまたはディスク上の仮想メモリ ページング ファイルに格納されているページが読み込まれるページのいずれかの仮想アドレス空間をマップします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1634">The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</span></span>  
  
 <span data-ttu-id="48f92-1635">このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1635">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="48f92-1636">プロパティ値が等しく、**仮想バイト**プロセスのパフォーマンス カウンター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1636">The property value is equivalent to the **Virtual Bytes** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1637">次のコード例では、メモ帳アプリケーションのインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1637">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="48f92-1638">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1638">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-1639">例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1639">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1640">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1640">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1641">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1641">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1642">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1642">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="48f92-1643">関連付けられたプロセスが終了するまで待機する時間を設定し、指定した時間が経過するかプロセスが終了するまで現在のスレッドの実行をブロックします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1643">Sets the period of time to wait for the associated process to exit, and blocks the current thread of execution until the time has elapsed or the process has exited.</span></span> <span data-ttu-id="48f92-1644">現在のスレッドがブロックされないようにする場合は、<see cref="E:System.Diagnostics.Process.Exited" /> イベントを使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1644">To avoid blocking the current thread, use the <see cref="E:System.Diagnostics.Process.Exited" /> event.</span></span>  
  
<span data-ttu-id="48f92-1645">コード例については、<see cref="P:System.Diagnostics.Process.StandardError" /> および <see cref="P:System.Diagnostics.Process.ExitCode" /> プロパティのリファレンス ページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="48f92-1645">For code examples, see the <see cref="P:System.Diagnostics.Process.StandardError" /> and the <see cref="P:System.Diagnostics.Process.ExitCode" /> property reference pages.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-1646">関連付けられたプロセスが終了するまで無期限に待機するように <see cref="T:System.Diagnostics.Process" /> コンポーネントに指示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1646">Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to exit.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1647"><xref:System.Diagnostics.Process.WaitForExit> 関連付けられたプロセスが終了するまで待ってから、現在のスレッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1647"><xref:System.Diagnostics.Process.WaitForExit> makes the current thread wait until the associated process terminates.</span></span>  <span data-ttu-id="48f92-1648">これは、プロセスの他のすべてのメソッドが呼び出された後に呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1648">It should be called after all other methods are called on the process.</span></span> <span data-ttu-id="48f92-1649">現在のスレッドがブロックされないようにする場合は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1649">To avoid blocking the current thread, use the <xref:System.Diagnostics.Process.Exited> event.</span></span>  
  
 <span data-ttu-id="48f92-1650">このメソッドに指示、<xref:System.Diagnostics.Process>コンポーネントを膨大な量のプロセスとイベント ハンドラーの終了時間を待機します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1650">This method instructs the <xref:System.Diagnostics.Process> component to wait an infinite amount of time for the process and event handlers to exit.</span></span> <span data-ttu-id="48f92-1651">これには、アプリケーションの応答を停止する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1651">This can cause an application to stop responding.</span></span> <span data-ttu-id="48f92-1652">呼び出す場合など、<xref:System.Diagnostics.Process.CloseMainWindow%2A>ユーザー インターフェイスを持つプロセスでは、オペレーティング システムに要求を関連付けられているプロセスを終了する可能性があります処理されない場合は、プロセスは、メッセージ ループに入ることはなくに書き込まれます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1652">For example, if you call <xref:System.Diagnostics.Process.CloseMainWindow%2A> for a process that has a user interface, the request to the operating system to terminate the associated process might not be handled if the process is written to never enter its message loop.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1653">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]以前のバージョン、<xref:System.Diagnostics.Process.WaitForExit>のオーバー ロードを待機<xref:System.Int32.MaxValue>ミリ秒 (約 24 日)、not 無期限にします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1653">In the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] and earlier versions, the <xref:System.Diagnostics.Process.WaitForExit> overload waited for <xref:System.Int32.MaxValue> milliseconds (approximately 24 days), not indefinitely.</span></span> <span data-ttu-id="48f92-1654">また、以前のバージョン待つことはなく終了イベント ハンドラーの完全な<xref:System.Int32.MaxValue>時間に達しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1654">Also, previous versions did not wait for the event handlers to exit if the full <xref:System.Int32.MaxValue> time was reached.</span></span>  
  
 <span data-ttu-id="48f92-1655">このオーバー ロードにより、リダイレクトされた標準出力の非同期イベントの処理など、すべての処理が完了したこと。</span><span class="sxs-lookup"><span data-stu-id="48f92-1655">This overload ensures that all processing has been completed, including the handling of asynchronous events for redirected standard output.</span></span> <span data-ttu-id="48f92-1656">呼び出しの後に、このオーバー ロードを使用する必要があります、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>オーバー ロードするときに、標準出力は非同期イベント ハンドラーにリダイレクトされました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1656">You should use this overload after a call to the <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload when standard output has been redirected to asynchronous event handlers.</span></span>  
  
 <span data-ttu-id="48f92-1657">システムがプロセスの詳細の管理情報を格納しが呼び出されているコンポーネントを返します (正常または異常終了を操作システムによって停止) の場合は、関連付けられたプロセスが終了したとき<xref:System.Diagnostics.Process.WaitForExit>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1657">When an associated process exits (that is, when it is shut down by the operation system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref:System.Diagnostics.Process.WaitForExit>.</span></span> <span data-ttu-id="48f92-1658"><xref:System.Diagnostics.Process>コンポーネントを含む、情報にアクセスできる、<xref:System.Diagnostics.Process.ExitTime%2A>を使用して、<xref:System.Diagnostics.Process.Handle%2A>終了のプロセスにします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1658">The <xref:System.Diagnostics.Process> component can then access the information, which includes the <xref:System.Diagnostics.Process.ExitTime%2A>, by using the <xref:System.Diagnostics.Process.Handle%2A> to the exited process.</span></span>  
  
 <span data-ttu-id="48f92-1659">関連付けられたプロセスが終了したため、<xref:System.Diagnostics.Process.Handle%2A>コンポーネントのプロパティが不要になった既存のプロセス リソースをポイントします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1659">Because the associated process has exited, the <xref:System.Diagnostics.Process.Handle%2A> property of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="48f92-1660">代わりにのハンドルは、プロセスのリソースについては、オペレーティング システムのアクセスにのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1660">Instead, the handle can be used only to access the operating system's information about the process resource.</span></span> <span data-ttu-id="48f92-1661">システムは、解放されていない終了のプロセスへのハンドルの<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>までメモリ内の情報、<xref:System.Diagnostics.Process>コンポーネントが具体的には、リソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1661">The system is aware of handles to exited processes that have not been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory until the <xref:System.Diagnostics.Process> component specifically frees the resources.</span></span> <span data-ttu-id="48f92-1662">このため、いつでも呼び出す<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンスを呼び出す<xref:System.Diagnostics.Process.Close%2A>と関連付けられたプロセスが終了することについて、管理情報が不要になった。</span><span class="sxs-lookup"><span data-stu-id="48f92-1662">For this reason, any time you call <xref:System.Diagnostics.Process.Start%2A> for a <xref:System.Diagnostics.Process> instance, call <xref:System.Diagnostics.Process.Close%2A> when the associated process has terminated and you no longer need any administrative information about it.</span></span> <span data-ttu-id="48f92-1663"><xref:System.Diagnostics.Process.Close%2A> 終了したプロセスに割り当てられたメモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1663"><xref:System.Diagnostics.Process.Close%2A> frees the memory allocated to the exited process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1664">「解説」を参照してください、<xref:System.Diagnostics.Process.StandardError%2A>プロパティ リファレンスのページ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1664">See the Remarks section of the <xref:System.Diagnostics.Process.StandardError%2A> property reference page.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1665">待機の設定にアクセスできませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1665">The wait setting could not be accessed.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="48f92-1666">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が設定されておらず、<see cref="P:System.Diagnostics.Process.Id" /> プロパティを判別する元となる <see cref="P:System.Diagnostics.Process.Handle" /> が存在しません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1666">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.</span></span>  
  
<span data-ttu-id="48f92-1667">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-1667">-or-</span></span> 
<span data-ttu-id="48f92-1668">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1668">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span>  
  
<span data-ttu-id="48f92-1669">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1669">-or-</span></span> 
<span data-ttu-id="48f92-1670">リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.WaitForExit" /> を呼び出そうとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1670">You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-1671">このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1671">This method is available only for processes that are running on the local computer.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1672">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1672">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1673">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1673">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds"><span data-ttu-id="48f92-1674">関連付けられたプロセスが終了するまで待機する時間。単位はミリ秒です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1674">The amount of time, in milliseconds, to wait for the associated process to exit.</span></span> <span data-ttu-id="48f92-1675">最大値は、32 ビット整数で表現できる最大値で、オペレーティング システムに対して無限大で表現される値です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1675">The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</span></span></param>
        <summary><span data-ttu-id="48f92-1676">関連付けられたプロセスが終了するまで、最大で指定したミリ秒間待機するように <see cref="T:System.Diagnostics.Process" /> コンポーネントに指示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1676">Instructs the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to exit.</span></span></summary>
        <returns><span data-ttu-id="48f92-1677">関連付けられたプロセスが終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1677"><see langword="true" /> if the associated process has exited; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1678"><xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 関連付けられたプロセスが終了するまで待ってから、現在のスレッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1678"><xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> makes the current thread wait until the associated process terminates.</span></span> <span data-ttu-id="48f92-1679">これは、プロセスの他のすべてのメソッドが呼び出された後に呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1679">It should be called after all other methods are called on the process.</span></span> <span data-ttu-id="48f92-1680">現在のスレッドがブロックされないようにする場合は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1680">To avoid blocking the current thread, use the <xref:System.Diagnostics.Process.Exited> event.</span></span>  
  
 <span data-ttu-id="48f92-1681">このメソッドに指示、<xref:System.Diagnostics.Process>コンポーネントをある程度のプロセスが終了する時間を待機します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1681">This method instructs the <xref:System.Diagnostics.Process> component to wait a finite amount of time for the process to exit.</span></span> <span data-ttu-id="48f92-1682">終了する要求が拒否されたため、間隔の終了で関連付けられたプロセスは終了しない場合`false`が呼び出し元のプロシージャに返されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1682">If the associated process does not exit by the end of the interval because the request to terminate is denied, `false` is returned to the calling procedure.</span></span> <span data-ttu-id="48f92-1683">指定できます<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>の`milliseconds`、および<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType>と同様に動作は、<xref:System.Diagnostics.Process.WaitForExit>オーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1683">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for `milliseconds`, and <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> will behave the same as the <xref:System.Diagnostics.Process.WaitForExit> overload.</span></span> <span data-ttu-id="48f92-1684">返すかどうかは、0 (ゼロ) をメソッドに渡す、`true`プロセスが既に終了している場合にのみ、すぐに返します`false`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1684">If you pass 0 (zero) to the method, it returns `true` only if the process has already exited; otherwise, it immediately returns `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="48f92-1685">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]と以前のバージョンで場合`milliseconds`が-1 の場合、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>のオーバー ロードを待機<xref:System.Int32.MaxValue>ミリ秒 (約 24 日)、not 無期限にします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1685">In the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] and earlier versions, if `milliseconds` was -1, the <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> overload waited for <xref:System.Int32.MaxValue> milliseconds (approximately 24 days), not indefinitely.</span></span>  
  
 <span data-ttu-id="48f92-1686">標準出力は、非同期イベント ハンドラーにリダイレクトされましたが、このメソッドが戻るときの出力の処理が完了していないことになります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1686">When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this method returns.</span></span> <span data-ttu-id="48f92-1687">非同期イベント処理が完了したことを確認するを呼び出して、<xref:System.Diagnostics.Process.WaitForExit>を受信した後はパラメーターを受け取らないオーバー ロードを`true`このオーバー ロードからします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1687">To ensure that asynchronous event handling has been completed, call the <xref:System.Diagnostics.Process.WaitForExit> overload that takes no parameter after receiving a `true` from this overload.</span></span> <span data-ttu-id="48f92-1688">ために、<xref:System.Diagnostics.Process.Exited>イベントは、Windows フォーム アプリケーションで正しく処理、設定、<xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1688">To help ensure that the <xref:System.Diagnostics.Process.Exited> event is handled correctly in Windows Forms applications, set the <xref:System.Diagnostics.Process.SynchronizingObject%2A> property.</span></span>  
  
 <span data-ttu-id="48f92-1689">関連付けられたプロセスが終了したとき (がシャット ダウン正常または異常終了により、オペレーティング システムによって)、システムがプロセスの詳細の管理の情報を格納しが呼び出されているコンポーネントを返します<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1689">When an associated process exits (is shut down by the operating system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>.</span></span> <span data-ttu-id="48f92-1690"><xref:System.Diagnostics.Process>コンポーネントを含む、情報にアクセスできる、<xref:System.Diagnostics.Process.ExitTime%2A>を使用して、<xref:System.Diagnostics.Process.Handle%2A>終了のプロセスにします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1690">The <xref:System.Diagnostics.Process> component can then access the information, which includes the <xref:System.Diagnostics.Process.ExitTime%2A>, by using the <xref:System.Diagnostics.Process.Handle%2A> to the exited process.</span></span>  
  
 <span data-ttu-id="48f92-1691">関連付けられたプロセスが終了したため、<xref:System.Diagnostics.Process.Handle%2A>コンポーネントのプロパティが不要になった既存のプロセス リソースをポイントします。</span><span class="sxs-lookup"><span data-stu-id="48f92-1691">Because the associated process has exited, the <xref:System.Diagnostics.Process.Handle%2A> property of the component no longer points to an existing process resource.</span></span> <span data-ttu-id="48f92-1692">代わりにのハンドルは、プロセスのリソースについては、オペレーティング システムのアクセスにのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1692">Instead, the handle can be used only to access the operating system's information about the process resource.</span></span> <span data-ttu-id="48f92-1693">システムは、解放されていない終了のプロセスへのハンドルの<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>までメモリ内の情報、<xref:System.Diagnostics.Process>コンポーネントが具体的には、リソースを解放します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1693">The system is aware of handles to exited processes that have not been released by <xref:System.Diagnostics.Process> components, so it keeps the <xref:System.Diagnostics.Process.ExitTime%2A> and <xref:System.Diagnostics.Process.Handle%2A> information in memory until the <xref:System.Diagnostics.Process> component specifically frees the resources.</span></span> <span data-ttu-id="48f92-1694">このため、いつでも呼び出す<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンスを呼び出す<xref:System.Diagnostics.Process.Close%2A>と関連付けられたプロセスが終了することについて、管理情報が不要になった。</span><span class="sxs-lookup"><span data-stu-id="48f92-1694">For this reason, any time you call <xref:System.Diagnostics.Process.Start%2A> for a <xref:System.Diagnostics.Process> instance, call <xref:System.Diagnostics.Process.Close%2A> when the associated process has terminated and you no longer need any administrative information about it.</span></span> <span data-ttu-id="48f92-1695"><xref:System.Diagnostics.Process.Close%2A> 終了したプロセスに割り当てられたメモリを解放します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1695"><xref:System.Diagnostics.Process.Close%2A> frees the memory allocated to the exited process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1696">コード例をご覧ください、<xref:System.Diagnostics.Process.ExitCode%2A>プロパティ。</span><span class="sxs-lookup"><span data-stu-id="48f92-1696">See the code example for the <xref:System.Diagnostics.Process.ExitCode%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="48f92-1697">待機の設定にアクセスできませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1697">The wait setting could not be accessed.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="48f92-1698">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が設定されておらず、<see cref="P:System.Diagnostics.Process.Id" /> プロパティを判別する元となる <see cref="P:System.Diagnostics.Process.Handle" /> が存在しません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1698">No process <see cref="P:System.Diagnostics.Process.Id" /> has been set, and a <see cref="P:System.Diagnostics.Process.Handle" /> from which the <see cref="P:System.Diagnostics.Process.Id" /> property can be determined does not exist.</span></span>  
  
<span data-ttu-id="48f92-1699">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-1699">-or-</span></span> 
<span data-ttu-id="48f92-1700">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1700">There is no process associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span>  
  
<span data-ttu-id="48f92-1701">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-1701">-or-</span></span> 
<span data-ttu-id="48f92-1702">リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> を呼び出そうとしています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1702">You are attempting to call <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> for a process that is running on a remote computer.</span></span> <span data-ttu-id="48f92-1703">このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1703">This method is available only for processes that are running on the local computer.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="48f92-1704"><paramref name="milliseconds" /> は無限のタイムアウトを表す -1 以外の負の数です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1704"><paramref name="milliseconds" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1705">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1705">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1706">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1706">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="48f92-1707">関連付けられたプロセスがアイドル状態になるまで、<see cref="T:System.Diagnostics.Process" /> コンポーネントを待機させます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1707">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait for the associated process to enter an idle state.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="48f92-1708">関連付けられたプロセスがアイドル状態になるまで、<see cref="T:System.Diagnostics.Process" /> コンポーネントを無期限に待機させます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1708">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait indefinitely for the associated process to enter an idle state.</span></span> <span data-ttu-id="48f92-1709">このオーバーロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスにだけ適用されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1709">This overload applies only to processes with a user interface and, therefore, a message loop.</span></span></summary>
        <returns><span data-ttu-id="48f92-1710">関連付けられたプロセスがアイドル状態になった場合は <see langword="true" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1710"><see langword="true" /> if the associated process has reached an idle state.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1711">使用<xref:System.Diagnostics.Process.WaitForInputIdle>メッセージ ループがアイドル状態に返されるまで待機する、アプリケーションの処理を強制します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1711">Use <xref:System.Diagnostics.Process.WaitForInputIdle> to force the processing of your application to wait until the message loop has returned to the idle state.</span></span> <span data-ttu-id="48f92-1712">ユーザー インターフェイスを持つプロセスを実行しているときに、オペレーティング システムで Windows メッセージがプロセスに送信されるたびに、メッセージ ループを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1712">When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="48f92-1713">プロセスは、メッセージ ループに戻ります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1713">The process then returns to the message loop.</span></span> <span data-ttu-id="48f92-1714">プロセスは、メッセージ ループ内でメッセージを待機しているアイドル状態であると言います。</span><span class="sxs-lookup"><span data-stu-id="48f92-1714">A process is said to be in an idle state when it is waiting for messages inside of a message loop.</span></span> <span data-ttu-id="48f92-1715">この状態は、アプリケーションは、開始のプロセス、アプリケーションはそのウィンドウと通信する前に、メイン ウィンドウの作成を完了するまで待機する必要がある場合などに便利です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1715">This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</span></span>  
  
 <span data-ttu-id="48f92-1716">プロセスは、メッセージ ループを持っていない場合<xref:System.Diagnostics.Process.WaitForInputIdle>スロー、<xref:System.InvalidOperationException>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1716">If a process does not have a message loop, <xref:System.Diagnostics.Process.WaitForInputIdle> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="48f92-1717"><xref:System.Diagnostics.Process.WaitForInputIdle>オーバー ロードの指示、<xref:System.Diagnostics.Process>メッセージ ループ内でアイドル状態になるプロセスを無期限に待機するコンポーネント。</span><span class="sxs-lookup"><span data-stu-id="48f92-1717">The <xref:System.Diagnostics.Process.WaitForInputIdle> overload instructs the <xref:System.Diagnostics.Process> component to wait indefinitely for the process to become idle in the message loop.</span></span> <span data-ttu-id="48f92-1718">この命令には、アプリケーションの応答を停止する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1718">This instruction can cause an application to stop responding.</span></span> <span data-ttu-id="48f92-1719">たとえば、プロセスが常に作成する場合、メッセージ ループを即座に終了コード フラグメントは、のように`while(true)`します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1719">For example, if the process is written to always exit its message loop immediately, as in the code fragment `while(true)`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1720">プロセスにグラフィカル インターフェイスがありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1720">The process does not have a graphical interface.</span></span>  
  
<span data-ttu-id="48f92-1721">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-1721">-or-</span></span> 
<span data-ttu-id="48f92-1722">不明なエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1722">An unknown error occurred.</span></span> <span data-ttu-id="48f92-1723">プロセスがアイドル状態になることができませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1723">The process failed to enter an idle state.</span></span>  
  
<span data-ttu-id="48f92-1724">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-1724">-or-</span></span> 
<span data-ttu-id="48f92-1725">プロセスは既に終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1725">The process has already exited.</span></span>  
  
<span data-ttu-id="48f92-1726">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-1726">-or-</span></span> 
<span data-ttu-id="48f92-1727">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1727">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1728">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1728">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1729">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1729">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds"><span data-ttu-id="48f92-1730">関連付けられたプロセスがアイドル状態になるまでの待機時間をミリ秒単位で指定する、1 ～ <see cref="F:System.Int32.MaxValue" /> の値。</span><span class="sxs-lookup"><span data-stu-id="48f92-1730">A value of 1 to <see cref="F:System.Int32.MaxValue" /> that specifies the amount of time, in milliseconds, to wait for the associated process to become idle.</span></span> <span data-ttu-id="48f92-1731">値 0 の場合はすぐに制御が戻され、値 -1 の場合は無期限に待機することを示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1731">A value of 0 specifies an immediate return, and a value of -1 specifies an infinite wait.</span></span></param>
        <summary><span data-ttu-id="48f92-1732">関連付けられたプロセスがアイドル状態になるまで、最大で指定したミリ秒間、<see cref="T:System.Diagnostics.Process" /> コンポーネントを待機させます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1732">Causes the <see cref="T:System.Diagnostics.Process" /> component to wait the specified number of milliseconds for the associated process to enter an idle state.</span></span> <span data-ttu-id="48f92-1733">このオーバーロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスにだけ適用されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1733">This overload applies only to processes with a user interface and, therefore, a message loop.</span></span></summary>
        <returns><span data-ttu-id="48f92-1734">関連付けられたプロセスがアイドル状態になった場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="48f92-1734"><see langword="true" /> if the associated process has reached an idle state; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1735">使用<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>メッセージ ループがアイドル状態に返されるまで待機する、アプリケーションの処理を強制します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1735">Use <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> to force the processing of your application to wait until the message loop has returned to the idle state.</span></span> <span data-ttu-id="48f92-1736">ユーザー インターフェイスを持つプロセスを実行しているときに、オペレーティング システムで Windows メッセージがプロセスに送信されるたびに、メッセージ ループを実行します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1736">When a process with a user interface is executing, its message loop executes every time a Windows message is sent to the process by the operating system.</span></span> <span data-ttu-id="48f92-1737">プロセスは、メッセージ ループに戻ります。</span><span class="sxs-lookup"><span data-stu-id="48f92-1737">The process then returns to the message loop.</span></span> <span data-ttu-id="48f92-1738">プロセスは、メッセージ ループ内でメッセージを待機しているアイドル状態であると言います。</span><span class="sxs-lookup"><span data-stu-id="48f92-1738">A process is said to be in an idle state when it is waiting for messages inside of a message loop.</span></span> <span data-ttu-id="48f92-1739">この状態は、アプリケーションは、開始のプロセス、アプリケーションはそのウィンドウと通信する前に、メイン ウィンドウの作成を完了するまで待機する必要がある場合などに便利です。</span><span class="sxs-lookup"><span data-stu-id="48f92-1739">This state is useful, for example, when your application needs to wait for a starting process to finish creating its main window before the application communicates with that window.</span></span>  
  
 <span data-ttu-id="48f92-1740">プロセスは、メッセージ ループを持っていない場合<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>スロー、<xref:System.InvalidOperationException>します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1740">If a process does not have a message loop, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="48f92-1741"><xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>オーバー ロードの指示、<xref:System.Diagnostics.Process>コンポーネントをある程度のメッセージ ループ内でアイドル状態になるプロセスの時間を待機します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1741">The <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> overload instructs the <xref:System.Diagnostics.Process> component to wait a finite amount of time for the process to become idle in the message loop.</span></span> <span data-ttu-id="48f92-1742">関連付けられたプロセスには、ループがまだメッセージを処理するため、間隔の終了までにアイドル状態ならない場合`false`が呼び出し元のプロシージャに返されます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1742">If the associated process has not become idle by the end of the interval because the loop is still processing messages, `false` is returned to the calling procedure.</span></span>  
  
 <span data-ttu-id="48f92-1743">イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="48f92-1743">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="48f92-1744">プロセスにグラフィカル インターフェイスがありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1744">The process does not have a graphical interface.</span></span>  
  
<span data-ttu-id="48f92-1745">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1745">-or-</span></span> 
<span data-ttu-id="48f92-1746">不明なエラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="48f92-1746">An unknown error occurred.</span></span> <span data-ttu-id="48f92-1747">プロセスがアイドル状態になることができませんでした。</span><span class="sxs-lookup"><span data-stu-id="48f92-1747">The process failed to enter an idle state.</span></span>  
  
<span data-ttu-id="48f92-1748">- または -</span><span class="sxs-lookup"><span data-stu-id="48f92-1748">-or-</span></span> 
<span data-ttu-id="48f92-1749">プロセスは既に終了しています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1749">The process has already exited.</span></span>  
  
<span data-ttu-id="48f92-1750">または</span><span class="sxs-lookup"><span data-stu-id="48f92-1750">-or-</span></span> 
<span data-ttu-id="48f92-1751">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1751">No process is associated with this <see cref="T:System.Diagnostics.Process" /> object.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1752">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1752">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1753">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1753">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1754">関連付けられたプロセスの物理メモリ使用量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1754">Gets the associated process's physical memory usage, in bytes.</span></span></summary>
        <value><span data-ttu-id="48f92-1755">関連付けられたプロセスが使用している物理メモリの合計容量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-1755">The total amount of physical memory the associated process is using, in bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1756">このプロパティによって返される値は、ワーキング セット メモリのバイト単位で、プロセスによって使用されるは、現在のサイズを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1756">The value returned by this property represents the current size of working set memory used by the process, in bytes.</span></span> <span data-ttu-id="48f92-1757">プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。</span><span class="sxs-lookup"><span data-stu-id="48f92-1757">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="48f92-1758">これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1758">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="48f92-1759">ワーキング セットには、共有とプライベートの両方のデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1759">The working set includes both shared and private data.</span></span> <span data-ttu-id="48f92-1760">共有データには、プロセスのモジュールや、システム ライブラリなど、プロセスが実行されるすべての指示を含むページが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1760">The shared data includes the pages that contain all the instructions that the process executes, including the process modules and the system libraries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1761">次の例では、メモ帳のインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1761">The following example starts an instance of Notepad.</span></span> <span data-ttu-id="48f92-1762">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1762">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-1763">例では、検出プロセスが終了すると、プロセスの終了コードを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1763">The example detects when the process exits, and displays the process' exit code.</span></span>  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1764">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1764">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1765">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1765">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1766">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1766">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="48f92-1767">関連付けられたプロセスに割り当てられた物理メモリの量 (バイト単位) を取得します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1767">Gets the amount of physical memory, in bytes, allocated for the associated process.</span></span></summary>
        <value><span data-ttu-id="48f92-1768">関連付けられたプロセスに割り当てられた物理メモリの量 (バイト単位)。</span><span class="sxs-lookup"><span data-stu-id="48f92-1768">The amount of physical memory, in bytes, allocated for the associated process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="48f92-1769">このプロパティによって返される値は、ワーキング セット メモリのバイト単位で、プロセスによって使用されるは、現在のサイズを表します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1769">The value returned by this property represents the current size of working set memory used by the process, in bytes.</span></span> <span data-ttu-id="48f92-1770">プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。</span><span class="sxs-lookup"><span data-stu-id="48f92-1770">The working set of a process is the set of memory pages currently visible to the process in physical RAM memory.</span></span> <span data-ttu-id="48f92-1771">これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1771">These pages are resident and available for an application to use without triggering a page fault.</span></span>  
  
 <span data-ttu-id="48f92-1772">ワーキング セットには、共有とプライベートの両方のデータが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1772">The working set includes both shared and private data.</span></span> <span data-ttu-id="48f92-1773">共有データには、プロセスのモジュールと、システム ライブラリの命令など、プロセスが実行されるすべての指示を含むページが含まれています。</span><span class="sxs-lookup"><span data-stu-id="48f92-1773">The shared data includes the pages that contain all the instructions that the process executes, including instructions in the process modules and the system libraries.</span></span>  
  
 <span data-ttu-id="48f92-1774">このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。</span><span class="sxs-lookup"><span data-stu-id="48f92-1774">This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors.</span></span> <span data-ttu-id="48f92-1775">プロパティ値が等しく、**ワーキング セット**プロセスのパフォーマンス カウンター。</span><span class="sxs-lookup"><span data-stu-id="48f92-1775">The property value is equivalent to the **Working Set** performance counter for the process.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="48f92-1776">次のコード例では、メモ帳アプリケーションのインスタンスを開始します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1776">The following code example starts an instance of the Notepad application.</span></span> <span data-ttu-id="48f92-1777">例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1777">The example then retrieves and displays various properties of the associated process.</span></span> <span data-ttu-id="48f92-1778">例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。</span><span class="sxs-lookup"><span data-stu-id="48f92-1778">The example detects when the process exits, and displays its exit code and peak memory statistics.</span></span>  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="48f92-1779">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) であるため、このプロパティはサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1779">The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="48f92-1780">直前の呼び出し元に対する完全な信頼。</span><span class="sxs-lookup"><span data-stu-id="48f92-1780">for full trust for the immediate caller.</span></span> <span data-ttu-id="48f92-1781">このメンバーは、部分的に信頼されているコードから使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="48f92-1781">This member cannot be used by partially trusted code.</span></span></permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>