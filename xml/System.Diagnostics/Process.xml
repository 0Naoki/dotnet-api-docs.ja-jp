<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6b1dc611089c85302c9d21de8cb2fc5281ea5b4d" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57937326" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>ローカル プロセスやリモート プロセスへのアクセスを提供し、ローカル システム プロセスの起動と停止ができるようにします。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process> コンポーネントは、コンピューターで実行されているプロセスへのアクセスを提供します。 プロセスとは、簡単に言えば実行中のアプリです。 スレッドは、オペレーティング システムがプロセッサ時間を割り当てる基本単位です。 スレッドは、別のスレッドによって実行されている部分を含む、プロセスのコードの任意の部分を実行できます。  
  
 <xref:System.Diagnostics.Process>コンポーネントは、アプリの起動、停止、制御、および監視を行うための便利なツールです。 <xref:System.Diagnostics.Process>コンポーネントを使用して、実行中のプロセスの一覧を取得したり、新しいプロセスを開始したりできます。 システム プロセスにアクセスするには、<xref:System.Diagnostics.Process> コンポーネントを使用します。 <xref:System.Diagnostics.Process>コンポーネントを初期化した後は、実行中のプロセスに関する情報を取得するために使用できます。 そのような情報には、スレッドのセットや、読み込まれたモジュール (.dll と .exe ファイル)、プロセスが使用しているメモリの量などのパフォーマンス情報が含まれます。  
  
 この型は <xref:System.IDisposable> インターフェイスを実装します。 型の使用が完了したら、直接的または間接的に型を破棄する必要があります。 直接的に型を破棄するには、`try` / `finally` ブロック内で <xref:System.IDisposable.Dispose%2A> メソッドを呼び出します。 間接的に型を破棄するには、`using` (C# の場合) または `Using` (Visual Basic 言語) などの言語構成要素を使用します。 詳細については、<xref:System.IDisposable> インターフェイスに関するトピック内の「IDisposable を実装するオブジェクトの使用」セクションを参照してください。  
  
> [!NOTE]
>  32 ビット プロセスは 64 ビット プロセスのモジュールにアクセスできません。 32 ビット プロセスから 64 ビット プロセスの詳細情報を取得しようとすると、<xref:System.ComponentModel.Win32Exception> 例外が発生します。 一方で、64 ビット プロセスは 32 ビット プロセスのモジュールにアクセスできます。  
  
 プロセス コンポーネントは、一度にすべてのプロパティのグループに関する情報を取得します。 <xref:System.Diagnostics.Process> コンポーネントは、いずれかのグループの 1 つのメンバーに関する情報を取得した後は、そのグループ内の他のプロパティの値をキャッシュします。そして、<xref:System.Diagnostics.Process.Refresh%2A> メソッドを呼び出すまで、そのグループの他のメンバーに関する新しい情報を取得しません。 そのため、プロパティ値は、最後の <xref:System.Diagnostics.Process.Refresh%2A> メソッドの呼び出しよりも新しい値を保証しません。 グループの内訳はオペレーティング システムに依存します。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
 システム プロセスは、プロセス識別子によって、システムで一意に識別されます。 多くの Windows リソースと同様に、プロセスはそれのハンドルによっても識別されますが、ハンドルはコンピューター上で一意でない場合があります。 ハンドルはリソースの識別子の総称です。 プロセス ハンドルは、オペレーティング システムによって保持され、<xref:System.Diagnostics.Process.Handle%2A> コンポーネントの <xref:System.Diagnostics.Process> プロパティを通じてアクセスできます。 これはプロセスが終了した場合でもアクセスできます。これにより、<xref:System.Diagnostics.Process.ExitCode%2A> (通常は、成功を示す 0 か、0 以外のエラー コードのどちらかです) や <xref:System.Diagnostics.Process.ExitTime%2A> などの、プロセスの管理情報を取得できます。 ハンドルは非常に貴重なリソースなので、ハンドル リークはメモリ リークよりも有害です。  
  
> [!NOTE]
>  このクラスには、リンク確認要求と、すべてのメンバーに適用されるクラス レベルの継承確認要求が含まれています。 直接の呼び出し元か派生クラスのいずれかに完全信頼アクセス許可がない場合、<xref:System.Security.SecurityException> がスローされます。 セキュリティ要求の詳細については、「[リンク確認要求](~/docs/framework/misc/link-demands.md)」を参照してください。  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] での注意  
 .NET Framework では、既定では <xref:System.Diagnostics.Process> クラスは <xref:System.Console> のエンコードを使用します。これは、入力ストリーム、出力ストリーム、およびエラー ストリームについては、通常はコード ページ エンコードです。 コード例では、システムのカルチャが英語 (米国) で、コード ページ 437 が <xref:System.Console> クラスの既定のエンコードです。 しかし、[!INCLUDE[net_core](~/includes/net-core-md.md)] では、これらのエンコードの限られたサブセットしか使用できないことがあります。 その場合は、<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> を既定のエンコードとして使用します。  
  
 <xref:System.Diagnostics.Process> オブジェクトが特定のコード ページ エンコードに依存している場合、<xref:System.Diagnostics.Process> のメソッドを呼び出す*前に*次の手順を行うと、特定のコード ページ エンコードも利用できます。  
  
1.  System.Text.Encoding.CodePages.dll アセンブリへの参照をプロジェクトに追加します。  
  
2.  <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> プロパティから、<xref:System.Text.EncodingProvider> オブジェクトを取得します。  
  
3.  <xref:System.Text.EncodingProvider> オブジェクトを <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> メソッドに渡すと、エンコーディング プロバイダーでサポートされているその他のエンコードを利用できるようになります。  
  
 <xref:System.Diagnostics.Process> のメソッドを呼び出す前にエンコーディング プロバイダーを登録していれば、<xref:System.Diagnostics.Process> クラスは、UTF8 ではなく既定のシステム エンコードを自動的に使用します。  
  
   
  
## Examples  
 次の例のインスタンスを使用して、<xref:System.Diagnostics.Process>プロセスを開始するクラス。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 次の例では、<xref:System.Diagnostics.Process>クラス自体と静的な<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するメソッド。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 次F#例、 `runProc` 、プロセスを開始する関数はすべての出力とエラー情報をキャプチャし、プロセスが実行時間をミリ秒単位の数を記録します。  `runProc`関数には、3 つのパラメーター: アプリケーションの起動、アプリケーション、および開始ディレクトリを指定する引数の名前。  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 コードを`runProc`によって関数が書き込まれた[ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment)下にあると、 [Microsoft Public License](https://opensource.org/licenses/ms-pl)します。  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このクラスは、部分的に信頼されたコードでは使用できません。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">継承クラスの完全な信頼。 部分的に信頼されたコードでは、このクラスを継承できません。</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">.NET Process クラスを使用します。</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定しない場合、<xref:System.Diagnostics.Process.MachineName%2A>プロパティ、既定値は、ローカル コンピューター (".")。  
  
 新しいに関連付けるための 2 つのオプションがある<xref:System.Diagnostics.Process>コンピューター上のプロセスとコンポーネント。 最初のオプションが、コンス トラクターを使用して作成するには、<xref:System.Diagnostics.Process>コンポーネント、設定の適切なメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティと呼び出し<xref:System.Diagnostics.Process.Start%2A>に関連付ける、<xref:System.Diagnostics.Process>新しいシステム プロセスを。 2 番目のオプションを関連付けるには、<xref:System.Diagnostics.Process>を使用して、実行中のシステム プロセスと<xref:System.Diagnostics.Process.GetProcessById%2A>またはのいずれか、<xref:System.Diagnostics.Process.GetProcesses%2A>値を返します。  
  
 使用する場合、`static`のオーバー ロード、 <xref:System.Diagnostics.Process.Start%2A> 、メソッド、新規システム プロセスを開始する方法が新たに作成<xref:System.Diagnostics.Process>コンポーネント、プロセスに関連付けます。  
  
 ときに、<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>プロパティがその既定値に設定`true`を使用して次のような方法でアプリケーションとドキュメントを開始することができます、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>は`false`、実行可能ファイルだけを開始することができます。  
  
 コマンドラインから呼び出すことができる実行可能ファイルは、2 つの方法のいずれかで開始できます: の適切なメンバーを設定して、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティと呼び出し、<xref:System.Diagnostics.Process.Start%2A>メソッドのパラメーターなしで、または適切なパラメーターを渡すことによって、`static` <xref:System.Diagnostics.Process.Start%2A>メンバー。  
  
 作成することができます、 <xref:System.Diagnostics.Process> 、静的なコンス トラクターを使用してコンポーネント<xref:System.Diagnostics.Process.Start%2A>のいずれかのオーバー ロード、または、 <xref:System.Diagnostics.Process.GetProcessById%2A>、 <xref:System.Diagnostics.Process.GetProcesses%2A>、または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッド。 関連付けられたプロセスにビューがあるため、設定が終了します。 これはメモリ内でプロセスのプロパティが変更されたときに自動的に更新される動的ビューではありません。 代わりに、呼び出す必要がある<xref:System.Diagnostics.Process.Refresh%2A>コンポーネントを更新するため、<xref:System.Diagnostics.Process>アプリケーションでプロパティ情報。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの基本優先順位を取得します。</summary>
        <value>関連付けられたプロセスの <see cref="P:System.Diagnostics.Process.PriorityClass" /> から算出される基本優先順位。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BasePriority%2A>プロセスが関連付けられているプロセス内で作成されたスレッドを開始する優先度。 システム モニターの優先度ベース カウンター基本優先順位に関する情報を表示できます。  
  
 プロセスは、他のユーザーの前に配置するときに、経過時間、またはその他の要因、オペレーティング システムは基本優先順位を変更できます時間に基づいています。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>プロパティでは、プロセスに割り当てられている開始の優先順位を表示することができます。 ただし、これは、読み取り専用であるために使用できません、<xref:System.Diagnostics.Process.BasePriority%2A>プロセスの優先順位を設定します。 優先順位を変更するには、使用、<xref:System.Diagnostics.Process.PriorityClass%2A>プロパティ。 <xref:System.Diagnostics.Process.BasePriority%2A>表示できる中に、システム モニターを使用して、<xref:System.Diagnostics.Process.PriorityClass%2A>はありません。 両方の<xref:System.Diagnostics.Process.BasePriority%2A>と<xref:System.Diagnostics.Process.PriorityClass%2A>プログラムから表示できます。 次の表は、関係<xref:System.Diagnostics.Process.BasePriority%2A>値と<xref:System.Diagnostics.Process.PriorityClass%2A>値。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスが終了しています。  
  
または 
プロセスが開始されていないため、プロセス ID はありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで、非同期読み取り操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardError%2A>同期または非同期でストリームを読み取ることができます。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスのエラー出力ストリームでの同期読み取り操作を実行します。 関連付けられているまで操作を実行しないでこれらの同期読み取り<xref:System.Diagnostics.Process>を書き込みます、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはストリームを閉じます。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。 このメソッドは、ストリームの出力に指定されたイベント ハンドラーを有効し、すぐにストリーム出力するイベント ハンドラー中に、その他の作業を実行できる呼び出し元に返します。  
  
 非同期の読み取り操作を実行する次の手順に従って<xref:System.Diagnostics.Process.StandardError%2A>の<xref:System.Diagnostics.Process>:  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> を `false` に設定します。  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> を `true` に設定します。  
  
3.  イベント ハンドラーを追加、<xref:System.Diagnostics.Process.ErrorDataReceived>イベント。 イベント ハンドラーに一致する必要があります、<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>デリゲート シグネチャ。  
  
4.  開始、<xref:System.Diagnostics.Process>します。  
  
5.  呼び出す<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>の<xref:System.Diagnostics.Process>します。 この呼び出しで非同期読み取り操作を開始する<xref:System.Diagnostics.Process.StandardError%2A>します。  
  
 たびに、関連付けられている非同期読み取り操作の開始、イベント ハンドラーが呼び出されたときに<xref:System.Diagnostics.Process>行のテキストを書き込み、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
 非同期の読み取り操作をキャンセルするには呼び出すことによって<xref:System.Diagnostics.Process.CancelErrorRead%2A>します。 呼び出し元によって、またはイベント ハンドラーによって、読み取り操作をキャンセルできます。 キャンセル後に呼び出すことができます<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>非同期読み取り操作を再開します。  
  
> [!NOTE]
>  リダイレクトされたストリームで読み取り操作を非同期と同期を混在させることはできません。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。 例に従っていない<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>への呼び出しで<xref:System.IO.StreamReader.ReadLine%2A>上、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはその逆。 ただし、異なるモードでの 2 つの異なるストリームを読み取ることができます。 たとえば、呼び出す<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>を呼び出して<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。  
  
   
  
## Examples  
 次の例では、`net view`コマンドをリモート コンピューターで使用可能なネットワーク リソースを一覧表示します。 ユーザーは、コマンドライン引数として対象のコンピューター名を提供します。 ユーザーには、エラー出力のファイル名を指定もできます。 この例では、プロセスを完了して、出力がコンソールに結果の書き込みの待機、net コマンドの出力を収集します。 ユーザーがオプションのエラー ファイルを指定する場合、例は、ファイルにエラーを書き込みます。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> プロパティが <see langword="false" /> である。  
  
または 
<see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで非同期読み取り操作は既に実行されています。  
  
または 
<see cref="P:System.Diagnostics.Process.StandardError" /> ストリームは、同期読み取り操作によって使用されています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで、非同期読み取り操作を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StandardOutput%2A>同期または非同期でストリームを読み取ることができます。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスの出力ストリームに同期の読み取り操作を実行します。 関連付けられているまで操作を実行しないでこれらの同期読み取り<xref:System.Diagnostics.Process>を書き込みます、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはストリームを閉じます。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 このメソッドは、ストリーム出力に指定されたイベント ハンドラーを有効にして、すぐにストリーム出力するイベント ハンドラー中に、その他の作業を実行できる呼び出し元に返します。  
  
 非同期の読み取り操作を実行する次の手順に従って<xref:System.Diagnostics.Process.StandardOutput%2A>の<xref:System.Diagnostics.Process>:  
  
1.  <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> を `false` に設定します。  
  
2.  <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> を `true` に設定します。  
  
3.  イベント ハンドラーを追加、<xref:System.Diagnostics.Process.OutputDataReceived>イベント。 イベント ハンドラーに一致する必要があります、<xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType>デリゲート シグネチャ。  
  
4.  開始、<xref:System.Diagnostics.Process>します。  
  
5.  呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>の<xref:System.Diagnostics.Process>します。 この呼び出しで非同期読み取り操作を開始する<xref:System.Diagnostics.Process.StandardOutput%2A>します。  
  
 たびに、関連付けられている非同期読み取り操作の開始、イベント ハンドラーが呼び出されたときに<xref:System.Diagnostics.Process>行のテキストを書き込み、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。  
  
 非同期の読み取り操作をキャンセルするには呼び出すことによって<xref:System.Diagnostics.Process.CancelOutputRead%2A>します。 呼び出し元によって、またはイベント ハンドラーによって、読み取り操作をキャンセルできます。 キャンセル後に呼び出すことができます<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>非同期読み取り操作を再開します。  
  
> [!NOTE]
>  リダイレクトされたストリームで読み取り操作を非同期と同期を混在させることはできません。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。 例に従っていない<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>への呼び出しで<xref:System.IO.StreamReader.ReadLine%2A>上、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはその逆。 ただし、異なるモードでの 2 つの異なるストリームを読み取ることができます。 たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を呼び出して<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
   
  
## Examples  
 次の例では、リダイレクトされたで非同期の読み取り操作を実行する方法を示しています。<xref:System.Diagnostics.Process.StandardOutput%2A>のストリーム、`sort`コマンド。 `sort`コマンドは、コンソール アプリケーションを読み取り、テキスト入力を並べ替えます。  
  
 例でのイベントのデリゲートを作成、`SortOutputHandler`イベント ハンドラーを関連付けます、<xref:System.Diagnostics.Process.OutputDataReceived>イベント。 イベント ハンドラーがリダイレクトされたからテキスト行を受け取る<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、テキストを書式設定し、画面にテキストを書き込みます。  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> プロパティが <see langword="false" /> である。  
  
または 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで非同期読み取り操作は既に実行されています。  
  
または 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームは、同期読み取り操作によって使用されています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームで、非同期読み取り操作をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> 非同期読み取り操作を開始、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。 <xref:System.Diagnostics.Process.CancelErrorRead%2A> 終了、非同期の読み取り操作。  
  
 キャンセル後に呼び出すことによって、非同期読み取り操作を再開できます<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>もう一度です。  
  
 呼び出すと<xref:System.Diagnostics.Process.CancelErrorRead%2A>、すべて進行中の読み取り操作の<xref:System.Diagnostics.Process.StandardError%2A>が完了し、イベント ハンドラーが無効になっています。 さらにリダイレクトされたすべての出力を<xref:System.Diagnostics.Process.StandardError%2A>は失われます。 イベント ハンドラーへの呼び出しで再度有効にするかどうかは<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>、非同期読み取り操作を再開します。 非同期の読み取り操作を再開する前に、イベント ハンドラーを変更する場合は、新しいイベント ハンドラーを追加する前に既存のイベント ハンドラーを削除する必要があります。  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  リダイレクトされた上および非同期の読み取り操作を混在させることはできません<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。 キャンセルした場合、非同期の読み取り操作で<xref:System.Diagnostics.Process.StandardError%2A>ストリームから読み取る、もう一度、使用する必要がありますし、必要がある<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>非同期読み取り操作を再開します。 従っていない<xref:System.Diagnostics.Process.CancelErrorRead%2A>読み取りのメソッドを呼び出し、同期を<xref:System.Diagnostics.Process.StandardError%2A>など<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、または<xref:System.IO.StreamReader.ReadToEnd%2A>します。  
  
   
  
## Examples  
 次の例では、開始、`nmake`コマンドでは、ユーザーが指定された引数。 エラーと出力ストリームが非同期的に読み取り収集されたテキスト行は、コンソールに表示されるだけでなくログ ファイルに書き込まれます。 コマンドの出力は、指定された行数を超えている場合は、非同期読み取り操作が取り消されました。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームは、非同期読み取り操作では有効になっていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションのリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームで、非同期読み取り操作をキャンセルします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> 非同期読み取り操作を開始、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 <xref:System.Diagnostics.Process.CancelOutputRead%2A> 終了、非同期の読み取り操作。  
  
 キャンセル後に呼び出すことによって、非同期読み取り操作を再開できます<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>もう一度です。  
  
 呼び出すと<xref:System.Diagnostics.Process.CancelOutputRead%2A>、すべて進行中の読み取り操作の<xref:System.Diagnostics.Process.StandardOutput%2A>が完了し、イベント ハンドラーが無効になっています。 さらにリダイレクトされたすべての出力を<xref:System.Diagnostics.Process.StandardOutput%2A>バッファーに保存されます。 イベント ハンドラーへの呼び出しで再度有効にするかどうかは<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>、保存済みの出力は、イベント ハンドラーに送信し、非同期読み取り操作を再開します。 非同期の読み取り操作を再開する前に、イベント ハンドラーを変更する場合は、新しいイベント ハンドラーを追加する前に既存のイベント ハンドラーを削除する必要があります。  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  リダイレクトされた上および非同期の読み取り操作を混在させることはできません<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。 キャンセルした場合、非同期の読み取り操作で<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームから読み取る、もう一度、使用する必要がありますし、必要がある<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>非同期読み取り操作を再開します。 従っていない<xref:System.Diagnostics.Process.CancelOutputRead%2A>読み取りのメソッドを呼び出し、同期を<xref:System.Diagnostics.Process.StandardOutput%2A>など<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、または<xref:System.IO.StreamReader.ReadToEnd%2A>します。  
  
   
  
## Examples  
 次の例では、開始、`nmake`コマンドでは、ユーザーが指定された引数。 エラーと出力ストリームが非同期的に読み取り収集されたテキスト行は、コンソールに表示されるだけでなくログ ファイルに書き込まれます。 コマンドの出力は、指定された行数を超えている場合は、非同期読み取り操作が取り消されました。  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームは、非同期読み取り操作では有効になっていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このコンポーネントに関連付けられているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Close%2A>メソッドにより、プロセスの終了が待機している場合、プロセスのハンドルを終了してプロセス固有のプロパティをクリアしますに待機を停止します。 <xref:System.Diagnostics.Process.Close%2A> 外部から参照されている場合に、標準の出力、入力、およびエラーのリーダーとライターを終了しません。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Dispose%2A> メソッドは <xref:System.Diagnostics.Process.Close%2A> を呼び出します。 配置すること、<xref:System.Diagnostics.Process>オブジェクト、`using`ブロックを呼び出すことがなくリソースを破棄<xref:System.Diagnostics.Process.Close%2A>します。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 関連付けられたプロセスの物理メモリ使用量は 10 秒間に最大 2 秒間隔で取得します。 この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。 例は、10 秒後に実行されている場合、プロセスを閉じます。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メイン ウィンドウにクローズ メッセージを送信して、ユーザー インターフェイスがあるプロセスを終了します。</summary>
        <returns>クローズ メッセージが正常に送信された場合は <see langword="true" />。関連付けられたプロセスにメイン ウィンドウがない場合、またはメイン ウィンドウが使用できない場合 (モーダル ダイアログ ボックスが表示されているときなど) は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスを実行しているときに、メッセージ ループは、待機状態です。 オペレーティング システムが Windows メッセージがプロセスに送信されるたびにメッセージ ループを実行します。 呼び出す<xref:System.Diagnostics.Process.CloseMainWindow%2A>メイン ウィンドウに、適切な形式でのアプリケーションでは、子ウィンドウを閉じ、アプリケーションの実行中のすべてのメッセージ ループでは失効の近くに要求を送信します。 呼び出すことによって、プロセスを終了する要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>アプリケーションの終了を強制しません。 アプリケーションは、終了する前にユーザー認証を求めることまたは拒否を終了することができます。 アプリケーションの終了を強制するには使用、<xref:System.Diagnostics.Process.Kill%2A>メソッド。 動作<xref:System.Diagnostics.Process.CloseMainWindow%2A>システム メニューを使用して、アプリケーションのメイン ウィンドウを閉じると、ユーザーの場合と同じです。 そのため、メイン ウィンドウを閉じることでプロセスを終了する要求はすぐに終了するアプリケーションを強制しません。  
  
 プロセスによって編集されたデータまたはプロセスに割り当てられたリソースが失われる場合を呼び出す<xref:System.Diagnostics.Process.Kill%2A>します。 <xref:System.Diagnostics.Process.Kill%2A> により、プロセスが異常終了と必要な場合にのみ使用する必要があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> により、プロセスの手順の終了し、インターフェイスを使用するアプリケーションのことをお勧めしているために、すべての windows を閉じます。 場合<xref:System.Diagnostics.Process.CloseMainWindow%2A>使用することができますが失敗した<xref:System.Diagnostics.Process.Kill%2A>プロセスを終了します。 <xref:System.Diagnostics.Process.Kill%2A> グラフィカル インターフェイスがないプロセスを終了する唯一の方法です。  
  
 呼び出すことができます<xref:System.Diagnostics.Process.Kill%2A>と<xref:System.Diagnostics.Process.CloseMainWindow%2A>ローカル コンピューターで実行されているプロセスに対してのみです。 プロセスが終了するリモート コンピューターで発生することはできません。 リモート コンピューター上で実行されているプロセスの情報のみ表示できます。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 関連付けられたプロセスの物理メモリ使用量は 10 秒間に最大 2 秒間隔で取得します。 この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。 例は、10 秒後に実行されている場合、プロセスを閉じます。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスは既に終了しています。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>このプロセスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが終了したときに、<see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させるかどうかを取得または設定します。</summary>
        <value>正常終了または <see cref="M:System.Diagnostics.Process.Kill" /> の呼び出しによって関連付けられたプロセスが終了したときに <see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。 注意してください、<see cref="E:System.Diagnostics.Process.Exited" />イベントが発生した場合でもの値<see cref="P:System.Diagnostics.Process.EnableRaisingEvents" />は<see langword="false" />中に、プロセスの終了時に、またはユーザーが実行する前に、<see cref="P:System.Diagnostics.Process.HasExited" />を確認します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティは、オペレーティング システムがプロセスをシャット ダウン時にコンポーネントを通知するかどうかを示します。 <xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティは、プロセスが終了しているアプリケーションに通知する非同期処理で使用されます。 (これは、終了イベントが発生するまでは、アプリケーションの処理を中断) 終了イベントを同期的に待機する、アプリケーションを強制するには、使用、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッド。

> [!NOTE]
> ダブルクリックして Visual Studio を使用して、<xref:System.Diagnostics.Process>プロジェクトで、コンポーネント、<xref:System.Diagnostics.Process.Exited>イベントのデリゲートとイベント ハンドラーが自動的に生成されます。 追加のコードのセット、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティを`false`します。 このプロパティを変更する必要があります`true`ときに実行するイベント ハンドラーの関連付けられたプロセスが終了します。

場合、コンポーネントの<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>値は`true`、または<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>は`false`と<xref:System.Diagnostics.Process.HasExited%2A>チェックは、コンポーネントにより呼び出され、コンポーネントは、関連付けられたプロセスの管理情報にアクセスできますオペレーティング システムによって格納されます。 このような情報が含まれています、 <xref:System.Diagnostics.Process.ExitTime%2A> 、<xref:System.Diagnostics.Process.ExitCode%2A>します。

関連付けられたプロセスが終了した後、<xref:System.Diagnostics.Process.Handle%2A>のコンポーネントをポイントしない既存のプロセス リソース。 代わりに、そのみ使用プロセス リソースについて、オペレーティング システムの情報にアクセスします。 オペレーティング システムがによってリリースされていない終了のプロセスへのハンドルがあることに注意してください<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>メモリ内の情報。

プロセスが終了するを監視に関連するコストがあります。 場合<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>は`true`、<xref:System.Diagnostics.Process.Exited>関連付けられたプロセスが終了するときにイベントが発生します。 手順、<xref:System.Diagnostics.Process.Exited>イベント時に実行します。

場合によっては、アプリケーションはプロセスを開始しますが、クロージャの通知は必要ありません。 たとえば、アプリケーションでは、テキストを編集がないことをメモ帳を使用するユーザーを許可するメモ帳を開始できます。 関連するアプリケーションの継続的な操作ではないため、プロセスの終了時に通知を回避するために選択できます。 設定<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に`false`システム リソースを保存できます。

## Examples  
次のコード例では、ファイルを出力するプロセスを作成します。 設定、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>させるプロセスをプロパティ、<xref:System.Diagnostics.Process.Exited>イベントが終了する場合。 <xref:System.Diagnostics.Process.Exited>イベント ハンドラーは、プロセス情報を表示します。

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのネイティブ プロパティ <see langword="SeDebugPrivilege" /> を有効にすることにより、<see cref="T:System.Diagnostics.Process" /> コンポーネントを、特殊なモードで実行されているオペレーティング システム プロセスと対話する状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部のオペレーティング システム プロセスは、特殊なモードで実行します。 プロパティを読み取るか、これらのプロセスにアタッチしようとしています。 は、呼び出した<xref:System.Diagnostics.Process.EnterDebugMode%2A>コンポーネント。 呼び出す<xref:System.Diagnostics.Process.LeaveDebugMode%2A>特殊なモードで実行されているこれらのプロセスへのアクセスが不要です。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがリダイレクトされた <see cref="P:System.Diagnostics.Process.StandardError" /> ストリームに書き込む場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ErrorDataReceived>イベントは、リダイレクトされた関連付けられたプロセスによって書き込まれたことを示します<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
 イベントがのみで非同期読み取り操作中に発生<xref:System.Diagnostics.Process.StandardError%2A>します。 非同期の読み取り操作を開始するには、リダイレクトする必要があります、<xref:System.Diagnostics.Process.StandardError%2A>のストリームを<xref:System.Diagnostics.Process>、イベント ハンドラーを追加、<xref:System.Diagnostics.Process.ErrorDataReceived>イベント、および呼び出し<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>します。 その後、<xref:System.Diagnostics.Process.ErrorDataReceived>イベント シグナル プロセスでは、リダイレクトされたに行を書き込むたびに<xref:System.Diagnostics.Process.StandardError%2A>プロセスが終了するかを呼び出すまで、ストリーム<xref:System.Diagnostics.Process.CancelErrorRead%2A>します。  
  
> [!NOTE]
>  非同期出力を処理するアプリケーションを呼び出す必要があります、<xref:System.Diagnostics.Process.WaitForExit>メソッドを出力バッファーがフラッシュされたことを確認します。 使用してタイムアウトを指定することに注意してください、<xref:System.Diagnostics.Process.WaitForExit(System.Int32)>オーバー ロードは*いない*出力バッファーがフラッシュされたことを確認します。
  
   
  
## Examples  
 次の例では、`net view`コマンドをリモート コンピューターで使用可能なネットワーク リソースを一覧表示します。 ユーザーは、コマンドライン引数として対象のコンピューター名を提供します。 ユーザーには、エラー出力のファイル名を指定もできます。 この例では、プロセスを完了して、出力がコンソールに結果の書き込みの待機、net コマンドの出力を収集します。 ユーザーがオプションのエラー ファイルを指定する場合、例は、ファイルにエラーを書き込みます。  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが終了したときにプロセスによって指定された値を取得します。</summary>
        <value>関連付けられたプロセスが終了したときにプロセスによって指定されたコード。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.ExitCode%2A>が終了すると、システム プロセスが返されるステータスを取得します。 はるか整数からの値を返すように、終了コードを使用することができます、`main()`プロシージャ。  
  
 <xref:System.Diagnostics.Process.ExitCode%2A>値をプロセスには、そのプロセスのアプリケーション開発者によって実装される特定の規則が反映されます。 意思決定、コード内に終了コード値を使用する場合は、アプリケーション プロセスによって使用される終了コードの規則がわかっていることを確認します。  
  
 開発者は通常によって正常に終了を示す、<xref:System.Diagnostics.Process.ExitCode%2A>呼び出し元のメソッドは、通常とは異なるプロセスの終了の原因を識別するために使用できる値は 0 以外の場合、0、および指定のエラーの値。 これらのガイドラインに従う必要はありませんが、規則をします。  
  
 取得しようとする場合、<xref:System.Diagnostics.Process.ExitCode%2A>がプロセスの終了前に、試行は例外をスローします。 確認、<xref:System.Diagnostics.Process.HasExited%2A>関連付けられたプロセスが終了したかどうかを確認するには、最初のプロパティ。  
  
> [!NOTE]
>  標準出力は、非同期イベント ハンドラーにリダイレクトされましたがと、ことで出力の処理が完了していない場合に<xref:System.Diagnostics.Process.HasExited%2A>返します`true`します。 非同期イベント処理が完了したことを確認するを呼び出して、<xref:System.Diagnostics.Process.WaitForExit>をチェックする前にパラメーターを受け取らないオーバー ロード<xref:System.Diagnostics.Process.HasExited%2A>します。  
  
 使用することができます、<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>メソッドを呼び出すと、関連付けられているプロセスを終了します。  
  
 関連付けられたプロセスが終了したときに通知する 2 つの方法がある: 同期的および非同期的にします。 同期の通知は、呼び出し元に依存、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドに関連付けられているコンポーネントを終了するまで、アプリケーションの処理を一時停止します。 非同期の通知は、<xref:System.Diagnostics.Process.Exited>イベント。 非同期の通知を使用する場合<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に設定する必要があります`true`の<xref:System.Diagnostics.Process>プロセスが終了したことを示す通知を受け取るコンポーネントです。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスは終了していません。  
  
または 
プロセス <see cref="P:System.Diagnostics.Process.Handle" /> は終了していません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.ExitCode" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが終了したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Exited>イベントは、関連付けられたプロセスが終了していることを示します。 この状況の発生を意味するか、プロセス終了 (中止) または正常に終了します。 場合にのみ、このイベントが発生する可能性がの値、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロパティは`true`します。  
  
 関連付けられたプロセスが終了したときに通知する 2 つの方法がある: 同期的および非同期的にします。 同期の通知呼び出し元の意味、<xref:System.Diagnostics.Process.WaitForExit%2A>プロセスを終了するまで、現在のスレッドをブロックするメソッド。 非同期通知を使用して、<xref:System.Diagnostics.Process.Exited>イベントで、呼び出し元スレッドがその間に実行を続行することができます。 後者の場合、<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>に設定する必要があります`true`Exited イベントを受信する呼び出し元のアプリケーション。  
  
 オペレーティング システムをシャット ダウン、プロセス、Exited イベントのハンドラーを登録している他のすべてのプロセスを通知します。 この時点でだけが終了したプロセスのハンドルを使用してなど一部のプロパティにアクセスする<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.HasExited%2A>そのハンドルを完全に解放するまで、オペレーティング システムが維持されます。  
  
> [!NOTE]
>  呼び出すことはできません、終了プロセスを識別するハンドルがある場合でも<xref:System.Diagnostics.Process.Start%2A>再接続するには、同じプロセスです。 呼び出す<xref:System.Diagnostics.Process.Start%2A>自動的に関連付けられたプロセスを解放し、同じファイルが完全に新しいプロセスに接続<xref:System.Diagnostics.Process.Handle%2A>します。  
  
 使用の詳細については、 <xref:System.Diagnostics.Process.Exited> Windows フォーム アプリケーションでイベントを参照してください、<xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティ。  
  
   
  
## Examples  
 次のコード例では、ファイルを出力するプロセスを作成します。 生成、<xref:System.Diagnostics.Process.Exited>ため、プロセスが終了するときにイベントを<xref:System.Diagnostics.Process.EnableRaisingEvents%2A>プロセスの作成時にプロパティが設定されました。 <xref:System.Diagnostics.Process.Exited>イベント ハンドラーは、プロセス情報を表示します。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが終了した時刻を取得します。</summary>
        <value>関連付けられたプロセスが終了した時刻を示す <see cref="T:System.DateTime" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 取得するプロセスが終了していない場合にしようとしています、<xref:System.Diagnostics.Process.ExitTime%2A>プロパティは例外をスローします。 使用<xref:System.Diagnostics.Process.HasExited%2A>取得する前に、<xref:System.Diagnostics.Process.ExitTime%2A>プロパティに関連付けられたプロセスが終了したかどうかを判断します。  
  
   
  
## Examples  
 次のコード例では、ファイルを出力するプロセスを作成します。 プロセスが発生、<xref:System.Diagnostics.Process.Exited>終了すると、イベントとイベント ハンドラーが表示されます、<xref:System.Diagnostics.Process.ExitTime%2A>プロパティおよびその他の情報を処理します。  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.ExitTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを取得し、現在アクティブなプロセスに関連付けます。</summary>
        <returns>呼び出し元のアプリケーションを実行しているプロセス リソースに関連付けられた新しい <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新たに作成する<xref:System.Diagnostics.Process>をインスタンス化し、ローカル コンピューター上のプロセス リソースに関連付けます。  
  
 などのような<xref:System.Diagnostics.Process.GetProcessById%2A>、 <xref:System.Diagnostics.Process.GetProcessesByName%2A>、および<xref:System.Diagnostics.Process.GetProcesses%2A>メソッド、<xref:System.Diagnostics.Process.GetCurrentProcess%2A>新しい、既存のリソースに関連付けます<xref:System.Diagnostics.Process>コンポーネント。  
  
   
  
## Examples  
 次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューター上と同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成し、指定した既存のプロセス リソースに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">システムで一意なプロセス リソースの識別子。</param>
        <summary>ローカル コンピューター上のプロセス ID が指定された新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを返します。</summary>
        <returns><paramref name="processId" /> パラメーターで識別されるローカル プロセス リソースに関連付けられた <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新たに作成する<xref:System.Diagnostics.Process>コンポーネントと、ローカル コンピューター上のプロセス リソースに関連付けます。 プロセス リソースが既に存在して、コンピューターのため<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>、システム リソースでは作成されませんが、リソースに関連付けますではなくアプリケーションによって生成<xref:System.Diagnostics.Process>コンポーネント。 プロセス<xref:System.Diagnostics.Process.Id%2A>コンピューターで現在実行中のプロセスに対してのみ取得できます。 プロセスの終了後<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>期限切れの識別子を渡すと、例外をスローします。  
  
 特定のコンピューター上のプロセス id は一意です。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> 最大で 1 つのプロセスを返します。 使用して、特定のアプリケーションを実行しているすべてのプロセスを取得したい場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>します。 指定したアプリケーションを実行しているコンピューターに複数のプロセスが存在する場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>関連付けられているすべてのプロセスを含む配列を返します。 各プロセスの識別子の順番を照会できます。 プロセス識別子で表示できる、`Processes`パネルの Windows タスク マネージャー。 `PID`列には、プロセスに割り当てられているプロセス id が表示されます。  
  
 `processId`パラメーターは、 <xref:System.Int32> (32 ビット符号付き整数)、基になる Windows API を使用しますが、 `DWORD` (符号なし 32 ビット整数) と同様の api。 これは歴史的な理由からです。
  
## Examples  
 次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューター上と同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> パラメーターで指定されたプロセスは実行されていません。 識別子の有効期限が切れている可能性があります。</exception>
        <exception cref="T:System.InvalidOperationException">このオブジェクトによってプロセスは開始されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">システムで一意なプロセス リソースの識別子。</param>
        <param name="machineName">ネットワーク上のコンピューターの名前。</param>
        <summary>プロセス ID とネットワーク上のコンピューターの名前が指定された新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを返します。</summary>
        <returns><paramref name="processId" /> パラメーターで識別されるリモート プロセス リソースに関連付けられた <see cref="T:System.Diagnostics.Process" /> コンポーネント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新たに作成する<xref:System.Diagnostics.Process>コンポーネントと、ネットワーク上のリモート コンピューター上のプロセス リソースに関連付けます。 プロセス リソースが既に存在して、指定したコンピューターのため<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>、システム リソースでは作成されませんが、リソースに関連付けますではなくアプリケーションによって生成<xref:System.Diagnostics.Process>コンポーネント。 プロセス<xref:System.Diagnostics.Process.Id%2A>コンピューターで現在実行中のプロセスに対してのみ取得できます。 プロセスの終了後<xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>期限切れの識別子を渡すと、例外をスローします。  
  
 特定のコンピューター上のプロセス id は一意です。 <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> 最大で 1 つのプロセスを返します。 使用して、特定のアプリケーションを実行しているすべてのプロセスを取得したい場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>します。 指定したアプリケーションを実行しているコンピューターに複数のプロセスが存在する場合<xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>関連付けられているすべてのプロセスを含む配列を返します。 各プロセスの識別子の順番を照会できます。 プロセス識別子で表示できる、`Processes`パネルの Windows タスク マネージャー。 `PID`列には、プロセスに割り当てられているプロセス id が表示されます。  
  
 指定しない場合、 `machineName`、ローカル コンピューターが使用されます。 設定して、ローカル コンピューターを指定する代わりに、`machineName`値に"."または空の文字列 ("")。  
  
 `processId`パラメーターは、 <xref:System.Int32> (32 ビット符号付き整数)、基になる Windows API を使用しますが、 `DWORD` (符号なし 32 ビット整数) と同様の api。 これは歴史的な理由からです。   
  
## Examples  
 次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューター上と同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="processId" /> パラメーターで指定されたプロセスは実行されていません。 識別子の有効期限が切れている可能性があります。  
  
または 
<paramref name="machineName" /> パラメーターの構文が正しくありません。 名前の長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">このオブジェクトによってプロセスは開始されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、既存のプロセス リソースに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ローカル コンピューター上の各プロセス リソースごとに新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成します。</summary>
        <returns>ローカル コンピューター上で実行されているすべてのプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しいの配列を作成する<xref:System.Diagnostics.Process>コンポーネントし、ローカル コンピューター上のすべてのプロセス リソースに関連付けます。 プロセス リソースが既に存在してローカル コンピューターでは、ため<xref:System.Diagnostics.Process.GetProcesses%2A>システム リソースは作成されませんが、リソースに関連付けますではなくアプリケーションによって生成される<xref:System.Diagnostics.Process>コンポーネント。 オペレーティング システム自体でバック グラウンド プロセスが実行されているため、この配列は空ではありません。  
  
 使用してユーザー数を制限するには、コンピューターで実行中のプロセスをすべて取得しない場合、<xref:System.Diagnostics.Process.GetProcessById%2A>または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッド。 <xref:System.Diagnostics.Process.GetProcessById%2A> 作成、<xref:System.Diagnostics.Process>システム上で、メソッドに渡すプロセス識別子によって識別プロセスに関連付けられているコンポーネント。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 配列を作成します<xref:System.Diagnostics.Process>メソッドに関連付けられているプロセス リソースを含む実行可能ファイルの共有コンポーネントを渡します。  
  
> [!NOTE]
>  複数の Windows サービス、サービス ホスト プロセス (svchost.exe) の同じインスタンス内で読み込むことができます。 GetProcesses が個々 のサービスです。 これらを識別できません。そのため、次を参照してください。<xref:System.ServiceProcess.ServiceController.GetServices%2A>します。  
  
   
  
## Examples  
 次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューター上と同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">プロセスの一覧を読み取る対象のコンピューター。</param>
        <summary>指定したコンピューター上の各プロセス リソースごとに新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントを作成します。</summary>
        <returns>指定したコンピューター上で実行されているすべてのプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、新しいの配列を作成する<xref:System.Diagnostics.Process>コンポーネントし (通常はリモート) の指定したコンピューター上のすべてのプロセス リソースに関連付けます。 プロセス リソースが既に存在してローカル コンピューターでは、ため<xref:System.Diagnostics.Process.GetProcesses%2A>システム リソースは作成されませんが、リソースに関連付けますではなくアプリケーションによって生成される<xref:System.Diagnostics.Process>コンポーネント。 オペレーティング システム自体でバック グラウンド プロセスが実行されているため、この配列は空ではありません。  
  
 使用してユーザー数を制限するには、コンピューターで実行中のプロセスをすべて取得しない場合、<xref:System.Diagnostics.Process.GetProcessById%2A>または<xref:System.Diagnostics.Process.GetProcessesByName%2A>メソッド。 <xref:System.Diagnostics.Process.GetProcessById%2A> 作成、<xref:System.Diagnostics.Process>システム上で、メソッドに渡すプロセス識別子によって識別プロセスに関連付けられているコンポーネント。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 配列を作成します<xref:System.Diagnostics.Process>メソッドに関連付けられているプロセス リソースを含む実行可能ファイルの共有コンポーネントを渡します。  
  
 このオーバー ロード、<xref:System.Diagnostics.Process.GetProcesses%2A>メソッドは、ネットワーク上のリモート コンピューターで実行されているプロセス リソースの一覧を取得する一般的に使用されますが、渡すことによって、ローカル コンピューターを指定することができます"."です。  
  
> [!NOTE]
>  複数の Windows サービス、サービス ホスト プロセス (svchost.exe) の同じインスタンス内で読み込むことができます。 GetProcesses が個々 のサービスです。 これらを識別できません。そのため、次を参照してください。<xref:System.ServiceProcess.ServiceController.GetServices%2A>します。  
  
   
  
## Examples  
 次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューター上と同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターの構文が正しくありません。 長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">リモート コンピューターに対してこの操作を実行することは、オペレーティング システム プラットフォームでサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">基になるシステム API にアクセスしようとして、問題が発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有する既存のプロセス リソースに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">プロセスのフレンドリ名。</param>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有するローカル コンピューター上のすべてのプロセス リソースに関連付けます。</summary>
        <returns>指定したアプリケーションまたはファイルを実行しているプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントとそれらをローカル コンピューターの同じ実行可能ファイルを実行しているすべてのプロセス リソースに関連付けます。 プロセス リソースが既に存在してコンピューターのため、<xref:System.Diagnostics.Process.GetProcessesByName%2A>システム リソースは作成されませんが、代わりに関連付けますアプリケーションによって生成される<xref:System.Diagnostics.Process>コンポーネント。 A`processName`が現在実行されていないローカル コンピューターでは、メソッドが返す配列を空にすることができますので、実行可能ファイルを指定できます。  
  
 プロセス名とは、プロセスは、.exe 拡張子またはパスが含まれていない、Outlook などのフレンドリ名です。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 取得して、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作することをお勧めします。 たとえば、として、実行可能ファイル名を渡すことができます、`processName`その実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンするために、パラメーター。  
  
 プロセスが<xref:System.Diagnostics.Process.Id%2A>は、システム上の 1 つのプロセス リソースには一意で、ローカル コンピューター上の複数のプロセス実行できるで指定されたアプリケーション、`processName`パラメーター。 そのため、 <xref:System.Diagnostics.Process.GetProcessById%2A> 、最大で 1 つのプロセスを返しますが、<xref:System.Diagnostics.Process.GetProcessesByName%2A>関連付けられているすべてのプロセスを含む配列を返します。 標準 API 呼び出しを使用して、プロセスを操作する必要がある場合は、その識別子のさらに、これらのプロセスの各を照会できます。 プロセス名だけでは、配列を取得するとプロセス リソースにアクセスすることはできません<xref:System.Diagnostics.Process>関連付けられているコンポーネント、プロセス リソースに、最初を終了し、それ以外の場合、システム リソースを操作します。  
  
   
  
## Examples  
 次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューター上と同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">プロセスのフレンドリ名。</param>
        <param name="machineName">ネットワーク上のコンピューターの名前。</param>
        <summary>新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントの配列を作成し、指定したプロセス名を共有するリモート コンピューター上のすべてのプロセス リソースに関連付けます。</summary>
        <returns>指定したアプリケーションまたはファイルを実行しているプロセス リソースを表す <see cref="T:System.Diagnostics.Process" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新規の配列を作成するには、このメソッドを使用して<xref:System.Diagnostics.Process>コンポーネントとそれらを指定したコンピューター上の同じ実行可能ファイルを実行しているすべてのプロセス リソースに関連付けます。 プロセス リソースが既に存在してコンピューターのため、<xref:System.Diagnostics.Process.GetProcessesByName%2A>システム リソースは作成されませんが、代わりに関連付けますアプリケーションによって生成される<xref:System.Diagnostics.Process>コンポーネント。 A`processName`が現在実行されていないローカル コンピューターでは、メソッドが返す配列を空にすることができますので、実行可能ファイルを指定できます。  
  
 プロセス名とは、プロセスは、.exe 拡張子またはパスが含まれていない、Outlook などのフレンドリ名です。 <xref:System.Diagnostics.Process.GetProcessesByName%2A> 取得して、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作することをお勧めします。 たとえば、として、実行可能ファイル名を渡すことができます、`processName`その実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンするために、パラメーター。  
  
 プロセスが<xref:System.Diagnostics.Process.Id%2A>は、システム上の 1 つのプロセス リソースには一意で、ローカル コンピューター上の複数のプロセス実行できるで指定されたアプリケーション、`processName`パラメーター。 そのため、 <xref:System.Diagnostics.Process.GetProcessById%2A> 、最大で 1 つのプロセスを返しますが、<xref:System.Diagnostics.Process.GetProcessesByName%2A>関連付けられているすべてのプロセスを含む配列を返します。 標準 API 呼び出しを使用して、プロセスを操作する必要がある場合は、その識別子のさらに、これらのプロセスの各を照会できます。 プロセス名だけでは、配列を取得するとプロセス リソースにアクセスすることはできません<xref:System.Diagnostics.Process>関連付けられているコンポーネント、プロセス リソースに、最初を終了し、それ以外の場合、システム リソースを操作します。  
  
 このオーバー ロードを使用すると、ローカル コンピューターおよびリモート コンピューター上のプロセスを取得します。 使用して"."ローカル コンピューターを指定します。 既定では、ローカル コンピューターを使用して別のオーバー ロードが存在します。  
  
 プロセスに関する統計情報などの情報を表示するのみのリモート コンピューター上のプロセスにアクセスできます。 閉じる、終了することはできません (を使用して<xref:System.Diagnostics.Process.Kill%2A>)、またはリモート コンピューターでプロセスを開始します。  
  
   
  
## Examples  
 次の例では、ローカルのコンピューターでは、ローカルのコンピューターと、ローカル コンピューター上の特定のプロセスで実行されているメモ帳のすべてのインスタンスで実行中のプロセス、現在のプロセスの情報を取得します。 リモート コンピューター上と同じプロセスの情報を取得します。  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> パラメーターの構文が正しくありません。 長さがゼロ (0) の可能性があります。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="machineName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">リモート コンピューターに対してこの操作を実行することは、オペレーティング システム プラットフォームでサポートされていません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="machineName" /> に接続する試みが失敗しました。

または 
プロセス情報を取得するために使用するパフォーマンス カウンター API へのアクセスに問題があります。 この例外は、Windows NT、Windows 2000、および Windows XP に固有のものです。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">基になるシステム API にアクセスしようとして、問題が発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのネイティブ ハンドルを取得します。</summary>
        <value>関連付けられたプロセスを起動したときに、オペレーティング システムがプロセスに割り当てたハンドル。 システムはこのハンドルを使用して、プロセス属性の追跡を続けます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーションでは、多くのプロセス情報および制御関数のパラメーターとして使用できるプロセスを識別するハンドルを取得できます。 このハンドルを使用するには初期化するために、<xref:System.Threading.WaitHandle>またはプラットフォームでネイティブ メソッドの呼び出しを呼び出します。  
  
 このプロセスのハンドルでは、アプリケーションごとに言い換えると、プロセスのハンドルを共有できないプライベートです。 プロセスにも、プロセス<xref:System.Diagnostics.Process.Id%2A>これとは異なり、<xref:System.Diagnostics.Process.Handle%2A>が一意でと、そのため、システム全体で有効な。  
  
 呼び出すことによって開始されるプロセスのみ<xref:System.Diagnostics.Process.Start%2A>設定、<xref:System.Diagnostics.Process.Handle%2A>プロパティの対応する<xref:System.Diagnostics.Process>インスタンス。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが開始されていないか、終了しました。 この <see cref="T:System.Diagnostics.Process" /> インスタンスにプロセスが関連付けられていないので、<see cref="P:System.Diagnostics.Process.Handle" /> プロパティを読み取ることができません。  
  
または 
<see cref="T:System.Diagnostics.Process" /> インスタンスは実行中のプロセスにアタッチされていますが、フル アクセス権を持つハンドルを取得するために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.Handle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが開いたハンドルの数を取得します。</summary>
        <value>プロセスが開いたオペレーティング システム ハンドルの数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは、プロセス オブジェクトを参照するための手段を提供します。 プロセスでは、ファイル、リソース、メッセージ キュー、およびその他の多くのオペレーティング システム オブジェクトへのハンドルを取得できます。 オペレーティング システム ハンドルの数が 0 の場合にのみ、プロセスに関連付けられているメモリを解放します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられているプロセスが終了したかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Diagnostics.Process" /> コンポーネントが参照するオペレーティング システム プロセスが終了している場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値`true`の<xref:System.Diagnostics.Process.HasExited%2A>関連付けられたプロセスが終了して正常または異常のいずれかを示します。 要求または関連付けられたプロセスを呼び出すことによって終了を強制できます<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。 ハンドルがプロセスに開いている場合は、オペレーティング システムは、プロセスが終了しましたが、ハンドル、終了コード、および終了時刻など、プロセスに関する管理情報を保持するときに、プロセス メモリを解放します。 この情報を取得するには、使用することができます、<xref:System.Diagnostics.Process.ExitCode%2A>と<xref:System.Diagnostics.Process.ExitTime%2A>プロパティ。 これらのプロパティは、このコンポーネントによって起動されたプロセスを自動的に設定されます。 管理情報がリリースされたときにすべて、<xref:System.Diagnostics.Process>システム プロセスに関連付けられているコンポーネントが破棄され、以上ないハンドルを終了したプロセスに保持します。  
  
 コードとは無関係に、プロセスを終了できます。 このコンポーネントを使用して、プロセスを開始した場合の値が更新されます<xref:System.Diagnostics.Process.HasExited%2A>自動的に関連付けられたプロセスが個別に終了した場合でもです。  
  
> [!NOTE]
>  標準出力は、非同期イベント ハンドラーにリダイレクトされましたが、ときにこのプロパティが返されるときにでは出力の処理が完了していないことは`true`します。 非同期イベント処理が完了したことを確認するを呼び出して、<xref:System.Diagnostics.Process.WaitForExit>をチェックする前にパラメーターを受け取らないオーバー ロード<xref:System.Diagnostics.Process.HasExited%2A>します。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 関連付けられたプロセスの物理メモリ使用量は 10 秒間に最大 2 秒間隔で取得します。 この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。 例は、10 秒後に実行されている場合、プロセスを閉じます。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">プロセスの終了コードを取得できませんでした。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.HasExited" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの一意の識別子を取得します。</summary>
        <value>この <see cref="T:System.Diagnostics.Process" /> インスタンスが参照する、システムが生成したプロセスの一意の識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス<xref:System.Diagnostics.Process.Id%2A>が関連付けられたプロセスが実行されていない場合は無効です。 取得を試みる前に、プロセスが実行されていることを確認する必要があります、そのため、<xref:System.Diagnostics.Process.Id%2A>プロパティ。 プロセスが終了するまでプロセス識別子は、システム全体でプロセスを一意に識別します。  
  
 新しいローカルまたはリモート コンピューターで実行されているプロセスを接続する<xref:System.Diagnostics.Process>インスタンスにプロセス id を渡すことによって、<xref:System.Diagnostics.Process.GetProcessById%2A>メソッド。 <xref:System.Diagnostics.Process.GetProcessById%2A> `static`新しいコンポーネントを作成するメソッドを設定し、<xref:System.Diagnostics.Process.Id%2A>新しいプロパティ<xref:System.Diagnostics.Process>インスタンスによって自動的に。  
  
 プロセス id は、システムによって再利用できます。 <xref:System.Diagnostics.Process.Id%2A>プロパティの値が、関連付けられたプロセスが実行中にのみ一意です。 システム プロセスが終了し、再利用できる、<xref:System.Diagnostics.Process.Id%2A>関連のないプロセスのプロパティの値。  
  
 識別子は、システム上で一意であるために渡すことができる他のスレッドに渡すことの代替として、<xref:System.Diagnostics.Process>インスタンス。 このアクションは、システム リソースを節約まだプロセスが正しく認識されていることを保証します。  
  
   
  
## Examples  
 次の例では、取得する方法、<xref:System.Diagnostics.Process.Id%2A>すべてのアプリケーションのインスタンスを実行します。 コードのメモ帳の新しいインスタンスを作成、メモ帳のすべてのインスタンスが一覧表示し、ユーザーを入力できるように、<xref:System.Diagnostics.Process.Id%2A>数を特定のインスタンスを削除します。  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスの <see cref="P:System.Diagnostics.Process.Id" /> プロパティが設定されていません。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティを <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスを即時中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> 強制的に、終了、プロセスの中に<xref:System.Diagnostics.Process.CloseMainWindow%2A>のみ終了を要求します。 グラフィカル インターフェイスを持つプロセスを実行しているときに、メッセージ ループは、待機状態です。 オペレーティング システムが Windows メッセージがプロセスに送信されるたびにメッセージ ループを実行します。 呼び出す<xref:System.Diagnostics.Process.CloseMainWindow%2A>メイン ウィンドウに、適切な形式でのアプリケーションでは、子ウィンドウを閉じ、アプリケーションの実行中のすべてのメッセージ ループでは失効の近くに要求を送信します。 呼び出すことによって、プロセスを終了する要求<xref:System.Diagnostics.Process.CloseMainWindow%2A>アプリケーションの終了を強制しません。 アプリケーションは、終了する前にユーザー認証を求めることまたは拒否を終了することができます。 アプリケーションの終了を強制するには使用、<xref:System.Diagnostics.Process.Kill%2A>メソッド。 動作<xref:System.Diagnostics.Process.CloseMainWindow%2A>システム メニューを使用して、アプリケーションのメイン ウィンドウを閉じると、ユーザーの場合と同じです。 そのため、メイン ウィンドウを閉じることでプロセスを終了する要求はすぐに終了するアプリケーションを強制しません。  
  
> [!NOTE]
>  <xref:System.Diagnostics.Process.Kill%2A>メソッドを非同期的に実行します。 呼び出した後、<xref:System.Diagnostics.Process.Kill%2A>メソッドを呼び出します、 <xref:System.Diagnostics.Process.WaitForExit%2A> 、プロセスを終了するかを確認するまで待機する方法、<xref:System.Diagnostics.Process.HasExited%2A>プロパティをプロセスが終了したかどうかを判断します。  
  
 プロセスによって編集されたデータまたはプロセスに割り当てられたリソースが失われる場合を呼び出す<xref:System.Diagnostics.Process.Kill%2A>します。 <xref:System.Diagnostics.Process.Kill%2A> 異常なプロセスを終了させます、必要な場合にのみ使用する必要があります。 <xref:System.Diagnostics.Process.CloseMainWindow%2A> により、プロセスの手順の終了し、インターフェイスを使用するアプリケーションのことをお勧めしているために、すべての windows を閉じます。 場合<xref:System.Diagnostics.Process.CloseMainWindow%2A>使用することができますが失敗した<xref:System.Diagnostics.Process.Kill%2A>プロセスを終了します。 <xref:System.Diagnostics.Process.Kill%2A> グラフィカル インターフェイスがないプロセスを終了する唯一の方法です。  
  
 呼び出すことができます<xref:System.Diagnostics.Process.Kill%2A>と<xref:System.Diagnostics.Process.CloseMainWindow%2A>ローカル コンピューターで実行されているプロセスに対してのみです。 プロセスが終了するリモート コンピューターで発生することはできません。 リモート コンピューター上で実行されているプロセスの情報のみ表示できます。  
  
> [!NOTE]
>  場合への呼び出し、<xref:System.Diagnostics.Process.Kill%2A>メソッドが、プロセスを終了して現在、中に行われた、<xref:System.ComponentModel.Win32Exception>アクセスが拒否されましたがスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられたプロセスを終了できませんでした。  
  
または 
プロセスを終了しています。  
  
または 
関連付けられたプロセスは、Win16 実行可能ファイルです。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.Kill" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスは既に終了しています。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> コンポーネントを、特殊なモードで実行されているオペレーティング システム プロセスと対話する状態から解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部のオペレーティング システム プロセスは、特殊なモードで実行します。 プロパティを読み取るか、これらのプロセスにアタッチしようとしています。 は、呼び出した<xref:System.Diagnostics.Process.EnterDebugMode%2A>コンポーネント。 呼び出す<xref:System.Diagnostics.Process.LeaveDebugMode%2A>特殊なモードで実行されているこれらのプロセスへのアクセスが不要です。  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスを実行しているコンピューターの名前を取得します。</summary>
        <value>関連付けられたプロセスを実行しているコンピューターの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 統計データを表示して、リモート コンピューターで実行されているプロセスのプロセス情報を呼び出すことはできません<xref:System.Diagnostics.Process.Start%2A>、 <xref:System.Diagnostics.Process.CloseMainWindow%2A>、または<xref:System.Diagnostics.Process.Kill%2A>リモート コンピューター上でします。  
  
> [!NOTE]
>  ローカル コンピューターに関連付けられたプロセスを実行しているときに、このプロパティは、期間を返します (".") マシン名。 使用する必要があります、<xref:System.Environment.MachineName%2A?displayProperty=nameWithType>正しいコンピューター名を取得するプロパティ。  
  
   
  
## Examples  
 使用するには、は、するには、次の例は、リモート コンピューターでメモ帳のインスタンスを少なくとも 1 つを開始します。 例では、リモート コンピューターをメモ帳が実行されているし、表示、それぞれの名前を要求する<xref:System.Diagnostics.Process.ProcessName%2A>、 <xref:System.Diagnostics.Process.Id%2A>、および<xref:System.Diagnostics.Process.MachineName%2A>各インスタンスのプロパティ。  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのメイン モジュールを取得します。</summary>
        <value>プロセスを開始する際に使用した <see cref="T:System.Diagnostics.ProcessModule" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス モジュールは、特定のプロセスに読み込まれる a.dll または .exe のファイルを表します。 <xref:System.Diagnostics.Process.MainModule%2A>プロパティでは、モジュール名、ファイル名、モジュールのメモリの詳細など、プロセスを開始するために使用する実行可能ファイルに関する情報を表示することができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainModule" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">32 ビット プロセスが 64 ビット プロセスのモジュールにアクセスしようとしています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。  
  
または 
プロセスが終了しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのメイン ウィンドウで使用するウィンドウ ハンドルを取得します。</summary>
        <value>関連付けられたプロセスのメイン ウィンドウで使用する、システムが生成したウィンドウ ハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メイン ウィンドウが現在、フォーカスがあるプロセスによって開かれたウィンドウ (、<xref:System.Windows.Forms.Form.TopLevel%2A>形式)。 使用する必要があります、<xref:System.Diagnostics.Process.Refresh%2A>を更新する方法、<xref:System.Diagnostics.Process>変更されている場合、現在のメイン ウィンドウのハンドルを取得するオブジェクト。 一般に、ウィンドウ ハンドルがキャッシュされるため使用<xref:System.Diagnostics.Process.Refresh%2A>現在のハンドルを取得することを保証するために事前します。  
  
 取得することができます、<xref:System.Diagnostics.Process.MainWindowHandle%2A>プロパティは、ローカル コンピューター上で実行されているプロセスに対してのみです。 <xref:System.Diagnostics.Process.MainWindowHandle%2A>プロパティは、プロセスに関連付けられているウィンドウを一意に識別する値。  
  
 プロセスでは、プロセスにグラフィカル インターフェイスがある場合にのみ関連付けられているメイン ウィンドウがあります。 関連付けられたプロセスには、メイン ウィンドウがない場合、<xref:System.Diagnostics.Process.MainWindowHandle%2A>値は 0 です。 値は 0、非表示されているプロセスのタスク バーに表示されないプロセス、つまりもです。 これは、タスク バーの右端にある、通知領域にアイコンとして表示されるプロセスの場合です。  
  
 プロセスを開始したし、メイン ウィンドウのハンドルを使用する場合は、使用を検討して、<xref:System.Diagnostics.Process.WaitForInputIdle%2A>起動が完了するプロセスをできるように、メイン ウィンドウのハンドルが作成されていることを確認する方法。 この操作を行わない場合、例外がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが終了したため、<see cref="P:System.Diagnostics.Process.MainWindowHandle" /> が定義されていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスのメイン ウィンドウのキャプションを取得します。</summary>
        <value>プロセスのメイン ウィンドウのタイトル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスでは、プロセスにグラフィカル インターフェイスがある場合にのみ関連付けられているメイン ウィンドウがあります。 関連付けられたプロセスにメイン ウィンドウがない場合 (ように<xref:System.Diagnostics.Process.MainWindowHandle%2A>は 0 です)、<xref:System.Diagnostics.Process.MainWindowTitle%2A>空の文字列 ("")。 プロセスを開始したしてメイン ウィンドウのタイトルを使用する場合は、使用を検討して、<xref:System.Diagnostics.Process.WaitForInputIdle%2A>起動が完了するプロセスをできるように、メイン ウィンドウのハンドルが作成されていることを確認する方法。 それ以外の場合、例外がスローされます。  
  
> [!NOTE]
>  メイン ウィンドウが現在、フォーカスのあるウィンドウです。プロセスの主なウィンドウをできない可能性がありますこれに注意してください。 使用する必要があります、<xref:System.Diagnostics.Process.Refresh%2A>を更新する方法、<xref:System.Diagnostics.Process>変更されている場合、現在のメイン ウィンドウのハンドルを取得するオブジェクト。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを起動し、プロセスのメイン ウィンドウのキャプションを取得します。  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスが終了したため、<see cref="P:System.Diagnostics.Process.MainWindowTitle" /> プロパティが定義されていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに許可されるワーキング セットの最大サイズ (バイト単位) を取得または設定します。</summary>
        <value>プロセスに許可されるメモリ上のワーキング セットの最大サイズ (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。 これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、アプリケーションを実行する .dll ファイルと system.dll ファイル内のページを含むすべての命令を含むページが含まれています。 ワーキング セットのサイズ増加、必要なメモリが増加します。  
  
 プロセスは、最小と最大ワーキング セットのサイズ。 プロセス リソースが作成されるたびに、システムは、、プロセスのワーキング セットの最小メモリ容量を予約します。 仮想メモリ マネージャーは、少なくとも最小限のメモリ常駐させるプロセスがアクティブであるが、保持の最大サイズを超えることはありませんしようとします。  
  
 システムでは、既定の作業セット サイズを設定します。 使用してこれらのサイズを変更することができます、<xref:System.Diagnostics.Process.MaxWorkingSet%2A>と<xref:System.Diagnostics.Process.MinWorkingSet%2A>メンバー。 ただし、これらの値の設定はありませんが保証メモリされます予約または常駐します。  
  
> [!NOTE]
>  プロセスのワーキング セットのサイズを大きくと、システムの他の部分から物理メモリを実行します。 システム パフォーマンスが低下することができますが、大きすぎるを最小値または最大のワーキング セットのサイズを要求しないことを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ワーキング セットの最大サイズが正しくありません。 この値は、ワーキング セットの最小サイズ以上である必要があります。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースからワーキング セット情報を取得できません。  
  
または 
プロセスが開始されていないので、プロセス識別子またはプロセス ハンドルが 0 です。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。  
  
または 
プロセスが終了しています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに許可されるワーキング セットの最小サイズ (バイト単位) を取得または設定します。</summary>
        <value>プロセスに必要なメモリ上のワーキング セットの最小サイズ (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。 これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、アプリケーションを実行する .dll ファイルと system.dll ファイル内のページを含むすべての命令を含むページが含まれています。 ワーキング セットのサイズ増加、必要なメモリが増加します。  
  
 プロセスは、最小と最大ワーキング セットのサイズ。 プロセス リソースが作成されるたびに、システムは、、プロセスのワーキング セットの最小メモリ容量を予約します。 仮想メモリ マネージャーは、少なくとも最小限のメモリ常駐させるプロセスがアクティブであるが、保持の最大サイズを超えることはありませんしようとします。  
  
 システムでは、既定の作業セット サイズを設定します。 使用してこれらのサイズを変更することができます、<xref:System.Diagnostics.Process.MaxWorkingSet%2A>と<xref:System.Diagnostics.Process.MinWorkingSet%2A>メンバー。 ただし、これらの値の設定はありませんが保証メモリされます予約または常駐します。  
  
> [!NOTE]
>  プロセスのワーキング セットのサイズを大きくと、システムの他の部分から物理メモリを実行します。 システム パフォーマンスが低下することができますが、大きすぎるを最小値または最大のワーキング セットのサイズを要求しないことを確認します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">ワーキング セットの最小サイズが正しくありません。 この値は、ワーキング セットの最大サイズ以下にする必要があります。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースからワーキング セット情報を取得できません。  
  
または 
プロセスが開始されていないので、プロセス識別子またはプロセス ハンドルが 0 です。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行中のプロセスの <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。  
  
または 
プロセスが終了しています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに読み込まれたモジュールを取得します。</summary>
        <value>関連付けられたプロセスに読み込まれたモジュールを表す <see cref="T:System.Diagnostics.ProcessModule" /> 型の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセス モジュールは、特定のプロセスに読み込まれる a.dll または .exe のファイルを表します。 A<xref:System.Diagnostics.ProcessModule>インスタンスでは、モジュール名、ファイル名、モジュールのメモリの詳細など、モジュールに関する情報を表示することができます。  
  
 プロセスでは、メモリに複数のモジュールを読み込むことができます。 たとえば、.exe ファイルを追加の .dll ファイルを読み込むには、複数のモジュールがあります。  
  
 プロセスを開始した後、システムには、プロセスが読み込まれるまでこのコレクションが空です。 プロセスのメイン ウィンドウにある場合は、呼び出す<xref:System.Diagnostics.Process.WaitForInputIdle%2A>コレクションが空でない場合にことを確認するには、このプロパティを取得する前に、一覧を取得します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.Modules" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">システム プロセスまたはアイドル状態のプロセスのいずれかの <see cref="P:System.Diagnostics.Process.Modules" /> プロパティにアクセスしようとしています。 これらのプロセスには、モジュールが存在しません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページングされないシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>システムによって関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができないメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページングされないシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができないシステム メモリの容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、現在のサイズ (バイト単位)、プロセスによって使用される非ページ システム メモリを表します。 システム メモリは、オペレーティング システムで使用される物理メモリがあり、ページおよび非ページ プールに分割されます。 非ページ メモリの割り当ては、システム メモリに保持され、仮想メモリ ページング ファイルにページ アウトできません。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値が等しく、 **Pool Nonpaged Bytes**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="E:System.Diagnostics.Process.Exited" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> 発生させる API メソッドには、<xref:System.Diagnostics.Process.Exited>イベント。 呼び出す<xref:System.Diagnostics.Process.OnExited%2A>により、<xref:System.Diagnostics.Process.Exited>イベントの発生を使用してイベントを発生させる唯一の方法であり、<xref:System.Diagnostics.Process>コンポーネント。 <xref:System.Diagnostics.Process.OnExited%2A> コンポーネントからクラスを派生するときに主に使用されます。  
  
 代替手段として<xref:System.Diagnostics.Process.OnExited%2A>、独自のイベント ハンドラーを記述することができます。 独自のイベント ハンドラー デリゲートおよびイベント処理メソッドを作成します。  
  
> [!NOTE]
>  Visual Studio 環境を使用している場合 (AddOnExited) イベント ハンドラー デリゲートおよびイベント処理メソッド (Process1_Exited) が作成されますをドラッグすると、<xref:System.Diagnostics.Process>コンポーネントをフォームにアイコンをダブルクリックします。 ときに実行するコードを作成する、 <xref:System.Diagnostics.Process.Exited> Process1_Exited プロシージャに入力されたイベントが発生します。 作成する必要はありません、<xref:System.Diagnostics.Process.OnExited%2A>メンバーが実装されているためです。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 概要については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.Diagnostics.Process.OnExited%2A>派生クラスのメソッド。  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが、リダイレクトされた <see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームに行を書き込む度に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OutputDataReceived>イベントでは、ことを示します、関連付けられている<xref:System.Diagnostics.Process>、リダイレクトされた、改行文字で終了して、行が書き込まれる<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。  
  
 非同期読み取り操作中に、イベントが有効になっている<xref:System.Diagnostics.Process.StandardOutput%2A>します。 非同期の読み取り操作を開始するには、リダイレクトする必要があります、<xref:System.Diagnostics.Process.StandardOutput%2A>のストリームを<xref:System.Diagnostics.Process>、イベント ハンドラーを追加、<xref:System.Diagnostics.Process.OutputDataReceived>イベント、および呼び出し<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>します。 その後、<xref:System.Diagnostics.Process.OutputDataReceived>イベント シグナル プロセスでは、リダイレクトされたに行を書き込むたびに<xref:System.Diagnostics.Process.StandardOutput%2A>プロセスが終了するかを呼び出すまで、ストリーム<xref:System.Diagnostics.Process.CancelOutputRead%2A>します。  
  
> [!NOTE]
>  非同期出力を処理するアプリケーションを呼び出す必要があります、<xref:System.Diagnostics.Process.WaitForExit%2A>メソッドを出力バッファーがフラッシュされたことを確認します。  
  
   
  
## Examples  
 次の例では、リダイレクトされたで非同期の読み取り操作を実行する方法を示しています。<xref:System.Diagnostics.Process.StandardOutput%2A>のストリーム、`ipconfig`コマンド。  
  
 例でのイベントのデリゲートを作成、`OutputHandler`イベント ハンドラーを関連付けます、<xref:System.Diagnostics.Process.OutputDataReceived>イベント。 イベント ハンドラーがリダイレクトされたからテキスト行を受け取る<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームは、テキストを書式設定し、コンソール ウィンドウの例の後に表示される出力文字列に保存します。  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページ メモリの量 (バイト単位) を取得します。</summary>
        <value>仮想メモリ ページング ファイルに書き込むことができる関連付けられたプロセスによって割り当てられたメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページ メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスの仮想メモリ ページング ファイル内で割り当てられたメモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、メモリ (バイト単位)、プロセスによって使用される仮想メモリ ページング ファイル内の現在のサイズを表します。 オペレーティング システムでは、物理メモリの量と組み合わせて仮想メモリ ページング ファイルを使用して、各プロセスの仮想アドレス領域を管理します。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。 プロセスのオペレーティング システムで使用されるメモリのサイズを取得する、<xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A>プロパティ。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値が等しく、**ページ ファイルのバイト数**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例は、メモ帳アプリケーションのインスタンスを起動しを取得して関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>システムによって関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができるメモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたページング可能なシステム メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた、仮想メモリ ページング ファイルに書き込むことができるシステム メモリの容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値によって返される値は、(バイト単位)、プロセスによって使用されているページング可能なシステム メモリの現在のサイズを表します。 システム メモリは、オペレーティング システムで使用される物理メモリがあり、ページおよび非ページ プールに分割されます。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。 プロセスによって使用されるアプリケーションのメモリのサイズを取得する、<xref:System.Diagnostics.Process.PagedMemorySize64%2A>プロパティ。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値が等しく、**ページ プールのサイズ**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される、仮想メモリ ページング ファイル内のメモリの最大量を取得します (バイト単位)。</summary>
        <value>関連付けられたプロセスによって割り当てられた、仮想メモリ ページング ファイルに書き込むことができたメモリの最大容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される、仮想メモリ ページング ファイル内のメモリの最大量を取得します (バイト単位)。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスの仮想メモリ ページング ファイル内で割り当てられたメモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値によって返される値は、(バイト単位)、起動されてから、プロセスで使用される仮想メモリ ページング ファイル内のメモリの最大サイズを表します。 オペレーティング システムでは、物理メモリの量と組み合わせて仮想メモリ ページング ファイルを使用して、各プロセスの仮想アドレス領域を管理します。 ページング可能なメモリが使用されていない場合は、ディスク上の仮想メモリ ページング ファイルに転送できます。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値が等しく、**ページ ファイルのバイト数のピーク**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される仮想メモリの最大量を取得します (バイト単位)。</summary>
        <value>関連付けられたプロセスが要求した仮想メモリの最大容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される仮想メモリの最大量を取得します (バイト単位)。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスに割り当てられた仮想メモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、(バイト単位)、起動されてから、プロセスによって使用される仮想メモリの最大サイズを表します。 オペレーティング システムでは、各プロセスの物理メモリまたはディスク上の仮想メモリ ページング ファイルに格納されているページが読み込まれるページのいずれかの仮想アドレス空間をマップします。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値が等しく、**仮想バイト ピーク**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのピーク ワーキング セット サイズをバイト単位で取得します。</summary>
        <value>関連づけられたプロセスが一度に要求した物理メモリのバイト単位での最大容量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。 これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールおよびシステム ライブラリを含む、プロセスが実行されるすべての指示を含むページが含まれています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスによって使用される物理メモリの最大量をバイト数として取得します。</summary>
        <value>プロセスの開始以降、関連付けられたプロセスに割り当てられた物理メモリの最大量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、ワーキング セット メモリのバイト単位で起動されてから、プロセスで使用されるの最大サイズを表します。 プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。 これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールと、システム ライブラリから命令を含む、プロセスが実行されるすべての指示を含むページが含まれています。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値が等しく、 **Working Set Peak**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メイン ウィンドウのフォーカス時に、オペレーティング システムによって関連付けられたプロセスの優先順位を一時的に上げるかどうかを示す値を取得または設定します。</summary>
        <value>待機状態から抜けたときにプロセスの優先順位を動的に上げる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 対象の優先度クラスには動的な優先順位の列挙値の 1 つのプロセスでスレッドを実行すると (<xref:System.Diagnostics.ProcessPriorityClass.Normal>、 <xref:System.Diagnostics.ProcessPriorityClass.High>、または<xref:System.Diagnostics.ProcessPriorityClass.RealTime>)、システムは、待機状態から抜けたときに一時的にスレッドの優先順位をブーストします。 このアクションでは、他のプロセスが現在のスレッドの処理を中断できなくなります。 <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>設定は、既存のすべてのスレッドと、その後、プロセスによって作成されたすべてのスレッドに影響します。 通常の動作を復元するには、設定、<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>プロパティを`false`します。  
  
> [!NOTE]
>  優先順位が高すぎると重要なオペレーティング システムおよびネットワーク機能、オペレーティング システムの他のタスクと問題の原因のリソースにドレインを実行できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセス リソースから priority boost 情報を取得できませんでした。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。  
  
または 
プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの全体的な優先順位カテゴリを取得または設定します。</summary>
        <value>プロセスの <see cref="P:System.Diagnostics.Process.BasePriority" /> を計算するときに使用する、関連付けられたプロセスの優先順位カテゴリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスの優先度クラスには、さまざまなスレッド優先度レベルが含まれます。 プロセスの優先度クラスを基準としたプロセスで実行されている優先順位が異なるスレッドを実行します。 Win32 では、クラスごとに 7 つの基本優先度レベルの 4 つの優先度クラスを使用します。 これらのプロセス優先度クラスをキャプチャ、<xref:System.Diagnostics.ProcessPriorityClass>できるようにする列挙体にプロセスの優先順位を設定する<xref:System.Diagnostics.ProcessPriorityClass.Idle>、 <xref:System.Diagnostics.ProcessPriorityClass.Normal>、 <xref:System.Diagnostics.ProcessPriorityClass.High>、 <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>、 <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>、または<xref:System.Diagnostics.ProcessPriorityClass.RealTime>します。 プロセスがプロセッサにアクセスの他のユーザーを事前設定する必要がある場合、オペレーティング システムによって経過またはその他の要因、基本優先度レベルを変更できます時間に基づいています。 さらに、設定、<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>を一時的に待機状態から作成されたスレッドの優先度レベルを上げます。 優先順位は、プロセスが待機状態に戻ったときにリセットされます。  
  
 <xref:System.Diagnostics.Process.BasePriority%2A>プロパティでは、プロセスに割り当てられている開始の優先順位を表示することができます。 ただし、これは、読み取り専用であるために使用できません、<xref:System.Diagnostics.Process.BasePriority%2A>プロセスの優先順位を設定するプロパティ。 優先順位を変更するには、使用、<xref:System.Diagnostics.Process.PriorityClass%2A>プロパティを取得または設定、プロセスの全体的な優先順位カテゴリ。  
  
 システム モニターを使用して、優先度クラスを表示できません。 次の表は、リレーションシップ、<xref:System.Diagnostics.Process.BasePriority%2A>と<xref:System.Diagnostics.Process.PriorityClass%2A>値。  
  
|BasePriority|PriorityClass|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセスのリソースからプロセス優先度情報を設定できないか、取得できませんでした。  
  
または 
プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PriorityClass" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できません。</exception>
        <exception cref="T:System.PlatformNotSupportedException">Windows 98 または Windows Millennium Edition (Windows Me) を使用していて、<see cref="P:System.Diagnostics.Process.PriorityClass" /> を <see langword="AboveNormal" /> または <see langword="BelowNormal" /> に設定しました。 これらのプラットフォームにおいて、優先度クラスにそれらの値はサポートされていません。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><see cref="T:System.Diagnostics.ProcessPriorityClass" /> 列挙体で定義されている有効な値が使用されていないため、優先度クラスを設定できません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたプライベート メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられ、他のプロセスと共有できないバイト数。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられたプライベート メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられ、他のプロセスと共有できないメモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、他のプロセスと共有することはできませんをバイト単位で、プロセスによって使用されるメモリの現在のサイズを表します。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値が等しく、 **Private Bytes**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスの特権プロセッサ時間を取得します。</summary>
        <value>プロセスが、オペレーティング システム コア内でコードを実行した合計時間を示す <see cref="T:System.TimeSpan" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスの名前を取得します。</summary>
        <value>システムで使用する、ユーザーがプロセスを識別するための名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.ProcessName%2A>プロパティは、.exe 拡張子またはパスが含まれていない Outlook など、実行可能ファイル名を保持します。 取得すると、同じ実行可能ファイルに関連付けられているすべてのプロセスを操作することをお勧めします。  
  
> [!NOTE]
>  [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] 、オペレーティング システム、<xref:System.Diagnostics.Process.ProcessName%2A>プロパティはプロセス モジュールの情報を取得できない場合、15 文字に切り捨て可能性があります。  
  
 呼び出すことができます<xref:System.Diagnostics.Process.GetProcessesByName%2A>、指定したコンピューター上のすべての実行中インスタンスを含む配列を取得する、実行可能ファイル名を渡します。 たとえば、この配列を使用すると、実行可能ファイルの実行中のすべてのインスタンスをシャット ダウンします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスに ID がないか、<see cref="T:System.Diagnostics.Process" /> に関連付けられているプロセスがありません。  
  
または 
関連付けられたプロセスが終了しました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.NotSupportedException">プロセスはこのコンピューター上のものではありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスでのスレッドの実行をスケジュールできるプロセッサを取得または設定します。</summary>
        <value>関連付けられたプロセスのスレッドを実行できるプロセッサを示すビットマスク。 既定値は、コンピューターのプロセッサ数によって異なります。 既定値は 2 <sup>n</sup> -1 で、n はプロセッサの数です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows 2000 以降では、プロセスのスレッドはプロセッサごとの移行、プロセッサーを移行できます。 重い負荷、プロセッサが特定のスレッドを実行する必要がありますを指定するパフォーマンスを向上できますプロセッサのキャッシュが再読み込み回数を削減します。 プロセッサと、スレッド間の関連付けは、プロセッサのアフィニティと呼ばれます。  
  
 各プロセッサは少しとして表されます。 ビット 0 がいずれかのプロセッサ、ビット 1 は、2 つのプロセッサとなどです。 値を 1 に、少し設定した場合は、対応するプロセッサがスレッドの割り当てに選択されます。 設定すると、<xref:System.Diagnostics.Process.ProcessorAffinity%2A>値を 0、オペレーティング システムには、スレッドのアフィニティにアルゴリズムのセットのスケジューリングします。 ときに、<xref:System.Diagnostics.Process.ProcessorAffinity%2A>値が 0 以外の値に設定されて、値は選択可能なプロセッサを指定するビットマスクとして解釈されます。  
  
 次の表に、選択した<xref:System.Diagnostics.Process.ProcessorAffinity%2A>8 プロセッサ システム値です。  
  
|ビットマスク|バイナリ値|対象となるプロセッサ|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 と 2|  
|0x0007|00000000 00000111|1、2、3|  
|0x0009|00000000 00001001|1 および 4|  
|0x007F|00000000 01111111|1、2、3、4、5、6 および 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているプロセスのリソースから <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> 情報を設定できないか、取得できませんでした。  
  
または 
プロセス識別子またはプロセス ハンドルが 0 です。 (プロセスは開始されていません。)</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が使用できませんでした。  
  
または 
プロセスが終了しています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プロセス コンポーネントにキャッシュされている関連付けられたプロセスに関するすべての情報を破棄します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 後<xref:System.Diagnostics.Process.Refresh%2A>を呼び出すときは、最初の要求と、関連付けられたプロセスから新しい値を取得するプロセスのコンポーネントの各プロパティについてはします。  
  
 ときに、<xref:System.Diagnostics.Process>コンポーネントは、プロセスのリソースのプロパティ値に関連付け、<xref:System.Diagnostics.Process>はすぐに、関連付けられたプロセスの状態に応じて設定されます。 その後、関連付けられているプロセスに関する情報が変更された場合、それらの変更には反映されません、<xref:System.Diagnostics.Process>コンポーネントのキャッシュされた値。 <xref:System.Diagnostics.Process>コンポーネントが関連付けられている時にプロセス リソースのスナップショットを示します。 関連付けられたプロセスの現在の値を表示するには、呼び出し、<xref:System.Diagnostics.Process.Refresh%2A>メソッド。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 関連付けられたプロセスの物理メモリ使用量は 10 秒間に最大 2 秒間隔で取得します。 この例では、10 秒が経過する前に、プロセスが終了するかどうかを検出します。 例は、10 秒後に実行されている場合、プロセスを閉じます。  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスのユーザー インターフェイスが応答するかどうかを示す値を取得します。</summary>
        <value>関連付けられたプロセスのユーザー インターフェイスがシステムに応答する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロセスは、ユーザー インターフェイス、<xref:System.Diagnostics.Process.Responding%2A>プロパティは、プロセスがユーザー入力に応答しているかどうかを判断するユーザー インターフェイスを接続します。 インターフェイスが、すぐに応答しない場合、<xref:System.Diagnostics.Process.Responding%2A>プロパティが返す`false`します。 このプロパティを使用して、関連付けられたプロセスのインターフェイスが応答を停止したかどうかを判断します。  
  
 プロセスがない場合、 <xref:System.Diagnostics.Process.MainWindowHandle%2A>、このプロパティを返します`true`します。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.Responding" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスへのネイティブ ハンドルを取得します。</summary>
        <value>このプロセスへのネイティブ ハンドル。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルは呼び出し元のコンポーネントがプロセスを起動した場合にのみ使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスのターミナル サービス セッション識別子を取得します。</summary>
        <value>関連付けられたプロセスのターミナル サービス セッション識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.SessionId%2A>プロパティは、アプリケーションが現在実行されているセッションを識別します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">このプロセスに関連付けられているセッションはありません。</exception>
        <exception cref="T:System.InvalidOperationException">このセッション識別子に関連付けられているプロセスはありません。  
  
または 
関連付けられたプロセスが、このコンピューター上にありません。</exception>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="P:System.Diagnostics.Process.SessionId" /> プロパティは Windows 98 ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのエラー出力の読み取りに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準エラー ストリームの読み取りに使用できる <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Diagnostics.Process>テキストがコンソールに通常表示されることを標準エラー ストリームにテキストを書き込みます。 リダイレクトすることにより、<xref:System.Diagnostics.Process.StandardError%2A>ストリームを操作するか、プロセスのエラー出力を抑制します。 たとえば、テキストをフィルター処理、異なる方法で書式を設定して、または、コンソールと指定したログ ファイルの両方に出力を書き込みます。  
  
> [!NOTE]
>  使用する<xref:System.Diagnostics.Process.StandardError%2A>、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>に`false`を設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType>に`true`します。 それ以外の場合からの読み取り、<xref:System.Diagnostics.Process.StandardError%2A>ストリームが例外をスローします。  
  
 リダイレクトされた<xref:System.Diagnostics.Process.StandardError%2A>同期または非同期でストリームを読み取ることができます。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスのエラー出力ストリームでの同期読み取り操作を実行します。 関連付けられているまで操作を実行しないでこれらの同期読み取り<xref:System.Diagnostics.Process>を書き込みます、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはストリームを閉じます。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。 このメソッドは、ストリーム出力に指定されたイベント ハンドラーを有効にして、すぐにストリーム出力するイベント ハンドラー中に、その他の作業を実行できる呼び出し元に返します。  
  
 同期読み取り操作は、呼び出し元からの読み取りとの間の依存関係を導入、<xref:System.Diagnostics.Process.StandardError%2A>ストリームと子要素は、そのストリームへの書き込みを処理します。 これらの依存関係と、デッドロック状態があります。 子プロセスのリダイレクトされたストリームから読み取ると、呼び出し元は、子に依存します。 呼び出し元は、子のストリームに書き込みまたはストリームを閉じるまで、読み取り操作を待機します。 子プロセスが、リダイレクトされたストリームを入力するための十分なデータを書き込むときに、親に依存します。 子プロセスは、親の完全なストリームから読み取りまたはストリームを閉じるまで、次の書き込み操作を待機します。 デッドロック状態の結果、呼び出し元と子プロセスが、操作を完了する相互に待機し、どちらも進むことができます。 呼び出し元と子プロセス間の依存関係を評価することによって、デッドロックを回避できます。  
  
 次の c# コードでは、たとえば、リダイレクトされたストリームから読み取り、子プロセスが終了するまで待機する方法を示します。  
  
```csharp  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 コード例は、呼び出すことによってデッドロック状態を回避`p.StandardError.ReadToEnd`する前に`p.WaitForExit`します。 デッドロック状態が生じる場合は、親プロセスが呼び出し`p.WaitForExit`する前に`p.StandardError.ReadToEnd`子プロセスは、リダイレクトされたストリームを入力するための十分なテキストを書き込みます。 親プロセスが、子プロセスが終了する無期限に待機します。 完全なから読み取る親の子プロセスを無制限に待機が<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
 同様の問題がある、標準出力と標準エラー ストリームからすべてのテキストを読み取るときにします。 たとえば、次の c# コードは、両方のストリームで読み取り操作を実行します。  
  
```csharp  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 コード例では、デッドロック状態を回避非同期の読み取り操作を実行して、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 デッドロック状態が、親の呼び出しを処理する場合に結果`p.StandardOutput.ReadToEnd`続けて`p.StandardError.ReadToEnd`子プロセスが、エラー ストリームを入力するための十分なテキストを書き込みます。 子プロセスが終了する親プロセスが無期限に待機がその<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 完全なから読み取る親の子プロセスを無制限に待機が<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
 非同期の読み取り操作は、これらの依存関係とデッドロックの可能性を回避するために使用できます。 または、別のスレッドで各ストリームの出力の読み取りを 2 つのスレッドを作成してデッドロックの状態を回避できます。  
  
> [!NOTE]
>  リダイレクトされたストリームで読み取り操作を非同期と同期を混在させることはできません。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。 例に従っていない<xref:System.Diagnostics.Process.BeginErrorReadLine%2A>への呼び出しで<xref:System.IO.StreamReader.ReadLine%2A>上、<xref:System.Diagnostics.Process.StandardError%2A>ストリーム、またはその逆。 ただし、異なるモードでの 2 つの異なるストリームを読み取ることができます。 たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を呼び出して<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
   
  
## Examples  
 次の例では、`net use`コマンドをユーザーがネットワーク リソースをマップする引数を指定します。 Net コマンドの標準エラー ストリームを読み取るし、コンソールに書き込みます。  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardError" /> ストリームがリダイレクト用に定義されていません。<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> が <see langword="true" /> に設定されており、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> が <see langword="false" /> に設定されていることを確認してください。  
  
または 
<see cref="P:System.Diagnostics.Process.StandardError" /> ストリームが、<see cref="M:System.Diagnostics.Process.BeginErrorReadLine" /> を使用した非同期読み取り操作のために開いています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの入力の書き込みに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準入力ストリームの書き込みに使用できる <see cref="T:System.IO.StreamWriter" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Diagnostics.Process>標準入力ストリーム、通常は、キーボードから入力テキストを読み取ることができます。 リダイレクトすることにより、 <xref:System.Diagnostics.Process.StandardInput%2A> 、ストリーム入力をプログラムで指定できます。 たとえば、キーボード入力を使用する代わりに、指定したファイルの内容をテキストまたは別のアプリケーションからの出力を指定できます。  
  
> [!NOTE]
>  使用する<xref:System.Diagnostics.Process.StandardInput%2A>、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>に`false`を設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType>に`true`します。 それ以外の場合、書き込み、<xref:System.Diagnostics.Process.StandardInput%2A>ストリームが例外をスローします。  
  
   
  
## Examples  
 次の例では、リダイレクトする方法を示しています、<xref:System.Diagnostics.Process.StandardInput%2A>プロセスのストリーム。 例は、開始、`sort`リダイレクトされた入力とコマンド。 次に、テキストのユーザーに求めますを渡して、`sort`プロセスによってリダイレクトされた<xref:System.Diagnostics.Process.StandardInput%2A>ストリーム。 `sort`コンソールのユーザーに結果が表示されます。  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> が <see langword="false" /> に設定されているため、<see cref="P:System.Diagnostics.Process.StandardInput" /> ストリームが定義されませんでした。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのテキスト出力の読み取りに使用されるストリームを取得します。</summary>
        <value>アプリケーションの標準出力ストリームの読み取りに使用できる <see cref="T:System.IO.StreamReader" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに、<xref:System.Diagnostics.Process>テキストがコンソールに通常表示されることを標準ストリームにテキストを書き込みます。 リダイレクトすることにより、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームを操作するか、プロセスの出力を抑制します。 たとえば、テキストをフィルター処理、異なる方法で書式を設定して、または、コンソールと指定したログ ファイルの両方に出力を書き込みます。  
  
> [!NOTE]
>  使用する<xref:System.Diagnostics.Process.StandardOutput%2A>、設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType>に`false`を設定する必要があります<xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType>に`true`します。 それ以外の場合からの読み取り、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームが例外をスローします。  
  
 リダイレクトされた<xref:System.Diagnostics.Process.StandardOutput%2A>同期または非同期でストリームを読み取ることができます。 などのメソッド<xref:System.IO.StreamReader.Read%2A>、 <xref:System.IO.StreamReader.ReadLine%2A>、および<xref:System.IO.StreamReader.ReadToEnd%2A>プロセスの出力ストリームに同期の読み取り操作を実行します。 関連付けられているまで操作を実行しないでこれらの同期読み取り<xref:System.Diagnostics.Process>を書き込みます、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはストリームを閉じます。  
  
 これに対し、<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>で読み取り操作を非同期の開始、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 このメソッドは、ストリーム出力に指定されたイベント ハンドラーを有効にして、すぐにストリーム出力するイベント ハンドラー中に、その他の作業を実行できる呼び出し元に返します。  
  
 同期読み取り操作は、呼び出し元からの読み取りとの間の依存関係を導入、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリームと子要素は、そのストリームへの書き込みを処理します。 これらの依存関係と、デッドロック状態があります。 子プロセスのリダイレクトされたストリームから読み取ると、呼び出し元は、子に依存します。 呼び出し元は、子のストリームに書き込みまたはストリームを閉じるまで、読み取り操作を待機します。 子プロセスが、リダイレクトされたストリームを入力するための十分なデータを書き込むときに、親に依存します。 子プロセスは、親の完全なストリームから読み取りまたはストリームを閉じるまで、次の書き込み操作を待機します。 デッドロック状態の結果、呼び出し元と子プロセスが、操作を完了する相互に待機し、どちらも進むことができます。 呼び出し元と子プロセス間の依存関係を評価することによって、デッドロックを回避できます。  
  
 次の c# コードでは、たとえば、リダイレクトされたストリームから読み取り、子プロセスが終了するまで待機する方法を示します。  
  
```csharp  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 コード例は、呼び出すことによってデッドロック状態を回避`p.StandardOutput.ReadToEnd`する前に`p.WaitForExit`します。 デッドロック状態が生じる場合は、親プロセスが呼び出し`p.WaitForExit`する前に`p.StandardOutput.ReadToEnd`子プロセスは、リダイレクトされたストリームを入力するための十分なテキストを書き込みます。 親プロセスが、子プロセスが終了する無期限に待機します。 完全なから読み取る親の子プロセスを無制限に待機が<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。  
  
 同様の問題がある、標準出力と標準エラー ストリームからすべてのテキストを読み取るときにします。 たとえば、次の c# コードは、両方のストリームで読み取り操作を実行します。  
  
```csharp  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 コード例では、デッドロック状態を回避非同期の読み取り操作を実行して、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 デッドロック状態が、親の呼び出しを処理する場合に結果`p.StandardOutput.ReadToEnd`続けて`p.StandardError.ReadToEnd`子プロセスが、エラー ストリームを入力するための十分なテキストを書き込みます。 子プロセスが終了する親プロセスが無期限に待機がその<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム。 完全なから読み取る親の子プロセスを無制限に待機が<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
 非同期の読み取り操作は、これらの依存関係とデッドロックの可能性を回避するために使用できます。 または、別のスレッドで各ストリームの出力の読み取りを 2 つのスレッドを作成してデッドロックの状態を回避できます。  
  
> [!NOTE]
>  リダイレクトされたストリームで読み取り操作を非同期と同期を混在させることはできません。 リダイレクトされたストリームの 1 回、<xref:System.Diagnostics.Process>が開かれる、非同期または同期のモードですべてさらに読み取られてそのストリームに対する操作が同じモードである必要があります。 例に従っていない<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>への呼び出しで<xref:System.IO.StreamReader.ReadLine%2A>上、<xref:System.Diagnostics.Process.StandardOutput%2A>ストリーム、またはその逆。 ただし、異なるモードでの 2 つの異なるストリームを読み取ることができます。 たとえば、呼び出す<xref:System.Diagnostics.Process.BeginOutputReadLine%2A>を呼び出して<xref:System.IO.StreamReader.ReadLine%2A>の<xref:System.Diagnostics.Process.StandardError%2A>ストリーム。  
  
   
  
## Examples  
 次の例では、ipconfig.exe コマンドを実行し、例のコンソール ウィンドウにその標準出力をリダイレクトします。  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームがリダイレクト用に定義されていません。<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> が <see langword="true" /> に設定されており、<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> が <see langword="false" /> に設定されていることを確認してください。  
  
または 
<see cref="P:System.Diagnostics.Process.StandardOutput" /> ストリームが、<see cref="M:System.Diagnostics.Process.BeginOutputReadLine" /> を使用した非同期読み取り操作のために開いています。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>プロセス リソースを起動し、<see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Diagnostics.Process" /> コンポーネントの <see cref="P:System.Diagnostics.Process.StartInfo" /> プロパティで指定されたプロセス リソースを起動 (または再利用) し、コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースが起動された場合は <see langword="true" />。新しいプロセス リソースが起動されなかった場合は <see langword="false" /> (既存のプロセスを再利用した場合など)。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用してプロセス リソースを起動し、現在に関連付ける<xref:System.Diagnostics.Process>コンポーネント。 戻り値`true`新しいプロセス リソースが開始されたことを示します。 指定されたプロセス リソースがある場合、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティが既にコンピューターで実行されている、リソースの追加のプロセスは起動されません。 代わりに、実行中のプロセス リソースを再利用と`false`が返されます。  
  
 ClickOnce アプリケーションを起動するには、アプリケーションをインストールした最初の場所 (たとえば、Web アドレス) を指定します。 ClickOnce アプリケーションは、ハード ドライブ上のインストール場所を指定することで開始されません。  
  
> [!NOTE]
>  Visual Studio でのこのオーバー ロードを使用している場合、<xref:System.Diagnostics.Process.Start%2A>メソッドは、ドラッグした後、コードに挿入する 1 つ、<xref:System.Diagnostics.Process>コンポーネントをデザイナーにします。 使用して、`Properties`を展開するにはウィンドウ、`StartInfo`カテゴリに適切な値を書き込むと、`FileName`プロパティ。 フォームの変更内容が表示されます`InitializeComponent`プロシージャ。  
  
 このオーバー ロード<xref:System.Diagnostics.Process.Start%2A>でない、`static`メソッド。 インスタンスから呼び出す必要がある、<xref:System.Diagnostics.Process>クラス。 呼び出しの前に<xref:System.Diagnostics.Process.Start%2A>、最初に指定する必要があります<xref:System.Diagnostics.Process.StartInfo%2A>プロパティについては、この<xref:System.Diagnostics.Process>インスタンスは、その情報を使用して起動するプロセスのリソースを決定するためです。  
  
 その他のオーバー ロード、<xref:System.Diagnostics.Process.Start%2A>メソッドは`static`メンバー。 インスタンスを作成する必要はありません、<xref:System.Diagnostics.Process>コンポーネント、メソッドのこれらのオーバー ロードを呼び出す前にします。 代わりに、呼び出すことができます<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>クラス自体、および新しい<xref:System.Diagnostics.Process>プロセスが開始された場合、コンポーネントを作成します。 または、`null`プロセスが再利用されたかどうかに返されます。 プロセス リソースが自動的に新しい関連付け<xref:System.Diagnostics.Process>コンポーネントによって返される、<xref:System.Diagnostics.Process.Start%2A>メソッド。  
  
 <xref:System.Diagnostics.Process.StartInfo%2A>の機能を複製するメンバーを使用できる、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。 適切な値を設定してコマンドラインに入力できるものを起動することができます、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ。 唯一<xref:System.Diagnostics.Process.StartInfo%2A>プロパティを設定する必要がありますが、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティ。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは実行可能ファイルは指定する必要はありません。 拡張機能は、システムにインストールされているアプリケーションに関連付けられた任意のファイルの種類のことができます。 たとえば、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>にメモ帳などのエディターでテキスト ファイルを関連付けるか、Microsoft Word などのワード プロセッシング ツールを使用してファイルを関連付けている場合、拡張子 .doc ことができる場合、プロパティは .txt 拡張子を持つことができます。  
  
 コマンドラインでは、特定の種類のファイルを実行するアクションを指定できます。 たとえば、ドキュメントを印刷またはテキスト ファイルを編集できます。 使用してこれらのアクションを指定、<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ。 ファイルを起動するときに他の種類のファイルには、コマンドライン引数を指定することができます、 `Run`  ダイアログ ボックス。 たとえば、することができます、URL を引数として渡しますとしてブラウザーを指定する場合、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>します。 これらの引数で指定できます、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティの<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>メンバー。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。  使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッド、ASP.NET Web ページまたはサーバー コントロールで、制限されたアクセス許可を持つ Web サーバーで、新しいプロセスを実行します。 プロセスでは、クライアントのブラウザーと同じコンテキストで起動しないと、ユーザーのデスクトップへのアクセスはありません。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。 使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。 使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。  
  
 マネージ スレッドのアパートメント状態に関する注意事項がここで必要があります。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`プロセス コンポーネントの<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、属性を設定して、アプリケーションでスレッド モデルを設定することを確認`[STAThread]`上、`main()`メソッド。 それ以外の場合、マネージ スレッドがであることができます、`unknown`状態またはに、`MTA`状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`します。 いくつかのメソッドのアパートメント状態でないことが必要な`unknown`します。 状態が明示的に設定されていないアプリケーションは、このようなメソッドを検出すると場合、既定`MTA`、一度設定すると、アパートメント状態が変更ことはできません。 ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。  
  
   
  
## Examples  
 次の例のインスタンスを使用して、<xref:System.Diagnostics.Process>プロセスを開始するクラス。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.Process" /> コンポーネントの <see cref="P:System.Diagnostics.Process.StartInfo" /> にファイル名が指定されませんでした。
あるいは、<see cref="P:System.Diagnostics.Process.StartInfo" /> プロパティの<see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> メンバーは <see langword="true" /> ですが、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />、または <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> は <see langword="true" /> です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドはシェルがサポートされていない Nano Server (.NET Core のみ) などのオペレーティング システムではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">ファイル名やコマンド ライン引数など、プロセスの起動に使用する情報が格納されている <see cref="T:System.Diagnostics.ProcessStartInfo" />。</param>
        <summary>プロセス起動情報 (起動するプロセスのファイル名など) が格納されているパラメーターで指定されたプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用して指定してプロセス リソースを開始する、<xref:System.Diagnostics.ProcessStartInfo>インスタンス。 オーバー ロードは、新しいリソースに関連付けます<xref:System.Diagnostics.Process>オブジェクト。  
  
> [!NOTE]
>  プロセスが開始されていないを開始する実行可能ファイルのアドレスが URL の場合と`null`が返されます。  
  
 このオーバー ロードでは、最初に、新しい作成せず、プロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。 このオーバー ロードを使用して、<xref:System.Diagnostics.ProcessStartInfo>パラメーターは、新しいを作成する明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>設定インスタンスその<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および通話<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。  
  
 使用して、<xref:System.Diagnostics.ProcessStartInfo>ように、パラメーターを指定する呼び出しをインスタンス<xref:System.Diagnostics.Process.Start%2A>を最大限にプロセスを開始する呼び出しに渡される内容が制御します。 ファイル名のみ、またはファイル名と引数を渡す必要がある場合は、新たに作成する必要はありません<xref:System.Diagnostics.ProcessStartInfo>オプションですが、インスタンスします。 唯一<xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType>プロパティを設定する必要がありますが、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティ。 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、実行可能ファイルを表す必要はありません。 拡張機能は、システムにインストールされているアプリケーションに関連付けられた任意のファイルの種類のことができます。 たとえば、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>にメモ帳などのエディターでテキスト ファイルを関連付けるか、Microsoft Word などのワード プロセッシング ツールを使用してファイルを関連付けている場合、拡張子 .doc ことができる場合、プロパティは .txt 拡張子を持つことができます。  
  
 ClickOnce アプリケーションを起動するには、アプリケーションをインストールした最初の場所 (たとえば、Web アドレス) を指定します。 ClickOnce アプリケーションは、ハード ドライブ上のインストール場所を指定することで開始されません。  
  
 場合、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>と<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>インスタンスが設定、管理されていない`CreateProcessWithLogonW`関数が呼び出されると、新しいウィンドウいてでプロセスを開始する、<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType>プロパティの値が`true`または、 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType>プロパティの値が<xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>します。 場合、<xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType>プロパティは`null`、<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>プロパティは、UPN の形式である必要があります*ユーザー*@*DNS_domain_name*します。   
  
 その他のオーバー ロードのオーバー ロードとは異なり<xref:System.Diagnostics.Process.Start%2A>パラメーターを持たないが、`static`メンバー。 既に作成しているとき、オーバー ロードを使用して、<xref:System.Diagnostics.Process>インスタンス、(ファイル名を含む)、指定した開始情報と関連付ける既存のプロセス リソースを開始する<xref:System.Diagnostics.Process>インスタンス。 いずれかを使用して、`static`を新規作成するときにオーバー ロード<xref:System.Diagnostics.Process>既存のコンポーネントのプロセスを開始するのではなくコンポーネント。 このオーバー ロードとパラメーターがないオーバー ロードの両方を使用してプロセス リソースの開始情報を指定することを許可する<xref:System.Diagnostics.ProcessStartInfo>インスタンス。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。  使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッド、ASP.NET Web ページまたはサーバー コントロールで、制限されたアクセス許可を持つ Web サーバーで、新しいプロセスを実行します。 プロセスでは、クライアントのブラウザーと同じコンテキストで起動しないと、ユーザーのデスクトップへのアクセスはありません。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。 使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。 使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。  
  
 マネージ スレッドのアパートメント状態に関する注意事項がここで必要があります。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`上、`startInfo`パラメーター、属性を設定して、アプリケーションでスレッド モデルを設定することを確認`[STAThread]`上、`main()`メソッド。 それ以外の場合、マネージ スレッドがであることができます、`unknown`状態またはに、`MTA`状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`します。 いくつかのメソッドのアパートメント状態でないことが必要な`unknown`します。 状態が明示的に設定されていないアプリケーションは、このようなメソッドを検出すると場合、既定`MTA`、一度設定すると、アパートメント状態が変更ことはできません。 ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。  
  
   
  
## Examples  
 まず、次の例は、Internet Explorer のインスタンスを生成し、ブラウザーで [お気に入り] フォルダーの内容を表示します。 Internet Explorer の他のいくつかのインスタンスを起動し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動する際に最小化ウィンドウで Internet Explorer を起動します。  
  
 このメソッドの他の使用の他の例の個々 のプロパティを参照してください、<xref:System.Diagnostics.ProcessStartInfo>クラス。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> プロパティにファイル名が指定されませんでした。  
  
または 
<paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティは <see langword="true" /> であり、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />、<see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />、または <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> プロパティも <see langword="true" /> です。  
  
または 
<paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> プロパティは <see langword="true" /> であり、<see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> プロパティは <see langword="null" /> でも空でもないか、または <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> プロパティは <see langword="null" /> ではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="startInfo" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="startInfo" /> パラメーターの <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> プロパティに指定されたファイルを見つけることができませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  
  
または 
引数の長さとプロセスへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます"  または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドはシェルがサポートされていない Nano Server (.NET Core のみ) などのオペレーティング システムではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行する文書またはアプリケーション ファイルの名前。</param>
        <summary>文書またはアプリケーション ファイルの名前を指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、そのファイル名を指定してプロセス リソースを起動します。 オーバー ロードは、新しいリソースに関連付けます<xref:System.Diagnostics.Process>オブジェクト。  
  
> [!NOTE]
>  プロセスが開始されていないを開始する実行可能ファイルのアドレスが URL の場合と`null`が返されます。  
  
 このオーバー ロードでは、最初に、新しい作成せず、プロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。 オーバー ロードは、新しいを作成する明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>インスタンス、設定、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および通話<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。  
  
 ClickOnce アプリケーションを起動するには設定して、`fileName`アプリケーションをインストールした最初の位置 (たとえば、Web アドレス) へのパラメーター。 ClickOnce アプリケーションは、ハード ドライブ上のインストール場所を指定することで開始されません。  
  
 そのファイル名を指定することによって、プロセスを開始するは内の情報を入力に似ています、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。 そのため、ファイル名は、実行可能ファイルを表す必要はありません。 種類のファイルを拡張機能に関連付けられているシステムにインストールされているアプリケーションのことができます。 たとえばのファイル名は、テキスト ファイルをメモ帳などのエディターに関連付けられましたか Microsoft Word などのワード プロセッシング ツールを使用してファイルを関連付けている場合、.doc ことができます、.txt 拡張子を使用できます。 同じで同様に、方法、 `Run`  ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。 たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーター。  
  
 このオーバー ロードは、プロセスのコマンドライン引数を許可しません。 プロセスの 1 つまたは複数のコマンドライン引数を指定する必要がある場合、<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType>または<xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType>オーバー ロードします。  
  
 その他のオーバー ロードのオーバー ロードとは異なり<xref:System.Diagnostics.Process.Start%2A>パラメーターを持たないが、`static`メンバー。 既に作成しているとき、オーバー ロードを使用して、<xref:System.Diagnostics.Process>インスタンス、(ファイル名を含む)、指定した開始情報と関連付ける既存のプロセス リソースを開始する<xref:System.Diagnostics.Process>インスタンス。 いずれかを使用して、`static`を新規作成するときにオーバー ロード<xref:System.Diagnostics.Process>既存のコンポーネントのプロセスを開始するのではなくコンポーネント。 このオーバー ロードとパラメーターがないオーバー ロードの両方を使用すると、起動するプロセスのリソースのファイル名を指定できます。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。  使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッド、ASP.NET Web ページまたはサーバー コントロールで、制限されたアクセス許可を持つ Web サーバーで、新しいプロセスを実行します。 プロセスでは、クライアントのブラウザーと同じコンテキストで起動しないと、ユーザーのデスクトップへのアクセスはありません。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。 使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。 使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。  
  
 マネージ スレッドのアパートメント状態に関する注意事項がここで必要があります。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`プロセス コンポーネントの<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、属性を設定して、アプリケーションでスレッド モデルを設定することを確認`[STAThread]`上、`main()`メソッド。 それ以外の場合、マネージ スレッドがであることができます、`unknown`状態またはに、`MTA`状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`します。 いくつかのメソッドのアパートメント状態でないことが必要な`unknown`します。 状態が明示的に設定されていないアプリケーションは、このようなメソッドを検出すると場合、既定`MTA`、一度設定すると、アパートメント状態が変更ことはできません。 ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。  
  
   
  
## Examples  
 まず、次の例は、Internet Explorer のインスタンスを生成し、ブラウザーで [お気に入り] フォルダーの内容を表示します。 Internet Explorer の他のいくつかのインスタンスを起動し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動する際に最小化ウィンドウで Internet Explorer を起動します。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境変数に、引用符を含む文字列があります。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="arguments">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>アプリケーションの名前とコマンド ライン引数のセットを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 そのファイルの名前とコマンドライン引数を指定してプロセス リソースを開始するのにには、このオーバー ロードを使用します。 オーバー ロードは、新しいリソースに関連付けます<xref:System.Diagnostics.Process>オブジェクト。  
  
> [!NOTE]
>  プロセスが開始されていないを開始する実行可能ファイルのアドレスが URL の場合と`null`が返されます。  
  
 このオーバー ロードでは、最初に、新しい作成せず、プロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。 オーバー ロードは、新しいを作成する明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>インスタンス、設定、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>と<xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および通話<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。  
  
 ファイルの名前と引数を指定することによって、プロセスを開始するはでコマンドライン引数とファイルの名前を入力に似ています、 `Run`  ダイアログ ボックス、Windows の`Start`メニュー。 そのため、ファイル名は、実行可能ファイルを表す必要はありません。 種類のファイルを拡張機能に関連付けられているシステムにインストールされているアプリケーションのことができます。 たとえばのファイル名は、テキスト ファイルをメモ帳などのエディターに関連付けられましたか Microsoft Word などのワード プロセッシング ツールを使用してファイルを関連付けている場合、.doc ことができます、.txt 拡張子を使用できます。 同じで同様に、方法、 `Run`  ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。 たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーター。 場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、対象となるテキスト ファイルなどのファイルを表す場合があります`Notepad.exe myfile.txt`します。 場合、`fileName`パラメーターがコマンド (.cmd) ファイルを表す、`arguments`パラメーターは、いずれかを含める必要があります、"`/c`「または」`/k`"コマンド ウィンドウが終了するか、完了した後に残すかどうかを指定する引数。  
  
 その他のオーバー ロードのオーバー ロードとは異なり<xref:System.Diagnostics.Process.Start%2A>パラメーターを持たないが、`static`メンバー。 既に作成しているとき、オーバー ロードを使用して、<xref:System.Diagnostics.Process>インスタンス、(ファイル名を含む)、指定した開始情報と関連付ける既存のプロセス リソースを開始する<xref:System.Diagnostics.Process>インスタンス。 いずれかを使用して、`static`を新規作成するときにオーバー ロード<xref:System.Diagnostics.Process>既存のコンポーネントのプロセスを開始するのではなくコンポーネント。 このオーバー ロードとパラメーターがないオーバー ロードの両方を使用すると、プロセスのリソースを起動してに渡すコマンドライン引数のファイル名を指定できます。  
  
 システムでパス変数を引用符で囲んで宣言している場合、その場所で見つかるプロセスを開始するときに、そのパスを完全修飾する必要があります。 そうしないと、システムはそのパスを見つけられません。 たとえば、`c:\mypath` がパスに含まれておらず、それを `path = %path%;"c:\mypath"`` のように引用符を使用して追加した場合、`c:\mypath` 内の任意のプロセスを開始するときに、それを完全修飾する必要があります。  
  
> [!NOTE]
>  ASP.NET Web ページとサーバー コントロールのコードは、Web サーバー上の ASP.NET ワーカー プロセスのコンテキストで実行されます。  使用する場合、<xref:System.Diagnostics.Process.Start%2A>メソッド、ASP.NET Web ページまたはサーバー コントロールで、制限されたアクセス許可を持つ Web サーバーで、新しいプロセスを実行します。 プロセスでは、クライアントのブラウザーと同じコンテキストで起動しないと、ユーザーのデスクトップへのアクセスはありません。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。 使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。 使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。 
  
 マネージ スレッドのアパートメント状態に関する注意事項がここで必要があります。 ときに<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>は`true`プロセス コンポーネントの<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、属性を設定して、アプリケーションでスレッド モデルを設定することを確認`[STAThread]`上、`main()`メソッド。 それ以外の場合、マネージ スレッドがであることができます、`unknown`状態またはに、`MTA`状態と競合するのには、後者<xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A>される`true`します。 いくつかのメソッドのアパートメント状態でないことが必要な`unknown`します。 状態が明示的に設定されていないアプリケーションは、このようなメソッドを検出すると場合、既定`MTA`、一度設定すると、アパートメント状態が変更ことはできません。 ただし、`MTA`オペレーティング システムのシェルが、スレッドを管理するときにスローされる例外が発生します。  
  
   
  
## Examples  
 まず、次の例は、Internet Explorer のインスタンスを生成し、ブラウザーで [お気に入り] フォルダーの内容を表示します。 Internet Explorer の他のいくつかのインスタンスを起動し、特定のページまたはサイトを表示します。 最後に、特定のサイトに移動する際に最小化ウィンドウで Internet Explorer を起動します。  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="fileName" /> パラメーターまたは <paramref name="arguments" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  
  
または 
引数の長さとプロセスへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます"  または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">PATH 環境変数に、引用符を含む文字列があります。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="userName">プロセスの開始時に使用するユーザー名。</param>
        <param name="password">プロセスを開始するときに使用するパスワードを含む <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">プロセスの開始時に使用するドメイン。</param>
        <summary>アプリケーションの名前、ユーザー名、パスワード、ドメインを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードを使用すると、そのファイル名、ユーザー名、パスワード、およびドメインを指定することで、新しいプロセスとそのプライマリ スレッドを作成できます。 新しいプロセスは、(ユーザー、ドメイン、およびパスワード) には、指定した資格情報のセキュリティ コンテキストで、指定した実行可能ファイルを実行します。  
  
> [!NOTE]
>  実行可能ファイルがリモート ドライブ上にある場合は、リンクされているドライブ文字ではなく uniform resource identifier (URI) を使用してネットワーク共有を識別する必要があります。  
  
> [!NOTE]
>  プロセスが開始されていないを開始する実行可能ファイルのアドレスが URL の場合と`null`が返されます。  
  
 このオーバー ロードでは、最初に、新しい作成せず、プロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。 オーバー ロードは、新しいを作成する明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>設定インスタンス、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>、および<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および通話<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。  
  
 同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。 たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーター。 場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、対象となるテキスト ファイルなどのファイルを表す場合があります`Notepad.exe myfile.txt`します。  
  
> [!NOTE]
>  ファイル名での実行可能ファイルを表す必要があります、<xref:System.Diagnostics.Process.Start%2A>がオーバー ロード`userName`、 `password`、および`domain`パラメーター。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。 使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。 使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。 
  
   
  
## Examples  
 次のコード例のこのオーバー ロードを開始する実行可能ファイルの使用例を示しものスローを示しています、<xref:System.ComponentModel.Win32Exception>非実行可能ファイルに関連付けられているアプリケーションを起動する試みが行われた場合。  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ファイル名が指定されませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドは Linux または macOS (.NET Core のみ) ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">プロセスで実行するアプリケーション ファイルの名前。</param>
        <param name="arguments">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <param name="userName">プロセスの開始時に使用するユーザー名。</param>
        <param name="password">プロセスを開始するときに使用するパスワードを含む <see cref="T:System.Security.SecureString" />。</param>
        <param name="domain">プロセスの開始時に使用するドメイン。</param>
        <summary>アプリケーションの名前、コマンド ライン引数のセット、ユーザー名、パスワード、およびドメインを指定してプロセス リソースを起動し、リソースを新しい <see cref="T:System.Diagnostics.Process" /> コンポーネントに関連付けます。</summary>
        <returns>プロセス リソースに関連付けられている新しい <see cref="T:System.Diagnostics.Process" />。プロセス リソースが起動されていない場合は <see langword="null" />。 同じプロセスのインスタンスが既に実行されているときに起動された新しいプロセスは、他のインスタンスから独立します。 また、Start では、<see cref="P:System.Diagnostics.Process.HasExited" /> プロパティが既に <see langword="true" /> に設定されている null 以外の Process が返される場合があります。 その場合、起動されたプロセス自体の既存のインスタンスがアクティブ化され、その後に終了されることがあります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルの名前、コマンドライン引数、ユーザー名、パスワード、およびドメインを指定して、新しいプロセスとそのプライマリ スレッドを作成するのにには、このオーバー ロードを使用します。 新しいプロセスは、(ユーザー、ドメイン、およびパスワード) には、指定した資格情報のセキュリティ コンテキストで、指定した実行可能ファイルを実行します。  
  
> [!NOTE]
>  実行可能ファイルがリモート ドライブ上にある場合は、リンクされているドライブ文字ではなく uniform resource identifier (URI) を使用してネットワーク共有を識別する必要があります。  
  
> [!NOTE]
>  プロセスが開始されていないを開始する実行可能ファイルのアドレスが URL の場合と`null`が返されます。  
  
 このオーバー ロードでは、最初に、新しい作成せず、プロセスを開始できます。<xref:System.Diagnostics.Process>インスタンス。 オーバー ロードは、新しいを作成する明示的な手順を実行する代わりに<xref:System.Diagnostics.Process>インスタンス、設定、 <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>、 <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>、 <xref:System.Diagnostics.ProcessStartInfo.Password%2A>、および<xref:System.Diagnostics.ProcessStartInfo.Domain%2A>のプロパティ、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティ、および呼び出し元<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンス。  
  
 同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、`fileName`パラメーター。 たとえば、設定、 `fileName` "Notepad.exe"または"Notepad"のいずれかのパラメーター。 場合、`fileName`パラメーターは、実行可能ファイルを表す、`arguments`パラメーターは、対象となるテキスト ファイルなどのファイルを表す場合があります`Notepad.exe myfile.txt`します。  
  
> [!NOTE]
>  ファイル名での実行可能ファイルを表す必要があります、<xref:System.Diagnostics.Process.Start%2A>がオーバー ロード`userName`、 `password`、および`domain`パラメーター。  
  
 使用するたびに<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するには、閉じる必要がありますまたはシステム リソースが失われる可能性です。 使用してプロセスを閉じる<xref:System.Diagnostics.Process.CloseMainWindow%2A>または<xref:System.Diagnostics.Process.Kill%2A>します。 使用して、プロセスを閉じているかどうかを確認することができます、<xref:System.Diagnostics.Process.HasExited%2A>プロパティ。 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ファイル名が指定されませんでした。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">関連付けられているファイルを開いているときにエラーが発生しました。  
  
または 
引数の長さと関連ファイルへの完全パスの長さの合計が、2080 文字を超えています。 この例外に関連付けられたエラー メッセージは、次のいずれかになります。"システム コールに渡されるデータ領域が小さすぎます"  または「アクセスが拒否されました。」</exception>
        <exception cref="T:System.ObjectDisposedException">プロセス オブジェクトは既には破棄されています。</exception>
        <exception cref="T:System.PlatformNotSupportedException">メソッドは Linux または macOS (.NET Core のみ) ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Diagnostics.Process" /> の <see cref="M:System.Diagnostics.Process.Start" /> メソッドに渡すプロパティを取得または設定します。</summary>
        <value>プロセスを起動するときに使用するデータを表す <see cref="T:System.Diagnostics.ProcessStartInfo" />。 これらの引数には、プロセスの起動時に使用する実行可能ファイルまたは文書の名前があります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> 使用して、プロセスを開始するパラメーターのセットを表します。 ときに<xref:System.Diagnostics.Process.Start%2A>が呼び出される、<xref:System.Diagnostics.Process.StartInfo%2A>プロセスを開始するを指定するために使用します。 必要なだけ<xref:System.Diagnostics.Process.StartInfo%2A>を設定するメンバーが、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティ。 指定することによって、プロセスを開始、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、情報を入力すると同様、**実行** ダイアログ ボックス、Windows の**開始**メニュー。 そのため、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティは、実行可能ファイルを表す必要はありません。 種類のファイルを拡張機能に関連付けられているシステムにインストールされているアプリケーションのことができます。 たとえば、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>にメモ帳などのエディターでテキスト ファイルを関連付けるか、Microsoft Word などのワード プロセッシング ツールを使用してファイルを関連付けている場合、.doc ことができる場合、.txt 拡張子を持つことができます。 同じで同様に、方法、**実行** ダイアログ ボックスで、実行可能ファイル名拡張子が .exe の有無を受け入れることができます、拡張子 .exe が省略可能で、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>メンバー。 たとえば、設定、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティを"Notepad.exe"または"Notepad"。  
  
 ClickOnce アプリケーションを起動するには設定して、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティをアプリケーションをインストールした最初の場所 (たとえば、Web アドレス)。 ClickOnce アプリケーションは、ハード ドライブ上のインストール場所を指定することで開始されません。  
  
 ファイル名には、.doc ファイルなどの非実行可能ファイルが含まれている場合は、ファイルを実行するには、どのようなアクションを指定する動詞を含めることができます。 たとえば、設定する、 <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> .doc 拡張子で終わるファイルの"Print"にします。 指定されたファイル名、<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティが値を手動で入力する場合、拡張子を指定する必要はありません、<xref:System.Diagnostics.ProcessStartInfo.Verb%2A>プロパティ。 ただし、使用する場合、<xref:System.Diagnostics.ProcessStartInfo.Verbs%2A>動詞を確認するには、拡張機能を含める必要があります。  
  
 指定されたパラメーターを変更することができます、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティを呼び出したときまで、<xref:System.Diagnostics.Process.Start%2A>メソッドを処理します。 変更するプロセスを開始した後、<xref:System.Diagnostics.Process.StartInfo%2A>値が影響を与えるまたは関連付けられたプロセスを再起動していません。 呼び出す場合、<xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29>メソッドを<xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType>と<xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType>プロパティ セットには、アンマネージ`CreateProcessWithLogonW`関数が呼び出されると、新しいウィンドウいてでプロセスを開始する、<xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A>プロパティの値が`true`または、 <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A>プロパティの値が<xref:System.Diagnostics.ProcessWindowStyle.Hidden>します。  
  
 使用していない場合、<xref:System.Diagnostics.Process.Start%2A>プロセスを開始するメソッド、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティは、プロセスを開始するためのパラメーターを反映しません。 例では、使用する場合の<xref:System.Diagnostics.Process.GetProcesses%2A>コンピューターで、実行中のプロセスの配列を取得する、<xref:System.Diagnostics.Process.StartInfo%2A>の各プロパティ<xref:System.Diagnostics.Process>元のファイル名またはプロセスを開始するための引数が含まれていません。  
  
 プロセスを起動すると、ファイル名は、(読み取り専用) のメンバーを追加するファイル<xref:System.Diagnostics.Process.MainModule%2A>プロパティ。 プロセスが開始した後、プロセスに関連付けられている実行可能ファイルを取得するには、使用する場合、<xref:System.Diagnostics.Process.MainModule%2A>プロパティ。 実行可能ファイルを設定する場合、<xref:System.Diagnostics.Process>インスタンスが、関連付けられたプロセスが開始されていない場合、使用、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティの<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>メンバー。 のメンバー、<xref:System.Diagnostics.Process.StartInfo%2A>プロパティに渡される引数には、<xref:System.Diagnostics.Process.Start%2A>メソッドを変更する、プロセスの<xref:System.Diagnostics.ProcessStartInfo.FileName%2A>プロパティ、関連付けられたプロセスが開始した後の状態はリセットされません、<xref:System.Diagnostics.Process.MainModule%2A>プロパティ。 これらのプロパティは、関連付けられたプロセスを初期化するためにのみ使用されます。  
  
   
  
## Examples  
 次の例を<xref:System.Diagnostics.Process.StartInfo%2A>ことで、ファイルを実行するアクションを実行して、ユーザー インターフェイスを表示するかどうか。 その他の例のプロパティのリファレンス ページを参照してください、<xref:System.Diagnostics.ProcessStartInfo>クラス。  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Diagnostics.Process.StartInfo" /> を指定する値は <see langword="null" /> です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスが起動された時刻を取得します。</summary>
        <value>プロセスが起動された時刻を示すオブジェクト。 プロセスが実行中でない場合は、例外がスローされます。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.StartTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.InvalidOperationException">プロセスが終了しています。  
  
または 
プロセスは開始されていません。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Windows 関数の呼び出しでエラーが発生しました。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセス終了イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用するオブジェクトを取得または設定します。</summary>
        <value>プロセスの <see cref="E:System.Diagnostics.Process.Exited" /> イベントの結果として発行されるイベント ハンドラー呼び出しをマーシャリングするために使用する <see cref="T:System.ComponentModel.ISynchronizeInvoke" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ときに<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>は`null`、処理するメソッド、<xref:System.Diagnostics.Process.Exited>イベントは、システム スレッド プールのスレッドで呼び出されます。 システム スレッド プールの詳細については、次を参照してください。<xref:System.Threading.ThreadPool>します。  
  
 ときに、<xref:System.Diagnostics.Process.Exited>イベントがなどのビジュアルの Windows フォーム コンポーネントによって処理されます、 <xref:System.Windows.Forms.Button>、システム スレッド プールを介したコンポーネントへのアクセスが機能しないか、例外が発生する可能性があります。 設定してこの問題を回避<xref:System.Diagnostics.Process.SynchronizingObject%2A>これにより、Windows フォームのコンポーネントを処理するメソッド、<xref:System.Diagnostics.Process.Exited>コンポーネントが作成された同じスレッドで呼び出されるイベント。  
  
 場合、<xref:System.Diagnostics.Process>内で使用する[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]Windows フォーム デザイナーで<xref:System.Diagnostics.Process.SynchronizingObject%2A>を含むコントロールを自動的に設定されますが、<xref:System.Diagnostics.Process>します。 配置する場合など、<xref:System.Diagnostics.Process>のデザイナーで`Form1`(から継承される<xref:System.Windows.Forms.Form>)、<xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティの<xref:System.Diagnostics.Process>のインスタンスに設定されている`Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 通常、このプロパティがコントロールまたはフォーム内でコンポーネントを配置するとこれらのコンポーネントは、特定のスレッドにバインドされるためです。  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスで実行されているスレッドのセットを取得します。</summary>
        <value>関連付けられたプロセスで現在実行中のオペレーティング システム スレッドを表す <see cref="T:System.Diagnostics.ProcessThread" /> 型の配列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スレッドは、プロセスでコードを実行します。 1 つのスレッド、プライマリ スレッドで各プロセスが開始されます。 どのスレッドでも新しいスレッドを作成できます。 プロセス内のスレッドは、プロセスのアドレス空間を共有します。  
  
 使用<xref:System.Diagnostics.ProcessThread>を現在のプロセスに関連付けられているすべてのスレッドを取得します。 プライマリ スレッドは必ずしも配列内のインデックス 0 位置です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">プロセスに <see cref="P:System.Diagnostics.Process.Id" /> がないか、<see cref="T:System.Diagnostics.Process" /> インスタンスに関連付けられているプロセスがありません。  
  
または 
関連付けられたプロセスが終了しました。</exception>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) です。Windows 98 や Windows Me でこのプロパティにアクセスするには <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> を <see langword="false" /> に設定します。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プロセス名の書式指定は文字列にします。親コンポーネント型があれば、この型と組み合わせます。</summary>
        <returns>ベース コンポーネントの <see cref="M:System.Object.ToString" /> の戻り値と組み合わせた <see cref="P:System.Diagnostics.Process.ProcessName" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="M:System.Diagnostics.Process.ToString" /> は、Windows 98 ではサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスの合計プロセッサ時間を取得します。</summary>
        <value>関連付けられたプロセスが CPU を使用した合計時間を示す <see cref="T:System.TimeSpan" />。 この値は、<see cref="P:System.Diagnostics.Process.UserProcessorTime" /> と <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> の合計です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロセスのユーザー プロセッサ時間を取得します。</summary>
        <value>関連付けられたプロセスが、プロセスのアプリケーション部分の内部 (オペレーティング システム コアの外部) でコードを実行した合計時間を示す <see cref="T:System.TimeSpan" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、プロセスの終了コードを表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <exception cref="T:System.NotSupportedException">リモート コンピューターで実行されているプロセスの <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> プロパティにアクセスしようとしています。 このプロパティはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスの仮想メモリのサイズ (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスが要求した仮想メモリの容量 (バイト単位)。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられた仮想メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた仮想メモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、(バイト単位)、プロセスによって使用される仮想メモリの現在のサイズを表します。 オペレーティング システムでは、各プロセスの物理メモリまたはディスク上の仮想メモリ ページング ファイルに格納されているページが読み込まれるページのいずれかの仮想アドレス空間をマップします。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値が等しく、**仮想バイト**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>関連付けられたプロセスが終了するまで待機する時間を設定し、指定した時間が経過するかプロセスが終了するまで現在のスレッドの実行をブロックします。 現在のスレッドがブロックされないようにする場合は、<see cref="E:System.Diagnostics.Process.Exited" /> イベントを使用します。  
  
コード例については、<see cref="P:System.Diagnostics.Process.StandardError" /> および <see cref="P:System.Diagnostics.Process.ExitCode" /> プロパティのリファレンス ページを参照してください。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスが終了するまで無期限に待機するように <see cref="T:System.Diagnostics.Process" /> コンポーネントに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> 関連付けられたプロセスが終了するまで待ってから、現在のスレッドを使用します。  これは、プロセスの他のすべてのメソッドが呼び出された後に呼び出す必要があります。 現在のスレッドがブロックされないようにする場合は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。  
  
 このメソッドに指示、<xref:System.Diagnostics.Process>コンポーネントを膨大な量のプロセスとイベント ハンドラーの終了時間を待機します。 これには、アプリケーションの応答を停止する可能性があります。 呼び出す場合など、<xref:System.Diagnostics.Process.CloseMainWindow%2A>ユーザー インターフェイスを持つプロセスでは、オペレーティング システムに要求を関連付けられているプロセスを終了する可能性があります処理されない場合は、プロセスは、メッセージ ループに入ることはなくに書き込まれます。  
  
> [!NOTE]
>  [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]以前のバージョン、<xref:System.Diagnostics.Process.WaitForExit>のオーバー ロードを待機<xref:System.Int32.MaxValue>ミリ秒 (約 24 日)、not 無期限にします。 また、以前のバージョン待つことはなく終了イベント ハンドラーの完全な<xref:System.Int32.MaxValue>時間に達しました。  
  
 このオーバー ロードにより、リダイレクトされた標準出力の非同期イベントの処理など、すべての処理が完了したこと。 呼び出しの後に、このオーバー ロードを使用する必要があります、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>オーバー ロードするときに、標準出力は非同期イベント ハンドラーにリダイレクトされました。  
  
 システムがプロセスの詳細の管理情報を格納しが呼び出されているコンポーネントを返します (正常または異常終了を操作システムによって停止) の場合は、関連付けられたプロセスが終了したとき<xref:System.Diagnostics.Process.WaitForExit>します。 <xref:System.Diagnostics.Process>コンポーネントを含む、情報にアクセスできる、<xref:System.Diagnostics.Process.ExitTime%2A>を使用して、<xref:System.Diagnostics.Process.Handle%2A>終了のプロセスにします。  
  
 関連付けられたプロセスが終了したため、<xref:System.Diagnostics.Process.Handle%2A>コンポーネントのプロパティが不要になった既存のプロセス リソースをポイントします。 代わりにのハンドルは、プロセスのリソースについては、オペレーティング システムのアクセスにのみ使用できます。 システムは、解放されていない終了のプロセスへのハンドルの<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>までメモリ内の情報、<xref:System.Diagnostics.Process>コンポーネントが具体的には、リソースを解放します。 このため、いつでも呼び出す<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンスを呼び出す<xref:System.Diagnostics.Process.Close%2A>と関連付けられたプロセスが終了することについて、管理情報が不要になった。 <xref:System.Diagnostics.Process.Close%2A> 終了したプロセスに割り当てられたメモリを解放します。  
  
   
  
## Examples  
 「解説」を参照してください、<xref:System.Diagnostics.Process.StandardError%2A>プロパティ リファレンスのページ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">待機の設定にアクセスできませんでした。</exception>
        <exception cref="T:System.SystemException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が設定されておらず、<see cref="P:System.Diagnostics.Process.Id" /> プロパティを判別する元となる <see cref="P:System.Diagnostics.Process.Handle" /> が存在しません。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。  
  
または 
リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.WaitForExit" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">関連付けられたプロセスが終了するまで待機する時間。単位はミリ秒です。 最大値は、32 ビット整数で表現できる最大値で、オペレーティング システムに対して無限大で表現される値です。</param>
        <summary>関連付けられたプロセスが終了するまで、最大で指定したミリ秒間待機するように <see cref="T:System.Diagnostics.Process" /> コンポーネントに指示します。</summary>
        <returns>関連付けられたプロセスが終了した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> 関連付けられたプロセスが終了するまで待ってから、現在のスレッドを使用します。 これは、プロセスの他のすべてのメソッドが呼び出された後に呼び出す必要があります。 現在のスレッドがブロックされないようにする場合は、<xref:System.Diagnostics.Process.Exited> イベントを使用します。  
  
 このメソッドに指示、<xref:System.Diagnostics.Process>コンポーネントをある程度のプロセスが終了する時間を待機します。 終了する要求が拒否されたため、間隔の終了で関連付けられたプロセスは終了しない場合`false`が呼び出し元のプロシージャに返されます。 指定できます<xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>の`milliseconds`、および<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType>と同様に動作は、<xref:System.Diagnostics.Process.WaitForExit>オーバー ロードします。 返すかどうかは、0 (ゼロ) をメソッドに渡す、`true`プロセスが既に終了している場合にのみ、すぐに返します`false`します。  
  
> [!NOTE]
>  [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]と以前のバージョンで場合`milliseconds`が-1 の場合、<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>のオーバー ロードを待機<xref:System.Int32.MaxValue>ミリ秒 (約 24 日)、not 無期限にします。  
  
 標準出力は、非同期イベント ハンドラーにリダイレクトされましたが、このメソッドが戻るときの出力の処理が完了していないことになります。 非同期イベント処理が完了したことを確認するを呼び出して、<xref:System.Diagnostics.Process.WaitForExit>を受信した後はパラメーターを受け取らないオーバー ロードを`true`このオーバー ロードからします。 ために、<xref:System.Diagnostics.Process.Exited>イベントは、Windows フォーム アプリケーションで正しく処理、設定、<xref:System.Diagnostics.Process.SynchronizingObject%2A>プロパティ。  
  
 関連付けられたプロセスが終了したとき (がシャット ダウン正常または異常終了により、オペレーティング システムによって)、システムがプロセスの詳細の管理の情報を格納しが呼び出されているコンポーネントを返します<xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>します。 <xref:System.Diagnostics.Process>コンポーネントを含む、情報にアクセスできる、<xref:System.Diagnostics.Process.ExitTime%2A>を使用して、<xref:System.Diagnostics.Process.Handle%2A>終了のプロセスにします。  
  
 関連付けられたプロセスが終了したため、<xref:System.Diagnostics.Process.Handle%2A>コンポーネントのプロパティが不要になった既存のプロセス リソースをポイントします。 代わりにのハンドルは、プロセスのリソースについては、オペレーティング システムのアクセスにのみ使用できます。 システムは、解放されていない終了のプロセスへのハンドルの<xref:System.Diagnostics.Process>コンポーネント、それが維持されるように、<xref:System.Diagnostics.Process.ExitTime%2A>と<xref:System.Diagnostics.Process.Handle%2A>までメモリ内の情報、<xref:System.Diagnostics.Process>コンポーネントが具体的には、リソースを解放します。 このため、いつでも呼び出す<xref:System.Diagnostics.Process.Start%2A>の<xref:System.Diagnostics.Process>インスタンスを呼び出す<xref:System.Diagnostics.Process.Close%2A>と関連付けられたプロセスが終了することについて、管理情報が不要になった。 <xref:System.Diagnostics.Process.Close%2A> 終了したプロセスに割り当てられたメモリを解放します。  
  
   
  
## Examples  
 コード例をご覧ください、<xref:System.Diagnostics.Process.ExitCode%2A>プロパティ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">待機の設定にアクセスできませんでした。</exception>
        <exception cref="T:System.SystemException">プロセス <see cref="P:System.Diagnostics.Process.Id" /> が設定されておらず、<see cref="P:System.Diagnostics.Process.Id" /> プロパティを判別する元となる <see cref="P:System.Diagnostics.Process.Handle" /> が存在しません。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。  
  
または 
リモート コンピューターで実行されているプロセスの <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> を呼び出そうとしています。 このメソッドはローカル コンピューターで実行中のプロセスに対してのみ使用可能です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="milliseconds" /> は無限のタイムアウトを表す -1 以外の負の数です。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>関連付けられたプロセスがアイドル状態になるまで、<see cref="T:System.Diagnostics.Process" /> コンポーネントを待機させます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>関連付けられたプロセスがアイドル状態になるまで、<see cref="T:System.Diagnostics.Process" /> コンポーネントを無期限に待機させます。 このオーバーロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスにだけ適用されます。</summary>
        <returns>関連付けられたプロセスがアイドル状態になった場合は <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.WaitForInputIdle>メッセージ ループがアイドル状態に返されるまで待機する、アプリケーションの処理を強制します。 ユーザー インターフェイスを持つプロセスを実行しているときに、オペレーティング システムで Windows メッセージがプロセスに送信されるたびに、メッセージ ループを実行します。 プロセスは、メッセージ ループに戻ります。 プロセスは、メッセージ ループ内でメッセージを待機しているアイドル状態であると言います。 この状態は、アプリケーションは、開始のプロセス、アプリケーションはそのウィンドウと通信する前に、メイン ウィンドウの作成を完了するまで待機する必要がある場合などに便利です。  
  
 プロセスは、メッセージ ループを持っていない場合<xref:System.Diagnostics.Process.WaitForInputIdle>スロー、<xref:System.InvalidOperationException>します。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle>オーバー ロードの指示、<xref:System.Diagnostics.Process>メッセージ ループ内でアイドル状態になるプロセスを無期限に待機するコンポーネント。 この命令には、アプリケーションの応答を停止する可能性があります。 たとえば、プロセスが常に作成する場合、メッセージ ループを即座に終了コード フラグメントは、のように`while(true)`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスにグラフィカル インターフェイスがありません。  
  
または 
不明なエラーが発生しました。 プロセスがアイドル状態になることができませんでした。  
  
または 
プロセスは既に終了しています。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="milliseconds">関連付けられたプロセスがアイドル状態になるまでの待機時間をミリ秒単位で指定する、1 ～ <see cref="F:System.Int32.MaxValue" /> の値。 値 0 の場合はすぐに制御が戻され、値 -1 の場合は無期限に待機することを示します。</param>
        <summary>関連付けられたプロセスがアイドル状態になるまで、最大で指定したミリ秒間、<see cref="T:System.Diagnostics.Process" /> コンポーネントを待機させます。 このオーバーロードは、ユーザー インターフェイスとメッセージ ループを持つプロセスにだけ適用されます。</summary>
        <returns>関連付けられたプロセスがアイドル状態になった場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>メッセージ ループがアイドル状態に返されるまで待機する、アプリケーションの処理を強制します。 ユーザー インターフェイスを持つプロセスを実行しているときに、オペレーティング システムで Windows メッセージがプロセスに送信されるたびに、メッセージ ループを実行します。 プロセスは、メッセージ ループに戻ります。 プロセスは、メッセージ ループ内でメッセージを待機しているアイドル状態であると言います。 この状態は、アプリケーションは、開始のプロセス、アプリケーションはそのウィンドウと通信する前に、メイン ウィンドウの作成を完了するまで待機する必要がある場合などに便利です。  
  
 プロセスは、メッセージ ループを持っていない場合<xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>スロー、<xref:System.InvalidOperationException>します。  
  
 <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29>オーバー ロードの指示、<xref:System.Diagnostics.Process>コンポーネントをある程度のメッセージ ループ内でアイドル状態になるプロセスの時間を待機します。 関連付けられたプロセスには、ループがまだメッセージを処理するため、間隔の終了までにアイドル状態ならない場合`false`が呼び出し元のプロシージャに返されます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">プロセスにグラフィカル インターフェイスがありません。  
  
または 
不明なエラーが発生しました。 プロセスがアイドル状態になることができませんでした。  
  
または 
プロセスは既に終了しています。  
  
または 
この <see cref="T:System.Diagnostics.Process" /> オブジェクトに関連付けられているプロセスはありません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスの物理メモリ使用量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスが使用している物理メモリの合計容量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、ワーキング セット メモリのバイト単位で、プロセスによって使用されるは、現在のサイズを表します。 プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。 これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールや、システム ライブラリなど、プロセスが実行されるすべての指示を含むページが含まれています。  
  
   
  
## Examples  
 次の例では、メモ帳のインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了すると、プロセスの終了コードを表示します。  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>関連付けられたプロセスに割り当てられた物理メモリの量 (バイト単位) を取得します。</summary>
        <value>関連付けられたプロセスに割り当てられた物理メモリの量 (バイト単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティによって返される値は、ワーキング セット メモリのバイト単位で、プロセスによって使用されるは、現在のサイズを表します。 プロセスのワーキング セットが、物理 RAM メモリ、プロセスに現在表示されているメモリ ページのセット。 これらのページは、常駐ページ フォールトを発生させずに使用するアプリケーションで使用できます。  
  
 ワーキング セットには、共有とプライベートの両方のデータが含まれています。 共有データには、プロセスのモジュールと、システム ライブラリの命令など、プロセスが実行されるすべての指示を含むページが含まれています。  
  
 このプロパティは、32 ビット プロセッサまたは 64 ビット プロセッサを持つコンピュータのメモリ使用量の監視に使用できます。 プロパティ値が等しく、**ワーキング セット**プロセスのパフォーマンス カウンター。  
  
   
  
## Examples  
 次のコード例では、メモ帳アプリケーションのインスタンスを開始します。 例に、取得し、関連付けられたプロセスのさまざまなプロパティを表示します。 例では、検出プロセスが終了し、終了コードとピーク メモリ統計情報を表示します。  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">プラットフォームが Windows 98 または Windows Millennium Edition (Windows Me) で、このプロパティがサポートされていません。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">直前の呼び出し元に対する完全な信頼。 このメンバーは、部分的に信頼されているコードから使用することはできません。</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>